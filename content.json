{"meta":{"title":"orangejuice's Blog","subtitle":"平凡的博客","description":"搬运中...","author":"orangejuice","url":"http://chasingdeath.github.io"},"pages":[{"title":"About","date":"2021-05-21T06:45:47.000Z","updated":"2021-05-21T06:50:44.183Z","comments":true,"path":"about/index.html","permalink":"http://chasingdeath.github.io/about/index.html","excerpt":"","text":"个人简介&amp;博客阅览帮助这是一个悲惨的蒟蒻ZJOIer的博客，目前正在打Cu的边缘努力挣扎 不善口胡，擅长套简单的模板题~~ 写过一点点多项式板板题，然鹅并没有任何用处 没看过concrete 数学 没有语文功底 很少打CodeForces，CodeChef，Topcoder，AtCoder 代码环境：Dev-Cpp × Emacs × VSCode × vim √ gvim √ Windows √ Linux √ 文章书写的时间跨度非常长，所以前面的可能不像是一个人写的 如果有出现很sb的错误，请@评论区 or qq 2946316707 板子问题:rep/drep是两端闭区间的循环,reg是register,erep是前向星遍历 ll:long long ull:unsigned long long u64:uint64_t=unsigned long long u32:uint32_t=unsigned i64:int64_t=long long i32:int32_t=int Pii: pair Mod1,Mod2是加减法取模 cmin,cmax=checkmin,checkmax 由于本人变量名比较随意，经常出现::，这个是访问主函数外(也就是空命名空间)的变量 代码中可能出现的$\\text{..{}}$是C++11+的lambda语句 代码中可能出现的模板在这里 for(.. : ..)是容器完全遍历，需要C++11 模板用到了default template，以及可能出现别的问题，因此编译需要C++11 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef unsigned long long ull;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125; 阅读帮助常用的，阅读帮助 $\\forall,\\exists$任意，存在 $\\oplus$ oplus 异或 $[\\text{Logical Expression}]$艾弗森括号，根据其中逻辑表达式的真伪，值为1/0 $\\overline{x}\\underline{x}$上升幂下降幂 $\\lfloor x\\rfloor$ 向下取整 $\\lceil x\\rceil$ 向上取整 $|S|$ 集合大小，或者是矩阵行列式 $[x^i]f(x)$ 多项式$f(x)$的$x^i$一项的系数 $f^{(i)}(x)$ 对$f(x)$求$i$阶导 组合数的几种形式$\\begin{aligned}C(n,m),C_n^m,\\binom{n}{m}\\end{aligned}$ 第一类斯特林数 $\\begin{bmatrix}n\\\\m\\end{bmatrix}$ 第二类斯特林数 $\\begin{Bmatrix}n\\\\m\\end{Bmatrix}$ \\\\\\\\下面是给自己写Markdown/LaTex用的 字符$\\alpha$ alpha $\\beta$ beta $\\theta$ theta $\\Theta$ Theta (这个才是时间复杂度的标准符号) $\\varphi$ varphi (常表示欧拉函数) $\\phi$ phi $\\Phi$ phi (磁通量?) $\\lambda$ lambda $\\mu$ mu $\\omega$ omega (常表示单位根) $\\Omega$ $\\zeta$ zeta (常表示黎曼函数) 表达情形表示推导关系 $\\leftarrow$ leftarrow $\\Leftarrow$ Leftarrow $\\longleftarrow$ longleftarrow $\\Longleftarrow$ Longleftarrow 右箭头同理，双向改为leftright即可 $\\Leftrightarrow$ Leftrightarrow 常表示等价 $\\not\\ $ 非 not 这个符号是加在下一个字符上面的 $\\forall$ forall 任意 $\\exists\\nexists$ exists,nexists 存在 逻辑运算 $\\and$ and 与 $\\or$ or 或 $\\oplus$ oplus 异或 $\\overline x$ 非(较少见) $[x]$ 艾弗森括号，其中$x$为一个逻辑表达式，其值为true:1 , false:0 $\\ne$ ne $\\le \\ge$ le,ge 显示与简单运算 A 引用，在行首直接加’&gt;’即可 加粗 … 删除线 ~~ .. ~~ $\\sim \\tilde {AB} \\widetilde{AB}$ \\sim , \\tilde {AB} ,\\widetilde{AB} 波浪线 $\\underline{AB}$ underline $\\overline{AB}$ overline $\\hat {AB}$ hat $\\widehat{AB}$ widehat $\\dot {A}$ dot $\\ddot A$ ddot $\\dddot A$ dddot $a^b$ a^{b} 上标 $a_b$ a_{b} 下标 $\\frac{a}{b}$ frac{}{} 分数 cfrac{}{}打开分数 $\\sum_{i=a}^b$ sum_{}^{} 求和 $\\prod_{i=a}^{b}$ prod_{}^{} 求积 $\\int$ int 积分 $\\iint$ iint 这几个可以通过双美刀 或者设置环境调节解析程度$\\text{\\begin{aligned}..\\end{aligned}}$ (这个是对齐环境) 或者\\displaystyle 来完成打开的显示模式 分段函数 $f(x)=\\left\\lbrace\\begin{aligned} 1 &amp;&amp; b\\\\ 123 &amp;&amp; d\\end{aligned}\\right.$ $\\text{f(x)\\left \\lbrace\\begin{aligned} 1 &amp;&amp; b \\\\ 123 &amp;&amp; d \\end{aligned}\\right.}$ $\\cdot$ cdot 点乘 $\\cdots$ cdots省略号 $\\times$ times 乘 $\\lfloor x\\rfloor$ lfloor ,rfloor 向下取整 $\\lceil x\\rceil$ lceil,rceil 向上取整 $x^{\\overline n}$ overline {n} 上升幂 $x^{\\underline{n}}$ underline{n} 下降幂 集合关系$\\in$ in 元素属于集合 $\\notin$ notin 不属于 $\\subset$ sub/subset 子集 $\\sube$ sube 子集或相等 $\\subseteqq$ subseteqq子集或相等 $\\subsetneq$ subneq 真子集 $\\subsetneqq$ subneqq 真子集 $\\supset$ supset 父集 $\\supe$ supe父集或相等 $\\supseteqq$ supseteqq 父集或相等 $\\supsetneq$ supsetneq 真父集 $\\supsetneqq$ supsetneqq 真父集 集合运算$\\empty$ empty 空集 $\\{\\}\\lbrace\\rbrace$ 反斜杠+{ }或\\lbrace\\rbrace 大括号 $|S|$ 集合大小 $\\cup$ cup 并 $\\cap$ cap 交 $\\bigcup$ bigcup $\\bigcap$ bigcap $A \\setminus B$ setminus A-B，集合减操作 $\\mathbb{ABCDE}$ mathbb{ABCDE} $\\Delta \\bigoplus $ Delta bigoplus 对称差(?)，通常直接用异或代替 函数/多项式$f’(x)$ 求导 $f^{(i)}(x)$求i阶导 $[x^i]f(x)$第$i$项","keywords":"关于我"},{"title":"友情链接","date":"2021-05-21T06:38:00.000Z","updated":"2021-05-21T06:45:01.158Z","comments":true,"path":"links/index.html","permalink":"http://chasingdeath.github.io/links/index.html","excerpt":"","text":"各大网站.. Luogu CodeForces CodeChef AtCoder Vijos Loj Uoj 51Nod 神仙学长的博客"},{"title":"标签云","date":"2021-05-21T08:14:37.000Z","updated":"2021-05-21T08:24:56.379Z","comments":true,"path":"tags/index.html","permalink":"http://chasingdeath.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CF1477E - Nezzar and Tournaments","slug":"CF1477E - Nezzar and Tournaments","date":"2021-05-21T05:38:22.000Z","updated":"2021-05-22T03:54:10.828Z","comments":true,"path":"articles/2021/05/21/fe60afd6.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/21/fe60afd6.html","excerpt":"","text":"CF1477E - Nezzar and Tournaments题目大意有两队人$a_i,i\\in[1,n],b_j,j\\in[1,m]$，现在把他们放在一起排成一行$c_i$ 顺次给每个人计分，初始$s_0=k$ $s_i=\\max\\{0,s_{i-1}+c_i-c_{\\max\\{i-1,1\\} } \\}$ 现在要最大化每个$a_i$所在位置的$s_i$之和 与 $b_i$所在$s_i$之和 的差 支持修改和对于不同$k$查询 分析考虑$k=0$简单情况 1.若$s_i$不清零，则$s_i=c_i-lst$，其中$lst$表示上一个被清零位置的$c_j$ 2.$s_i$清零，则$c_i&lt;lst$ 容易发现，$\\displaystyle s_i=c_i-\\min_{j\\leq i} \\{ c_j\\}$ 那么对于含$k$的情况，类似可以得到 $\\displaystyle s_i=k-c_1+c_i+\\max\\{0,c_1-k-\\min_{j\\leq i} \\{c_j\\} \\}$ 假设我们固定了一个$c_1$，现在考虑对于剩下的$a_i,b_j$排出一个最优的排列 容易发现，$k-c_1+c_i$的贡献时固定的，只有前缀最小值会影响答案 我们希望对于$b_i$，前缀最小值较大，$a_i$反之 那么容易发现可以先降序排列$b_j$，再正序排列$a_i$ 此时$b_{\\min}$可以贡献给$a_i$的前缀最小值，同时$b_j$的前缀最小值能够取到最大 此时，不妨设$c_1=t$，$\\min\\{a_i,b_i\\}=Min$ 在$\\min\\{c_j\\}=c_1$时，$\\max$里的东西没有贡献，故可以得到 1.对于每个$a_i$，若它没有被放在$c_1$，则贡献$k-t+a_i+\\max\\{0,t-k-Min\\}$ 2.对于每个$b_i$（不特殊考虑第一个），则贡献$-(k-t+b_i+\\max\\{0,t-k-b_i\\})$（忽略最小值为$t$的情况） 则最终式子为 $\\displaystyle f(t)=(n-[t\\in a_i])\\cdot \\max\\{0,t-k-Min\\}-\\sum \\max\\{0,t-k-b_i\\}+(m-n)t+C$ 其中$C=(n-m)k+\\sum a_i-\\sum b_i$ 容易发现$f(t)$是关于$t$的分段一次函数，根据斜率变化情况分析，极值位置仅$O(1)$个 那么对于$a_i$作为$t$和$b_j$作为$t$的情况，分别计算$f(t)$的极值位置 极值位置需要一个$k$大查询和$\\text{lower_bound}$ 计算$f(t)$需要一个前缀查询 我用$\\text{BIT}$充当平衡树来维护，复杂度为$O((n+m+q)\\log 10^6)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283const int N=1e6+10,INF=1e9+10;int n,m,q;int a[N],b[N];struct BIT&#123; ll s[N]; int c[N],n; void Init(int m)&#123; n=m; &#125; void Add(int p,int x,int y)&#123; p++; while(p&lt;N) s[p]+=x,c[p]+=y,p+=p&amp;-p; &#125; ll Que(int p)&#123; p++; if(p&lt;=0) return 0; ll sum=0,cnt=0,t=p-1; while(p) sum+=s[p],cnt+=c[p],p-=p&amp;-p; return t*cnt-sum; &#125; int Rank(int p)&#123; if(p&lt;0) return 0; // 一些奇怪的边界特判 ，防止查询越界 p++,cmin(p,N-1); int res=0; while(p) res+=c[p],p-=p&amp;-p; return res; &#125; int Kth(int k)&#123; // 注意一定要避免找到并不存在的数值 cmin(k,n),cmax(k,1); int p=0; drep(i,19,0) if(p+(1&lt;&lt;i)&lt;N &amp;&amp; c[p+(1&lt;&lt;i)]&lt;k) k-=c[p+=1&lt;&lt;i]; return p; &#125; int Prev(int x) &#123; return Kth(Rank(x)); &#125; int Next(int x) &#123; return Kth(min(n,Rank(x)+1)); &#125;&#125; A,B;ll delta;void AddA(int x,int k)&#123; delta+=x*k; A.Add(x,x*k,k);&#125;void AddB(int x,int k)&#123; delta-=x*k; B.Add(x,x*k,k);&#125;ll QueA(ll k)&#123; ll Min=min(A.Kth(1),B.Kth(1)); auto F=[&amp;](ll t)&#123; return (n-1)*max(0ll,t-k-Min)-B.Que(t-k)+(m-n)*t; &#125;; ll ans=max(F(A.Kth(1)),F(A.Kth(n))); int p=B.Kth(m-1)+k; cmax(ans,F(A.Prev(p))),cmax(ans,F(A.Next(p))); return ans;&#125;ll QueB(ll k)&#123; ll Min=min(A.Kth(1),B.Kth(1)); auto F=[&amp;](ll t)&#123; return n*max(0ll,t-k-Min)-B.Que(t-k)+(m-n)*t; &#125;; ll ans=max(F(B.Kth(1)),F(B.Kth(m))); int p=B.Kth(m)+k; cmax(ans,F(B.Prev(p))),cmax(ans,F(B.Next(p))); return ans;&#125;ll Que(ll k)&#123; return max(QueA(k),QueB(k))+delta+(n-m)*k;&#125;int main()&#123; n=rd(),m=rd(),q=rd(),A.Init(n),B.Init(m); rep(i,1,n) AddA(a[i]=rd(),1); rep(i,1,m) AddB(b[i]=rd(),1); while(q--) &#123; int opt=rd(); if(opt==1) &#123; int x=rd(),y=rd(); AddA(a[x],-1),AddA(a[x]=y,1); &#125; else if(opt==2) &#123; int x=rd(),y=rd(); AddB(b[x],-1),AddB(b[x]=y,1); &#125; else printf(&quot;%lld\\n&quot;,Que(rd())); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"下降幂多项式","slug":"下降幂多项式","date":"2021-05-20T01:52:48.000Z","updated":"2021-05-22T03:54:11.316Z","comments":true,"path":"articles/2021/05/20/15776de2.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/20/15776de2.html","excerpt":"","text":"下降幂多项式 下降幂的定义下降幂$\\text{Falling Factorial}$ 下降幂多项式$\\text{Falling Factorial Polynomial}$下面简称$\\text{FFP}$ $x$的$n$阶下降幂$x^{\\underline n}=\\prod_0^{n-1}(x-i) = \\frac{x!} {(x-n)!}$ 一个下降幂多项式$F(x)=\\sum a_ix^{\\underline i}$ 学习了斯特林数或许对于下降幂的性质能够有所了解 快速求解$x^{\\underline n}$的展开形式$x^{\\underline{n} }=x(x-1)\\cdots (x-n+1)$ 考虑倍增求解，假设已知$F(x)=x^{\\underline{n} }$ 要求$G(x)=x^{\\underline{2n} }$ 显然$G(x)=F(x)F(x-n)$ 而$\\begin{aligned} F(x-n)=\\sum_{i=0}^{n} [x^i]F(x) \\cdot (x-n)^i\\end{aligned}$ 用一次卷积处理这个二项展开即可 复杂度为$O(n\\log n)$ FFP与其点值的$\\text{EGF}$点值的$\\text{EGF}$为$\\begin{aligned} EGF(F(x))=\\sum_0^{\\infty}\\frac{F(i)x^i } {i!}\\end{aligned}$ $\\begin{aligned}EGF(F(x))=\\sum_{i=0}^{\\infty}\\frac{x^i} {i!}\\sum_{j=0}^{n} \\frac{i!} {(i-j)!}\\cdot F_j\\end{aligned}$ $\\begin{aligned}EGF(F(x))=\\sum_{i=0}^{\\infty}x^i \\sum_{j=0}^{n} \\frac{1} {(i-j)!}\\cdot F_j\\end{aligned}$ 换一下顺序 $\\begin{aligned}EGF(F(x))=\\sum_{i=0}^{n} F_i \\sum_{j=i}^{\\infty}\\frac{1} {(j-i)!} x^j\\end{aligned}$ $\\begin{aligned}EGF(F(x))=\\sum_{i=0}^{n} F_i \\cdot x^i \\sum_{j=0}^{\\infty}\\frac{1} {j!} x^j\\end{aligned}$ $\\begin{aligned}EGF(F(x))=\\sum_{i=0}^{n} F_i \\cdot x^i e^x\\end{aligned}$ 那么直接和$e^x$卷积就可以得到$F(x)$的$\\text{EGF}$ Tips: $e^x$直接带入展开式$\\begin{aligned} e^{ax}=\\sum_0^{\\infty}\\frac{(ax)^i} {i!} \\end {aligned}$ 如果要从$\\text{EGF}$得到$F(x)$ $\\begin{aligned}EGF(F(x))=\\sum_{i=0}^{n} F_i \\cdot x^ie^x\\end{aligned}$ $\\begin{aligned} F_i=\\frac{EGF(F(x))} {x^ie^x} \\end{aligned}$ 那么就直接卷上$e^{-x}$就可以了 即可以通过简单卷积完成$\\text{FFP} \\Longleftrightarrow \\text{EGF}$的转化 FFP卷积求出$\\text{EGF}$，然后点值对应相乘(注意乘完之后要补上一个$i!$)，最后再反求$F(x)$ Tips: 下面的知识恐怕需要先学多点求值/快速插值 多项式转FFP带入$0,\\cdots n-1$，多点求值得到$\\text{FFP}$点值的$EGF$，然后求得到$\\text{FFP}$ FFP转多项式求出$F(x)$的$EGF$，然后带入前$n$项的值，快速插值回来即可 由于$x_i$是连续的，所以不需要再多点求值求解$\\prod\\frac{1} {x_i-x_j}$，可以直接阶乘得到 关于上升幂$x^{\\overline n}=\\frac{(x+n-1)!} {(x-1)!}=x(x+1)(x+2)\\cdots(x+n-1)$ 容易发现的是$x^{\\overline n}=(-x)(-((-x)-1))(-((-x)-2))\\cdots (-(-x-(n-1)))=(-1)^n (-x)^{\\underline{n} }$ 所以上升幂多项式与普通多项式的转化 可以认为是上面的点值变成了$0,-1,\\cdots ,-(n-1)$，奇数项系数取反","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"CF1411F - the Thorny Path","slug":"CF1411F - The Thorny Path","date":"2021-05-20T00:55:46.000Z","updated":"2021-05-22T03:54:10.811Z","comments":true,"path":"articles/2021/05/20/8d2e7059.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/20/8d2e7059.html","excerpt":"","text":"CF1411F - The Thorny Path题目大意给定一个置换$p_i$，求通过最少次交换$p_i,p_j$，使得最终的置换中所有置换环$size$乘积最大 分析一个常规结论： 对于$n(n\\ge 3)$的拆分$n=\\sum_{i=1}^m a_i$，最大化$\\prod a_i$，最优情况下 1.$n\\mod 3=0$，$a_i=3$ 2.$n\\mod 3=2$，$i&lt;m,a_i=3 ; a_m=2$ 3.$n\\mod 3=1$，$i&lt;m,a_i=3 ; a_m=4$或$i&lt;m-1,a_i=3 ;a_{m-1}=a_m=2$ 简要证明 容易发现对于任意$n$，最终$a_i$的方案是$O(1)$的，设当前置换环为$b_i$，我们需要操作$b_i$变成$a_i$ 1.一次在同环交换可以分裂一个环 2.一次异环交换合并两个环 所以原问题实际上就是最少次数分裂合并$b_i$ 对于$n\\mod 3=0$或$n\\mod 3=2$的情况，如果当前$b_i\\ge 3$，可以一直不停分裂 最终剩下的就是$b’_i=1$或者$b’_i=2$ 对于$n\\mod 3=2$的情况，优先从中取出一个2&lt;或者由两个1合并得到一个2 剩下的优先合并1和2，然后剩下的自己合并 $n\\mod 3=1$同理，但是$a_i=4$的情况也不能分裂，需要拿出来特殊处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const int N=1e6+10,P=1e9+7;int n,m;int Pow[N];int A[N],L[N],C,R[N],D;int vis[N];int Calc(int c1,int c2)&#123; int t=min(c1,c2),ans=t; c1-=t,c2-=t; if(c1) ans+=c1/3*2; if(c2) ans+=c2; return ans;&#125;int Calc(int c1,int c2,int c4)&#123; return c4+Calc(c1+c4,c2); &#125;int main()&#123; rep(i,*Pow=1,N-1) Pow[i]=1ll*Pow[i-1]*3%P; rep(_,1,rd()) &#123; n=rd(); rep(i,1,n) A[i]=rd(),vis[i]=0; C=0; rep(i,1,n) if(!vis[i]) &#123; int c=0; for(int j=i;!vis[j];j=A[j]) c++,vis[j]=1; L[++C]=c; &#125; if(n%3==0) &#123; printf(&quot;%d &quot;,Pow[n/3]); int ans=0; rep(i,1,C) &#123; while(L[i]&gt;3) L[i]-=3,ans++; if(L[i]==3) L[i]=0; &#125; int c1=0,c2=0; rep(i,1,C) if(L[i]==1) c1++; else if(L[i]==2) c2++; ans+=Calc(c1,c2); printf(&quot;%d\\n&quot;,ans); continue; &#125; if(n%3==2) &#123; printf(&quot;%d &quot;,Pow[n/3]*2%P); int cnt=n/3,ans=0; rep(i,1,C) &#123; while(cnt &amp;&amp; L[i]&gt;3) L[i]-=3,cnt--,ans++; if(L[i]==3 &amp;&amp; cnt) L[i]=0,cnt--; &#125; int c1=0,c2=0; rep(i,1,C) if(L[i]==1) c1++; else if(L[i]==2) c2++; if(c2) c2--; else c1-=2,ans++; ans+=Calc(c1,c2); printf(&quot;%d\\n&quot;,ans); continue; &#125; printf(&quot;%lld &quot;,Pow[(n-4)/3]*4ll%P); int cnt=(n-4)/3,c3=0,ans=0; rep(i,1,C) &#123; while(cnt &amp;&amp; L[i]&gt;4) L[i]-=3,cnt--,ans++; if(L[i]==3 &amp;&amp; cnt) L[i]=0,cnt--; &#125; int c1=0,c2=0,c4=0; rep(i,1,C) if(L[i]==1) c1++; else if(L[i]==2) c2++; else if(L[i]==3) c3++; else if(L[i]==4) c4++; if(c3) ans++; else &#123; int w=1e9; if(c4) cmin(w,Calc(c1,c2,c4-1)); if(c1&gt;=4) cmin(w,Calc(c1-4,c2,c4)+2); if(c2&gt;=2) cmin(w,Calc(c1,c2-2,c4)); if(c1&gt;=2 &amp;&amp; c2) cmin(w,Calc(c1-2,c2-1,c4)+1); ans+=w; &#125; printf(&quot;%d\\n&quot;,ans); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[水]整数拆分积","slug":"[水]整数拆分积","date":"2021-05-20T00:55:12.000Z","updated":"2021-05-22T03:54:11.104Z","comments":true,"path":"articles/2021/05/20/69b2f79f.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/20/69b2f79f.html","excerpt":"","text":"[水]整数拆分积这是一个常规（小学奥数）结论 问题：对于$n(n\\ge 3)$，要求构造拆分$n=\\sum_{i=1}^m a_i$，最大化$\\prod a_i$ 最优情况下，满足 1.$n\\mod 3=0$，$a_i=3$ 2.$n\\mod 3=2$，$i&lt;m,a_i=3 ; a_m=2$ 3.$n\\mod 3=1$，$i&lt;m,a_i=3 ; a_m=4$或$i&lt;m-1,a_i=3 ;a_{m-1}=a_m=2$ 容易发现$a_i=2,a_i=4$的都是边界情况，我们只需要分析为何$a_i=3$能够最大化答案 考虑由高维均值不等式 $\\displaystyle \\sqrt[m]{\\prod a_i}\\leq \\frac{\\sum a_i} {m}$ $\\displaystyle \\prod a_i\\leq (\\frac{\\sum a_i} {m})^m$ 故知在$a_i$尽量平均时取到最值 现在只需分析$a_i=x$在何时取到最值 不妨用一个函数$g(x)=x^{\\frac{n} {x} }$来描述问题 由于上标中的$n$不影响单调性，不妨分析$\\displaystyle f(x)=g^{\\frac{1} {n} }(x)=x^{\\frac{1} {x} }$ $f(x)=e^{\\frac{\\ln x} {x} }$ $f’(x)=e^{\\frac{\\ln x} {x} }\\cdot \\frac{1-\\ln x} {x^2}$ 容易发现$f(x)$在$x_0=e$处取极大值 由于$x’\\in \\Z$，带入$f(2)\\approx 1.414,f(3)\\approx 1.442$ 故取$a_i=3$","categories":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}]},{"title":"CF1456E - XOR-Ranges","slug":"CF1456E - XOR-ranges","date":"2021-05-19T04:05:11.000Z","updated":"2021-05-22T03:54:10.819Z","comments":true,"path":"articles/2021/05/19/301596e8.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/19/301596e8.html","excerpt":"","text":"CF1456E - XOR-ranges题目大意有$n$个二进制数$a_i\\in[L_i,R_i]$，给定每个二进制位的权值 序列$a_i$的权值就是$a_i\\oplus a_{i+1}$二进制为权值之和 求所有满足$a_i\\in[L_i,R_i]$的最小权值 分析显然需要我们考虑对于一个数进行 数位$dp$的过程 从高位到低位，一个数要么最终都一直被限制着，要么在两个不同的位置分别解除了$L_i,R_i$的限制 容易发现，$L_i,R_i$中某一个先被解除的限制一定是在第一个$\\text{bit}(L_{i},p)\\ne \\text{bit}(R_i,p)$的位置 （实际上是小于号） 此后，选择的数一直跟着剩下的限制直到下一个位置解除 不妨考虑$L_i,R_i$中限制时间较长的一个限制，设在$p$这一位解除，那么 1.$\\exists k&lt;p,\\text{bit}(L_i,k)\\ne \\text{bit}(R_i,k)$ 2.如果是$R_i$，那么$\\text{bit}(R_i,p)=1,\\text{bit}(a_i,p)=0$ 如果是$L_i$，那么$\\text{bit}(R_i,p)=0,\\text{bit}(a_i,p)=1$ 如果最终每个数解除限制的位置如下 考虑他们如何对于答案贡献 对于每个二进制位，如果存在空白段，空白段的二进制可以跟随左边的段或者右边的段改变 当左边和右边最邻近的两个数这一位不同，则产生贡献 因此考虑依次扫描每一个二进制位，找到相邻可能产生贡献的$(a_l,a_r)$ 从低位到高位，这就是一个不断将$(a_l,a_r)$分裂为$(a_l,a_k),(a_k,a_r)$的过程 也就是一个 笛卡尔树上的区间dp 对于当前二进制位$p$和数对$a_l,a_r$，我们需要知道的是 $a_l$是受到$L_l$还是$R_l$的限制，且是否$p$这一位它解除了限制 （因为解除贡献的这一位与$L_l / R_l$相反） $a_r$是同理 转移可以直接进入下一个二进制位，计算$a_l,a_r$的贡献 或者分裂区间枚举中点$k$，$a_k$恰好在这一位解除限制（或者$a_k$一直都没有解除限制，此时$p=0$） 此时$L_k,R_k$必然满足前面提到的限制，并且根据$\\text{bit}(L_k,p)$和$\\text{bit}(R_k,p)$枚举$k$受到$L_k$或者$R_k$的限制 123456789101112131415161718192021222324252627282930const int N=55;int n,k;ll L[N][2],C[N];ll dp[N][N][N][2][2][2][2];int bit(ll x,int p)&#123; return (x&gt;&gt;p)&amp;1; &#125;ll dfs(int p,int l,int r,int f,int x,int g,int y)&#123; if(p==k) return r-l==1?0:1e18; ll &amp;res=dp[p][l][r][f][x][g][y]; if(~res) return res; res=dfs(p+1,l,r,f,0,g,0)+(l &amp;&amp; r&lt;=n &amp;&amp; (x^y^bit(L[l][f]^L[r][g],p)))*C[p]; rep(k,l+1,r-1) &#123; // a[k] is limited all time if(!p) rep(j,0,1) cmin(res,dfs(p,l,k,f,x,j,0)+dfs(p,k,r,j,0,g,y)); // a[k] frees at p if((L[k][0]^L[k][1])&gt;&gt;(p+1)) &#123; // L,R has some different bits before p rep(j,0,1) if(bit(L[k][j],p)==j) cmin(res,dfs(p,l,k,f,x,j,1)+dfs(p,k,r,j,1,g,y)); &#125; &#125; return res;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); rep(i,1,n) rep(j,0,1) scanf(&quot;%lld&quot;,L[i]+j); rep(i,0,k-1) scanf(&quot;%lld&quot;,C+i); memset(dp,-1,sizeof dp); printf(&quot;%lld\\n&quot;,dfs(0,0,n+1,0,0,0,0));&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1452G - Game on Tree","slug":"CF1452G - Game On Tree","date":"2021-05-18T13:53:18.000Z","updated":"2021-05-22T03:54:10.817Z","comments":true,"path":"articles/2021/05/18/54f0570a.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/18/54f0570a.html","excerpt":"","text":"CF1452G - Game On Tree题目大意A和B在树上Van游戏，每个人操作一些点 A操作一个点$i$，B操作一个点集$a_j$ 每轮A,B分别进行操作，可以对于自己的所有点任意移动1步或0步 在某一轮，当A的点碰到B的点时游戏结束 A希望尽量迟结束，B希望尽量早结束 给定B的初始点集$a_j$，对于A的每个初始点$i$判断多少轮结束 分析由于B的操作显然是不停向A收缩直到碰到 那么可以广搜求出每个点原地不动时被B干掉的时间$F_i$ 那么考虑A的移动过程，每一步可以到达一个点$u$ 必须满足在第$i$步所在的点$u$，$F_u&gt;i$，否则结束游戏 对于初始节点$u$，不妨设最终结束的节点为$t$，我们希望一路跑到$t$然后站住不动，此时答案就是$F_t$ 而实际上，任何一个点$u$能够跑到$t$，等价于$dis(u,t)&lt;F_t$ Proof: 由最短路三角不等式可知 $\\forall (u,v)\\in Tree, dis_{v}-1\\leq dis_u\\leq dis_{v}+1$ 即$dis_e$在树的路径上连续变化，不妨设移动路径为$p_i,i\\in[1,k],p_k=t,k\\leq F_t$ 若能在$F_t-1$的时间内到达$p_k$，那么必然能在$F_t-2$的时间内到达$p_{k-1}$ 进而归纳得到 那么问题变成了，对于每个点$u$，向周围$F_u-1$范围内的点对于$F_u$取$\\max$ 容易点分治处理，复杂度为$O(n\\log n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const int N=2e5+10,INF=1e9+10;int n,F[N],A[N];vector &lt;int&gt; G[N];queue &lt;int&gt; que;int mi,rt,sz[N],vis[N];void FindRt(int n,int u,int f)&#123; int ma=0; sz[u]=1; for(int v:G[u]) if(!vis[v] &amp;&amp; v!=f) &#123; FindRt(n,v,u),sz[u]+=sz[v]; cmax(ma,sz[v]); &#125; cmax(ma,n-sz[u]); if(mi&gt;ma) mi=ma,rt=u;&#125;int dep[N],id[N],c,s[N];void dfs(int u,int f)&#123; id[++c]=u; for(int v:G[u]) if(v!=f &amp;&amp; !vis[v]) &#123; dep[v]=dep[u]+1; dfs(v,u); &#125;&#125;void Div(int n,int u)&#123; mi=1e9,FindRt(n,u,0),u=rt,vis[u]=1; c=0,dep[u]=0,dfs(u,0); rep(i,0,c) s[i]=0; rep(i,1,c) &#123; int u=id[i]; if(F[u]&gt;dep[u]) cmax(s[min(c,F[u]-1-dep[u])],F[u]); &#125; drep(i,c-1,0) cmax(s[i],s[i+1]); rep(i,1,c) cmax(A[id[i]],s[dep[id[i]]]); for(int v:G[u]) if(!vis[v]) &#123; if(sz[v]&gt;sz[u]) sz[v]=n-sz[u]; Div(sz[v],v); &#125;&#125;int main()&#123; rep(i,2,n=rd())&#123; int u=rd(),v=rd(); G[u].pb(v),G[v].pb(u); &#125; rep(i,1,n) F[i]=-1; rep(i,1,rd()) &#123; int x=rd(); F[x]=0,que.push(x); &#125; while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int v:G[u]) if(F[v]==-1) F[v]=F[u]+1,que.push(v); &#125; Div(n,1); rep(i,1,n) printf(&quot;%d &quot;,A[i]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1051G - Distinctification","slug":"CF1051G - Distinctification","date":"2021-05-18T13:46:22.000Z","updated":"2021-05-22T03:54:10.757Z","comments":true,"path":"articles/2021/05/18/30c61159.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/18/30c61159.html","excerpt":"","text":"CF1051G - Distinctification题目大意对于一个二元组集合$\\{(a_i,b_i)\\}$ 每次可以进行操作 1.如果存在$a_i=a_j$，可以花费$b_i$代价$a_i$增加1 2.如果存在$a_i=a_{j}+1$，可以花费$-b_i$代价使$a_i$减少1 现在依次向集合插入$n$个二元组，求在所有时刻，对于当前的集合进行操作 最终使得不存在$a_i=a_j$时的最小花费（可以为负） 分析容易发现对于给定的$a_i$集合，最终$a_i$的集合唯一固定 具体的，每次插入一个数值$x$，如果出现重复就会不停将$x$向后推推推 而事实上答案为$\\sum b_i\\cdot (a’_i-a_i)$，那么只需要最小化$\\sum b_ia’_i$ 容易发现在任意时刻，如果$[L,R]$内所有$a_i$都出现，就可以任意交换他们的$b_i$ 那么最终状态中每一个$a_i$连通块内，按照$b_i$从大到小排序即可 每次插入一个元素维护连通块之间的合并以及求出$\\sum b_ia’_i$即可 可以用启发式合并/线段树合并维护 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const int N=4e5+10,M=N*19,INF=1e9+10;int n;int ls[M],rs[M],c[M],cnt;ll s[M],ans[M];ll Ans;int F[N],rt[N];int Find(int x)&#123; return F[x]==x?x:F[x]=Find(F[x]); &#125;void Up(int x)&#123; c[x]=c[ls[x]]+c[rs[x]],s[x]=s[ls[x]]+s[rs[x]]; ans[x]=ans[ls[x]]+ans[rs[x]]+c[rs[x]]*s[ls[x]];&#125;void Upd(int &amp;p,int l,int r,int x)&#123; if(!p) p=++cnt; if(l==r) &#123; c[p]=1,s[p]=x; return; &#125; int mid=(l+r)&gt;&gt;1; x&lt;=mid?Upd(ls[p],l,mid,x):Upd(rs[p],mid+1,r,x); Up(p);&#125;int Union(int x,int y,int l=1,int r=n)&#123; if(!x||!y) return x|y; int mid=(l+r)&gt;&gt;1; ls[x]=Union(ls[x],ls[y],l,mid),rs[x]=Union(rs[x],rs[y],mid+1,r); return Up(x),x;&#125;void Add(int x,int k)&#123; x=Find(x); Ans+=k*(x*s[rt[x]]+ans[rt[x]]);&#125;int main()&#123; n=rd(); rep(i,1,n)&#123; int x=rd(),y=rd(); Ans-=1ll*x*y; int f=Find(x); if(!f) f=F[x]=x; else Add(f,-1),F[f+c[rt[f]]]=f; Upd(rt[f],1,n,y); while(x=Find(x),y=Find(x-1)) &#123; Add(y,-1); F[x]=x-1; rt[y]=Union(rt[y],rt[x]); &#125; while(x=Find(x),y=Find(x+c[rt[x]])) &#123; Add(y,-1); F[x+c[rt[x]]]=x; rt[x]=Union(rt[x],rt[y]); &#125; Add(x,1),printf(&quot;%lld\\n&quot;,Ans); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"PKUSC2021游记","slug":"PKUSC2021游记","date":"2021-05-17T06:01:56.000Z","updated":"2021-05-22T03:54:10.987Z","comments":true,"path":"articles/2021/05/17/a8924e44.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/17/a8924e44.html","excerpt":"","text":"PKUSC2021游记前言上次PKUWC体验 结果今年没有WC Day 0余姚还是比较近的嘛，5个小时就到了 在车上吃了一个榴莲千层有点饱啊 入住mj酒店，然鹅机房队伍人数是奇数，于是乎… （qy是不是也在这个酒店里） 为毛这个浴室正对着床，还是非全遮挡的玻璃设计 诶什么时候酒店都禁止发放洗漱用品了 不管了不管了先滑 Day 1凌晨诶天好像亮了… …这么大个人连睡觉拉窗帘都不会… 诶怎么才5点，再睡一会~~~ 6点：f**k睡不着起来high！！ 7点：进食时间 上午这个酒店最近很忙啊。。 一个房间都不能连着住还得更替一下吗。。。 三人入住套间~~~ 分离的 1大床 + 2小床 + 2空调 + 2 洗手台！！ 这样的房间给我来一打！！ 进入正题 报道+试机。。。。 完了昨晚+今早打了一小会儿音游，脖子居然有一点点受不了 徒步到达余姚中学… 唉，这个校门咋了个这么nb 排队登记…..名单上怎么半天找不到我自己…. 哦！原来那张不是浙江的 上手先让我们来看一看机子的配置 i3-8700U 嗯. Win10 64bit 嗯. Dev-cpp 嗯. Visual Basic,UltraEdit,Photoshop 嗯？ 嗯？没别的了？？？？ woc 我上次用Dev-Cpp什么时候的事了 ……龟速码板子中….. 哇试机还有两道题目,开openjudge.cn！ T1 嗯…. T2 嗯…. 完了试机题目看起来好难啊，我是不是完蛋了 下午这怎么没有午休时间的 还是好晕 -30+min贴座位表啦 一万只健壮神仙堵着看，我咋办 -10min……Dev-Cpp板子板子板子…… 痛苦啊！！ 敲到一半，发现同桌的”板子”似乎特别长？ 旁边似乎是一个神仙，感觉很熟悉但是我并不认识的神仙 然后我看到一行这样的代码 1const int mod = 998244353; ok ，明白，那我也敲一下 NTTNTTNTT 0+++min九条可怜九条可怜九条可怜九条可怜九条可怜九条可怜九条可怜九条可怜 T1 嗯，看起来可能是签到题？ 矩阵矩阵 T2 逛gai 画图画图！！分析分析！！ 我的草稿纸在跳舞！！ 算了先开T3 T3 德 州 扑 克 儿 德 州 扑 克 儿 德 州 扑 克 儿 啊 啊 啊 啊 啊 仔细分析，看起来$s=2,s=3$就是大模拟 真棒！！！！ line 30: hash(int *a){ line 50:} line 60: calc(int *a){ line 120: } line 130: Solves3(){ line 170:} …. 终于写完第一档分了！！ 样例: ok ok 提交: wa ？？ 仔细观察，修改：wa ？？？ 仔细观察，修改×2：wa ？？？ 仔细读题： 还是好奇怪为什么poker会有一个按照字典序比较大小的阶段，真是怪了 要不改成数值试一下 提交：pass subtask1 ？？？？？？？？？？ 暴力修改。。。 提交： TLE Subtask2 稍加优化:79pts get 下面这21分不要也罢！！ T2 again 一样的草稿纸，一样的折线图 每次操作好像会删除若干个谷，把若个峰复制一份？ 均摊均摊 数据结构数据结构 封装封装！！ debugging…………………. 17:00啊妈妈我终于过了 让我们荡起双桨，小船儿推 停停停 认真思考T3… 认真思考T3… 认真思考T3… 可以，感性理解一波这个状压代码写不完，那不如 让我们荡起双桨，小船儿推 停停停 诶某张纸上好像说D:\\ \\software里面有点东西，不知道是什么 gviminstaller.exe 测试新配置………. 出考场同桌：为毛我T3过不了第二档分！！ 我：？？？？ 机房同志：我T2 两个log 交满了过不去 机房同志：我T2 根号log 交满了过不去 机房同志：我 Splay T了 我：？？？？ 是我运气好？？？？ 看来我用Dev-Cpp打的分数居然非常非常高？？ 下面是自行进食时间。。。。 三人正在前往KFC。。。 订购2个汉堡，两个鸡块桶…. （被大佬请客了 诶三个人吃两个全家桶吗 看来事实验证了人的胃可以自由扩张5倍 晚上这nm吃得太饱了 电视：正在播放夺宝奇兵2 我们：这什么邪教仪式我去 邪教蛊惑人心 time ????旁边：快帮我看看这个笔记本电源线怎么插不进去 我：？？插？？？怎么线头软绵绵的 旁边：完了怎么有一股烧焦的味道 … 奇了怪了，今天怎么一整晚教练没来查房？？ Day27:00 醒，真棒！ 7:30吃饭，真棒！ 8:00集合，7:50才出宾馆，真棒！ 飞奔 早上合影+参观？？ 进校门看到一个巨大的铁架台，转头已经是密匝匝的人群，看来来对时候了 组织人员： 180+的最后一排！ 175+的倒数第二排！ ….. 各位领导第一排！ 我们：为什么我们教练没在第一排？ 前面：哦你们教练昨天喝高了还没醒 纳尼！！ 组织人员： 人到齐了吗！！！ 怎么还多空了一排 所有人前进一排！！！ （场外又走来一个人）同学你去第三排 大家看镜头！！再来一次！！ 好的，接下来我们坐公交车去梦麟校区！ 抵达梦麟校区参观大厅+领导讲话 参观NOI试场 参观寝室？？？？？？？？？？ 带队老师：同学们上二楼！！没关系看一下看一下 我们：？s？s？狂？喜？ 公交车返回…… 北京时间10:10 老师：同学们食堂在这里！！自己打啊 我：？？ 别人：gogogo！！ 同行的人：太早了去买点饮料吧 于是出校买饮料 成功绕过一整条街 我们 。。回来了。。。 中午11:50了，怎么楼下还空的 诶好像座位表贴出来了，今天没有堵门神仙了 20min目睹qy坐在考场门口的台阶上看qq 谁去问一下他昨天AK了没有 -15min这次知道要可以用gvim了…. 看向前面：VSCode？？帅啊！！ 0+++minT1 删边加边删边加边删边加边删边加边 dp换根dp换根dp换根dp换根 ….. 1h later….我终于过了。。 T2 这是什么奇怪的贪心+数据结构题 不管了先贪心 尝试1….. 样例好强 尝试2….. 第一个数据好强 值域dp….. 喜提11分 尝试3….. ….. 尝试x…. 算了先看看T3 T3 昨天都打牌了，今天总是一个常规一点的防AK题吧（反正都不会写 哇$n\\leq 50,m,k\\leq 150$难道这是签到题 嗯Day2 T3怎么可能是签到题？ 仔细观察。。。 [0,m]内随机的实数 连续型概率dp耶！ 连续型概率dp耶！ 连续型概率dp耶！ 容斥尝试…. dp尝试…. 二元函数积分… ….. $n=3$手动积分中。。。喜提10pts $n=4$手动积分中。。。喜提20pts 痛苦草稿$\\downarrow $ T2 again 我不行了，试了一堆垃圾贪心（后来发现似乎有一个是对的，但是我写挂了） 不如试一下倒着贪心吧。。。 40pts get… 溜了溜了 T3 again 尝试2元分段函数积分中….. 交换元。。 平移元。。 积分。。 居然还要考虑两个元的大小关系！！ 好的我放弃了 gvim无法拯救我，要不下次挑战一下别的 出考场160我没了… 教练终于又出现了!! 教练坚持要合影一下 结果直接赶走了其他教练 成就达成：在科技楼前面合影 昨天是KFC，今天是金拱门！ 然鹅同行三人有一个已经坐上动车溜了 订购麦旋风，汉堡，鸡块桶….（又被大佬请客了 晚上明天只有面试和颁奖，那 今夜不眠不休！ 能卡在一个画面整整4小时，宾馆的电视真是惊人 笔记本太la什么干不得，居然开始推gal了 1:30am…..我不行了我不行了…… Day38:00公布面试名单，但是8:30才开始….那不如多滑一会儿 8:00出发，突然开始下小雨 ，然鹅有伞的同志已经溜了…… 冲冲冲 8:10抵达，为什么门口看起来也不是很热闹… 嗯，似乎发生了什么奇怪的事 这都可以，居然白来了 出校门，大雨….. 撒腿就跑 嗯有人叫我？哇学弟offer了free打的ride 10mins later…教练on QQ: 四楼机房 我：？？？？ 中途下车飞回去 10:20我终于回来了…. 小滑一会儿 11:20为什么他们还没回来 有点撑不住，躺下再睡一会儿 门铃适时响起….. 11:40这总到饭点了吧 前天KFC，昨天金拱门，那今天是不是必胜客/华莱士什么的 于是我们吃外卖 于是我们吃…黄焖鸡 2:00p.m.原来酒店还可以这么迟退房 2:10p.m.提前进入会场，看到zyy来拷课件 表示几乎没见过神仙，所以基本都不认识 3:20++p.m.领导发话结束，zyy上场： “不是所有题都是我出的，不要都找我喷” D1T1 … 1e9 tlog t您确定能过吗 D1T2 … 好多神奇算法 zyy: 两个log 应该当场是可能过的 D1T3 … zyy: 这题不是我出的 果然不是人写的 zyy: 复杂度，复杂度玄学，但是出题人说能过。为什么能过，我也不知道。 ？？ D2T1 您把换根dp讲的好轻巧 D2T2 … 结论说太快了没听懂 D2T3 … 果然有积分做法 还可以按照小数部分的顺序dp啊 zyy: 考场上有人写了这个暴力，然后clock()sleep()把数据骗出来，是唯一一个过了的人 zyy: 我觉得他真的很强 tql tql orz orz 颁奖老师：人有点多，分机房发吧 2号机房…3号机房…4号机房…5号机房… 剩下的去我的左手边… 楼下机房：为什么楼上都发好了下面这么慢 4:20p.m.提前开溜","categories":[{"name":"游记","slug":"travel","permalink":"http://chasingdeath.github.io/categories/travel/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"游记","slug":"travel","permalink":"http://chasingdeath.github.io/categories/travel/"}]},{"title":"个人简介&博客阅览帮助&?","slug":"个人简介&博客阅览帮助& ","date":"2021-05-17T04:55:07.000Z","updated":"2021-05-22T03:54:11.318Z","comments":true,"path":"articles/2021/05/17/2c66e6d.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/17/2c66e6d.html","excerpt":"","text":"个人简介&amp;博客阅览帮助&amp;?这是一个悲惨的蒟蒻ZJOIer的博客，目前正在打Cu的边缘努力挣扎 不善口胡，擅长套简单的模板题~~ 写过一点点多项式板板题，然鹅并没有任何用处 没看过concrete 数学 没有语文功底 很少打CodeForces，CodeChef，Topcoder，AtCoder 代码环境：Dev-Cpp × Emacs × VSCode × vim √ gvim √ Windows √ Linux √ 文章书写的时间跨度非常长，所以前面的可能不像是一个人写的 如果有出现很sb的错误，请@评论区 or qq 2946316707 板子问题:rep/drep是两端闭区间的循环,reg是register,erep是前向星遍历 ll:long long ull:unsigned long long u64:uint64_t=unsigned long long u32:uint32_t=unsigned i64:int64_t=long long i32:int32_t=int Pii: pair Mod1,Mod2是加减法取模 cmin,cmax=checkmin,checkmax 由于本人变量名比较随意，经常出现::，这个是访问主函数外(也就是空命名空间)的变量 代码中可能出现的$\\text{..{ } }$是C++11+的lambda语句 代码中可能出现的模板在这里 for(.. : ..)是容器完全遍历，需要C++11 模板用到了default template，以及可能出现别的问题，因此编译需要C++11 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef unsigned long long ull;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125; 阅读帮助常用的，阅读帮助 $\\forall,\\exists$任意，存在 $\\oplus$ oplus 异或 $[\\text{Logical Expression}]$艾弗森括号，根据其中逻辑表达式的真伪，值为1/0 $\\overline{x}\\underline{x}$上升幂下降幂 $\\lfloor x\\rfloor$ 向下取整 $\\lceil x\\rceil$ 向上取整 $|S|$ 集合大小，或者是矩阵行列式 $[x^i]f(x)$ 多项式$f(x)$的$x^i$一项的系数 $f^{(i)}(x)$ 对$f(x)$求$i$阶导 组合数的几种形式$\\begin{aligned}C(n,m),C_n^m,\\binom{n} {m}\\end{aligned}$ 第一类斯特林数$\\begin{bmatrix}n\\\\m\\end{bmatrix}$ 第二类斯特林数$\\begin{Bmatrix}n\\\\m\\end{Bmatrix}$ \\\\\\\\下面是给自己写Markdown/LaTex用的 字符$\\alpha$ alpha $\\beta$ beta $\\theta$ theta $\\Theta$ Theta (这个才是时间复杂度的标准符号) $\\varphi$ varphi (常表示欧拉函数) $\\phi$ phi $\\Phi$ phi (磁通量?) $\\lambda$ lambda $\\mu$ mu $\\omega$ omega (常表示单位根) $\\Omega$ $\\zeta$ zeta (常表示黎曼函数) 表达情形表示推导关系 $\\leftarrow$ leftarrow $\\Leftarrow$ Leftarrow $\\longleftarrow$ longleftarrow $\\Longleftarrow$ Longleftarrow 右箭头同理，双向改为leftright即可 $\\Leftrightarrow$ Leftrightarrow 常表示等价 $\\not\\ $ 非 not 这个符号是加在下一个字符上面的 $\\forall$ forall 任意 $\\exists\\nexists$ exists,nexists 存在 逻辑运算$\\and$ and 与 $\\or$ or 或 $\\oplus$ oplus 异或 $\\overline x$ 非(较少见) $[x]$ 艾弗森括号，其中$x$为一个逻辑表达式，其值为true:1 , false:0 $\\ne$ ne $\\le \\ge$ le,ge 显示与简单运算 A 引用，在行首直接加’&gt;’即可 加粗 … 删除线 ~~ .. ~~ $\\sim \\tilde {AB} \\widetilde{AB}$ \\sim , \\tilde {AB} ,\\widetilde{AB} 波浪线 $\\underline{AB}$ underline $\\overline{AB}$ overline $\\hat {AB}$ hat $\\widehat{AB}$ widehat $\\dot {A}$ dot $\\ddot A$ ddot $\\dddot A$ dddot $a^b$ a^{b} 上标 $a_b$ a_{b} 下标 $\\frac{a} {b}$ frac{ } { } 分数 cfrac{ } { }打开分数 $\\sum_{i=a}^b$ sum_{ }^{ } 求和 $\\prod_{i=a}^{b}$ prod_{ }^{ } 求积 $\\int$ int 积分 $\\iint$ iint 这几个可以通过双美刀 或者设置环境调节解析程度$\\text{\\begin{aligned}..\\end{aligned} }$ (这个是对齐环境) 或者\\displaystyle 来完成打开的显示模式 分段函数 $f(x)=\\left\\lbrace\\begin{aligned} 1 && b\\\\ 123 && d\\end{aligned}\\right.$ $\\text{f(x)\\left \\lbrace\\begin{aligned} 1 && b \\\\ 123 && d \\end{aligned}\\right.}$ $\\cdot$ cdot 点乘 $\\cdots$ cdots省略号 $\\times$ times 乘 $\\lfloor x\\rfloor$ lfloor ,rfloor 向下取整 $\\lceil x\\rceil$ lceil,rceil 向上取整 $x^{\\overline n}$ overline {n} 上升幂 $x^{\\underline{n} }$ underline{n} 下降幂 集合关系$\\in$ in 元素属于集合 $\\notin$ notin 不属于 $\\subset$ sub/subset 子集 $\\sube$ sube 子集或相等 $\\subseteqq$ subseteqq子集或相等 $\\subsetneq$ subneq 真子集 $\\subsetneqq$ subneqq 真子集 $\\supset$ supset 父集 $\\supe$ supe父集或相等 $\\supseteqq$ supseteqq 父集或相等 $\\supsetneq$ supsetneq 真父集 $\\supsetneqq$ supsetneqq 真父集 集合运算$\\empty$ empty 空集 $\\{ \\}\\lbrace\\rbrace$ 反斜杠+{ }或\\lbrace\\rbrace 大括号 $|S|$ 集合大小 $\\cup$ cup 并 $\\cap$ cap 交 $\\bigcup$ bigcup $\\bigcap$ bigcap $A \\setminus B$ setminus A-B，集合减操作 $\\mathbb{ABCDE}$ mathbb{ABCDE} $\\Delta \\bigoplus $ Delta bigoplus 对称差(?)，通常直接用异或代替 函数/多项式$f’(x)$ 求导 $f^{(i)}(x)$求i阶导 $[x^i]f(x)$第$i$项","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「USACO 2021 US Open Platinum」Routing Schemes","slug":"「USACO 2021 US Open Platinum」Routing Schemes","date":"2021-05-13T05:23:58.000Z","updated":"2021-05-22T03:54:11.265Z","comments":true,"path":"articles/2021/05/13/4dfec51.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/13/4dfec51.html","excerpt":"","text":"「USACO 2021 US Open Platinum」Routing Schemes$K=0$此时，我们只需要求合法的匹配路径数量，并且一个路径是从小到大的 由于题目保证一定存在合法路径，从$1$到$n$考虑每一条$(u,v),(v&gt;u)$ 我们可以看成是很多个$S$在路径上被从$1-n$不断地推过去 设一个点的入度为 $ind_v=\\sum_{(u,v)} 1+[v为S]$ $outd_u=\\sum_{(u,v)} 1+[u为R]$ 每次到达一个点，必然有其$ind_u=outd_u$，即推进来的$S$个数恰好等于出边个数 此时合法的分配这$outd_u$个$S$的方案数就是$outd_u!$ 直接求$\\prod outd_i!$即可 $K=1$存在反边的图看起来十分难处理，不妨直接把反边断掉 假设断掉前包含环的路径为 $S_1\\rightarrow a\\rightarrow b\\rightarrow R_1 (a&gt;b)$ 则断掉后的路径变成$S_1\\rightarrow a$，$b\\rightarrow R$ 不妨将在$a$上额外添加一个$R$，在$b$上额外添加一个$S$ 此时，新的问题又只包含$(u,v)(u&lt;v)$，同$K=0$求解 理想情况下，新问题中的所有方案均可以通过将$a,b$相接还原 但是显然如果最终方案上$b\\rightarrow a$相接就会成环 所以需要额外$dp$出包含$b\\rightarrow a$的非法方案 考虑用类似$K=0$的办法，我们扫描每个$i$将$S$向后推 令$dp_i$表示当前$dp$的路径最后一个点是$i$的方案数 我们希望结束点是$a$，开始点是$b$ 此时依次推过去$i$，此时只有$dp_{j},j\\ge i$的情况是合法的 考虑$j=i$时，需要为$j$找一个归宿$k$，或者判定$j=a$时结束路径 此时，相当于在原图上使$outd_i$减少了$1$ 得到转移$dp_k\\leftarrow dp_j\\cdot (outd_i-1)!$ 当$j&gt;i$时，不需要考虑$j$的变化 得到转移$dp_j\\leftarrow dp_j\\cdot outd_i!$ $K=2$有了$K=1$的铺垫，想必这里十分简单 设反边为$(a,b),(c,d)$，显然加入两组$S,R$ 考虑新图上什么样的情况是不合法的 1.$b\\rightarrow a$ 2.$d\\rightarrow c$ 注意1,2是有交的 3.$b\\rightarrow c\\rightarrow d\\rightarrow a$ 环交错扭在一起，这种情况比较容易漏掉 稍微容斥一下即可 复杂度分析： 扫描每个$i$时，$dp_{x,y}$中满足$x=i$或$y=i$的有$O(n)$个，转移每个需要$O(n)$时间 扫描每个$i$时，$dp_{x,y}$中满足$x=i$且$y=i$的有$O(1)$个，转移每个需要$O(n^2)$时间 因此复杂度为$O(n^3)$，常数不算太大 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107const int N=110,P=1e9+7;int n,k,J[N];char s[N];int G[N][N];namespace pt1&#123; void Solve()&#123; int ans=1; rep(i,1,n) ans=1ll*ans*J[deg[i]]%P; printf(&quot;%d\\n&quot;,ans); &#125;&#125;int deg[N];int Calc1(int a,int b)&#123; static int dp[N]; // calculate stategies that contain b-&gt;a memset(dp,0,sizeof dp); dp[b]=1; rep(i,1,n) &#123; drep(j,n+1,i) if(dp[j]) &#123; if(j==i) &#123; if(i==a) dp[n+1]=(dp[n+1]+1ll*J[deg[i]-1]*dp[j])%P; else &#123; rep(k,i+1,n) if(G[i][k]) dp[k]=(dp[k]+1ll*J[deg[i]-1]*dp[j])%P; &#125; &#125; else dp[j]=1ll*dp[j]*J[deg[i]]%P; &#125; &#125; return dp[n+1];&#125;int Calc2(int a,int b,int c,int d)&#123; // calculate strategies that contain both b-&gt;a,d-&gt;c static int dp[N][N]; memset(dp,0,sizeof dp),dp[b][d]=1; rep(i,1,n) &#123; drep(x,n+1,i) drep(y,n+1,i) if(dp[x][y]) &#123; int t=1ll*dp[x][y]*J[deg[i]-(x==i)-(y==i)]%P; if(x!=i &amp;&amp; y!=i) &#123; dp[x][y]=t; continue; &#125; if(x!=i) &#123; if(y==c) dp[x][n+1]+=t,Mod1(dp[x][n+1]); else rep(j,i+1,n) if(G[i][j]) dp[x][j]+=t,Mod1(dp[x][j]); continue; &#125; if(y!=i) &#123; if(x==a) dp[n+1][y]+=t,Mod1(dp[n+1][y]); else rep(j,i+1,n) if(G[i][j]) dp[j][y]+=t,Mod1(dp[j][y]); continue; &#125; if(x==a) &#123; if(y==c) dp[n+1][n+1]+=t,Mod1(dp[n+1][n+1]); else rep(j,i+1,n) if(G[i][j]) dp[n+1][j]+=t,Mod1(dp[n+1][j]); continue; &#125; if(y==c) &#123; rep(j,i+1,n) if(G[i][j]) dp[j][n+1]+=t,Mod1(dp[j][n+1]); &#125; else &#123; rep(j,i+1,n) if(G[i][j]) rep(k,i+1,n) if(G[i][k] &amp;&amp; j!=k) dp[j][k]+=t,Mod1(dp[j][k]); &#125; &#125; &#125; return dp[n+1][n+1];&#125;namespace pt2&#123; void Solve()&#123; int a=-1,b=-1; rep(i,1,n) rep(j,1,i-1) if(G[i][j]) a=i,b=j; int ans=1; rep(i,1,n) ans=1ll*ans*J[deg[i]]%P; ans-=Calc1(a,b),Mod2(ans); printf(&quot;%d\\n&quot;,ans); &#125;&#125;namespace pt3&#123; void Solve()&#123; int a=-1,b=-1,c=-1,d=-1; rep(i,1,n) rep(j,1,i-1) if(G[i][j]) &#123; if(a==-1) a=i,b=j; else c=i,d=j; &#125; int ans=1; rep(i,1,n) ans=1ll*ans*J[deg[i]]%P; ans-=Calc1(a,b),Mod2(ans); ans-=Calc1(c,d),Mod2(ans); ans+=Calc2(a,b,c,d),Mod1(ans); ans-=Calc2(c,b,a,d),Mod2(ans); printf(&quot;%d\\n&quot;,ans); &#125;&#125;int main()&#123; rep(i,*J=1,N-1) J[i]=1ll*J[i-1]*i%P; rep(_,1,rd()) &#123; n=rd(),k=rd(),scanf(&quot;%s&quot;,s+1); rep(i,1,n) rep(j,1,n) scanf(&quot;%1d&quot;,G[i]+j); rep(i,1,n) &#123; deg[i]=s[i]==&#x27;R&#x27;; rep(j,1,n) deg[i]+=G[i][j]; &#125; if(k==0) pt1::Solve(); else if(k==1) pt2::Solve(); else pt3::Solve(); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"USACO","slug":"USACO","permalink":"http://chasingdeath.github.io/tags/USACO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「USACO 2021 US Open Platinum」Balanced Subsets","slug":"「USACO 2021 US Open Platinum」Balanced Subsets","date":"2021-05-13T05:11:11.000Z","updated":"2021-05-22T03:54:11.263Z","comments":true,"path":"articles/2021/05/13/2d2aef2a.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/13/2d2aef2a.html","excerpt":"","text":"「USACO 2021 US Open Platinum」Balanced Subsets考虑题目给出的定义对应怎样的图形，显然是一个凸的封闭图形 不妨通过左右边线描述，从上到下 1.左边线先左移再右移 2.右边线先右移再左移 不妨直接令$dp_{i,l,r,f1,f2}$表示当前第$i$行，当前左右边线为$l,r(l\\leq r,\\forall j\\in[l,r],a_{i,j}=G)$ $f1,f2$表示当前左右边线处于左移还是右移状态 以左边线为例，定义右移开始的时刻为第一个$l&gt;l’$的时刻 容易得到转移，是一个前/后缀和的形式 那么对于$[l,r]$两维分别做前缀和，然后$O(n^3)$转移即可 注意转移过程中要确保$[l’,r’],[l,r]$有交 以下是暴力二维前缀和+手艹9种转移的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243const int N=170,P=1e9+7;int n;int c[N];char s[N];int dp[N][N][2][2];int F[N][N][2][2];int S(int a,int b,int x1,int x2,int y1,int y2)&#123; x1--,y1--; return (0ll+F[x2][y2][a][b]-F[x1][y2][a][b]-F[x2][y1][a][b]+F[x1][y1][a][b])%P;&#125;int main()&#123; n=rd(); int ans=0; rep(i,1,n) &#123; scanf(&quot;%s&quot;,s+1); rep(j,1,n) c[j]=c[j-1]+(s[j]==&#x27;G&#x27;); memset(F,0,sizeof F); rep(i,1,n) rep(j,1,n) rep(a,0,1) rep(b,0,1) &#123; F[i][j][a][b]=(0ll+F[i-1][j][a][b]+F[i][j-1][a][b]-F[i-1][j-1][a][b]+dp[i][j][a][b])%P; &#125; memset(dp,0,sizeof dp); rep(l,1,n) rep(r,l,n) if(c[r]-c[l-1]==r-l+1) &#123; (dp[l][r][0][0]+=S(0,0,l,r,l,r))%=P; (dp[l][r][1][0]+=S(0,0,1,l-1,l,r))%=P; (dp[l][r][0][1]+=S(0,0,l,r,r+1,n))%=P; (dp[l][r][1][1]+=S(0,0,1,l-1,r+1,n))%=P; (dp[l][r][0][1]+=S(0,1,l,r,r,n))%=P; (dp[l][r][1][1]+=S(0,1,1,l-1,r,n))%=P; (dp[l][r][1][0]+=S(1,0,1,l,l,r))%=P; (dp[l][r][1][1]+=S(1,0,1,l,r+1,n))%=P; (dp[l][r][1][1]+=S(1,1,1,l,r,n))%=P; &#125; rep(l,1,n) rep(r,l,n) if(c[r]-c[l-1]==r-l+1) dp[l][r][0][0]++; rep(l,1,n) rep(r,l,n) rep(a,0,1) rep(b,0,1) if(dp[l][r][a][b]) ans=(ans+dp[l][r][a][b])%P; &#125; Mod2(ans),printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"USACO","slug":"USACO","permalink":"http://chasingdeath.github.io/tags/USACO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「USACO 2021 US Open Platinum」United Cows of Farmer John","slug":"「USACO 2021 US Open Platinum」United Cows of Farmer John","date":"2021-05-13T03:47:16.000Z","updated":"2021-05-22T03:54:11.267Z","comments":true,"path":"articles/2021/05/13/13490733.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/13/13490733.html","excerpt":"","text":"「USACO 2021 US Open Platinum」United Cows of Farmer John考虑依次枚举右端点$i$，计算左边合法的方案数，设一个数$x$上次出现的位置为$lst_x$ 则$i$能够作为右端点的区间就是$[lst_{a_i}+1,i-2]$ 考虑什么样的位置可以作为左端点，显然这个点在$[1,i]$中是最后一次出现 我们将不妨这样的点权值设为$w_i=1$ 考虑一个点作为中间点贡献怎样的区间，同样的，这个点在$[1,i]$中是最后一次出现 并且，能够贡献的区间$&gt;$上一次出现的位置$lst_x$ 这个中间点能够匹配的左端点个数就是$\\displaystyle \\sum_{k=lst_{a_j}+1}^{j-1} w_k$ 现在我们要用数据结构动态修改某一个位置的$w_i$，增减$[lst_{a_j}+1,j-1]$的区间，查询$[lst_{a_i}+1,i-2]$ 不妨再为一个点增加点权$t_i$，此时我们要维护的操作 1.单点修改$w_i$ 2.区间修改$t_i$ 3.求$w_it_i$区间和 在线段树上每个节点维护$w_i$之和，$w_it_i$之和，可以标记永久化$t_i$ 具体实现参考代码（实际写得很丑） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int N=2e5+10,INF=1e9+10;int n;int lst[N],lst2[N],cnt;ll s1[N&lt;&lt;2],s2[N&lt;&lt;2];int t[N&lt;&lt;2];// s1表示w之和，s2表示区间内部t[i]*w[i]之和，t[i]现在是永久化的标记void Up(int p)&#123; s2[p]=s2[p&lt;&lt;1]+s2[p&lt;&lt;1|1]; s1[p]=s1[p&lt;&lt;1]+s1[p&lt;&lt;1|1]+s2[p]*t[p];&#125;void Upd(int p,int l,int r,int x)&#123; if(l==r) &#123; s2[p]^=1,s1[p]=t[p]*s2[p]; return; &#125; int mid=(l+r)&gt;&gt;1; x&lt;=mid?Upd(p&lt;&lt;1,l,mid,x):Upd(p&lt;&lt;1|1,mid+1,r,x); Up(p);&#125;void Upd(int p,int l,int r,int ql,int qr,int x)&#123; if(ql&gt;qr) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; t[p]+=x,s1[p]+=x*s2[p]; return; &#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) Upd(p&lt;&lt;1,l,mid,ql,qr,x); if(qr&gt;mid) Upd(p&lt;&lt;1|1,mid+1,r,ql,qr,x); Up(p);&#125;struct Node&#123; ll x,y; Node(ll x=0,ll y=0):x(x),y(y)&#123; &#125; Node operator + (const Node __) &#123; return Node(x+__.x,y+__.y); &#125;&#125;;Node Que(int p,int l,int r,int ql,int qr)&#123; if(ql&gt;qr) return Node(); if(ql&lt;=l &amp;&amp; r&lt;=qr) return Node(s1[p],s2[p]); int mid=(l+r)&gt;&gt;1; Node res; if(ql&lt;=mid) res=res+Que(p&lt;&lt;1,l,mid,ql,qr); if(qr&gt;mid) res=res+Que(p&lt;&lt;1|1,mid+1,r,ql,qr); res.x+=res.y*t[p]; return res;&#125;int main()&#123; n=rd(); ll ans=0; rep(i,1,n) &#123; int x=rd(); if(lst[x]) &#123; Upd(1,1,n,lst[x]),cnt--; Upd(1,1,n,lst2[x]+1,lst[x],-1); &#125; Node t=Que(1,1,n,lst[x]+1,i-2); ans+=t.x; Upd(1,1,n,i),cnt++,Upd(1,1,n,lst[x]+1,i-1,1); lst2[x]=lst[x],lst[x]=i; &#125; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"USACO","slug":"USACO","permalink":"http://chasingdeath.github.io/tags/USACO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF715E - Complete the Permutations","slug":"CF715E - Complete the Permutations","date":"2021-05-12T13:07:19.000Z","updated":"2021-05-22T03:54:10.865Z","comments":true,"path":"articles/2021/05/12/268c9698.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/12/268c9698.html","excerpt":"","text":"CF715E - Complete the Permutations题目大意对于两个排列$p,q$，令$p\\rightarrow q$代价为通过交换使得$p$变成$q$的最小步数 现在部分给定了$p$和$q$，求所有情况下，$p\\rightarrow q=i,i\\in[0,n-1]$的排列组数目 分析排列变换显然要放到置换环上考虑，考虑两个排列之间的变换有多种等价的方式 不妨认为连的边就是$p_i\\rightarrow q_i$，最终操作步数就是$n-$置换环的个数 对于已经确定的部分，能够确定的边可以直接连，能够确定的链可以缩成点 那么最终，图上只剩下三种待定的边 $0\\rightarrow 0,0\\rightarrow x,x\\rightarrow 0$，其中$0\\rightarrow x,x\\rightarrow 0$表示一条出现了一半的边 ps: 如果有$0\\rightarrow x\\rightarrow 0$，那么直接缩成一个$0\\rightarrow 0$看待 不妨设这三种边个数分别为$A,B,C$，已经确定的环可以数出是$D$最后加入答案 由于一个$A$由两边确定，实际上确定一个边组之后，排列$0\\rightarrow 0$的位置得到$A!$种方案，也可以最后加入答案 考虑什么样的边可以接成环 仅A:$0\\rightarrow 0,0\\rightarrow 0\\cdots$ 仅B: $0\\rightarrow x,0\\rightarrow x\\cdots$ 仅C: $x\\rightarrow 0,x\\rightarrow 0,\\cdots$ A+B=A,$0\\rightarrow x+0\\rightarrow 0=0\\rightarrow 0$ C+A=A,$0\\rightarrow 0+x\\rightarrow 0=0\\rightarrow 0$ 实际上，组合环的情况 B前面要么是B要么是A，最终将A后面跟着的小弟B都缩在一起看待 C后面要么是C要么是A，最终将A前面跟着的大哥C都缩在一起看待 实际上B,C计算类似，我们能够得到一个计算思路 将每个B,C加入组合环对于组合环缩点之后的点数无影响，那么可以将A,B,C分离计算 那么考虑一个B要么在单纯的B环上要么在组合环上 枚举有$i$个$B$在单纯B环上，构成$j$个环的方案数（当然要先组合数将$j$个点选出） 这就是第一类斯特林数$\\begin{bmatrix}i\\\\j\\end{bmatrix}$，参考 剩下的加入组合环中，考虑依次加入每个B，每个B可以接在B后面也可以接在A后面 方案数即$A^{\\overline{B-i} }$，最终计算得到$G_i$表示B构成了i个单纯B环的方案数，复杂度为$O(n^2)$ A的贡献不需要将组合环和单纯A环分开考虑，直接就是$F_i=\\begin{bmatrix}A\\\\i\\end{bmatrix}$ 最后将三种点背包合并，加入前面提到的常量即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)enum&#123;N=300,P=998244353&#125;;int n;int p[N],q[N],pre[N],nxt[N],A,B,E,D;int F[N],G[N],H[N],V[N];int S[N][N],T[N][N],C[N][N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); rep(i,1,n) pre[i]=nxt[i]=-1; rep(i,**S=1,n) rep(j,1,i) S[i][j]=(S[i-1][j-1]+1ll*(i-1)*S[i-1][j])%P; rep(i,0,n) rep(j,*T[i]=1,n) T[i][j]=1ll*T[i][j-1]*(i+j-1)%P; rep(i,0,n) rep(j,*C[i]=1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%P; rep(i,1,n) scanf(&quot;%d&quot;,p+i); rep(i,1,n) &#123; scanf(&quot;%d&quot;,q+i); if(p[i] &amp;&amp; q[i]) nxt[p[i]]=q[i],pre[q[i]]=p[i]; else if(p[i]) nxt[p[i]]=0; else if(q[i]) pre[q[i]]=0; &#125; rep(i,1,n) if(pre[i]&lt;=0) &#123; int j=i; for(;nxt[j]&gt;0;j=nxt[j]) V[j]=1; V[j]=1; if(pre[i]==nxt[j]) A+=pre[i]==-1; // ==0 || ==-1 ,but we can&#x27;t count 0 in else if(~pre[i]) B++; else E++; &#125; rep(i,1,n) if(!V[i]) &#123; for(int j=i;!V[j];j=nxt[j]) V[j]=1; D++; &#125; int c=1; rep(i,1,A) c=1ll*c*i%P; rep(i,0,A) F[i]=1ll*c*S[A][i]%P; rep(i,0,B) rep(j,0,i) G[j]=(G[j]+1ll*S[i][j]*T[A][B-i]%P*C[B][i])%P; rep(i,0,E) rep(j,0,i) H[j]=(H[j]+1ll*S[i][j]*T[A][E-i]%P*C[E][i])%P; rep(i,0,n) V[i]=0; rep(i,0,A) rep(j,0,B) V[i+j+D]=(V[i+j+D]+1ll*F[i]*G[j])%P; rep(i,0,n) F[i]=0; rep(i,0,A+B+D) rep(j,0,E) F[n-i-j]=(F[n-i-j]+1ll*V[i]*H[j])%P; rep(i,0,n-1) printf(&quot;%d &quot;,F[i]);&#125; 进一步的优化？$F_i$的计算时标准的第一类斯特林数行，用倍增法求上升幂即可 $\\displaystyle G(x)=\\sum_{i=0}^B A^{\\overline{B-i} }\\binom{B} {i} x^{\\overline{i} }$ 把系数拿出来，可以直接做一个上升幂多项式转普通多项式 复杂度为$O(n\\log ^2n)$ （听说可以$O(n\\log n)$但是我没有脑子只会套板子哈哈哈哈） 以下未上传！！！如果看到说明我在搞笑！！！看到叫我 $\\displaystyle G_i=\\sum_{j=i}^B \\binom{B} {j}A^{\\overline{B-j} }\\cdot [x^j]\\frac{1} {i!}(-1)^i\\ln^i(1-x)$ $\\displaystyle G_i=\\sum_{j=i}^B \\frac{B!} {j!(B-j)!}\\frac{(A+B-j-1)!} {(A-1)!}\\cdot [x^j]\\frac{1} {i!}(-1)^i\\ln^i(1-x)$ $\\displaystyle G_i=\\frac{(-1)^iB!} {(A-1)!i!} \\sum_{j=i}^B \\frac{(A+B-j-1)!} {j!(B-j)!}\\cdot [x^j]\\ln^i(1-x)$ 由于对于每个$i$，$\\displaystyle \\sum_{j=i}^B \\frac{(A+B-j-1)!} {j!(B-j)!}$是常量，设 $\\displaystyle \\varphi(x)=\\sum_{j=0}^B x^{-1-j} \\frac{(A+B-j-1)!} {j!(B-j)!}$(为什么是是$-1-j$会在下面出现) $\\displaystyle G_i=\\frac{(-1)^iB!} {(A-1)!i!} [x^{-1}] \\varphi(x)\\ln^i(1-x)$ 对比扩展拉格朗日反演的形式 $\\displaystyle [x^n]H(G(x))=\\frac{1} {n}[x^{-1}]H’(x)(\\frac{1} {F(x)})^n$，其中$G(x)$为$F(x)$的复合逆 得到$\\displaystyle H(x)=\\int \\varphi(x),F(x)=\\frac{1} {\\ln(1-x)}$ 从而得到$F(x)$的复合逆为$\\displaystyle 1-e^{x^{-1} }$ 现在要算$H(1-e^{x^{-1} })=\\sum$","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1503E - 2-Coloring","slug":"CF1503E - 2-Coloring","date":"2021-05-12T09:57:01.000Z","updated":"2021-05-22T03:54:10.836Z","comments":true,"path":"articles/2021/05/12/4187466f.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/12/4187466f.html","excerpt":"","text":"CF1503E - 2-Coloring题目大意给定一个$n\\times m$网格图，给每个格子黑白染色，使得最终 每行恰好只有一条黑色线段，每列恰好只有一条白色线段 求方案数 分析这种东西当然是分析好情况就ok了 大概分几种情况 1. 2. 3. 为什么要把第三种拿出来说呢，实际上第三种是1和2的交（黑白都是梯形，确信） 那么枚举中间的分界线，根据中间相距最近的两个点的位置就能用组合数确定答案 （虽然代码里不是组合数） 前缀和优化即可$O(nm)$，注意两个梯形可以对称，所以最后答案*2 12345678910111213141516171819202122232425262728293031323334353637383940414243const int N=2030,INF=1e9+10,P=998244353;int n,m;int dp[N][N],ans;// dp[i][j]是i个，每个&gt;=0且递增，最后一个&lt;=j的方案数ll F(int n,int m)&#123; if(m&lt;0) return 0; return m==0?1:(dp[n][m]-dp[n][m-1]+P)%P;&#125;int S[N],T[N];void Calc()&#123; rep(i,1,n-1) &#123; int s=0; rep(j,1,m-1) &#123; s=(s+1ll*F(j,i)*dp[m-j][i-1])%P; ans=(ans+1ll*s*F(m-j,n-i)%P*dp[j][n-i-1])%P; &#125; &#125;&#125;int main()&#123; dp[0][0]=1; rep(i,1,N-1)&#123; rep(j,0,N-1) &#123; if(j) dp[i-1][j]+=dp[i-1][j-1],Mod1(dp[i-1][j]); dp[i][j]=dp[i-1][j]; &#125; &#125; n=rd(),m=rd(); Calc(),swap(n,m),Calc(); rep(i,1,n-1) &#123; int s=0; rep(j,1,m-1) &#123; s=1ll*F(j,i)*dp[m-j][i-1]%P; ans=(ans-1ll*s*F(m-j,n-i)%P*dp[j][n-i-1])%P; &#125; &#125; Mod2(ans); printf(&quot;%d\\n&quot;,ans*2%P);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1392H - ZS Shuffles Cards","slug":"CF1392H - ZS Shuffles Cards","date":"2021-05-12T04:14:04.000Z","updated":"2021-05-22T03:54:10.801Z","comments":true,"path":"articles/2021/05/12/49ee0c99.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/12/49ee0c99.html","excerpt":"","text":"CF1392H - ZS Shuffles Cards题目大意给定$n$张卡和$m$个终止符，初始时随机打乱成排列，每次操作选出最前面的卡$x$拿走 1.如果$x$不是终止符，将$x$放入集合 2.如果$x$是终止符，那么重新打乱$n+m$张卡 求期望多少步$S$变成全集 分析令$dp_i$表示当前手上有$i$张不同卡时期望多少步结束 按轮考虑，一轮期望操作次数固定，即 $\\displaystyle \\frac{\\displaystyle \\sum _{i=0}^n \\binom{n+m-i-1} {m-1}(i+1)} {\\displaystyle \\binom{n+m} {m} }$ 现在考虑从$dp_{i+j}$转移过来，当前的牌可以分为三类 1.手里有的 2.手里没有的 3.终止牌 我们计算$dp_{i+j}$向$dp_i$转移时的概率，并不需要管1类卡，只需要考虑2,3类卡的相对顺序 不妨直接忽略手里的$i$张卡，得到转移系数 $dp_{i+j}\\rightarrow dp_i: \\cfrac{\\displaystyle \\binom{n-i-j-1} {m-1} } {\\displaystyle \\binom{n-i+m} {m} }$ 容易发现可以将$\\displaystyle dp_{i+j}\\binom{n-i-j-1} {m-1}$累和完成 注意$dp_i$有向$dp_{i}$自己的转移，需要解一次方程，因此需要求逆元 1234567891011121314151617181920212223242526272829const int N=4e6+10,P=998244353;int n,m;int I[N],J[N];ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int F[N];ll C(int n,int m)&#123; return 1ll*J[n]*I[m]%P*I[n-m]%P; &#125;ll IC(int n,int m)&#123; return 1ll*I[n]*J[m]%P*J[n-m]%P; &#125;int main()&#123; rep(i,*J=1,N-1) J[i]=1ll*J[i-1]*i%P; I[N-1]=qpow(J[N-1]); drep(i,N-1,1) I[i-1]=1ll*I[i]*i%P; n=rd(),m=rd(); ll s=0,inv=IC(n+m,m),coef=0; rep(i,0,n) coef=(coef+C(n+m-i-1,m-1)*(i+1))%P; coef=coef*inv%P; drep(i,n-1,0) &#123; ll p=C(n+m-i-1,m-1),t=IC(n-i+m,m); F[i]=(s*t%P+coef)%P*qpow(P+1-p*t%P)%P; s=(s+1ll*p*F[i])%P; &#125; printf(&quot;%d\\n&quot;,F[0]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"多项式与点值式","slug":"多项式与点值式","date":"2021-05-12T01:04:01.000Z","updated":"2021-05-22T03:54:11.350Z","comments":true,"path":"articles/2021/05/12/a8fd8b80.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/12/a8fd8b80.html","excerpt":"","text":"多项式与点值式正常$\\text{DFT/IDFT}$是构造一个特殊的点值式，即$x_i=\\omega_{n}^i$ 如果能通过题目条件构造出来这样的点值，就可以直接$\\text{DFT/IDFT}$ 那如果不能的话。。。。。 多项式多点求值一个多项式$F(x)$我们求它在$x_0,x_0,\\cdots x_{m-1}$上的点值 核心是分治+多项式取模，因此常数很大 对于当前分治区间$[l,r]\\in[0,m-1]$ 需要快速构造一个长度为$\\frac{r-l+1} {2}$的等价多项式进入分治区间 令$G_{l,r}(x)=\\prod_l^r(1-x_i)$ 由于$G_{l,r(x_l)}=\\cdots=G_{l,r}(x_r)=0$ 所以可以将$F(x)$对于$G_{l,mid}(x)$和$G_{mid+1,r}(x)$分别取模之后得到两个等价式 递归到$[l=r]$时，$F(x)$只剩下常数项 需要被访问的$G(x)$可以预先跑一遍分治NTT求出 那么复杂度就是$O(n\\log ^2n)$ 这种做法代码实现困难，而且常数非常大 \\ 多项式快速插值对于点对$(x_i,y_i)$ 多项式拉格朗日插值的式子是 $$\\begin{aligned}F(x) = \\sum_{i=0}^{n-1} y_i \\prod_{i\\ne j} \\frac{x-x_j} {x_i-x_j}\\end{aligned}$$ 那么需要快速求出$\\prod \\frac{1} {x_i-x_j}$ 构造多项式$G(x)=\\prod (x-x_i)$ 那么$\\prod (x_i-x_j)=\\frac{G} {x-x_i}(x_i)$ 由于$G(x),x-x_i$在$x_i$上的点值均为$0$ 我们要求的多项式就是$\\begin{aligned} \\prod_{i\\ne j} (x_i-x_j) \\end{aligned}=\\frac{G(x)} {x-x_i}$ 即求出$\\frac{G} {x-x_i}(x_i)$ 分母分子均为$0$，所以带入洛必达法则$\\begin{aligned}\\frac{G} {x-x_i}(x_i)=\\frac{G'} {(x-x_i)'}(x_i)=G'(x_i)\\end{aligned}$ 那么求出$G’(x)$，然后多项式多点求值即可 剩下那一部分的答案，可以简单地分治合并上来，$[l=r]$时，多项式是一个常数 合并上来时 $[l,mid]$的答案补上$\\prod_{mid+1}^r (x-x_i)$ $[mid+1,r]$的答案补上$\\prod_{l}^{mid} (x-x_i)$ 即复杂度为$O(n\\log ^2n)$ 垃圾模板题卡常 \\\\应用转置原理对于多点求值的优化由于这个东西实在是太新了，所以没有什么文献可以看 关于转置原理的前置定义矩阵的转置: 对于$n\\cdot m$的矩阵$M$，它的转置$M^{T}$为交换行列坐标后得到的$m\\cdot n$的矩阵 其满足运算性质: 1.逆: ${(A^T)}^T=A$ 2.和:$(A+B)^T=A^T+B^T$ 3.反积:$(AB)^T=B^TA^T$ 初等矩阵: 初等矩阵是指单位矩阵通过初等变换(交换行列，某一行(列)乘上$k$加到另一行(列)上，类似高斯消元)得到的矩阵 对于计算$b=A\\cdot a$，其中$A$为矩阵，$a,b$为列向量 考虑先计算$b’=A^T\\cdot a$ 出计算$b’$的过程，这可以分解成若干步操作（或说是初等矩阵）$E_1,E_2,\\cdots E_k$ 即$b’=E_1\\cdot E_2\\cdot E_3\\cdots E_k\\cdot a$ 将$E_i$倒序执行，并且每一步都换成原先操作的转置$E_i^T$，就能得到$A\\cdot a$ 即$b=E^T_k\\cdot E^T_{k-1}\\cdots E^T_1\\cdot a$ 应用转置原理的优化核心如果把多项式系数视为列向量$F$，则可以把多项式多点求值的过程视为一个矩阵运算$M$ 为了便于描述，设要求的点值和多项式项数均为$n$ 设要求的点横坐标为$x_i$，则$M$是范德蒙德矩阵 $1$ $x_0^1$ $x_0^2$ … 1 $x_1^1$ $x_1^2$ … 1 $x_2^1$ $x_2^2$ … … 分析会发现我们要求的实际上是$b=M\\cdot F$（到底是谁对矩阵乘法有误解？） 现在来将问题转置，先假装求$b’=M^T\\cdot F$ $1$ 1 1 … $x_0^1$ $x_1^1$ $x_2^1$ … $x_0^2$ $x_1^2$ $x_2^2$ … … 实际$M^T\\cdot F$得到的结果用形式幂级数表示是 $\\displaystyle\\sum F_i\\sum_{j=0}^{n-1}x_i^j\\equiv \\sum \\frac{F_i} {1-x_ix}\\pmod {x^n}$ 求$\\displaystyle M^T\\cdot F= \\sum \\frac{F_i} {1-x_ix}\\pmod {x^n}$ 可以用两次分治 $\\text{NTT}$ 解决，大致过程可以描述为 1.将问题转化为求$\\begin{aligned} \\frac{\\sum F_i\\prod _{i\\ne j} {(1-x_jx)} } {\\prod (1-x_ix)}\\end{aligned} $ 2.对于分治节点$[L,R]$，求得$T(L,R)=\\prod_{i=L}^R{(1-x_i)}$ 3.从下往上合并，每次合并答案为$A(L,R)=A(L,mid)\\cdot T(mid+1,R)+A(mid+1,R)\\cdot T(L,mid)$ 4.最后将答案$A(0,n-1)$除以$\\prod(1-x_ix)$ \\然后我们考虑把所有的操作都反过来并且换成转置，求得$M\\cdot F$ 因为过程中涉及到多项式卷积，设其转置运算为$\\oplus$ 我们知道普通的多项式卷积为$F(x)\\cdot G(x)=\\sum_i\\sum_j [x^i]F(x)[x^j]G(x)x^{i+j}$ 则其转置为$mul^T(F(x),G(x))=F(x)\\oplus G(x)=\\sum_i\\sum_{j\\leq i} [x^i]F(x)[x^j]G(x)x^{i-j}$ 可以看到这个操作会导致多项式项数降低，若原先$F(x),G(x)$最高项为$n,m$，则转置卷积后最高项为$n-m$ \\那么给出整个转置后的过程为 1.在$F(x)$后面加上若干个$0$，求出$\\displaystyle A(0,n-1)=F(x) \\oplus \\frac{1} {\\prod(1-x_ix)}$的前$n$项 2.对于每个分治节点，依然预处理$\\displaystyle T(L,R)=\\prod_{i=L}^R{(1-x_ix)}$ 3.从顶向下递归，向子节点下传 $A(L,mid)= A(L,R)\\oplus T(mid+1,R)$ $A(mid+1,R)= A(L,R)\\oplus T(L,mid)$ 递归到子节点时，只剩一项，即是每一个点值 \\关于这个优化的效果: 1.不需要写多项式除法和取模了! 2.第二次分治的过程中调用的$mul^T$长度短一倍 下面这份代码是优化过的版本，能快一倍左右，但关键还是代码短听说可以被卡常卡到1s跑1e6 Luogu Submission 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1&lt;&lt;17,P=998244353;typedef vector &lt;int&gt; V;int n,m;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int w[N],Inv[N+1],rev[N];void Init()&#123; w[N/2]=1; for(int t=qpow(3,(P-1)/N),i=N/2+1;i&lt;N;++i) w[i]=1ll*w[i-1]*t%P; drep(i,N/2-1,1) w[i]=w[i&lt;&lt;1]; Inv[0]=Inv[1]=1; rep(i,2,N) Inv[i]=1ll*(P-P/i)*Inv[P%i]%P;&#125;int Init(int n) &#123; int R=1,cc=-1; while(R&lt;n) R&lt;&lt;=1,cc++; rep(i,1,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;cc); return R;&#125;void NTT(int n,V &amp;A,int f)&#123; ull a[N]; if((int)A.size()&lt;n) A.resize(n); rep(i,0,n-1) a[i]=A[rev[i]]; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=a[j+i]*e[j-l]%P; a[j+i]=a[j]+P-t; a[j]+=t; &#125; &#125; &#125; rep(i,0,n-1) A[i]=a[i]%P; if(f==-1) &#123; reverse(A.begin()+1,A.end()); rep(i,0,n-1) A[i]=1ll*A[i]*Inv[n]%P; &#125;&#125;V operator ~ (V F) &#123; int n=F.size(); if(n==1) return V&#123;(int)qpow(F[0])&#125;; V G=F; G.resize((n+1)/2),G=~G; int R=Init(n*2); NTT(R,F,1),NTT(R,G,1); rep(i,0,R-1) F[i]=(2-1ll*F[i]*G[i]%P+P)*G[i]%P; NTT(R,F,-1),F.resize(n); return F;&#125;V operator * (V A,V B) &#123; int n=A.size()+B.size()-1,R=Init(n); NTT(R,A,1),NTT(R,B,1); rep(i,0,R-1) A[i]=1ll*A[i]*B[i]%P; NTT(R,A,-1),A.resize(n); return A;&#125;V Evaluate(V F,V X)&#123; static int ls[N&lt;&lt;1],rs[N&lt;&lt;1],cnt; static V T[N&lt;&lt;1]; static auto TMul=[&amp;](V F,V G)&#123; reverse(G.begin(),G.end()); int n=F.size(),m=G.size(),R=Init(n); NTT(R,F,1),NTT(R,G,1); rep(i,0,R-1) F[i]=1ll*F[i]*G[i]%P; NTT(R,F,-1); V T(n-m+1); rep(i,0,n-m) T[i]=F[i+m-1]; return T; &#125;; static function &lt;int(int,int)&gt; Build=[&amp;](int l,int r) &#123; int u=++cnt; ls[u]=rs[u]=0; if(l==r) &#123; T[u]=V&#123;1,P-X[l]&#125;; return u; &#125; int mid=(l+r)&gt;&gt;1; ls[u]=Build(l,mid),rs[u]=Build(mid+1,r); T[u]=T[ls[u]]*T[rs[u]]; return u; &#125;; int n=F.size(),m=X.size(); cmax(n,m),F.resize(n),X.resize(n); cnt=0,Build(0,n-1); F.resize(n*2+1),T[1]=TMul(F,~T[1]); int p=0; rep(i,1,cnt) if(ls[i]) &#123; swap(T[ls[i]],T[rs[i]]); int R=Init(T[i].size()),n=T[i].size(),m1=T[ls[i]].size(),m2=T[rs[i]].size(); NTT(R,T[i],1); reverse(T[ls[i]].begin(),T[ls[i]].end()); reverse(T[rs[i]].begin(),T[rs[i]].end()); NTT(R,T[ls[i]],1); NTT(R,T[rs[i]],1); rep(j,0,R-1) &#123; T[ls[i]][j]=1ll*T[ls[i]][j]*T[i][j]%P; T[rs[i]][j]=1ll*T[rs[i]][j]*T[i][j]%P; &#125; NTT(R,T[ls[i]],-1); NTT(R,T[rs[i]],-1); rep(j,0,n-m1) T[ls[i]][j]=T[ls[i]][j+m1-1]; T[ls[i]].resize(n-m1+1); rep(j,0,n-m2) T[rs[i]][j]=T[rs[i]][j+m2-1]; T[rs[i]].resize(n-m2+1); //T[ls[i]]=TMul(T[i],T[ls[i]]); T[rs[i]]=TMul(T[i],T[rs[i]]); &#125; else X[p++]=T[i][0]; X.resize(m); return X;&#125;int main()&#123; Init(),n=rd(),m=rd(); V F(n+1),X(m); rep(i,0,n) F[i]=rd(); rep(i,0,m-1) X[i]=rd(); V Res=Evaluate(F,X); for(int i:Res) printf(&quot;%d\\n&quot;,i);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"CF1499G - Graph Coloring","slug":"CF1499G - Graph Coloring","date":"2021-05-11T12:31:07.000Z","updated":"2021-05-22T03:54:10.834Z","comments":true,"path":"articles/2021/05/11/24cd28ff.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/11/24cd28ff.html","excerpt":"","text":"CF1499G - Graph Coloring题目大意有一个二分图，$m$条边，每条边可以选择为+1或者-1，表示两端的点权值$a_u,a_v\\pm 1$ 最终的权值总和是$\\sum |a_u|$ 现在要维护一个动态加边操作 每次加边之后动态维护一个最优的方案最小化权值和，输出其$\\text{Hash}$和 分析容易发现在最优中方案$|a_u|\\leq 1$ 且一个点$a_u=\\pm 1$当且仅当$deg_u \\mod 2=1$ 在依次加入每条边的过程中，一旦出现环，显然环上的边经交错染色之后贡献可以忽略 且奇点总是成对地出现，两个成对的奇点能够确定一条路径 我们只需要在动态加边的过程中，维护对于这样奇点的路径以及环的交替染色即可 注意： 一个点可以被多条路径经过，但是在奇点成对地过程中 我们只认为其中一条的端点是它 那么我们在路径两端记录这条路径，每次加入一条边之后，可能产生多条路径的合并 而在实际实现的过程中，并没有必要把环从路径上删除 假设当前得到路径$x\\rightarrow y$，加入一条边$y,z$且$z$在$x\\rightarrow y$上 此时，我们直接认为新的路径端点就是$(x,z)$即可 环的部分依然可以保留在路径上，跟随路径进行交替染色而不影响答案 此时操作被简化为了合并两段交替路径（实际上就是在合并欧拉路径） 可以用带权并查集维护 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int N=4e5+10,P=998244353;int n1,n2,m,w=1;int S[N][2],F[N],K[N],D[N];int Find(int x)&#123; if(F[x]==x) return F[x]; int f=F[x]; F[x]=Find(F[x]); D[x]^=D[f]; return F[x];&#125;int ans;void Uni(int x,int y)&#123; int fx=Find(x),fy=Find(y),d=D[x]^D[y]^1; if(fx==fy) return; if(d) &#123; ans-=S[fx][1],Mod2(ans); swap(S[fx][0],S[fx][1]); ans+=S[fx][1],Mod1(ans); D[fx]=1; &#125; F[fx]=fy; rep(i,0,1) S[fy][i]+=S[fx][i],Mod1(S[fy][i]);&#125;void Add()&#123; int x=rd(),y=rd()+n1; w*=2,Mod1(w),S[++m][0]=w,F[m]=m; if(K[x]&lt;K[y]) swap(x,y); if(!K[x]&amp;&amp;!K[y]) K[x]=K[y]=m; else if(!K[y]) Uni(K[x],m),K[x]=0,K[y]=m; else Uni(K[x],m),Uni(K[y],m),K[x]=K[y]=0;&#125;int A[N],C;int main()&#123; n1=rd(),n2=rd(); rep(_,1,rd()) Add(); rep(_,1,rd()) &#123; if(rd()==1) Add(),printf(&quot;%d\\n&quot;,ans),fflush(stdout); else &#123; C=0; rep(i,1,m) if(Find(i),D[i]==1) A[++C]=i; printf(&quot;%d\\n&quot;,C); rep(i,1,C) printf(&quot;%d &quot;,A[i]); puts(&quot;&quot;),fflush(stdout); &#125; &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1288F - Red-Blue Graph","slug":"CF1288F - Red-Blue Graph","date":"2021-05-11T10:38:09.000Z","updated":"2021-05-22T03:54:10.781Z","comments":true,"path":"articles/2021/05/11/cb068eec.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/11/cb068eec.html","excerpt":"","text":"CF1288F - Red-Blue Graph题目大意给定一个二部图，每条边可以为红色/蓝色/无色，且一条边为红色需要付出$r$的代价，为蓝色需要$b$的代价 每个点可以为红色/蓝色/无色 1.如果该点为红色，则其所连的边中红色边边数 严格大于 蓝色边边数 2.如果该点为蓝色，则其所连的边中蓝色边边数 严格大于 红色边边数 求最小化代价满足上述限制 分析二分图果然和网络流密不可分 考虑从奇怪的题目中归纳一个费用流模型 用一个点的流量表示红色边-蓝色边的数量，将问题描述为 1.一条边如果为红色，那么所关联的点从$S$强制得到$1$的流量 2.一个边如果选蓝色，那么所关联的点强制向$T$流$1$的流量 3.如果一个点为红色，那么它最终应该仍然有流量多 那么强制这个点必须还能向$T$流$1$的流量，剩余随意 4.如果一个点为蓝色，那么它最终应该仍然流量不足 那么强制这个点必须从$S$得到$1$的流量，剩余随意 然而这个模型无法解决一条边对于其两端点的决策 常见的处理二分图思路：考虑将右半边图红蓝反着建立 此时令一条边对应的中继节点从$S$得到$2$的流量 这个节点向左边的点流0，表示这条边选择蓝色 这个节点向左边的点流1，表示这条边选择白色 这个节点向左边的点流2，表示这条边选择红色 同时将代价加入即可 这样给每个点额外增加了一个基准偏移的流量，需要简单处理一下 用代价为$-\\infty$的边表示这条边强制选择 注意最终求出的是最小费用，而不是最大流 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const int N=2e5+10,INF=1e9+10;int n1,n2,S,T,V,m,r,b;struct Edge&#123; int to,nxt,w,c;&#125; e[N];int head[N],ecnt=1;void AddEdge(int u,int v,int w,int c)&#123; e[++ecnt]=(Edge)&#123;v,head[u],w,c&#125;; head[u]=ecnt;&#125;void Link(int u,int v,int w,int c)&#123; AddEdge(u,v,w,c),AddEdge(v,u,0,-c); &#125;ll ans,dis[N];char s[N];int inq[N],pre[N],w[N];int main()&#123; n1=rd(),n2=rd(),m=rd(),r=rd(),b=rd(),S=n1+n2+1,T=S+1,V=T; scanf(&quot;%s&quot;,s+1); rep(i,1,n1) &#123; if(s[i]==&#x27;R&#x27;) Link(i,T,1,-INF),ans+=INF,Link(i,T,INF,0); if(s[i]==&#x27;B&#x27;) Link(S,i,1,-INF),ans+=INF,Link(S,i,INF,0); if(s[i]==&#x27;U&#x27;) Link(S,i,INF,0),Link(i,T,INF,0); &#125; scanf(&quot;%s&quot;,s+1); rep(i,1,n2) &#123; if(s[i]==&#x27;B&#x27;) Link(i+n1,T,1,-INF),ans+=INF,Link(i+n1,T,INF,0); if(s[i]==&#x27;R&#x27;) Link(S,i+n1,1,-INF),ans+=INF,Link(S,i+n1,INF,0); if(s[i]==&#x27;U&#x27;) Link(S,i+n1,INF,0),Link(i+n1,T,INF,0); &#125; rep(i,1,m) &#123; int u=rd(),v=rd()+n1; Link(S,++V,2,-INF),ans+=2*INF; Link(V,u,1,0),Link(V,v,1,0); Link(V,u,1,r),Link(V,v,1,b); Link(u,T,1,-INF),ans+=INF; Link(v,T,1,-INF),ans+=INF; &#125; while(1) &#123; static queue &lt;int&gt; que; rep(i,1,V) dis[i]=1e18; dis[S]=0,que.push(S),w[S]=INF; while(!que.empty()) &#123; int u=que.front(); que.pop(); inq[u]=0; for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to,c=e[i].c; if(!e[i].w || dis[v]&lt;=dis[u]+c) continue; dis[v]=dis[u]+c,w[v]=min(e[i].w,w[u]),pre[v]=i; if(!inq[v]) que.push(v),inq[v]=1; &#125; &#125; if(dis[T]&gt;0) break; int c=w[T]; ans+=dis[T]*c; for(int u=T;u!=S;u=e[pre[u]^1].to) &#123; //cout&lt;&lt;u&lt;&lt;endl; e[pre[u]].w-=c,e[pre[u]^1].w+=c; &#125; &#125; if(ans&gt;INF) puts(&quot;-1&quot;); else &#123; printf(&quot;%lld\\n&quot;,ans); rep(u,T+1,T+m) &#123; int c=0; for(int i=head[u];i;i=e[i].nxt) if(e[i].to&lt;=n1) c+=e[i^1].w; putchar(&quot;BUR&quot;[c]); &#125; &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1491G - Switch and Flip","slug":"CF1491G - Switch and Flip","date":"2021-05-11T10:19:55.000Z","updated":"2021-05-22T03:54:10.832Z","comments":true,"path":"articles/2021/05/11/25b7427f.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/11/25b7427f.html","excerpt":"","text":"CF1491G - Switch and Flip题目大意有$n$个硬币，编号$1-n$，第$i$个位置上当前放了编号$a_i$的硬币 每次交换$(a_i,a_j)i\\ne j$，且将硬币$a_i,a_j$翻转 求方案使得最终使得$a_i=i$且每个硬币恰好为原先方向 $n\\ge 3$，方案步数$\\leq n+1$ 分析显然要先对于$a_i$求出置换环，步数$\\leq n+1$说明 1.general的情况可以用$n$步解决$n$个点 2.存在至多一个特殊情况要$n+1$步 手玩发现我们无法$n$步解决一个大小为$n$的环 但是如果环上恰好已经有两个硬币被翻过，那么可以 图上点表示硬币编号，箭头所指是这个硬币应该在的位置 我们从一个已经翻转的点开始，不断交换$i,a_i$上的硬币，会将$a_i$移动到到应该在的位置上 同时下一个位置被翻转 不断进行这个操作，直到这个点消去了半边环，遇到了下一个点也是被翻过的点 此时再从下一个点开始将环的另外半边消去 那么考虑如何让一个环有两个已经翻转的点 假设提取出了$c$个环，我们可以先尽量成对匹配两个环 通过一次跨过环的交换操作合并两个大小$x,y$的环，同时生成两个翻转点 然后进项上面的操作，需要$x+y-1$次，恰好一共$x+y$次 那么对于最后剩下的一个环 1.如果前面已经有环被匹配过 那么随便选择一个当前$a_i=i$的自环与其合并即可 2.整个图为一个大环 先通过交换$1,a_1$将$a_1$弹出，然后$a_1$再和环上另外一个元素交换 此时$a_1$变成未翻转状态，环又并成一个环+2个翻转点 1234567891011121314151617181920212223242526272829303132333435363738394041424344const int N=2e5+10,INF=1e9+10;int n;int a[N],vis[N],b[N],c;int X[N],Y[N],C,col[N];void Swap(int x,int y)&#123; X[++C]=x,Y[C]=y; swap(a[x],a[y]),col[a[x]]^=1,col[a[y]]^=1;&#125;void Solve(int i)&#123; while(!col[a[i]]) i=a[i]; while(!col[a[a[i]]]) Swap(i,a[i]); i=a[i]; while(i!=a[i]) Swap(i,a[i]);&#125;int main()&#123; n=rd(); rep(i,1,n) a[i]=rd(); rep(i,1,n) if(!vis[i]) &#123; for(int j=i;!vis[j];j=a[j]) vis[j]=1; b[++c]=i; &#125; for(int i=1;i&lt;c;i+=2) &#123; Swap(b[i],b[i+1]); Solve(b[i]); &#125; if(c&amp;1) &#123; if(c==1) &#123; int t=a[1]; Swap(1,a[1]),Swap(t,a[1]); Solve(i); &#125; else &#123; rep(i,1,n) if(a[i]==i) &#123; Swap(i,b[c]); Solve(i); break; &#125; &#125; &#125; printf(&quot;%d\\n&quot;,C); rep(i,1,C) printf(&quot;%d %d\\n&quot;,X[i],Y[i]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1264E - Beautiful League","slug":"CF1264E - Beautiful League","date":"2021-05-11T09:53:03.000Z","updated":"2021-05-22T03:54:10.776Z","comments":true,"path":"articles/2021/05/11/46af0e1d.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/11/46af0e1d.html","excerpt":"","text":"CF1264E - Beautiful League题目大意给定一张竞赛图，其中一些边已经确定 现在求确定剩余边的方向，使得最终图上三元环个数最大 分析三元问题着实难以处理 考虑什么样的三个点$(x,y,z)$无法构成一个环： 三个点恰好存在一个点$x$得到两条入边，即$x\\leftarrow y,x\\leftarrow z$ 此时无法构成环 于是问题转化为统计$x$的入度$ind_x$，减少的三元环个数就是$\\sum \\binom{ind_i} {2}$ 考虑用网络流计算答案，每一条边$(u,v)$可以选择从$S$流向$u$或者$v$ 一个点得到$i$的流量付出$\\binom{i} {2}$的代价流出$T$ 因此每个点向$T$连$n-1$条流量为$1$，代价分别为为$\\binom{j} {2}-\\binom{j-1} {2}$的边 求满流最小费用即可，输出方案容易根据流量情况判断 复杂度为$O(\\text{MCMF}(n^2,n^2))$ 或者$O(\\text{MCMF}(n,n^2))$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int N=2e5+10,INF=1e9+10;int n,m,S,T,V;struct Edge&#123; int to,nxt,w,c;&#125; e[N];int head[N],ecnt=1;void AddEdge(int u,int v,int w,int c)&#123; e[++ecnt]=(Edge)&#123;v,head[u],w,c&#125;; head[u]=ecnt;&#125;void Link(int u,int v,int w,int c)&#123; AddEdge(u,v,w,c),AddEdge(v,u,0,-c); &#125;int ans,dis[N];char s[N];int inq[N],pre[N],w[N];int mk[110][110];int main()&#123; n=rd(),m=rd(),S=n+1,T=V=S+1; rep(i,1,n) rep(j,1,n-1) Link(i,T,1,j*(j-1)/2-(j-1)*(j-2)/2); memset(mk,-1,sizeof mk); while(m--) &#123; int u=rd(),v=rd(); if(u&lt;v) mk[u][v]=1; else mk[v][u]=0; &#125; rep(i,1,n) rep(j,i+1,n) &#123; Link(S,++V,1,0); if(mk[i][j]!=0) Link(V,j,1,0); if(mk[i][j]!=1) Link(V,i,1,0); &#125; while(1) &#123; static queue &lt;int&gt; que; rep(i,1,V) dis[i]=INF; dis[S]=0,que.push(S),w[S]=INF; while(!que.empty()) &#123; int u=que.front(); que.pop(); inq[u]=0; for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to,c=e[i].c; if(!e[i].w || dis[v]&lt;=dis[u]+c) continue; dis[v]=dis[u]+c,w[v]=min(e[i].w,w[u]),pre[v]=i; if(!inq[v]) que.push(v),inq[v]=1; &#125; &#125; if(dis[T]==INF) break; int c=w[T]; ans+=dis[T]*c; for(int u=T;u!=S;u=e[pre[u]^1].to) e[pre[u]].w-=c,e[pre[u]^1].w+=c; &#125; memset(mk,0,sizeof mk); rep(a,1,n) rep(b,a+1,n) &#123; int u=++T; for(int i=head[u];i;i=e[i].nxt) if(e[i].to&lt;=n &amp;&amp; !e[i].w) &#123; if(e[i].to==b) mk[a][b]=1; else mk[b][a]=1; &#125; &#125; rep(i,1,n) &#123; rep(j,1,n) putchar(mk[i][j]+&#x27;0&#x27;); puts(&quot;&quot;); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1187G - Gang Up","slug":"CF1187G - Gang Up","date":"2021-05-11T09:39:01.000Z","updated":"2021-05-22T03:54:10.765Z","comments":true,"path":"articles/2021/05/11/930769ac.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/11/930769ac.html","excerpt":"","text":"CF1187G - Gang Up题目大意有$k$个人在一张无向图上往1走，可以选择在原地不动或者走一条边 一个人在$x$时间到达目的地的代价是$c\\cdot x$，$c$是常数 一条边同一时间被$x$个人经过的代价是$x^2\\cdot d$，$d$是常数 最小化代价 分析无法贪心，无法最短路的题目，那就先试试网络流 考虑将时间和位置压在一起建立节点，时间$\\leq n+k$ $(t,u)\\rightarrow (t+1,u) $ $(t,u)\\rightarrow (t+1,v)$ 在原地保持的边代价为$c$，流量$\\infty$ 在两点间移动的代价由于与个数有关，可以建立$k$条边 每条代价是$d(i^2-(i-1)^2)+c=c+(2i-1)d$ 得到一个$O((n+k)n)$点数$O((n+k)m\\cdot k)$边数的图 然后可以考虑依次将每个人加入流量 但是实际上，并不需要显式地将所有边连出来跑网络流 每次加入一个点看做一个带回撤的最短路问题，有效的边只有$(n+k)m$条 因此复杂度为$O(k\\cdot \\text{SPFA}((n+k)n,(n+k)m))$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const int N=110,INF=1e9+10;int n,m,k,C,D;int a[N];struct Edge&#123; int to,nxt;&#125; e[N&lt;&lt;1];int head[N],ecnt=1;void AddEdge(int u,int v)&#123; e[++ecnt]=(Edge)&#123;v,head[u]&#125;; head[u]=ecnt;&#125;int dis[N][N],pre[N][N],inq[N][N],G[N][N],W[N][N];static queue &lt;Pii&gt; que;void Upd(int x,int y,int d,int p)&#123; if(dis[x][y]&gt;d) &#123; dis[x][y]=d,pre[x][y]=p; if(!inq[x][y]) inq[x][y]=1,que.push(mp(x,y)); &#125;&#125;int cnt[N][N];int main()&#123; n=rd(),m=rd(),k=rd(),C=rd(),D=rd(); rep(i,1,k) a[i]=rd(); rep(i,1,m) &#123; int u=rd(),v=rd(); AddEdge(u,v),AddEdge(v,u); rep(j,1,n+k) G[j][i*2]=G[j][i*2+1]=1; &#125; int ans=0; rep(_,1,k) &#123; int u=a[_]; rep(i,1,n+k) rep(j,1,n) dis[i][j]=INF; dis[1][u]=0,que.push(mp(1,u)); int tu=1,ti=-1,mi=1e9; while(!que.empty()) &#123; int t=que.front().first,u=que.front().second; que.pop(); inq[t][u]=0; if(u==1 &amp;&amp; dis[t][u]&lt;mi) mi=dis[t][u],ti=t,tu=u; if(t&gt;1 &amp;&amp; W[t-1][u]) Upd(t-1,u,dis[t][u]-C,1001); if(t&lt;n+k) Upd(t+1,u,dis[t][u]+C,1002); for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(G[t-1][i^1]&gt;1) Upd(t-1,v,dis[t][u]-(G[t-1][i^1]-2)*D-C,-(i^1)); if(t&lt;n+k) Upd(t+1,v,dis[t][u]+G[t][i]*D+C,i); &#125; &#125; ans+=mi; while(tu!=u || ti!=1) &#123; int t=pre[ti][tu]; if(t==1001) --W[ti++][tu]; else if(t==1002) W[--ti][tu]++; else if(t&lt;0) G[ti][-t]-=2,tu=e[-t].to,ti++; else G[ti-1][t]+=2,tu=e[t^1].to,ti--; &#125; &#125; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"最小树形图 | 最小内向森林","slug":"最小树形图   最小内向森林","date":"2021-05-11T00:50:37.000Z","updated":"2021-05-22T03:54:11.383Z","comments":true,"path":"articles/2021/05/11/65eb8d72.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/11/65eb8d72.html","excerpt":"","text":"最小树形图 | 最小内向森林最小树形图对于带权有向图$G=(V,E)$ 对于根$root$最小树形图为以$root$为根的外向树最小边权和 有根树的树形图对于确定的$root$求最小树形图 朱刘算法核心: 1:对于有向图上的一个非根节点，对于它的所有入边加减一个权值$v$，最优解的树形图形态不变 因为所有非根点必然有一条入边，所以可以对于每个点，取入边边权最小值减去，把减去的部分加入答案 经过这样的操作使得每条边边权非负，且每个点都有一条为0的入边 \\2:对于权非负的有向图上，如果存在一个边权均为0的环，可以把环上的点收缩 因为无论最后得到的树形图如何连边，一定可以通过断掉环上的一条边来生成一个可行的树形图 算法流程 1.为每个点的入边更改边权 2.收缩0环 ​ 2.1 存在环 : 回到1 ​ 2.2 不存在环：结束算法 此时存在两种情况 1.图不连通，无解 2.图联通，每个点一定存在一条为0的入边，取出一个合法边集， 然后依次展开每个被收缩的0环，即可得到一个最小树形图方案 复杂度分析： 每次收缩环需要依次遍历，每次至少缩小一个点，因此复杂度上限为$O(nm)$ \\Tips: 1.注意不要更改根的入边 2.0边构成的的图不连通 实现：只记录一条0边指向的点，找环 1234567891011121314151617181920212223242526272829303132333435363738394041424344const int N=10010,INF=1e9;int n,m,rt,ans;int U[N],V[N],W[N];int id[N],inw[N],pre[N];void Reweight()&#123; rep(i,1,n) inw[i]=INF,pre[i]=0; rep(i,1,m) if(U[i]!=V[i] &amp;&amp; V[i]!=rt) if(inw[V[i]]&gt;W[i]) inw[V[i]]=W[i],pre[V[i]]=U[i]; rep(i,1,n) if(i!=rt &amp;&amp; id[i]==i) &#123; if(inw[i]==INF) puts(&quot;-1&quot;),exit(0); ans+=inw[i]; &#125; rep(i,1,m) if(U[i]!=V[i] &amp;&amp; V[i]!=rt) W[i]-=inw[V[i]];&#125;int vis[N];int Union()&#123; int fl=0; rep(i,1,n) vis[i]=0; rep(i,1,n) if(id[i]==i &amp;&amp; !vis[i]) &#123; int u=i; while(u &amp;&amp; !vis[u]) vis[u]=i,u=pre[u]; if(vis[u]==i) &#123; int v=pre[u]; fl=1; while(v!=u) id[v]=u,v=pre[v]; &#125; &#125; return fl;&#125;int main()&#123; n=rd(),m=rd(),rt=rd(); rep(i,1,n) id[i]=i; rep(i,1,m) U[i]=rd(),V[i]=rd(),W[i]=rd(); while(1) &#123; Reweight(); if(!Union()) break; rep(i,1,m) U[i]=id[U[i]],V[i]=id[V[i]]; rt=id[rt]; &#125; printf(&quot;%d\\n&quot;,ans);&#125; 可并堆优化朱刘算法涉及到的操作： 1.依次插入每个点，为其确定一条最小的出边 2.如果出边（0边）构成了环，将环上的点缩点 3.合并环上点的点出边集合，并将这个点重新加入待定点集 3操作要用可并堆维护合并点集入边的最小权值，并且支持全局减操作 2操作用并查集维护判断是否出现了环，我写得比较丑，一个并查集存缩点之后新点的编号，一个存点所在连通块 比较常见的实现是左偏树，因为便于全局修改的标记下传操作，代码也比较好写 用可并堆维护朱刘算法的操作，单次合并操作为$O(\\log m)$，因此复杂度为$O((n+m)\\log m)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int N=100010;int n,m,rt,ans;// 轻度封装的左偏树class Heap&#123;private: Heap *ls,*rs; Pii val; int tag,dis; void Down()&#123; if(ls) ls-&gt;val.first+=tag,ls-&gt;tag+=tag; if(rs) rs-&gt;val.first+=tag,rs-&gt;tag+=tag; tag=0; &#125; void Up()&#123; if(rs &amp;&amp; (!ls || rs-&gt;dis&gt;ls-&gt;dis)) swap(ls,rs); dis=rs?rs-&gt;dis+1:1; &#125;public: Heap()&#123; &#125; Heap(Pii x)&#123; ls=rs=0,val=x,tag=0,dis=1; &#125; friend Heap* Union(Heap* a,Heap *b) &#123; if(!a) return b; if(!b) return a; if(a-&gt;val&gt;b-&gt;val) swap(a,b); a-&gt;Down(),a-&gt;rs=Union(a-&gt;rs,b); return a-&gt;Up(),a; &#125; void Add(int x)&#123; tag+=x,val.first+=x; &#125; Pii top()&#123; return val; &#125; Heap* pop()&#123; return Down(),Union(ls,rs); &#125;&#125; *H[N];int F[N],J[N]; // F存连通块，J存编号Pii G[N];int Find(int x)&#123; return F[x]==x?x:F[x]=Find(F[x]); &#125;int I(int x)&#123; return J[x]==x?x:J[x]=I(J[x]); &#125;void Work(int i) &#123; // 依次加入每个点，先把自环弹掉 while(H[i] &amp;&amp; I(H[i]-&gt;top().second)==i) H[i]=H[i]-&gt;pop(); if(!H[i]) puts(&quot;-1&quot;),exit(0); G[i]=H[i]-&gt;top(),H[i]-&gt;Add(-G[i].first),H[i]=H[i]-&gt;pop(); ans+=G[i].first; int v=I(G[i].second); if(Find(i)!=Find(v)) F[Find(i)]=Find(v); else &#123; for(int u=v;u!=i;u=I(G[u].second)) J[I(u)]=i,H[i]=Union(H[i],H[u]); Work(i); &#125;&#125;int main()&#123; n=rd(),m=rd(),rt=rd(); rep(i,1,n) J[i]=F[i]=i; rep(i,1,m) &#123; int u=rd(),v=rd(),w=rd(); H[v]=Union(H[v],new Heap(mp(w,u))); &#125; rep(i,1,n) if(I(i)==i &amp;&amp; i!=rt) Work(i); printf(&quot;%d\\n&quot;,ans);&#125; 无根树的最小树形图建立超级原点$S$向$V$中的点连边权极大的边，以限制每次只选一条这样的边 单次得到答案后减去这个极大值即可，注意如果答案中出现多个这样的极大值，说明原图无解是无解的 最小内向森林对于给定的值$k$，最小内向森林是一个有根树集合，且其恰好包含$k$条边 凸优化+朱刘算法最小内向森林问题是一个凸函数问题，可以考虑$\\text{wqs}$二分 同样建立超级原点$S$，二分原点$S$向$V$中点连的边权$\\alpha$ 通过朱刘算法得到新图的最小树形图 二分使得最终的树形图包含原点度数为$|V|-1-k$即可 优先内向树扩张算法考虑在上面二分的过程中，一个点向原点连边当且仅当这个点不再有边边权$&lt;\\alpha$ 同时一旦这个点向原点连边，就不再会与其他任何点合并 也就是这点的所有出边再减去下一条最小树边权值之后，存在一个$\\alpha’&lt;0$ 容易想到按照每个点最小边的边权为优先级进行操作 最后被扩展的边的实际上就是我们要找的$\\alpha$ 令$dec_u$表示$u$节点中，被合并上来所有节点已经减掉的值的最大值 $dec_u’=dec_u+\\min \\{w_{v,u} \\}$，合并时$dec_u$取$\\max$ 按照$dec’_u$递增的顺序考虑每个点的扩张，最后一个$dec’_u$就是我们所需要的$\\alpha$ 用一个额外的堆维护$dec’_u$的权值，直到扩张满$k$次即可 复杂度为$O((n+m)\\log m+n\\log n)$","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"CF1061E - Politics","slug":"CF1061E - Politics","date":"2021-05-10T12:44:05.000Z","updated":"2021-05-22T03:54:10.759Z","comments":true,"path":"articles/2021/05/10/260b711d.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/10/260b711d.html","excerpt":"","text":"CF1061E - Politics题目大意给定两棵有根树$T_1,T_2$，节点均从$1-n$编号 对于节点$i$，有权值$a_i$，每个节点可以被选择一次 对于$T_1,T_2$，有$q_1,q_2$条限制，每条限制了一个子树$k$内恰好有$x$个点被选择 求最大化选择的权值之和，或者确定不存在方案 分析如果剥离树的结构考虑，让问题变成点集之和的限制 这是一个经典的无法处理的问题，或许可以单纯形试试看 那么考虑树的结构如何处理 我们认为一个点被选择会向祖先链上的点总和+1，这是一个链状更新 可以用一棵内向树描述，再将限制加在边上，就能够得到一个简单的网络流模型 然而边权无法限制满流（除非上下界网络流），而现在问题不仅带权，还同时涉及两棵树 因此引入费用是必须的 解决恰好为$x$的限制考虑将有限制的边视作特殊，我们将这条边额外加上一个费用$\\infty$，最后从答案中减去 如果最优解中无法流满这些边，答案将$&lt;0$ 解决两棵树Naive的思路，我们需要强制两棵树上同编号的点入流相同 经过长时间弱智的思考，这无法实现 于是想办法强制两个点入流不同 容易发现，对于被选个数的限制可以对称转化为限制未选个数 从源点$S$向$i_0$连一条流量为1的边，$i_0$流向$i_1$表示选择$i$，流向$i_2$表示不选 将$T_1$建成选择点的限制，$T_2$建成不选点的限制即可 形式化的说，对于一个费用流，我们想要限制两条边$flow_1=flow_2$ 即$flow_1-flow_2=0$，这难以做到 但是我们可以限制$flow_1+(-flow_2)=0$，或者说 $flow_1+(w-flow_2)=w$ 并且将对于$flow_2$的限制转化为对$w-flow_2$的限制，此时额外建立一个点$t$ $S$向$t$连$(w,\\infty)$，强制向$t$流满$w$的流量，然后再从$t$向$flow_1,w-flow_2$分流即可 $\\text{EK}$费用流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1544,INF=1e9+7;int n,m,d;int a[N];struct Edge&#123; int to,nxt,w,c;&#125; e[N*4];int head[N],ecnt=1;void AddEdge(int u,int v,int w,int c)&#123; e[++ecnt]=(Edge)&#123;v,head[u],w,c&#125;; head[u]=ecnt;&#125;void Link(int u,int v,int w,int c)&#123; AddEdge(u,v,w,c),AddEdge(v,u,0,-c); &#125;int S=1,T=2,V=2;ll ans=0;struct Tree&#123; vector &lt;int&gt; G[N]; int Rt,sz[N],lim[N],fa[N]; void dfs(int u,int f) &#123; //cout&lt;&lt;&quot;pre dfs &quot;&lt;&lt;u&lt;&lt;endl; sz[u]=1,lim[u]=-1,fa[u]=f; for(int v:G[u]) if(v!=f) &#123; dfs(v,u); sz[u]+=sz[v]; &#125; &#125; void ReadTree()&#123; rep(i,2,n)&#123; int u=rd(),v=rd(); G[u].pb(v),G[v].pb(u); &#125; dfs(Rt,0); &#125; void ReadLimit()&#123; rep(_,1,rd()) &#123; int u=rd(),x=rd(); //cout&lt;&lt;&quot;$&quot;&lt;&lt;sz[u]&lt;&lt;endl; if(sz[u]&lt;x) puts(&quot;-1&quot;),exit(0); lim[u]=x; &#125; &#125; void Init(int k)&#123; fa[Rt]=T-V; if(k==0) &#123; rep(i,1,n) &#123; Link(T+i,V+i,1,a[i]); if(~lim[i]) &#123; ans-=1ll*lim[i]*INF; Link(V+i,V+fa[i],lim[i],INF); &#125; else Link(V+i,V+fa[i],n,0); &#125; &#125; else &#123; rep(i,1,n) &#123; Link(T+i,V+i,1,0); if(~lim[i]) &#123; ans-=1ll*(sz[i]-lim[i])*INF; Link(V+i,V+fa[i],sz[i]-lim[i],INF); &#125; else Link(V+i,V+fa[i],n,0); &#125; &#125; V+=n; &#125;&#125; Tr[2];ll dis[N];int vis[N],pre[N];int SPFA()&#123; static queue &lt;int&gt; que; rep(i,1,V) dis[i]=-1e18; que.push(S),dis[S]=0; while(!que.empty()) &#123; int u=que.front(); que.pop(); vis[u]=0; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].to,c=e[i].c; if(dis[v]&gt;=dis[u]+c || !e[i].w) continue; dis[v]=dis[u]+e[i].c,pre[v]=i; //cout&lt;&lt;&quot;$&quot;&lt;&lt;u&lt;&lt;&#x27; &#x27;&lt;&lt;v&lt;&lt;&#x27; &#x27;&lt;&lt;e[i].c&lt;&lt;&#x27; &#x27;&lt;&lt;e[i].w&lt;&lt;endl; if(!vis[v]) vis[v]=1,que.push(v); &#125; &#125; return dis[T]&gt;-1e18;&#125;void EK()&#123; while(SPFA()) &#123; int w=INF; for(int u=T;pre[u];u=e[pre[u]^1].to) cmin(w,e[pre[u]].w); for(int u=T;pre[u];u=e[pre[u]^1].to) e[pre[u]].w-=w,e[pre[u]^1].w+=w; ans+=w*dis[T]; &#125;&#125;int main()&#123; n=rd(),Tr[0].Rt=rd(),Tr[1].Rt=rd(); rep(i,1,n) Link(S,V+i,1,INF),ans-=INF; V+=n; rep(i,1,n) a[i]=rd(); rep(i,0,1) Tr[i].ReadTree(); rep(i,0,1) Tr[i].ReadLimit(),Tr[i].Init(i); EK(); if(ans&lt;0) puts(&quot;-1&quot;); else printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1368G - Shifting Dominoes","slug":"CF1368G - Shifting Dominoes","date":"2021-05-10T10:36:58.000Z","updated":"2021-05-22T03:54:10.792Z","comments":true,"path":"articles/2021/05/10/ffa7592.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/10/ffa7592.html","excerpt":"","text":"CF1368G - Shifting Dominoes题目大意给定一个被$1\\times 2$的骨牌（横向或者竖向）铺满的方格图 现在可以拿走一个骨牌，之后任意一个骨牌可以沿着其放置方向左右移动至多一步 求最终两个空位所在不同位置的方案数 分析观察一个空位的移动 如果上/下/左/右边是一条骨牌，则可以移动到该骨牌所在的上/下/左/右边方格 将这个移动方式构成一个有向图（当然忽略反复横跳的情况） 大胆猜测此时你会发现它是 两片外向树森林，下面说明三个充分条件 1.跳跃的过程为$(x,y)\\rightarrow (x\\pm 2,y\\pm 2)$，显然$x+y$的奇偶性不变，故可以黑白染色分为两部分 2.一个点至多有一条入边：一个点的入边只能来自其所在骨牌的另一边 3.图中不存在环： 假设构成了一个环，此时这些边对应的骨牌围成一个不规则的环 从环的某一个角出发，向四周走，发现其余所有点总能完成一一匹配 也就是说，环内部包含的点个数为奇数，显然不存在这样的覆盖方案 答案计算考虑移除一张骨牌生成两个点$(x,y)$，两个点分属于两片森林，并且可以向下走 不妨求出森林的$\\text{dfs}$序，此时问题变成了一个二维空间矩形覆盖问题 可以扫描线+线段树解决 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394const int N=2e5+10;int n,m,d;string s[N];int I(int x,int y)&#123; return (x-1)*m+y; &#125;ll ans;vector &lt;int&gt; G[N];int col(int u)&#123; return ((u-1)%m+(u-1)/m)&amp;1; &#125;void Link(int u,int v)&#123; G[u].pb(v),ind[v]++; &#125;int ind[N],L[N],R[N],dfn;void dfs(int u,int f)&#123; L[u]=++dfn; for(int v:G[u]) if(v!=f) dfs(v,u); R[u]=dfn;&#125;// 线段树维护扫描过程中第二维未被覆盖的点个数struct Node&#123; int mi,x; Node operator + (const Node _) const &#123; Node res; res.mi=min(mi,_.mi),res.x=0; if(mi==res.mi) res.x+=x; if(_.mi==res.mi) res.x+=_.x; return res; &#125;&#125; tr[N&lt;&lt;2];int t[N&lt;&lt;2];void Down(int p)&#123; if(!t[p]) return; rep(i,p&lt;&lt;1,i+1) t[i]+=t[p],tr[i].mi+=t[p]; t[p]=0;&#125;void Upd(int p,int l,int r,int ql,int qr,int x)&#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; t[p]+=x,tr[p].mi+=x; return; &#125; Down(p); int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) Upd(p&lt;&lt;1,l,mid,ql,qr,x); if(qr&gt;mid) Upd(p&lt;&lt;1|1,mid+1,r,ql,qr,x); tr[p]=tr[p&lt;&lt;1]+tr[p&lt;&lt;1|1];&#125;struct Update&#123; int p,l,r,x; bool operator &lt; (const Update __) const &#123; return p&lt;__.p; &#125;&#125; U[N*2];int C;void Add(int x,int y)&#123; if(col(x)) swap(x,y); U[++C]=(Update)&#123;L[x],L[y],R[y],1&#125;; U[++C]=(Update)&#123;R[x]+1,L[y],R[y],-1&#125;;&#125;void Build(int p,int l,int r)&#123; tr[p]=(Node)&#123;0,r-l+1&#125;; if(l==r) return; int mid=(l+r)&gt;&gt;1; Build(p&lt;&lt;1,l,mid),Build(p&lt;&lt;1|1,mid+1,r);&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,n) &#123; cin&gt;&gt;s[i]; rep(j,1,m) &#123; if(s[i][j-1]==&#x27;U&#x27;) if(i&gt;1) Link(I(i-1,j),I(i+1,j)); if(s[i][j-1]==&#x27;D&#x27;) if(i&lt;n) Link(I(i+1,j),I(i-1,j)); if(s[i][j-1]==&#x27;L&#x27;) if(j&gt;1) Link(I(i,j-1),I(i,j+1)); if(s[i][j-1]==&#x27;R&#x27;) if(j&lt;m) Link(I(i,j+1),I(i,j-1)); &#125; &#125; // 获得dfs序 rep(i,1,n*m) if(!ind[i]) dfs(i,0); rep(i,1,n) &#123; rep(j,1,m) &#123; if(s[i][j-1]==&#x27;U&#x27;) Add(I(i,j),I(i+1,j)); if(s[i][j-1]==&#x27;L&#x27;) Add(I(i,j),I(i,j+1)); &#125; &#125; Build(1,1,dfn); sort(U+1,U+C+1); int p=1; rep(i,1,dfn) &#123; while(p&lt;=C &amp;&amp; U[p].p&lt;=i) Upd(1,1,dfn,U[p].l,U[p].r,U[p].x),p++; int c=dfn-(tr[1].mi==0?tr[1].x:0); ans+=c; &#125; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1111E - Tree","slug":"CF1111E - Tree","date":"2021-05-10T09:42:13.000Z","updated":"2021-05-22T03:54:10.763Z","comments":true,"path":"articles/2021/05/10/cb63d4bc.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/10/cb63d4bc.html","excerpt":"","text":"CF1111E - Tree题目大意给定一棵无根树$T$，$q$次查询每次查询一个给定一个根$r$，点集$S$和限制$m$ 求将$S$分成不超过$m$个非空集合，使得最终每个集合内不存在两点为祖先关系 分析容易发现题目是一个给定部分点集的树形$dp$，因此需要用虚树来处理 将$r$也加入虚树，从$r$开始$\\text{dfs}$即确定了根为$r$ dp部分一种思路是树形背包，计算子树内分为$i$个集合的方案数，枚举在$\\text{LCA}$处合并两个集合 但是由于要枚举合并的个数，难以写出优秀的复杂度 由于一条祖先链上点之间的集合独立，容易描述，因此可以考虑$\\text{dfs}$序dp 按照$\\text{dfs}$依次加入每一个点$u$，令$dp_i$表示当前有$i$个集合的方案数 则在$i$个集合中包含$dep_u$个集合$u$无法加入 枚举$i$，加入一个点$O(m)$转移，滚动数组即可 复杂度为$O(n\\log n+\\sum |S|\\cdot m)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const int N=1e5+10,P=1e9+7;int n,m;int L[N],top[N],son[N],sz[N],dfn,fa[N],dep[N];struct Edge&#123; int to,nxt;&#125; e[N&lt;&lt;1];int head[N],ecnt;void AddEdge(int u,int v)&#123; e[++ecnt]=(Edge)&#123;v,head[u]&#125;; head[u]=ecnt;&#125;void dfs(int u)&#123; sz[u]=1; for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(v==fa[u]) continue; dep[v]=dep[fa[v]=u]+1,dfs(v); if(sz[v]&gt;sz[son[u]]) son[u]=v; sz[u]+=sz[v]; &#125;&#125;void dfs(int u,int t)&#123; top[u]=t,L[u]=++dfn; if(son[u]) dfs(son[u],t); for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(v==son[u] || v==fa[u]) continue; dfs(v,v); &#125;&#125;int LCA(int x,int y)&#123; while(top[x]!=top[y]) dep[top[x]]&gt;dep[top[y]]?x=fa[top[x]]:y=fa[top[y]]; return dep[x]&lt;dep[y]?x:y;&#125;vector &lt;int&gt; G[N];int stk[N],T;void Link(int u,int v)&#123; G[u].pb(v),G[v].pb(u); &#125;void Ins(int u)&#123; if(T&lt;=1) return void(stk[++T]=u); int lca=LCA(u,stk[T]); if(lca==stk[T]) return void(stk[++T]=u); while(T&gt;1 &amp;&amp; L[stk[T-1]]&gt;=L[lca]) Link(stk[T],stk[T-1]),T--; if(stk[T]!=lca) Link(stk[T],lca),stk[T]=lca; stk[++T]=u;&#125;int dis[N],mk[N];int dp[310],a[N],c,rt;void dfs_dp(int u,int f)&#123; dis[u]=dis[f]+mk[u]; if(mk[u]) drep(i,m,0) dp[i]=((i?dp[i-1]:0)+1ll*(i-dis[f])*dp[i])%P; for(int v:G[u]) if(v!=f) dfs_dp(v,u); mk[u]=0,G[u].clear();&#125;int main()&#123; n=rd(),m=rd(); rep(i,2,n)&#123; int u=rd(),v=rd(); AddEdge(u,v),AddEdge(v,u); &#125; dfs(1),dfs(1,1); rep(_,1,m) &#123; c=rd(),m=rd(),rt=rd(); rep(i,1,c) mk[a[i]=rd()]=1; a[++c]=1,a[++c]=rt; sort(a+1,a+c+1,[&amp;](int x,int y)&#123; return L[x]&lt;L[y]; &#125;); T=0; rep(i,1,c) if(a[i]!=a[i-1]) Ins(a[i]); while(T&gt;1) Link(stk[T-1],stk[T]),T--; rep(i,0,m) dp[i]=0; dp[0]=1; dfs_dp(rt,0); int ans=0; rep(i,1,m) ans+=dp[i],Mod1(ans); printf(&quot;%d\\n&quot;,ans); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1468L - Prime Divisors Selection","slug":"CF1468L - Prime Divisors Selection","date":"2021-05-09T13:42:37.000Z","updated":"2021-05-22T03:54:10.822Z","comments":true,"path":"articles/2021/05/09/4360f883.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/09/4360f883.html","excerpt":"","text":"CF1468L - Prime Divisors Selection题目大意对于一个序列$A$，一个合法的质因子序列$P$满足$\\forall P_i|A_i,P_i\\ is\\ a\\ prime$ 给定一个序列$a_i,i\\in[1,n]$，求选出$k$个数，使得对于选出的序列$A$ 不存在一个$P$使得$P$中某个元素恰好出现一次 $n\\leq 1000,a_i\\leq 10^{18}$ 分析由题目的意思我们知道肯定要分解质因数 Pollard’s_Rho!!! $10^{18}$分解质因数可不是开玩笑的。。。 所以先考虑合法$A$的判定 判定$A$合法假设可以存在一个元素恰好出现一次$x$，那么在$A$所有元素质因子中至少要包含一个$x$ 并且，不存在两个元素只包含$x$ 也就是说，对于合法的$A$中出现的所有质因子$x$，都必须存在两个元素只包含$x$ 我们称只包含$x$作为质因子的元素为$x$-元素，为了构造合法的$A$，我们必须对于一些$x$选出若干对$x$-元素 对于每个$x$，我们只把前两个$x-$元素视为有效，假设有$c$对这样的元素 那么情况分几种 1.$2|k,2c\\ge k$，那么直接随意选完即合法 2.$2c\\ge k,2\\not |k$，此时我们需要选出部分对，使得剩下的元素中存在一个数它的因子集已经被选 枚举剩下一个元素，判定合法即可 3.$2c\\leq k$，此时可以将$c$对全部选出，判断是否还存在$k-2c$个可以选择即可 质因数分解亲身试验，我的Pollards_Rho它T飞了 容易发现，对于$x-$元素我们只需要找到它的$a_i=x^k$ 对于其他元素我们只需要找到$a_i$对应的$x$的集合，或者判断无法被$x-$元素集合包含 由于$n\\leq 1000$，我们可以先得到$x-$元素集合，其他元素我们最后一个个判定 找到$a_i=x^k$问题简化了很多 如果你相信std::pow，可以直接来 只需要找到一个最小的$k’$，使得$a_i=x’^{k’}$，判定$x’$是否为质数，如果是则停止，否则继续分解$x’$ 对于$k’\\leq 3$，甚至更大一些的情况，std::pow比较可信 而$k’&gt;3$的情况（实际上$k’=4$被$k’=2$包含，所以是$k’\\ge 5$） 实际上$x’$已经很小了，直接枚举质数即可 素数判定依然需要$\\text{Miller_Rabin}$，但是至少不用Pollards_Rho了 CodeForces Submission 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139const int N=1e5+10;int n,m;int pri[N],pc,notpri[N];ll qmul(ll x,ll y,ll P)&#123; ull z=(long double)x/P*y+0.5; ll res=(ull)x*y-z*P; Mod2(res); return res;&#125;ll qpow(ll x,ll k,ll P)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=qmul(x,x,P)) if(k&amp;1) res=qmul(res,x,P); return res;&#125;int Miller_Rabin(ll n)&#123; if(n&lt;N) return !notpri[n]; if(~n&amp;1) return 0; ll s=n-1,t=0; while(s%2==0) s/=2,t++; rep(k,1,7) &#123; ll a=qpow(pri[rand()%pc+1],s,n),b; rep(i,1,t) &#123; b=qmul(a,a,n); if(b==1 &amp;&amp; a!=1 &amp;&amp; a!=n-1) return 0; a=b; &#125; if(a!=1) return 0; &#125; return 1;&#125;ll a[N],mk[N];vector &lt;ll&gt; F[N]; // Factor Set of each elementvector &lt;ll&gt; IF; // Independent Factor Setvoid unique(vector &lt;ll&gt; &amp;a)&#123; sort(a.begin(),a.end()),a.erase(unique(a.begin(),a.end()),a.end()); &#125;map &lt;ll,vector&lt;int&gt; &gt; M;ll ans[N];void Outp()&#123; rep(i,1,m) ans[i]=a[ans[i]]; sort(ans+1,ans+m+1); rep(i,1,m) printf(&quot;%lld &quot;,ans[i]); exit(0);&#125;ll Root2(ll n)&#123; ll x=round(sqrt(n)); return x*x==n?x:-1;&#125;ll Root3(ll n)&#123; ll x=round(pow(n,1./3)); return x*x*x==n?x:-1;&#125;ll KDivide(ll x)&#123; if(Miller_Rabin(x)) return x; ll y; if(~(y=Root2(x))) return KDivide(y); if(~(y=Root3(x))) return KDivide(y); ll U=pow(x,1./5)+4; vector &lt;ll&gt; fac; for(int i=1;pri[i]&lt;=U;++i) if(x%pri[i]==0) &#123; while(x%pri[i]==0) x/=pri[i]; fac.pb(pri[i]); &#125; if(fac.size()==1 &amp;&amp; x==1) return fac[0]; return -1;&#125;int main()&#123; rep(i,2,N-1) if(!notpri[i]) &#123; pri[++pc]=i; for(int j=i+i;j&lt;N;j+=i) notpri[j]=1; &#125; n=rd(),m=rd(); rep(i,1,n) &#123; ll x=KDivide(a[i]=rd&lt;ll&gt;()); if(~x) IF.pb(x); &#125; unique(IF); rep(i,1,n) &#123; ll x=a[i]; for(ll y:IF) if(x%y==0) &#123; while(x%y==0) x/=y; F[i].pb(y); &#125; if(x&gt;1) F[i].pb(-1),F[i].pb(-2); // invalid factor, emm... to avoid some situation we push two if(F[i].size()==1 &amp;&amp; M[F[i][0]].size()&lt;2) M[F[i][0]].pb(i),mk[i]=1; &#125; int c=0; for(auto i:M) if(i.second.size()&gt;=2) c++; if(m%2==0 &amp;&amp; c*2&gt;=m) &#123; // choose k/2 pairs!! int k=m; for(auto i:M) if(i.second.size()&gt;=2) &#123; if(!k) break; rep(j,0,1) ans[k--]=i.second[j]; &#125; Outp(); &#125; if(c*2&gt;=m) &#123; // find another rep(i,1,n) if(!mk[i] &amp;&amp; (int)F[i].size()&lt;=m/2) &#123; int f=1; for(ll x:F[i]) if(M[x].size()&lt;2) f=0; if(f) &#123; int k=m; ans[k--]=i; for(ll x:F[i]) &#123; rep(j,0,1) ans[k--]=M[x][j]; M.erase(x); &#125; for(auto i:M) if(i.second.size()&gt;=2) &#123; if(!k) break; rep(j,0,1) ans[k--]=i.second[j]; &#125; Outp(); &#125; &#125; &#125; else &#123; int k=m; for(auto i:M) if(i.second.size()&gt;=2) &#123; if(!k) break; rep(j,0,1) ans[k--]=i.second[j]; &#125; // Count if we have left much enough... rep(i,1,n) if(!mk[i]) &#123; if(!k) break; int f=1; for(ll x:F[i]) if(M[x].size()&lt;2) f=0; if(f) ans[k--]=i; &#125; if(!k) Outp(); &#125; puts(&quot;0&quot;);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1392I - Kevin and Grid","slug":"CF1392I - Kevin and Grid","date":"2021-05-09T13:04:13.000Z","updated":"2021-05-22T03:54:10.803Z","comments":true,"path":"articles/2021/05/09/974e38c2.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/09/974e38c2.html","excerpt":"","text":"CF1392I - Kevin and Grid题目大意给定一张网格图，每个点上$(i,j)$写着$a_i+b_j$ 对于一个给定阈值$x$，将图分为$a_i+b_j&lt;x$和$a_i+b_j\\ge x$两组连通块 定义一个能够连通到网格图边界的连通块的价值为1，否则为2 有$q$次查询，每次给定$x$，求两种连通块价值之差 分析是网格图上的连通块计数，并且看起来无法真的搜索连通块，于是想到平面图的欧拉定理 欧拉定理连通块计数式子$C=|V|-|E|+|F|-1$ 考虑和题目给定的奇妙的价值有什么关系 显然价值是连通块个数加上被包含的连通块个数 答案应该是$S_1-S_2=|V_1|-|V_2|-|E_1|+|E_2|+|F_1|-|F_2|+1类被包含个数-2类被包含个数$ 容易观察发现，当一个1类连通块被包含时，$F_2$就增加1 也就是说$1类被包含个数-|F_2|$最终只剩下 ：外层无限区域 以及 四相邻连通块 设四个相邻连通块的个数为$D_1,D_2$ 那么$S_1-S_2=|V_1|-|V_2|-|E_1|+|E_2|+D_1-D_2$ 关于如何统计$a_i+b_j\\leq x$的个数，还多组查询，你猜猜要干嘛…. 比较不用过脑子的，做7次FFT乘法即可，也可以共用一些FFT结果 $\\downarrow \\downarrow \\downarrow $我没有脑子！！！ (/ha/ha/ha/ha/ha) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const int N=1&lt;&lt;18;const db PI=acos(-1);struct Cp&#123; db a,b; Cp()&#123; &#125; Cp(db a,db b):a(a),b(b)&#123; &#125; Cp operator + (const Cp _) const&#123; return Cp(a+_.a,b+_.b); &#125; Cp operator - (const Cp _) const&#123; return Cp(a-_.a,b-_.b); &#125; Cp operator * (const Cp _) const&#123; return Cp(a*_.a-b*_.b,a*_.b+b*_.a); &#125;&#125; R[N];int rev[N];void FFT(Cp *a,int f)&#123; rep(i,0,N-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); static Cp e[N&gt;&gt;1]; e[0]=Cp(1,0); for(int i=1;i&lt;N;i&lt;&lt;=1) &#123; Cp t(cos(PI/i),f*sin(PI/i)); for(int j=i-2;j&gt;=0;j-=2) e[j+1]=(e[j]=e[j&gt;&gt;1])*t; for(int l=0;l&lt;N;l+=i*2)&#123; for(int j=l;j&lt;l+i;++j) &#123; Cp t=a[j+i]*e[j-l]; a[j+i]=a[j]-t; a[j]=a[j]+t; &#125; &#125; &#125; if(f==-1) rep(i,0,N-1) a[i].a/=N;&#125;// 这个变量名求轻喷int n,m,q;int a[N],b[N];ll A[N],B[N],C[N],D1[N],D2[N];// A为&lt;x块个数// B为&lt;x边数// C为&gt;=x边数// D1,D2同上述Cp D[N],E[N],F[N],G[N],H[N],I[N];void Add(ll *a,Cp *b,Cp *c) &#123; rep(i,0,N-1) R[i]=b[i]*c[i]; FFT(R,-1); rep(i,0,N-1) a[i]+=round(R[i].a);&#125;int main()&#123; rep(i,0,N-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(N/2)); n=rd(),m=rd(),q=rd(); rep(i,1,n) &#123; D[a[i]=rd()].a++; if(i&gt;1) F[max(a[i-1],a[i])].a++, G[min(a[i-1],a[i])].a++; &#125; rep(i,1,m) &#123; E[b[i]=rd()].a++; if(i&gt;1) H[max(b[i-1],b[i])].a++, I[min(b[i-1],b[i])].a++; &#125; FFT(D,1),FFT(E,1); FFT(F,1),FFT(G,1); FFT(H,1),FFT(I,1); Add(A,D,E); Add(B,D,H),Add(B,F,E); Add(C,D,I),Add(C,G,E); Add(D1,F,H),Add(D2,G,I); rep(i,1,N-1) A[i]+=A[i-1],B[i]+=B[i-1],D1[i]+=D1[i-1]; drep(i,N-2,0) C[i]+=C[i+1],D2[i]+=D2[i+1]; while(q--) &#123; int x=rd(); ll ans=1ll*n*m-2*A[x-1]-C[x]+B[x-1]+D2[x]-D1[x-1]; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"平面图的欧拉定理","slug":"平面图的欧拉定理","date":"2021-05-09T12:20:52.000Z","updated":"2021-05-22T03:54:11.363Z","comments":true,"path":"articles/2021/05/09/338be5d9.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/09/338be5d9.html","excerpt":"","text":"平面图的欧拉定理平面图平面图是一张无向图，顾名思义 存在一种在平面上画点的方法，使得所有的边不会相交 欧拉定理对于一张平面图$G=(V,E)$，$F$为平面图上的边把平面划分的区域个数（注意统计最外层的无限区域），则 一张平面图是连通的 $\\Longleftrightarrow$ $|V|-|E|+|F|=2$ 下面是一个例子 $|V|=5,|E|=8,F=5$ (包含最外层的区域) 很显然这个定理也可以用来统计联通块的数量/区域的数量 即$C=|V|-|E|+|F|-1$ 欧拉定理与网格图当题目涉及到网格图染色问题时，不妨将所有染色的网格视为点，边即为四联通 此时构成一个特殊的平面图，且此时可以发现 $F$为 4相邻块个数 + 空腔个数 + 1 $|E|$为相邻对数 $|V|$为染色个数 由此可以在染色问题上把 空腔数量 与 连通性结合起来 作为一种可能出现的思路","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"CF1299D - Around the World","slug":"CF1299D - Around the World","date":"2021-05-09T11:37:49.000Z","updated":"2021-05-22T03:54:10.783Z","comments":true,"path":"articles/2021/05/09/e34c0694.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/09/e34c0694.html","excerpt":"","text":"CF1299D - Around the World题目大意给定一张带权无向图，满足经过1号点不存在长度$&gt;3$的简单环 求删除1号点所连边的一个子集，使得剩下的边构成的图满足 不存在一条 非完全重复 回路 异或和为0 非完全重复即所有边恰好被经过偶数次的回路 边权$&lt;32$ 分析考虑如何判定0回路 1.任意一个回路由同一连通块内的环叠加产生 2.将所有$\\text{dfs}$树上的环边提取出来，无法加入线性基时则存在0回路 线性基是重要的判断0回路的方法，因此考虑直接将线性基压进状态进行$dp$ dp删除1所连边后，对于每个连通块考虑计算 设连通块内环边的线性基为$D$（加入每条都能成功插入，否则直接跳过该连通块） 包含$C$条连接1的边 仍需考虑经过1的环边，题目限制了这样的环边在每个连通块内最多有一条 不妨提取这条边，设其所在三元环权为$L$ 那么转移分为3种 1.不选这个连通块 2.选择连通块内所有边，但是不选三元环，即$3\\cdot 2^{C-2}-1$ (如果存在$L$) 暴力合并$dp$状态中的线性基和$D$即可，依次插入$D$中的每条基 3.额外再选择$L$，$2^{C-2}$ 状压线性基容易发现线性基最多有15个位置可能出现1，可以暴力二进制存下来 实际上，合法的线性基通过高斯消元之后种类非常少，因此复杂度有保证 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103const int N=1e5+10,P=1e9+7;int n,m;vector &lt;Pii&gt; G[N];ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;#define Gauss rep(i,0,4) if(d[i]) rep(j,i+1,4) if(d[j]&amp;(1&lt;&lt;i)) d[j]^=d[i];\\ drep(i,4,0) D=(D&lt;&lt;(i+1))|d[i];int Ins(int &amp;D,int x)&#123; int d[5]; rep(i,0,4) d[i]=D&amp;((1&lt;&lt;(i+1))-1),D&gt;&gt;=i+1; int f=0; drep(i,4,0) if(x&amp;(1&lt;&lt;i)) &#123; if(d[i]) x^=d[i]; else &#123; f=1,d[i]=x; break; &#125; &#125; if(!f) return 0; Gauss; return 1;&#125;int Uni(int &amp;D,int E)&#123; if(!E) return 1; int d[5]; rep(i,0,4) d[i]=D&amp;((1&lt;&lt;(i+1))-1),D&gt;&gt;=i+1; rep(i,0,4) &#123; int x=E&amp;((1&lt;&lt;(i+1))-1); E&gt;&gt;=i+1; if(!x) continue; int f=0; drep(i,4,0) if(x&amp;(1&lt;&lt;i)) &#123; if(d[i]) x^=d[i]; else &#123; f=1,d[i]=x; break; &#125; &#125; if(!f) return 0; &#125; Gauss; return 1;&#125;struct Table&#123; int val[1&lt;&lt;15],a[1&lt;&lt;15],c; void Add(int x,int v) &#123; if(!val[x]) a[c++]=x; val[x]+=v,Mod1(val[x]); &#125; void clr()&#123; rep(i,0,c-1) val[a[i]]=0; c=0; &#125;&#125; dp[2];int vis[N],dfn,dis[N],D,F,E[N],L,C;void dfs(int u) &#123; vis[u]=++dfn; if(~E[u]) C++; for(Pii i:G[u]) if(i.first!=1) &#123; int v=i.first; if(~E[u] &amp;&amp; ~E[v]) L=E[u]^E[v]^i.second; // 找到了一个经过1的三元环 if(!vis[v]) dis[v]=dis[u]^i.second,dfs(v); else if(vis[v]&gt;vis[u]) &#123; F&amp;=Ins(D,dis[v]^dis[u]^i.second); &#125; &#125;&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,m) &#123; int u=rd(),v=rd(),w=rd(); G[u].pb(mp(v,w)),G[v].pb(mp(u,w)); &#125; rep(i,1,n) E[i]=-1; for(Pii i:G[1]) E[i.first]=i.second; int cur=0; dp[0].Add(0,1); for(Pii i:G[1]) &#123; int v=i.first; if(vis[v]) continue; F=1,D=C=0,L=-1,dfs(v); if(!F) continue; dp[!cur].clr(); if(~L) C-=2; C=qpow(2,C); rep(i,0,dp[cur].c-1) &#123; int x=dp[cur].a[i],y=dp[cur].val[x]; dp[!cur].Add(x,y); if(Uni(x,D)) &#123; dp[!cur].Add(x,((~L?3ll:1ll)*C-1)*y%P); if(~L &amp;&amp; Ins(x,L)) dp[!cur].Add(x,1ll*y*C%P); &#125; &#125; cur^=1; &#125; int ans=0; rep(i,0,dp[cur].c-1) (ans+=dp[cur].val[dp[cur].a[i]])%=P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1379E - Inverse Genealogy","slug":"CF1379E - Inverse Genealogy","date":"2021-05-09T11:20:24.000Z","updated":"2021-05-22T03:54:10.795Z","comments":true,"path":"articles/2021/05/09/6befe245.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/09/6befe245.html","excerpt":"","text":"CF1379E - Inverse Genealogy题目大意给定$n,k$，要求构造一棵二叉树满足 1.除了叶子以外的节点有两个儿子 2.称一个节点是特殊的：两个儿子中，一个儿子$size$至少是另一个的两倍 要求特殊的节点恰好有$k$个 分析首先考虑一些简单的情况 1.$2|n$时不存在合法二叉树 2.$n$个节点的树，能够包含$0$个特殊节点当且仅当$\\exists 2^i-1=n$ 也就是能够构成一棵完美二叉树 3.除了$2$情况外的树，顺次放置每个节点得到的二叉树恰好包含1一个特殊点 那么当$k\\leq 1$时的情况均可以被解决 否则，考虑通过加上一条极长的链来构造 即构造一个一边儿子大小为1，另一边顺次相接的链，这样能够做到最大利用点数 最多能得到$\\frac{n-3} {2}$个特殊点 然而我们必须处理剩余点的分配，下面给出的构造能够解决$k\\in [2,\\frac{n-3} {2}]$的情况 通用构造经过不断尝试得到的构造方法，好像很强 假设得到一条长度为$m$且右偏的上述链，将剩下的点分配到两个地方 1.根的左儿子 2.链底的右儿子 分配方式就是顺次放置每个节点得到的二叉树 设剩下节点个数+根的左儿+链底的右儿子$=c$ 设$f(n)=1-[\\exists 2^i-1=n]$，特别的，当$2|n$时，$f(n)=\\infty$ 假设根的左儿子分配大小为$x$，则新的树特殊点数目就是 $m-2+f(x)+f(c-x)+[c-x\\ge 3]+[x\\ge 2(n-1-x) \\text{ or } (n-1-x)\\ge 2x]$ 枚举每一个$x\\in[1,c-1]$，判定上式是否成立即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const int N=1e5+10;#define NO puts(&quot;NO&quot;),exit(0)int n,m;int fa[N];int chk(int a,int b) &#123; if(a&gt;b) swap(a,b); return a*2&lt;=b;&#125;void Out()&#123; puts(&quot;YES&quot;); rep(i,1,n) printf(&quot;%d &quot;,fa[i]); exit(0);&#125;int Get(int l,int r) &#123; rep(i,l+1,r) fa[i]=l-1+(i-l+1)/2; return l;&#125;int Mincost(int x)&#123; if(~x&amp;1) return 1e9; rep(i,0,17) if(x+1==(1&lt;&lt;i)) return 0; return 1;&#125;int main()&#123; n=rd(),m=rd(); if(Mincost(n)==m) Get(1,n),Out(); if(m==0) NO; if(~n&amp;1) NO; if((m+1)*2&gt;=n) NO; int r=(m+1)*2+1; if(r==n) &#123; rep(i,1,m+1) fa[i*2]=i*2-1,fa[i*2+1]=i*2-1; Out(); &#125; r-=2; int c=n-r+2; if(m&gt;1) rep(x,1,c-1) if(Mincost(x)+Mincost(c-x)-!chk(c-x,n-1-(c-x))+(x&gt;=3)==1) &#123; rep(i,1,m) fa[i*2]=i*2-1,fa[i*2+1]=i*2-1; int t=max(0,r-2); fa[Get(r-1,r+x-2)]=t; fa[2]=t; fa[Get(r+x-1,n)]=1; Out(); &#125; NO;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1305G - Kuroni and Antihype","slug":"CF1305G - Kuroni and Antihype","date":"2021-05-09T00:57:34.000Z","updated":"2021-05-22T03:54:10.787Z","comments":true,"path":"articles/2021/05/09/2165e626.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/09/2165e626.html","excerpt":"","text":"CF1305G - Kuroni and Antihype题目大意有$n$个人，每个人有一个权值$a_i$ 每个人可以自己选择放入集合，不获得分数 或者一个已经在集合中的人$i$可以把一个$a_i \\ \\text{and}\\ a_j=0$的$j$放入集合，并且获得$a_i$的分数 求最大得分总和 模型分析按照原题的模型分析，视$a_i\\rightarrow a_j$为一条权值为$a_i$边，则实际上求的是 最大外向森林 考虑加入$a_0=0$，且$a_0$初始在集合中，一个人自己放入集合视作被$0$放入集合 那么问题简化为求以0为根的 最大外向树 进一步观察会发现： 在外向树上每个点贡献次数就是$a_i\\cdot (deg_i-1)$ 那么最大化$a_i\\cdot (deg_i-1)$等价于最大化$\\sum a_i\\cdot deg_i$ 那么我们将一条边的权值$a_i\\rightarrow a_j$改为$a_i+a_j$，此时边双向权值相同 问题就变成了求最大生成树 计算生成树只有暴力解法 倒着枚举$a_i+a_j=S$，枚举$S$的子集$T$就能确定两个点 并查集处理加边即可，复杂度为$O(\\cfrac{3^{18} } {2}\\cdot \\alpha(n))$ $\\text{CodeForces}$真的有点快！！ 12345678910111213141516171819202122const int N=1&lt;&lt;18,INF=1e9+10;int n,a[N],F[N];ll ans;int Find(int x)&#123; return F[x]==x?x:F[x]=Find(F[x]); &#125;int main()&#123; n=rd(); rep(i,1,n) &#123; int x=rd(); a[x]++,ans-=x; &#125; a[0]++; rep(i,0,N-1) F[i]=i; drep(i,N-1,1) &#123; for(int S=i,T;(S^i)&lt;=S;S=(S-1)&amp;i) if(a[S] &amp;&amp; a[T=S^i] &amp;&amp; Find(S)!=Find(T)) &#123; ans+=1ll*(a[S]+a[T]-1)*i; a[S]=a[T]=1,F[Find(S)]=Find(T); &#125; &#125; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1276F - Asterisk Substrings","slug":"CF1276F - Asterisk Substrings","date":"2021-05-09T00:13:39.000Z","updated":"2021-05-22T03:54:10.779Z","comments":true,"path":"articles/2021/05/09/b4dda2ab.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/09/b4dda2ab.html","excerpt":"","text":"CF1276F - Asterisk Substrings题目大意给定串$S,|S|=n$，设一个串的子串集合为$Sub(S)$ 求$|Sub(S) \\cup Sub(+S[2:n])\\cup Sub(S[1:1]++S[3:n])\\cup \\cdots|$ 其中*表示特殊字符而不是通配符 分析对于不包含*的串，显然就是$Sub(S)$，可以通过后缀数组，后缀自动机来计算 对于包含*的串，考虑分两部分计算 1.对于后面接的串$T$分类对于后面接的串$T$，$T$在原串$S$出现的位置对应后缀数组上一段$\\text{rank}$区间$[l,r]$ 考虑按照原串后缀数组的$\\text{height}$建立笛卡尔树，此时容易发现，不同的$[l,r]$就是 笛卡尔树上每一个节点对应的区间，而这个$[l,r]$出现的个数就是$height_u-height_{fa_u}$ 2.对于每一个$[l,r]$计算前面接的串$R$的种类那么在前面接的串$R$就是从$[l,r]$中$sa[i]-2$对应的所有前缀中 选择某一条后缀得到 在笛卡尔树上计算时，我们需要从儿子中合并两段$[l,r],[l’,r’]$，计算不同串个数 也就是说我们需要动态维护一个集合$Set$为反串后缀的子集，并且计算这些后缀能够构成的串种类 对于$Set$为全集的情况，我们知道答案就是$\\sum |suf_i|-\\sum height_i$ 这条式子的意义实际上是： 按照$\\text{rank}$考虑每一个后缀，减去前面已经出现过的所有串，就是减去和前面串最大的$\\text{LCP}$ 由于$\\text{LCP}(i,j)$取决于中间$height$的最小值，按$\\text{rank}$加入时$\\text{LCP}$的最大值就是$height_{i-1}$ 那么这个计算思路对于$Set$中元素不连续的情况显然依然成立 只需要动态维护出现位置的$\\text{rank}$，不断减去相邻两个位置$i,j$的$\\text{LCP}$即可 用$\\text{std::set}$+启发式合并即可$O(n\\log ^2n)$维护，$\\text{LCP}$用后缀数组$\\text{RMQ}$即可$O(1)$求（实际上带一个$\\log $也不影响总复杂度） 或许用线段树合并可以做到$O(n\\log n)$ 代码的话$\\downarrow $，有轻度封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;enum&#123;N=100010&#125;;int n,m;char s[N];struct Suffix_Array&#123;int rk[N&lt;&lt;1],tmp[N],cnt[N],sa[N],lcp[N];void Build() &#123; rep(i,1,n) cnt[s[i]-&#x27;a&#x27;]++; rep(i,1,25) cnt[i]+=cnt[i-1]; rep(i,1,n) rk[i]=cnt[s[i]-&#x27;a&#x27;]; drep(i,n,1) sa[cnt[s[i]-&#x27;a&#x27;]--]=i; for(int m=n,k=1;;k&lt;&lt;=1) &#123; int h=0; rep(i,n-k+1,n) tmp[++h]=i; rep(i,1,n) if(sa[i]&gt;k) tmp[++h]=sa[i]-k; rep(i,1,n) cnt[rk[sa[i]]]=i; drep(i,n,1) sa[cnt[rk[tmp[i]]]--]=tmp[i]; rep(i,1,n) tmp[sa[i]]=tmp[sa[i-1]]+(rk[sa[i]]!=rk[sa[i-1]]||rk[sa[i-1]+k]!=rk[sa[i]+k]); rep(i,1,n) rk[i]=tmp[i]; if((m=rk[sa[n]])==n) break; &#125; int h=0; rep(i,1,n) &#123; int j=sa[rk[i]-1]; if(h) h--; while(s[i+h]==s[j+h]) h++; lcp[rk[i]-1]=h; &#125;&#125;&#125; ;struct LCPer:Suffix_Array&#123;int st[20][N],Log[N];void Init() &#123; rep(i,2,n) Log[i]=Log[i&gt;&gt;1]+1; rep(i,1,n) st[0][i]=lcp[i]; rep(i,1,Log[n]) &#123; int len=1&lt;&lt;(i-1); rep(j,1,n-len+1) st[i][j]=min(st[i-1][j],st[i-1][j+len]); &#125;&#125;int LCP(int i,int j) &#123; if(i==j) return n-sa[i]+1; if(i&gt;j) swap(i,j); j--; int d=Log[j-i+1]; return min(st[d][i],st[d][j-(1&lt;&lt;d)+1]);&#125;&#125; S;struct SA_Solver:Suffix_Array&#123;int stk[N],top,ls[N],rs[N],mk[N];ll ans,F[N*2];set &lt;int&gt; st[N*2];void dfs(int &amp;u,int l,int r,int lst)&#123; if(l==r) &#123; u=++m; int p=sa[l]; if(p&gt;2) &#123; int q=n-(p-2)+1; F[u]=n-q+1; st[u].insert(S.rk[q]); &#125; if(p&gt;1) ans+=1ll*(n-p+1-lst)*(F[u]+1); return; &#125; dfs(ls[u],l,u,lcp[u]),dfs(rs[u],u+1,r,lcp[u]); if(st[ls[u]].size()&gt;st[rs[u]].size()) swap(ls[u],rs[u]); swap(st[u],st[rs[u]]),F[u]=F[ls[u]]+F[rs[u]]; int t=-1; for(int i:st[ls[u]]) &#123; if(~t) F[u]+=S.LCP(t,i); t=i; auto r=st[u].upper_bound(i); if(r!=st[u].end()) F[u]-=S.LCP(i,*r); if(r!=st[u].begin()) &#123; auto l=r; l--; if(r!=st[u].end()) F[u]+=S.LCP(*l,*r); F[u]-=S.LCP(*l,i); &#125; st[u].insert(i); &#125; ans+=1ll*(lcp[u]-lst)*(F[u]+1);&#125;void Solve()&#123; rep(i,1,n-1) &#123; while(top &amp;&amp; lcp[stk[top]]&gt;lcp[i]) ls[i]=stk[top--]; if(top) rs[stk[top]]=i; stk[++top]=i; &#125; rep(i,1,n-1) mk[ls[i]]=mk[rs[i]]=1; rep(i,1,n) ans+=n-i+1-lcp[i]; ans++; int lst=-1; rep(i,1,n) if(S.sa[i]&gt;1) &#123; ans+=n-S.sa[i]+1; if(~lst) ans-=min(S.LCP(i,lst),min(n-S.sa[i]+1,n-S.sa[lst]+1)); lst=i; &#125; ans++; rep(i,1,n-1) if(!mk[i]) dfs(i,1,n,0); printf(&quot;%lld\\n&quot;,ans);&#125;&#125; T;int main()&#123; scanf(&quot;%s&quot;,s+1),n=m=strlen(s+1); if(n==1) return puts(&quot;3&quot;),0; T.Build(),reverse(s+1,s+n+1),S.Build(),S.Init(); T.Solve();&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1082F - Speed Dial","slug":"CF1082F - Speed Dial","date":"2021-05-08T10:58:06.000Z","updated":"2021-05-22T03:54:10.761Z","comments":true,"path":"articles/2021/05/08/d60b19a0.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/08/d60b19a0.html","excerpt":"","text":"CF1082F - Speed Dial题目大意给定$n$个电话号码，你可以随意生成$k$个快捷键，每个快捷键是一个数字串 最终拨号方式： 选择 至多一个 快捷键按下，对于剩余部分手动补全，且不允许退格 每个电话号码有拨打次数，最小化手动补全部分的长度总和 分析如果每次选定一个集合使其公用一个快捷键，那么其长度必然是集合中所有串的$\\text{LCP}$ 假设确定了一个$\\text{LCP}$，那么对应的串集合容易发现就是$\\text{trie}$树上的一个子树 于是先将所有串加入$\\text{trie}$树，此时问题转化为 选择至多$k$个$\\text{LCP}$（默认根节点选了且没有代价），使得每个电话号码到其祖先中最深$\\text{LCP}$的距离之和最小 由于有拨打次数的限制，且其数值相对较大，难以存入dp状态 于是想到在祖先钦定$\\text{LCP}$，然后从子树取值 令$dp_{u,i,j}$表示计算$u$子树内的答案，已经钦定祖先中最深的$\\text{LCP}$长度为$i$，且在子树内又钦定了$j$个$\\text{LCP}$ 合并子树时对于每个$i$，背包合并$j$，决策$u$自己是否选为$\\text{LCP}$即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445const int N=510,INF=1e9+10;int n,m;int trie[N][10],cnt,c[N];char s[N];int dp[N][N][12];int F[N][12],G[12],dep[N];void dfs(int u) &#123; for(int v:trie[u]) if(v) dep[v]=dep[u]+1,dfs(v); memset(F,63,sizeof F); rep(i,0,dep[u]) F[i][0]=c[u]*(dep[u]-i); for(int v:trie[u]) if(v) &#123; rep(j,0,dep[u]) &#123; rep(k,0,m) G[k]=F[j][k],F[j][k]=INF; rep(k,0,m) rep(d,0,m-k) cmin(F[j][k+d],G[k]+dp[v][j][d]); &#125; &#125; rep(d,0,dep[u]) &#123; rep(i,0,m) dp[u][d][i]=INF; rep(i,0,m) &#123; cmin(dp[u][d][i+1],F[dep[u]][i]); cmin(dp[u][d][i],F[d][i]); &#125; &#125;&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,n) &#123; scanf(&quot;%s&quot;,s+1); int u=0; for(int j=1;s[j];++j) &#123; int &amp;v=trie[u][s[j]-&#x27;0&#x27;]; if(!v) v=++cnt; u=v; &#125; c[u]+=rd(); &#125; dfs(0); int ans=INF; rep(i,0,m) cmin(ans,dp[0][0][i]); printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1366G - Construct the String","slug":"CF1366G - Construct the String","date":"2021-05-08T10:48:27.000Z","updated":"2021-05-22T03:54:10.790Z","comments":true,"path":"articles/2021/05/08/62b22b70.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/08/62b22b70.html","excerpt":"","text":"CF1366G - Construct the String题目大意给定一个初始串$S$和目标串$T$ 其中$S$除了包含字母外还包含删除标记’.’ 具体的$S$表示的字符串$f(S)$，就是依次加入每个字母，或者在删除标记处删除上一个字符（不存在这个字符则非法） 求删除$S$中最少的字符，使得$f(S’)=T$ 吐槽$O(n^2)$出$n\\leq 10^4$??? 朴素dp分析这种题目容易想到记录在$T$中匹配位置的$dp$，通过枚举$S$的每一个字符 1.匹配 2.手动删除 3.被’.’删除 然而被’.’删除的情况实际难以处理，因为无法额外记录待定的’.’个数 基于括号树的思路考虑对于不完全的括号序列的包含关系建立树，注意到 1.一个已经和’.’匹配的字符，不需要考虑它被手动删除的情况 2.一个字符能够保留，当且仅当所有跨过其的右括号被删除 跨过其的右括号即祖先中的右括号 所以此时dp决策可以简单地归纳为 1.保留一整个匹配括号的子树，进入后面的匹配 2.否则，删除右括号，并且决定自己这个字符是否匹配，然后递归进入子树 代码没写 更简洁的表述实际上与上面类似，但是更加简化了模型，转移可以简单归纳为 1.匹配当前字符 2.删除当前字符 3.找到当前字符匹配右括号，跳过这一段 原理： 实际上朴素dp缺陷就在于： 如果当前这个字符被后面的某一个’.’删除，却又无法匹配时，无法被加入状态 此时手动补充直接跳到删除这个字符的位置 充分性理解：在新串中匹配该字符的右括号 和 当前后缀中匹配该字符的括号相同 如果要让这个字符被’.’删除，那么到当前后缀中匹配该字符的括号为止，中间的部分不可能保留 手动删除只会让匹配该字符的括号右移，这不会更优 1234567891011121314151617181920212223const int N=10010,P=1e9+7;int n,m;char s[N],t[N];int dp[N][N];int main()&#123; scanf(&quot;%s%s&quot;,s,t),n=strlen(s),m=strlen(t); rep(i,0,n) memset(dp[i],63,(min(m,i)+2)&lt;&lt;2); rep(i,*dp[0]=0,n-1) &#123; if(s[i]!=&#x27;.&#x27;) &#123; int j=i,c=0; do c+=s[j++]==&#x27;.&#x27;?-1:1; while(c &amp;&amp; j&lt;n); if(!c) rep(k,0,min(m,i)) cmin(dp[j][k],dp[i][k]); &#125; rep(j,0,min(m,i)) &#123; cmin(dp[i+1][j],dp[i][j]+1); if(s[i]==t[j]) cmin(dp[i+1][j+1],dp[i][j]); &#125; &#125; printf(&quot;%d\\n&quot;,dp[n][m]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1201E2 - Knightmare (Hard)","slug":"CF1201E2 - Knightmare (hard)","date":"2021-05-08T10:10:57.000Z","updated":"2021-05-22T03:54:10.767Z","comments":true,"path":"articles/2021/05/08/da5446ce.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/08/da5446ce.html","excerpt":"","text":"CF1201E2 - Knightmare (hard)题目大意$n\\times m(2|n,2|m)$的棋盘上有两个 马 (Knight是国际象棋) 分别位于$S_1=(x_1,y_1),S_2=(x_2,y_2)$ 他们分别要到达$T_1=(\\frac{n} {2},\\frac{m} {2}),T_2=(\\frac{n} {2}+1,\\frac{m} {2})$ 一方胜利的情况是： 1.吃掉另一方 2.到达自己的目标位置，且这个位置不能被另一方吃掉 你可以选定操作先手还是后手，要求和交互器交互，并且在350步内取胜 分析首先是一个重要的性质：双方必然有一方永远无法吃掉另一方 考虑象棋的移动，每次$(x\\pm 1,y\\pm 2)$或者$(x\\pm 2,y\\pm 1)$ 每次操作，必然导致$x+y\\mod 2$改变，在双方轮流操作的过程中 必然有一方走的时候永远无法和另一方同奇偶，也就是无法吃掉另一方 在此基础上，考虑几种情况 设$D(a,b)$为$a,b$两点的距离，$f$为先手是否永远不会被吃 1.先手可以在不被后手吃掉的情况下到达目标，且先于后手 先于后手即$D(S_1,T_1)\\leq D(S_2,T_2)$ 先手不被后手吃掉的情况 1.$f$ ： 显然 2.$D(S_1,T_1)&lt;D(S_2,T_1)$： 此时，假设后手存在一个吃掉先手的策略 那么后手经过这个吃掉先手的点到达$T_1$的最短路一定和先手相同，故矛盾 2.后手可以在不被先手吃掉的情况下到达目标，且先于先手 $D(S_1,T_1)&gt;D(S_2,T_2)$ 对称情况 1.$not\\ f$ 2.$D(S_2,T_2)&lt;D(S_1,T_2)-1$ 以上两种情况均直接冲最短路到达目标 3.双方均无法安全直接抵达目标 此时，考虑选择不会被吃的一方操作 由于自己是无敌的，可以考虑先猛扑对方的终点 3.1 $f=true$，选择先手 先走到$T_2$堵住后手，然后可以绕三步到达$T_1$ 先手占据$T_2$时，后手无法到达$T_2$ 走第一步时，由于先手限制着，后手无法进入$T_2$ 走第二步时，根据奇偶性分析，后手无法到达$T_2$的奇偶性 第三步到达目标 3.2$f=false$，同理 实现可以好好封装一下 我曾经以为不用读入 由于交互器下面读入的参数可能会让交互器走智障操作 如果能吃掉对方，一定要直接吃掉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const int N=1010,INF=1e9+10;const int dx[]=&#123;1,1,-1,-1,2,2,-2,-2&#125;;const int dy[]=&#123;2,-2,2,-2,1,-1,1,-1&#125;;int n,m,opt;int x=-2,y=-2;void input()&#123; x=rd(),y=rd(); if(x==-1) exit(0);&#125;void CB()&#123; puts(&quot;BLACK&quot;),fflush(stdout),input(); &#125;void CW()&#123; puts(&quot;WHITE&quot;),fflush(stdout); &#125;struct Bfser&#123; int dis[N][N],pre[N][N]; int QX[N*N],QY[N*N],L,R; int u,v; int Reach() &#123; int a=abs(u-x),b=abs(y-v); if(a&gt;b) swap(a,b); return a==1 &amp;&amp; b==2; &#125; void Bfs(int x,int y)&#123; u=x,v=y; QX[L=R=1]=x,QY[1]=y,pre[x][y]=-1,dis[x][y]=1; for(;L&lt;=R;) &#123; x=QX[L],y=QY[L++]; rep(i,0,7) &#123; int x1=x+dx[i],y1=y+dy[i]; if(x1&lt;1 || y1&lt;1 || x1&gt;n || y1&gt;m || dis[x1][y1]) continue; dis[x1][y1]=dis[x][y]+1,QX[++R]=x1,QY[R]=y1,pre[x1][y1]=i; &#125; &#125; &#125; void Go(int d,int k=1) &#123; if(Reach()) printf(&quot;%d %d\\n&quot;,x,y),fflush(stdout),exit(0); printf(&quot;%d %d\\n&quot;,u+=dx[d],v+=dy[d]),fflush(stdout); if(k) input(); &#125; void Go(int x,int y,int k) &#123; vector &lt;int&gt; s; while(~pre[x][y]) &#123; int t=pre[x][y]; s.pb(t),x-=dx[t],y-=dy[t]; &#125; drep(i,s.size()-1,0) Go(s[i],k+i); &#125;&#125; B,W;int main()&#123; n=rd(),m=rd(); int x1=rd(),y1=rd(),x2=rd(),y2=rd(); W.Bfs(x1,y1),B.Bfs(x2,y2); int f=((x1+y1)&amp;1)!=((x2+y2)&amp;1); if(W.dis[n/2][m/2]&lt;=B.dis[n/2+1][m/2] &amp;&amp; (f || W.dis[n/2][m/2]&lt;B.dis[n/2][m/2])) &#123; CW(),x=x2,y=y2,W.Go(n/2,m/2,0); &#125; else if(B.dis[n/2+1][m/2]&lt;W.dis[n/2][m/2] &amp;&amp; (B.dis[n/2+1][m/2]&lt;W.dis[n/2+1][m/2]-1 || !f)) &#123; CB(),B.Go(n/2+1,m/2,0); &#125; else if(f) &#123; CW(),x=x2,y=y2,W.Go(n/2+1,m/2,1); W.Go(2),W.Go(5),W.Go(7,0); &#125; else &#123; CB(),B.Go(n/2,m/2,1); B.Go(0),B.Go(7),B.Go(5,0); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1221G - Graph and Numbers","slug":"CF1221G - Graph And Numbers","date":"2021-05-08T09:18:02.000Z","updated":"2021-05-22T03:54:10.774Z","comments":true,"path":"articles/2021/05/08/d94695b.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/08/d94695b.html","excerpt":"","text":"CF1221G - Graph And Numbers题目大意给定一个$n$点$m$边的无向图，$n\\leq 40$ 求给所有点01染色，满足 至少存在一条边两边的点均为0 至少存在一条边两边的点一个为0，一个为1 至少存在一条边两边的点均为1 的方案数 分析至少存在 问题并不好处理，由于限制有3个，可以通过$2^3$种情况容斥得到 设三种边类型为0,1,2 即计算 1.不存在0 2.不存在1 3.不存在2 4.不存在01 5.不存在02 6.不存在12 7.不存在012 逐个击破2.即计算所有边连接两个点染色相同方案数，统计连通块即可 4/6即统计所有点两边都是1/0的方案数 5即统计所有边两端点颜色不同的方案数，即二分图染色数 7.即m=0 1,3类似，可以归纳为每条边两端的点至少有一个为1 似乎有点类似一般图独立集个数的求解 由于$n\\leq 40$，考虑 $\\text{meet in the middle}$ 做 枚举半边，判断集合内部是否有非法边，然后根据集合之间的非法边以及自己集合内部为0的点 确定另一个集合必须选择为1的点集 因此需要一个父集前缀和 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const int N=45;int n,m;int G[N][N];ll E[N]; // 这东西居然要开long longll Solve0()&#123; static int S[1&lt;&lt;20]; ll ans=0; int m=n/2,A=(1&lt;&lt;m)-1; rep(i,0,(1&lt;&lt;m)-1) &#123; ll T=0; rep(j,0,m-1) if(~i&amp;(1&lt;&lt;j)) T|=E[j]; S[i]=(~i&amp;T&amp;A)==0; &#125; // 父集前缀和 for(int i=1;i&lt;=A;i&lt;&lt;=1) for(int l=0;l&lt;=A;l+=i*2) for(int j=l;j&lt;l+i;++j) S[j]+=S[j+i]; rep(i,0,(1&lt;&lt;(n-m))-1) &#123; ll T=0; rep(j,0,n-m-1) if(~i&amp;(1&lt;&lt;j)) T|=E[j+m]; if((T&gt;&gt;m)&amp;~i) continue; T&amp;=A,ans+=S[T]; &#125; return ans;&#125;ll Solve1()&#123; static int vis[N]; function&lt;void(int)&gt; dfs=[&amp;](int u) &#123; if(vis[u]) return; vis[u]=1; rep(i,0,n-1) if(G[u][i]) dfs(i); &#125;; ll ans=1; rep(i,0,n-1) if(!vis[i]) dfs(i),ans&lt;&lt;=1; return ans;&#125;ll Solve01()&#123; ll ans=1; rep(i,0,n-1) if(!E[i]) ans&lt;&lt;=1; return ans;&#125;ll Solve02()&#123; static int vis[N],fl=1; function &lt;void(int,int)&gt; dfs=[&amp;](int u,int c) &#123; if(vis[u]) &#123; if(vis[u]!=c) fl=0; return; &#125; vis[u]=c; rep(i,0,n-1) if(G[u][i]) dfs(i,3-c); &#125;; ll ans=1; rep(i,0,n-1) if(!vis[i]) dfs(i,1),ans&lt;&lt;=1; return fl*ans;&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,m) &#123; int x=rd()-1,y=rd()-1; G[x][y]=G[y][x]=1; E[x]|=1ll&lt;&lt;y,E[y]|=1ll&lt;&lt;x; &#125; ll ans=1ll&lt;&lt;n; ans-=2*Solve0(),ans-=Solve1(); ans+=2*Solve01()+Solve02(); if(m==0) ans-=1ll&lt;&lt;n; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1408 - Clusterization Counting","slug":"CF1408 - Clusterization Counting","date":"2021-05-08T04:31:59.000Z","updated":"2021-05-22T03:54:10.808Z","comments":true,"path":"articles/2021/05/08/524f7bdc.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/08/524f7bdc.html","excerpt":"","text":"CF1408 - Clusterization Counting题目大意给定$n$个点无向带权完全图，求将这些点分组，使得 组内的边边权 都小于 组内点连到组外点的边权 保证边权不同 分析考虑如何确定合法的分组 从小到大依次加入每一条边，则一个合法的分组一定在某一个时刻满足 1.这个分组是一个极大的连通块 2.这个分组是一个团 dp考虑类似$\\text{Kruskal}$重构树的方法，对于合并的过程转化为树形结构 此时，分组决策只有两种 1.这个点儿子内部分别分组，背包合并 2.如果这个点恰好是合法的分组，那么选择这个点建立新的分组，并且此时儿子必须都是散点 借用树形背包的复杂度分析，$dp$部分复杂度为$O(n^2)$ 排序可以桶排 1234567891011121314151617181920212223242526272829303132const int N=3010,P=998244353;int n,m,k;int F[N],S[N],C[N];int Find(int x)&#123; return F[x]==x?x:F[x]=Find(F[x]); &#125;int dp[N][N/2];int X[N*N/4],Y[N*N/4];int main()&#123; n=rd(); rep(i,1,n) F[i]=i,S[i]=1,C[i]=0,dp[i][0]=dp[i][1]=1; rep(i,1,n) rep(j,1,n) &#123; int x=rd(); if(i&lt;j) X[x]=i,Y[x]=j; &#125; rep(i,0,n*n) if(X[i]) &#123; int x=Find(X[i]),y=Find(Y[i]); if(x==y) &#123; if(++C[x]==S[x]*(S[x]-1)/2) dp[x][1]++; &#125; else &#123; ++n; rep(a,0,S[x]) rep(b,0,S[y]) if((a&gt;0)==(b&gt;0)) dp[n][a+b]=(dp[n][a+b]+1ll*dp[x][a]*dp[y][b])%P; F[x]=F[y]=n,S[n]=S[x]+S[y],C[n]=C[x]+C[y]+1,F[n]=n; if(C[n]==S[n]*(S[n]-1)/2) dp[n][1]++; &#125; &#125; rep(i,1,S[n]) printf(&quot;%d &quot;,dp[n][i]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1450H2 - Multithreading (Hard Version)","slug":"CF1450H2 - Multithreading (Hard Version)","date":"2021-05-07T12:07:47.000Z","updated":"2021-05-22T03:54:10.814Z","comments":true,"path":"articles/2021/05/07/b640b4e8.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/07/b640b4e8.html","excerpt":"","text":"CF1450H2 - Multithreading (Hard Version)题目大意给定一个均分成$n$份($n$为偶数)的圆，每份上有一个元素为0/1，其中一些元素的值未知，且随机 当存在一个方案，0和0连线，1和1连线，使得每个元素都被恰好连一条线时，称环$c$合法 定义$f(c)$为上述连线方案中 不同色连线交叉的最小次数 同时需要支持修改元素，求$f(c)$的期望 贪心求解指定环首先考虑一个Naive的贪心，在环上一旦出现相邻两点同色，就将他们连线然后删除 直到最后，就将变成01交替，设此时环长$n’$，考虑再让相邻的00,11连线 则得到交叉个数为$\\frac{n’} {4}$ 这个贪心甚至连不带修的情况都做不了 简化求解考虑上面贪心过程中被抵消的点 容易发现一定是一个奇数位置的点去抵消一个偶数位置的点 并且抵消之后其他位置的奇偶性保持不变 因此猜想最终剩下的黑点数量就是$|cnt_{odd}-cnt_{even}|$ 其中$cnt_{odd},cnt_{even}$表示已经确定的1元素在奇数/偶数位上的个数 也容易证明 根据贪心，显然同奇偶的点无法抵消，因此$ans\\ge |cnt_{odd}-cnt_{even}|$ 而一旦存在两个不同奇偶的黑点，若他们不相邻 则他们之间一定存在一对相邻白点（否则奇偶性不对），进而不断合并白点使得它们相邻 白点可以对称得到相同值的式子，最终得到答案就是 $\\displaystyle \\frac{|cnt_{odd}-cnt_{even}|} {2}$ 答案式子设已经确定的部分$\\delta=cnt_{odd}-cnt_{even}$，未确定的部分包含$x$个奇数位置，$y$个偶数位置 则Naive的计算答案式子为 $\\displaystyle Sum=\\sum_{i=0}^x \\sum_{j=0}^y \\frac{1} {2}\\cdot [2|i-j+\\delta] \\cdot |\\delta+i-j|\\binom{x} {i}\\binom{y} {j}$ NTT 补上方案数$2^{x+y-1}$（因为只有一半的方案奇偶性相同），用$y-j$代换$j$ $\\displaystyle E=\\frac{1} {2^{x+y} }\\sum_{i=0}^x \\sum_{j=0}^y \\cdot [2|i-y+j+\\delta] \\cdot |\\delta+i-y+j|\\binom{x} {i}\\binom{y} {j}$ 转换为$\\displaystyle i+j\\leftarrow \\binom{x} {i}\\binom{y} {j}$的形式后，带入组合意义合并$i,j$ $\\displaystyle E=\\frac{1} {2^{x+y} }\\sum_{i=0}^{x+y} \\cdot [2|\\delta-y+i] \\cdot |\\delta-y+i|\\binom{x+y} {i}$ 不妨设$\\delta’=\\delta-y$ $\\displaystyle E=\\frac{1} {2^{x+y} }\\sum_{i=0}^{x+y} \\cdot [\\delta’\\equiv i\\pmod 2] \\cdot |\\delta’+i|\\binom{x+y} {i}$ 根据$\\delta’+i$的正负性容易确定一个范围，范围两边都是计算都转化为 $\\displaystyle S(n,m)=\\sum _{i=0}^m [2\\not |i]\\cdot i\\cdot \\binom{n} {i}$ $\\displaystyle S(n,m)=\\sum _{i=0}^m [2\\not |i]\\cdot n\\cdot \\frac{(n-1)!} {(n-i)!(i-1)!}$ $\\displaystyle S(n,m)=n\\sum _{i=0}^{m-1} [2 |i]\\cdot \\binom{n-1} {i}$ 形如$\\displaystyle m|2, S’(n,m)=\\sum _{i=0}^m [2|i]\\cdot \\binom{n} {i} $，可以转化为 $\\displaystyle S’(n,m)=\\sum _{i=0}^m 2|i$ $\\displaystyle S’(n,m)=\\sum _{i=0}^m \\binom{n-1} {i}$ 组合数关于$m$一维的前缀和是一个经典的步移问题 $S(n,m-1)=S(n,m)-C(n,m)$ $S(n,m+1)=S(n,m)+C(n,m+1)$ $S(n+1,m)=\\displaystyle \\sum_{i=0}^m C(n+1,m)=\\sum_{i=0}^mC(n,i)+\\sum_{i=0}^{m-1}C(n,i-1)=2S(n,m)-C(n,m)$ $\\displaystyle S(n-1,m)=\\frac{S(n,m)+C(n-1,m)} {2}$ 封装一下计算即可，复杂度为$O(n)$ 真的只是一点点麻烦 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=2e5+10,P=998244353;int n,m;int I[N],J[N];int P1[N],P2[N];ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;char s[N];int d,x,y;int Pow2(int x)&#123; return x&lt;0?P2[-x]:P1[x]; &#125;int C(int n,int m)&#123; return n&lt;0||m&lt;0||n&lt;m?0:1ll*J[n]*I[m]%P*I[n-m]%P; &#125;int p1,p2,cur=1;// 组合数关于m的前缀和，步移计算int SC(int n,int m) &#123; if(n&lt;0||m&lt;0) return 0; if(m==0) return 1; if(m&gt;=n) return Pow2(n); if(m==n-1) return Pow2(n)-1; /* Brute Force int sum=0; rep(i,0,m) sum=(sum+C(n,i))%P; return sum; */ /* assertions blows static int fl=1; assert(fl || abs(p1-n)+abs(p2-m)&lt;=10); fl=0; */ while(p2&gt;m) cur=(cur-C(p1,p2--))%P; while(p2&lt;m) cur=(cur+C(p1,++p2))%P; while(p1&lt;n) cur=(cur*2ll-C(p1++,p2))%P; while(p1&gt;n) cur=1ll*(cur+C(--p1,p2))*(P+1)/2%P; return cur;&#125;// T 指前面的S&#x27;int T(int n,int m,int k)&#123; return k==1?(SC(n,m)-T(n,m,0))%P:(n==0?m&gt;=0:SC(n-1,m-(m&amp;1))); &#125;int T(int n,int l,int r,int k)&#123; /*Brute Force int sum=0; rep(i,l,r) if((i&amp;1)==k) sum=(sum+C(n,i))%P; return sum; */ return l&gt;r?0:(T(n,r,k)-T(n,l-1,k))%P; &#125;int S(int n,int m)&#123; return 1ll*n*T(n-1,m-1,0)%P; &#125;int S(int n,int l,int r,int k=1)&#123; /*Brute Force int sum=0; rep(i,l,r) if((i&amp;1)==k) sum=(sum+1ll*i*C(n,i))%P; return sum; */ if(l&gt;r) return 0; if(k==0) return (1ll*n*(SC(n-1,r-1)-SC(n-1,l-2))-S(n,l,r))%P; return (S(n,r)-S(n,l-1))%P;&#125;int Que()&#123; int D=d-y,n=x+y,ans=0; /* Brute Force rep(i,0,n) if((i&amp;1)==(D&amp;1)) &#123; ans=(ans+1ll*abs(D+i)*C(n,i))%P; &#125; */ if(D&lt;0) &#123; int t=-D-1; ans=(ans-1ll*D*T(n,t,D&amp;1))%P; ans=(ans-S(n,0,t,D&amp;1))%P; &#125; if(D+n&gt;=0) &#123; ans=(ans+1ll*D*T(n,max(0,-D),n,D&amp;1))%P; ans=(ans+S(n,max(0,-D),n,D&amp;1))%P; &#125; ans=1ll*(ans+P)*Pow2(-n)%P; return ans;&#125;int main()&#123; rep(i,*P1=1,N-1) P1[i]=P1[i-1]*2,Mod1(P1[i]); rep(i,*P2=1,N-1) P2[i]=((P2[i-1]&amp;1)?P2[i-1]+P:P2[i-1])/2; rep(i,*J=1,N-1) J[i]=1ll*J[i-1]*i%P; I[N-1]=qpow(J[N-1]); drep(i,N-1,1) I[i-1]=1ll*I[i]*i%P; n=rd(),m=rd(),scanf(&quot;%s&quot;,s+1); rep(i,1,n) &#123; if(s[i]==&#x27;b&#x27;) i&amp;1?d++:d--; if(s[i]==&#x27;?&#x27;) i&amp;1?x++:y++; &#125; printf(&quot;%d\\n&quot;,Que()); while(m--) &#123; int i=rd(),c=getchar(); if(s[i]==&#x27;b&#x27;) i&amp;1?d--:d++; if(s[i]==&#x27;?&#x27;) i&amp;1?x--:y--; s[i]=c; if(s[i]==&#x27;b&#x27;) i&amp;1?d++:d--; if(s[i]==&#x27;?&#x27;) i&amp;1?x++:y++; printf(&quot;%d\\n&quot;,Que()); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1379F2 - Chess Strikes Back (Hard Version)","slug":"CF1379F2 - Chess Strikes Back (hard version)","date":"2021-05-07T08:05:25.000Z","updated":"2021-05-22T03:54:10.797Z","comments":true,"path":"articles/2021/05/07/7c270418.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/07/7c270418.html","excerpt":"","text":"CF1379F2 - Chess Strikes Back (hard version)题目大意给定一个$2n\\times 2m$的交错棋盘，一个位置$(i,j)$可以放当且仅当$2|i+j$ 给定$q$次操作，每次操作在一个位置加入或删除一个障碍 求是否存在一种方案能在棋盘上放入$nm$个互不攻击的国王（国王走九宫格） 分析棋盘是交错的减少了很多无法处理的情况 容易发现，任何一个King都只能在它自己$2\\times 2$的小方格内选择两种位置 如果一个$2\\times 2$的单元左上角被填了，那么它就只能选择右下角 而根据这个King的互斥位置，在其右下方的所有King都只能选择右下角 如果右下角被占了同理，左上方的King只能选择左上角 实际上判定是否有解就是判定这些关系是否互斥，将每个点按照其所属$2\\times 2$单元编号 则问题转化为一个检查二维偏序的问题 删点容易通过线段树分治转化，偏序可以用树状数组处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const int N=2e5+10,P=998244353;int n,m,q;int X[N],Y[N];int A[N*20],B[N*20],C[N*20],T;int ans;void Add(int x,int y)&#123; int t=x&amp;1; x=(x+1)/2,y=(y+1)/2; if(t) &#123; for(int i=x;i&lt;=n;i+=i&amp;-i) ans+=Y[i]&gt;=y; for(int i=x;i&lt;=n;i+=i&amp;-i) if(X[i]&gt;y) A[++T]=0,B[T]=i,C[T]=X[i],X[i]=y; &#125; else &#123; for(int i=x;i;i-=i&amp;-i) ans+=X[i]&lt;=y; for(int i=x;i;i-=i&amp;-i) if(Y[i]&lt;y) A[++T]=1,B[T]=i,C[T]=Y[i],Y[i]=y; &#125;&#125;void Back()&#123; if(A[T]==0) X[B[T]]=C[T]; else Y[B[T]]=C[T]; T--;&#125;map &lt;Pii,int&gt; M;vector &lt;Pii&gt; G[N&lt;&lt;2];void Ins(int p,int l,int r,int ql,int qr,Pii x)&#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) return G[p].pb(x); int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) Ins(p&lt;&lt;1,l,mid,ql,qr,x); if(qr&gt;mid) Ins(p&lt;&lt;1|1,mid+1,r,ql,qr,x);&#125;void Solve(int p,int l,int r)&#123; int t1=T,t2=ans; for(auto i:G[p]) Add(i.first,i.second); if(l==r) puts(ans?&quot;NO&quot;:&quot;YES&quot;); else &#123; int mid=(l+r)&gt;&gt;1; Solve(p&lt;&lt;1,l,mid),Solve(p&lt;&lt;1|1,mid+1,r); &#125; while(T&gt;t1) Back(); ans=t2;&#125;int main()&#123; memset(X,10,sizeof X); n=rd(),m=rd(),q=rd(); rep(i,1,q) &#123; int x=rd(),y=rd(); Pii t(x,y); if(M[t]==0) M[t]=i; else Ins(1,1,q,M[t],i-1,t),M[t]=0; &#125; for(auto i:M) if(i.second!=0) Ins(1,1,q,i.second,q,i.first); Solve(1,1,q);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF Round  635 Div.1 Chiori and Doll Picking (Hard Version)","slug":"CF Round  635 Div.1 Chiori and Doll Picking (hard version)","date":"2021-05-07T07:21:19.000Z","updated":"2021-05-22T03:54:10.747Z","comments":true,"path":"articles/2021/05/07/f5140243.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/07/f5140243.html","excerpt":"","text":"CF Round #635 Div.1 Chiori and Doll Picking (hard version)考虑对于$a_i$建立线性基$d$，并且通过高斯消元重整，使得$d$中 每一个元素的最高位 仅自己包含 不妨设$k=|d|$，一个基底的生成集合为$S(d)$，设$A=S(d)$，预处理部分复杂度为$O(nm+k^2)$ \\根据线性基的基本性质，我们知道任何一个$x\\in S(d)$有$2^{n-k}$种生成方法 因此我们只需要计算线性基元素异或的答案即可，这样我们将问题规模降低到了$k$ \\\\暴力1对于$k\\leq 27$，暴力枚举每个元素是否选择，可以通过预处理让复杂度降至$O(2^k)$ 暴力2$m\\leq 35，k&gt;27$时 由于线性基包含$k$个关键01位，$m-k$个非关键01位 通过高斯消元可以使得基的每一位仅包含一个关键01位 令$dp_{S,i}$表示选择了$i$个基，非关键01位异或和为$S$的方案数 复杂度为$O(2^{m-k}m^2)$ 对称暴力由于$m\\leq 53$，而我们能够暴力解决$k\\leq 27$，则可以考虑剩下的$m-k$个位，想办法在$O(2^{m-k})$时间内求解 \\考虑计算个数为$c$的方案数，我们用一个卷积形式来描述，令$\\displaystyle F_c(x)=\\sum_{|T|=c}x^{T}$ 则容易发现 $ans_c=x^{\\empty}$，其中$\\bigoplus$表示 异或 (集合对称差) 卷积 显然我们需要$\\text{FWT}$来计算这个东西，也就是计算 $[x^{\\empty}]\\text{FWT}(\\text{FWT}(A)\\cdot \\text{FWT}(F_c))$ 先考虑比较复杂的$G=\\text{FWT}(A)$的计算 下面你需要良好掌握$\\text{FWT}$，参考 1: $G(x)$中每一非零项系数为$2^k$考虑线性基$A$的元素是封闭的，则有$A\\bigoplus A=A\\cdot |A|$ 即$G\\cdot G=G\\cdot 2^k$，解方程得到$[x^S]G\\in\\{0,2^k\\}$ 2:$[x^S]G(x)=2^k\\Longleftrightarrow \\forall T,|S\\cap T|\\equiv 0\\pmod 2$由$\\text{FWT}$式子 $[x^S]G(x)=\\sum (-1)^{|S\\cap T|} [x^T]A(x)$ 而$A(x)$由$2^k$个1构成，故得结论 确定非零项由恒等式$|X\\cap S|+|Y\\cap S|\\equiv|(X\\oplus Y)\\cap S|\\pmod 2$，得到简化 1.若$X,Y$对于$S$合法，则$X\\oplus Y$同样合法，只需要考虑线性基$d$中元素对于$S$的限制 2.假设已知$S,T$非零，则$S\\oplus T$非零，因此可以考虑用一个线性基$d’$来描述合法元素 确定$|d’|$大小则$2^kS(d’)=G$，$\\text{IFWT}(2^k\\cdot S(d’))=A$ 带入两边$x^{\\empty}$项的值，容易得到$|S(d’)|=2^{m-k}$，故$|d’|=m-k$ $|d’|=m-k$是接近前面猜想的一大跳跃 构造$d’$?考虑用0/1矩阵形式描述线性基$d$ 将$d$中的元素中的最高位移动到主对角线上最高的$k$个位置，此时每一行一定是一个主对角线元素后面跟上一些位置$\\ge k+1$的元素 此时$d’$的构造即：主对角线取反，其余位置为转置 $\\color{blue} 1$ 0 0 $\\color{blue} 1$ 0 0 $\\color{blue} 1$ 0 0 $\\color{blue} 1$ 0 0 $\\color{blue} 1$ $\\color{blue} 1$ 0 $\\color{red}1$ 0 $\\color{red}1$ $\\color{red}1$ 0 0 $\\color{red}1$ 0 $\\color{red}1$ $\\color{red}1$ Proof: 显然这样构造出的$d’$元素最低位独立，因此不线性相关，只需要证明满足限制即可 首先$d_i$与$d’_j$在主对角线上无交，有交部分一定是一个主对角线元素与一个非主对角线元素交 若$d_{i}$与$d’_j$在$d_{i,j},d’_{j,j}$有交，则在其关于主对角线对称的位置$d_{i,i},d’_{i,j}$处同样有交 因此交都是成对出现的 \\\\ 由此我们可以在$2^{m-k}$时间内通过暴力枚举得到$G$中每个非零项 下面考虑$\\text{FWT}(F^c)$的贡献的部分实际极其简单 可以根据$G$中每一项$x^S$的$|S|$确定$\\text{FWT}(F^c)$ $[x^S]\\text{FWT}(F^c)=\\sum_{|T|=c}(-1)^{|S\\cup T|}$ 对于$G$中不同的$|S|$分类，对于$|T|=c$，枚举$|S\\cup T|$，添加组合数系数即可计算贡献 注意最后求出的答案$[x^{\\empty}]$为对应项相乘之后求和除去$\\text{IFWT}$的$2^k$ 复杂度为$O(2^{m-k}+m^3+nm)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const int N=210,P=998244353;int n,m,c;ll d[62],e[63],C[62][62],W[63][63];ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;vector &lt;int&gt; Enum(ll *d)&#123; static ll a[N],S[1&lt;&lt;15],T[1&lt;&lt;15],bin[1&lt;&lt;15]; int n=0,m; rep(i,0,61) if(d[i]) a[n++]=d[i]; m=n/2; rep(i,0,m) bin[1&lt;&lt;i]=i; rep(i,1,(1&lt;&lt;m)-1) S[i]=S[i&amp;(i-1)]^a[bin[i&amp;-i]]; rep(i,1,(1&lt;&lt;(n-m))-1) T[i]=T[i&amp;(i-1)]^a[bin[i&amp;-i]+m]; vector &lt;int&gt; res(::m+1); int X=(1&lt;&lt;m)-1; rep(i,0,(1&lt;&lt;n)-1) res[__builtin_popcountll(S[i&amp;X]^T[i&gt;&gt;m])]++; return res;&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,n) &#123; ll x=rd&lt;ll&gt;(); drep(i,m-1,0) if(x&amp;(1ll&lt;&lt;i)) &#123; if(!d[i]) &#123; d[i]=x,c++; break; &#125; else x^=d[i]; &#125; &#125; if(c&lt;=27) &#123; n=qpow(2,n-c); vector &lt;int&gt; res=Enum(d); rep(i,0,m) res[i]=1ll*res[i]*n%P; rep(i,0,m) printf(&quot;%d &quot;,res[i]); return 0; &#125; rep(i,0,m) rep(j,*C[i]=1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%P; rep(i,0,m) &#123; // F_i变成j之后的变化 rep(j,0,m) rep(k,0,min(i,j)) &#123; W[i][j]=(W[i][j]+1ll*(k&amp;1?-1:1)*C[j][k]*C[m-j][i-k])%P; &#125; &#125; rep(i,0,m-1) if(d[i]) rep(j,i+1,m) if(d[j]&amp;(1ll&lt;&lt;i)) d[j]^=d[i]; rep(i,0,m-1) if(d[i]) &#123; rep(j,0,i-1) if(d[i]&amp;(1ll&lt;&lt;j)) e[j]|=1ll&lt;&lt;i; &#125; else e[i]|=1ll&lt;&lt;i; vector &lt;int&gt; t=Enum(e),ans(m+1); n=qpow(2,n-c+c-m+P-1); rep(i,0,m) rep(j,0,m) ans[i]=(ans[i]+1ll*W[i][j]*t[j])%P; rep(i,0,m) ans[i]=1ll*(ans[i]+P)*n%P; rep(i,0,m) printf(&quot;%d &quot;,ans[i]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1393E2 - Twilight and Ancient Scroll (Harder Version) ","slug":"CF1393E2 - Twilight and Ancient Scroll (harder version) ","date":"2021-05-07T04:11:27.000Z","updated":"2021-05-22T03:54:10.806Z","comments":true,"path":"articles/2021/05/07/8ef026cd.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/07/8ef026cd.html","excerpt":"","text":"CF1393E2 - Twilight and Ancient Scroll (harder version)题目大意给定$n$个串$S_i$，求在每个串中至多删除一个字符（可以删到空） 最终$S’_i$字典序单调不减的方案数 dp显然是记录上一个串删除的位置$j$，得到$dp_j$，依次考虑每个串 设$S$为当前串，$T$为上一个串 每次我们枚举当前串删除的位置$i$，不妨设得到的新串为$S’$，考虑对于$S’$找到所有合法转移 设$L=LCP(S,T)$，在$T$中删除位置为$t$ 1.$t&gt;L+1$ 则可以根据$T_{L+1}$和$S’_{L+1}$的关系确定$T’$与$S’$的关系，只需要处理一个后缀和$suf_i$ 2.设$p$为$T_{L+1}$向前延伸且字符相同的最长位置，$t\\in[p,L+1]$ 此时，删除$T_t$可能会使得$L’&gt;L$，所以提出来特殊处理 显然$t\\in[p,L+1]\\Leftrightarrow t=L+1$，那么对于得到的新串可以再求$LCP(S’,T’)$来判断大小 只需要一个区间和 3.$t&lt;p$，此时$L’=LCP(S’,T’)&lt;L$ 由于$L’&lt;L$,比较$S’,T’$相当于比较$T_{t:},T_{t+1:}$ 其中$T_{t:}$表示$T$在$t$开始的后缀，那么预处理找到所有合法的$t$，累前缀和即可得到$pre_{p-1}$ 关于实现写$\\text{SA,SAM}$就完蛋了 由于删除一个字符之后，求$LCP$的两个串就是在原串基础上进行$\\pm 1$的偏移 线性预处理三个$LCP$数组即可，当然真正求的时候需要分类讨论一下(真的，就一下/md) 判断$T_{t:},T_{t+1:}$容易倒着线性预处理出来，在代码里是$chk_i$ 所有操作均可以线性处理，时间复杂度为$O(L)$，77ms Tips: 比较过程中容易出现奇妙的越界，我写得很丑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const int N=1e6+10,P=1e9+7;int n,m;char A[2][N],*S=A[0],*T=A[1];int X[N],Y[N],Z[N];int dp[N],F[N],suf[N],pre[N],chk[N],L[N];int main()&#123; rep(_,1,rd()) &#123; swap(S,T),swap(n,m); scanf(&quot;%s&quot;,S+1),n=strlen(S+1); rep(i,n+1,m+2) S[i]=1; rep(i,m+1,n+2) T[i]=-1; if(!m) &#123; rep(i,1,n+1) dp[i]=1; continue; &#125; rep(i,max(n,m)+1,i+2) X[i]=Y[i]=Z[i]=0; drep(i,max(n,m),1) &#123; X[i]=S[i]==T[i]?X[i+1]+1:0; Y[i]=S[i]==T[i+1]?Y[i+1]+1:0; Z[i]=S[i+1]==T[i]?Z[i+1]+1:0; &#125; // initiate suf[m+2]=0; drep(i,m+1,1) suf[i]=suf[i+1]+dp[i],Mod1(suf[i]); drep(i,m,1) chk[i]=T[i]!=T[i+1]?T[i]&gt;T[i+1]:chk[i+1]; rep(i,1,m+1) L[i]=T[i]==T[i-1]?L[i-1]:i; rep(i,1,m) pre[i]=pre[i-1]+chk[i]*dp[i],Mod1(pre[i]); rep(i,1,n+1) &#123; int l=min(X[1],i-1); if(l==i-1) l+=Z[i]; F[i]=0; auto I=[&amp;](int x)&#123; return (x&gt;=i)+x; &#125;; // type1 , deleted pos &gt; l+1 if(T[l+1]&lt;=S[I(l+1)]) F[i]+=suf[l+2],Mod1(F[i]); int p=L[l+1]; // type2 ,delete T between [p..l+1] ,the same as we delete T[l+1] int r=0; // r= LCP(S&#x27;[l+2],T[l+2]) ,check if delete T[l+1], T&#x27;&lt;=S&#x27; if(l+1&lt;i) r+=min(i-l-1,Y[l+1]); if(r==max(0,i-l-1)) r+=X[l+2+r]; if(T[l+2+r]&lt;=S[I(l+1+r)]) F[i]=(F[i]+0ll+suf[p]-suf[l+2]+P)%P; // type3 , delete T at [1,p-1], so LCP&#x27;&lt;l , and we determine T&#x27;&lt;=S&#x27; by chk[i] F[i]=(F[i]+pre[p-1])%P; &#125; rep(i,1,n+1) dp[i]=F[i]; &#125; int ans=0; rep(i,1,n+1) ans+=dp[i],Mod1(ans); printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1217F - Forced Online Queries Problem","slug":"CF1217F - Forced Online Queries Problem","date":"2021-05-07T04:08:02.000Z","updated":"2021-05-22T03:54:10.771Z","comments":true,"path":"articles/2021/05/07/385be545.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/07/385be545.html","excerpt":"","text":"CF1217F - Forced Online Queries Problem题目大意$n$个点无向图，$m$次操作，每次加入/删除一条边，或者查询两个点连通性 $lst$为上次查询的连通性情况，即$lst=\\{0,1\\}$ 加密方式为$x=(x’+lst-1)\\mod n+1$ 吐槽如果你管这叫Forced Online？ 分析无强制在线如果没有这个假的强制在线，考虑用线段树分治解决 预处理每条边出现的时间区间$[L,R]$，加入线段树，用按秩合并并查集维护加边和回撤即可 伪强制在线依然是预处理每条边的时间区间 虽然我们无法确定一条边存在的时间区间 但是我们可以确定一条边可能存在，或者说可能被修改的时间区间 一次修改对应两条可能的边，对于两种可能都加入两条边对应的时间节点 每次加边修改指定边，对于涉及的两条边，修改之后判断是否存在 然后对于存在的边，将这条边从现在开始到 下一个时间节点 出现之间都插入即可 注意这个线段树分治是”半在线”的，即要一边处理操作一边插入修改 由于修改的区间和目前遍历的区间不交，所以容易实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const int N=2e5+10;int n,m,c;map &lt;int,int&gt; M[N],I[N];vector &lt;int&gt; T[N*2];int P[N*2];int stk[N],top,S[N],F[N];int Find(int x)&#123; while(F[x]!=x) x=x[F][F]; return x;&#125;void Union(int x,int y)&#123; x=Find(x),y=Find(y); if(x==y) return; if(S[x]&gt;S[y]) swap(x,y); F[x]=y,S[y]+=S[x],stk[++top]=x;&#125;void Back()&#123; int x=stk[top--]; S[F[x]]-=S[x],F[x]=x;&#125;vector &lt;Pii&gt; G[N&lt;&lt;2];void Add(int p,int l,int r,int ql,int qr,Pii x)&#123; if(ql&gt;qr) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) return G[p].pb(x); int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) Add(p&lt;&lt;1,l,mid,ql,qr,x); if(qr&gt;mid) Add(p&lt;&lt;1|1,mid+1,r,ql,qr,x);&#125;int opt[N],A[N],B[N],lst;void Solve(int p,int l,int r)&#123; int tmp=top; for(Pii t:G[p]) Union(t.first,t.second); if(l==r) &#123; int x=(A[l]+lst-1)%n+1; int y=(B[l]+lst-1)%n+1; if(x&gt;y) swap(x,y); if(opt[l]==1) &#123; M[x][y]^=1; rep(i,0,1) &#123; int x=(A[l]+i-1)%n+1; int y=(B[l]+i-1)%n+1; if(x&gt;y) swap(x,y); int id=I[x][y]; P[id]++; if(M[x][y]) Add(1,1,m,l+1,T[id][P[id]]-1,mp(x,y)); &#125; &#125; else &#123; lst=Find(x)==Find(y); putchar(lst+48); &#125; &#125; else &#123; int mid=(l+r)&gt;&gt;1; Solve(p&lt;&lt;1,l,mid),Solve(p&lt;&lt;1|1,mid+1,r); &#125; while(top&gt;tmp) Back();&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,n) F[i]=i,S[i]=1; rep(i,1,m) &#123; opt[i]=rd(),A[i]=rd(),B[i]=rd(); if(opt[i]==1) rep(lst,0,1) &#123; int x=(A[i]+lst-1)%n+1; int y=(B[i]+lst-1)%n+1; if(x&gt;y) swap(x,y); if(!I[x][y]) I[x][y]=++c; T[I[x][y]].pb(i); &#125; &#125; rep(i,1,c) T[i].pb(m+1); Solve(1,1,m);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"},{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1510H - Hard Optimization","slug":"CF1510H - Hard Optimization","date":"2021-05-06T11:16:11.000Z","updated":"2021-05-22T03:54:10.839Z","comments":true,"path":"articles/2021/05/06/4ded51dd.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/06/4ded51dd.html","excerpt":"","text":"CF1510H - Hard Optimization题目大意给定$n$个区间$L_i,R_i$，满足其两两之间要么包含要么不交，且所有$L_i,R_i$互不相同 求为每个区间选定$L_i\\leq l_i&lt;r_i\\leq R_i$，$[l_i,r_i]$仅在端点相交 使得$\\sum r_i-l_i$，并且输出方案 分析乍一看，$L_i,R_i$的关系构成森林 哇树形$dp$ 哇输出方案！ 树形$dp$还可以输出方案！！！！！！！！！ 考虑从子树合并$dp$信息，令$dp_{u,i,S}$表示 已经确定$u$的子树内的答案，且向祖先接了$i$个区间 $S$表示 左边以及右边 是否有 待定未匹配 的区间端点 按照$L_i$依次合并每个儿子，两个儿子之间可以将未匹配的端点匹配，加入待选集合 待选集合即指向祖先借的个数 每个点在合并结束之后可以匹配同时新建未匹配的左右端点（实际上就是为了给自己定一个方案区间） 关于输出方案 存储每个转移的前驱指针，包括合并以及每个点最后的决策 暴力回溯每个状态，其中待选集合可以用一个栈处理 分类讨论gogogo！！！！ 没错三个都是我 可能少讨论了一些，但是没有关系！！！！！！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair &lt;int,int&gt; Pii;#define mp make_pair#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)int cmax(int &amp;a,int b)&#123; return a&lt;b?a=b,1:0; &#125;const int N=2010,P=998244353;int n;int L[N],R[N];int dp[N][N][4],sz[N],len[N],fa[N];vector &lt;int&gt; E[N];int X[N],Y[N];int F[N][4],G[N][4];int p1[N][N][4],p2[N][N][4];// p1 存储合并子树的前驱// p2 存储每个点最后决策时的变化void dfs(int u) &#123; sort(E[u].begin(),E[u].end(),[&amp;](int x,int y)&#123; return L[x]&lt;L[y]; &#125;); // 叶子暴力赋初值 if(!E[u].size()) &#123; sz[u]=0; dp[u][0][0]=R[u]-L[u]; dp[u][0][1]=R[u]; dp[u][0][2]=-L[u]; dp[u][0][3]=0; return; &#125; sz[u]=0; for(int v:E[u]) dfs(v); memset(F,-63,sizeof F); for(int v:E[u]) &#123; if(v==E[u][0]) &#123; rep(i,0,sz[v]) rep(j,0,3) F[i][j]=dp[v][i][j],p1[v][i][j]=i*16+j; sz[u]+=sz[v]; continue; &#125; rep(i,0,sz[u]) rep(j,0,3) G[i][j]=F[i][j],F[i][j]=-1e9; rep(i,sz[u]+1,sz[u]+sz[v]) rep(j,0,3) F[i][j]=-1e9; rep(i,0,sz[u]) rep(a,0,3) rep(j,0,sz[v]) rep(b,0,3) if((a&gt;&gt;1)==(b&amp;1)) &#123; if(cmax(F[i+j+(b&amp;1)][(a&amp;1)|(b&amp;2)],G[i][a]+dp[v][j][b])) &#123; p1[v][i+j+(b&amp;1)][(a&amp;1)|(b&amp;2)]=j*16+a*4+b; &#125; &#125; sz[u]+=sz[v]+1; &#125; rep(i,0,sz[u]) rep(j,0,3) &#123; if(i &amp;&amp; cmax(dp[u][i-1][j],F[i][j])) p2[u][i-1][j]=1; if(j&amp;1 &amp;&amp; cmax(dp[u][i][j-1],F[i][j]-L[u])) p2[u][i][j-1]=2; if(j&amp;2 &amp;&amp; cmax(dp[u][i][j-2],F[i][j]+R[u])) p2[u][i][j-2]=3; if(j&amp;1 &amp;&amp; cmax(dp[u][i][j],F[i][j])) p2[u][i][j]=4; if(j&amp;2 &amp;&amp; cmax(dp[u][i][j],F[i][j])) p2[u][i][j]=5; &#125;&#125;stack &lt;Pii&gt; stk;Pii dfs2(int u,int a,int b) &#123; if(!E[u].size()) &#123; X[u]=L[u],Y[u]=R[u]; return mp(L[u],R[u]); &#125; int typ=p2[u][a][b]; switch(typ) &#123; case 0: &#123; break; &#125; case 1: &#123; a+=1; break; &#125; case 2: &#123; b+=1; break; &#125; case 3: &#123; b+=2; break; &#125; case 4: &#123; break; &#125; case 5: &#123; break; &#125; &#125; reverse(E[u].begin(),E[u].end()); int r=0,lst=-1; for(int v:E[u]) &#123; int t=p1[v][a][b]; Pii p=dfs2(v,t&gt;&gt;4,t&amp;3); if(t&amp;2) &#123; if(lst==-1) r=p.second; else stk.push(mp(p.second,lst)),lst=-1; &#125; if(t&amp;1) lst=p.first; a-=(t&gt;&gt;4)+(t&amp;1),b=(t&gt;&gt;2)&amp;3; &#125; switch(typ) &#123; case 0:&#123; break; &#125; case 1:&#123; X[u]=stk.top().first,Y[u]=stk.top().second,stk.pop(); break; &#125; case 2:&#123; X[u]=L[u],Y[u]=lst; break; &#125; case 3:&#123; X[u]=r,Y[u]=R[u]; break; &#125; case 4:&#123; X[u]=L[u],Y[u]=lst,lst=L[u]; break; &#125; case 5:&#123; X[u]=r,Y[u]=R[u],r=R[u]; break; &#125; &#125; return mp(lst,r);&#125;int main()&#123; memset(dp,-63,sizeof dp),scanf(&quot;%d&quot;,&amp;n); rep(i,1,n) scanf(&quot;%d%d&quot;,L+i,R+i),len[i]=R[i]-L[i]; rep(i,1,n) &#123; rep(j,1,n) if(L[j]&lt;L[i] &amp;&amp; R[i]&lt;R[j] &amp;&amp; (!fa[i] || len[j]&lt;len[fa[i]])) fa[i]=j; if(fa[i]) E[fa[i]].pb(i); &#125; int ans=0; rep(i,1,n) if(!fa[i]) &#123; dfs(i); ans+=dp[i][0][0],dfs2(i,0,0); &#125; printf(&quot;%d\\n&quot;,ans); rep(i,1,n) printf(&quot;%d %d\\n&quot;,X[i],Y[i]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1514E - Baby Ehab's Hyper Apartment","slug":"CF1514E - Baby Ehab's Hyper Apartment","date":"2021-05-06T04:07:57.000Z","updated":"2021-05-22T03:54:10.843Z","comments":true,"path":"articles/2021/05/06/5bbe56ea.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/06/5bbe56ea.html","excerpt":"","text":"CF1514E - Baby Ehab’s Hyper Apartment题目大意交互题，给定$n$元竞赛图，方向未知，通过两种操作 1.查询$(a,b)$方向 ，上限$9n$次 2.查询$a$到达一个集合$S$是否存在正向边，上限$2n$次 判定所有点之间能否互相到达 分析能否互相到达是一个强连通问题，因此需要求出分量以及分量之间的拓扑关系 由于是竞赛图，最终的每个分量一定可以排成一排，只能由前面向后面连边 由于$9\\approx \\log n$，我们需要一个带$\\log $的算法 考虑将分量内部相对顺序随意，其他关系按照拓扑序确定 通过一个 伪排序 得到一个初始序列 然后只需要合并得到强连通分量的区间 具体的，按照序列顺序，顺次向图上加入每个点$i$ 对于每个点$i$和当前的其所在分量$A$，左边的分量$B$，以及左边所有点的集合$S$ 判断$A,B$是否合并，即判断$i$是否有到达$S$的边 最多有$n-1$次合并，以及$n-1$次合并失败 tips: 由于标准库实现的原因，伪排序不能用std::sort，但是可以用std::stable_sort 12345678910111213141516171819202122232425262728293031323334353637const int N=2e5+10;int n;int Que(int a,int b)&#123; printf(&quot;1 %d %d\\n&quot;,a,b),fflush(stdout); return rd();&#125;int P[N];int L[N],F[N];int main()&#123; rep(_,1,rd()) &#123; n=rd(); rep(i,0,n-1) F[i]=P[i]=i; stable_sort(P,P+n,Que); rep(i,0,n-1) &#123; L[i]=i; while(L[i]) &#123; printf(&quot;2 %d %d &quot;,P[i],L[i]); rep(j,0,L[i]-1) printf(&quot;%d &quot;,P[j]); puts(&quot;&quot;),fflush(stdout); if(rd()) L[i]=L[L[i]-1]; else break; &#125; rep(j,L[i],i) F[P[j]]=i; &#125; puts(&quot;3&quot;); rep(i,0,n-1) &#123; rep(j,0,n-1) putchar((F[i]&lt;=F[j])+&#x27;0&#x27;); puts(&quot;&quot;); &#125; fflush(stdout); if(rd()==-1) break; &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1515G - Phoenix and Odometers","slug":"CF1515G - Phoenix and Odometers","date":"2021-05-06T03:58:26.000Z","updated":"2021-05-22T03:54:10.846Z","comments":true,"path":"articles/2021/05/06/f9236b96.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/06/f9236b96.html","excerpt":"","text":"CF1515G - Phoenix and Odometers题目大意给定一张带权有向图，每次查询$v,s,t$表示从$v$出发并且回到$v$，可以经过重边 判断是否存在经过路径总长$l$满足$l+s\\equiv 0 \\pmod t$ \\分析显然$v$只能在其自己的强连通分量里走，并且分量内部的任意一个环都是可达的 由于是模意义下，所以环的贡献可以抵消，环之间可以无限叠加 根据裴蜀定理，能够生成的数就是是$\\gcd(len_i)$的倍数 只需预处理强连通分量内部的环，判断$\\gcd(len_i,t)|\\gcd(s,t)$即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const int N=2e5+10;int n,m;struct Edge&#123; int to,nxt,w;&#125;e[N];int head[N],ecnt;void AddEdge(int u,int v,int w)&#123; e[++ecnt]=(Edge)&#123;v,head[u],w&#125;; head[u]=ecnt;&#125;ll G[N],S[N];ll gcd(ll a,ll b)&#123; return b==0?a:gcd(b,a%b); &#125;int t[N],low[N],dfn,stk[N],ins[N],top,id[N],scc;ll dis[N];void dfs(int u)&#123; ins[stk[++top]=u]=1,low[u]=t[u]=++dfn; for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(!t[v]) &#123; dis[v]=dis[u]+e[i].w; dfs(v),cmin(low[u],low[v]); &#125; else if(ins[v]) &#123; // 不管是横边还是返祖边，长度都是dis[u]-dis[v]!!! cmin(low[u],t[v]); G[u]=gcd(G[u],dis[u]-dis[v]+e[i].w); &#125; &#125; if(low[u]==t[u]) &#123; ++scc; for(int v=-1;v!=u;) &#123; ins[v=stk[top--]]=0; id[v]=scc,S[scc]=gcd(S[scc],G[v]); &#125; &#125;&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,m) &#123; int u=rd(),v=rd(),w=rd(); AddEdge(u,v,w); &#125; rep(i,1,n) if(!t[i]) dfs(i); rep(_,1,rd()) &#123; int u=rd(),s=rd(),t=rd(); s=gcd(s,t),t=gcd(t,S[id[u]]); puts(s%t==0?&quot;YES&quot;:&quot;NO&quot;); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1516E - Baby Ehab Plays With Permutations","slug":"CF1516E - Baby Ehab Plays with Permutations","date":"2021-05-06T03:51:43.000Z","updated":"2021-05-22T03:54:10.850Z","comments":true,"path":"articles/2021/05/06/9a349a81.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/06/9a349a81.html","excerpt":"","text":"CF1516E - Baby Ehab Plays with Permutations题目大意给定一个排列$1-n$，对于每个$i\\in[1,k]$，求出恰好操作$i$能够生成的不同排列个数 分析设排列为$P_i$，考虑对于最终态每个$(i,P_i)$构成的环组进行$dp$ 一个长度为$n$的环有$(n-1)!$种可能的排列，且需要至少$n-1$次操作得到 考虑先$dp$求出至少$i$次操作，生成了总长为$j$的环的种类数，合并两个环类似$\\text{exp}$计算 偶数操作显然是可以抵消的，并且奇数次操作无法抵消，故还需根据奇偶性累前缀和 1234567891011121314151617181920212223242526272829303132333435const int N=410,P=1e9+7;int n,m;ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int C[N][N],F[N],D[N],I[N],J[N];int dp[N][N];int main()&#123; n=rd(),m=rd(); rep(i,0,N-1) rep(j,*C[i]=1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%P; I[0]=I[1]=J[0]=J[1]=1; rep(i,2,N-1) &#123; J[i]=1ll*J[i-1]*i%P; I[i]=1ll*(P-P/i)*I[P%i]%P; &#125; // D[i]=C(n,i) D[0]=1; rep(i,1,min(m*2,n)) D[i]=1ll*D[i-1]*(n-i+1)%P*I[i]%P; rep(i,1,N-1) I[i]=1ll*I[i-1]*I[i]%P; dp[0][0]=1; rep(i,0,m) rep(j,0,i*2) if(dp[i][j]) rep(k,1,m-i) &#123; // 生成了k+1个数 // C[j+k+1][j] 组合，强制一个元素在第一位 // J[k] 环排列 dp[i+k][j+k+1]=(dp[i+k][j+k+1]+1ll*dp[i][j]*C[j+k][j]%P*J[k])%P; &#125; rep(i,0,m) rep(j,0,i*2) if(dp[i][j]) F[i]=(F[i]+1ll*D[j]*dp[i][j])%P; rep(i,2,m) F[i]+=F[i-2],Mod1(F[i]); rep(i,1,m) printf(&quot;%d &quot;,F[i]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1519F - Chests and Keys","slug":"CF1519F - Chests and Keys","date":"2021-05-05T13:41:31.000Z","updated":"2021-05-22T03:54:10.863Z","comments":true,"path":"articles/2021/05/05/b1c1356c.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/05/b1c1356c.html","excerpt":"","text":"CF1519F - Chests and Keys题目大意给定$n$个宝箱，$m$种锁和对应的钥匙 每个箱子有$a_i$块钱，每种钥匙$b_i$块，给箱子$i$装上$j$这种锁需要$c_{i,j}$的代价 一个箱子可以装多把锁 求最小的代价，使得无论怎么买钥匙取开箱子都无法赚钱 $n,m\\leq 6,a_i,b_i\\leq 4$ ？？？？？？ 《关于Codeforce 3200 是朴素搜索一事》 复杂度上限？大概$2^{41}++$ -&gt; 873ms 再把-1判掉 -&gt;31ms CodeForces Submission 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)const int N=10,P=998244353;int n,m;int a[N],b[N],c[N][N];int A[1&lt;&lt;6],B[1&lt;&lt;6],s[N][1&lt;&lt;6],bin[1&lt;&lt;6];int C[1&lt;&lt;6];int st[N];int ans=1e9;void dfs(int p,int s)&#123; if(s&gt;=ans) return; if(p==n) &#123; ans=s; return; &#125; rep(S,0,(1&lt;&lt;m)-1) &#123; int fl=1; if(s+::s[p][S]&gt;=ans) continue; st[p]=S; drep(T,(1&lt;&lt;(p+1))-1,1&lt;&lt;p) &#123; C[T]=C[T^(1&lt;&lt;p)]|st[p]; if(A[T]&gt;B[C[T]]) &#123; fl=0; break; &#125; &#125; if(fl) dfs(p+1,s+::s[p][S]); &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,0,max(n,m)-1) bin[1&lt;&lt;i]=i; rep(i,0,n-1) scanf(&quot;%d&quot;,a+i); rep(i,0,m-1) scanf(&quot;%d&quot;,b+i); rep(i,0,n-1) rep(j,0,m-1) scanf(&quot;%d&quot;,c[i]+j); rep(i,0,n-1) rep(j,i+1,n-1) if(a[j]&gt;a[i]) swap(a[i],a[j]),swap(c[i],c[j]); rep(S,1,(1&lt;&lt;n)-1) A[S]=A[S&amp;(S-1)]+a[bin[S&amp;-S]]; rep(S,1,(1&lt;&lt;m)-1) B[S]=B[S&amp;(S-1)]+b[bin[S&amp;-S]]; rep(i,0,n-1) rep(S,1,(1&lt;&lt;m)-1) s[i][S]=s[i][S&amp;(S-1)]+c[i][bin[S&amp;-S]]; int s=0; rep(i,0,n-1) s+=a[i]; rep(i,0,m-1) s-=b[i]; if(s&gt;0) return puts(&quot;-1&quot;),0; dfs(0,0); printf(&quot;%d\\n&quot;,ans==1e9?-1:ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1519E - Off by One","slug":"CF1519E - Off by One","date":"2021-05-05T09:32:37.000Z","updated":"2021-05-22T03:54:10.859Z","comments":true,"path":"articles/2021/05/05/b225cfbd.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/05/b225cfbd.html","excerpt":"","text":"CF1519E - Off by One题目大意给定$n$个点$(x_i,y_i)=(\\frac{a_i} {b_i},\\frac{c_i} {d_i})$，求一个最大的匹配 满足匹配的点对$(x_i,y_i),(x_j,y_j)$每个点经过如下操作 $(x,y)\\rightarrow (x+1,y) or (x,y+1)$ 之后可能满足$\\frac{y_i’} {x_i’}=\\frac{y’_j} {x_j’}$ 模型简化按照$\\frac{y’} {x’}$对于每个点经过两种可能变换的值分类，建立节点 我们需要决策每个$P_i$选的变换种类 显然每个斜率对应的个数为偶数时，都可以完成匹配 对于每一个$P_i$，设其两种变换之后变成的斜率对应节点为$(u,v)$，那么连一条无向边 现在问题转化为对于无向边定向，使得最少的点入度为奇数 对于任意一个连通块，若其包含奇数条边，那么至少有一个点入度为奇数 否则一定可以完成匹配 具体的，随便选择一个点作为根，然后只对于祖先向子孙的边考虑关系 从子孙向上考虑所有的边，优先让子孙的入度为偶数 那么只有包含奇数条边时，根的入度为奇数，其他节点入度永远是偶数 即达到最优解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int N=4e5+10,P=998244353;int n,m;struct Edge&#123; int to,nxt;&#125; e[N*2];int head[N];struct Node&#123; ll a,b; bool operator &lt; (const Node __) const &#123; return a&lt;__.a || (a==__.a &amp;&amp; b&lt;__.b); &#125; &#125;;vector &lt;int&gt; G[N];map &lt;Node,int&gt; M;ll gcd(ll a,ll b)&#123; return b==0?a:gcd(b,a%b); &#125;int Div(int a,int b,int c,int d)&#123; ll x=1ll*a*d,y=1ll*b*c,g=gcd(x,y); x/=g,y/=g; Node t=(Node)&#123;x,y&#125;; int &amp;u=M[t]; if(!u) u=++m; return u;&#125;int vis[N],s[N],dfn;void dfs(int u)&#123; vis[u]=++dfn,s[u]=0; for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(vis[v] &amp;&amp; vis[v]&lt;vis[u]) continue; if(!vis[v]) dfs(v); if(!s[v]) s[u]^=1,G[u].pb(i/2); else s[v]^=1,G[v].pb(i/2); &#125;&#125;int main()&#123; n=rd(); rep(i,1,n) &#123; int a=rd(),b=rd(),c=rd(),d=rd(); int u=Div(a+b,b,c,d),v=Div(a,b,c+d,d); e[i*2]=(Edge)&#123;u,head[v]&#125;,head[v]=i*2; e[i*2+1]=(Edge)&#123;v,head[u]&#125;,head[u]=i*2+1; &#125; rep(i,1,m) if(!vis[i]) dfs(i); int ans=0; rep(i,1,m) ans+=G[i].size()/2; printf(&quot;%d\\n&quot;,ans); rep(i,1,m) &#123; rep(j,0,G[i].size()/2-1) printf(&quot;%d %d\\n&quot;,G[i][j*2],G[i][j*2+1]); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1517F - Reunion","slug":"CF1517F - Reunion","date":"2021-05-05T09:10:56.000Z","updated":"2021-05-22T03:54:10.856Z","comments":true,"path":"articles/2021/05/05/a8127eac.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/05/a8127eac.html","excerpt":"","text":"CF1517F - Reunion题目大意对于一棵树，树上每个节点颜色在在黑白之间均等随机 定义r: 从某一个点$u$开始，$r$为使得距离$u$在$r$以内的点均为均为黑点的最大距离 求$r$的期望，全黑和全白的情况$r$特殊处理 模型转化当然是期望转概率，枚举$d$，计算$\\max\\{r\\}\\ge d$的概率 然而$\\exists r\\ge d$并不好算，于是算$\\nexists r\\ge d$的概率 看成是用白点去覆盖整棵树，每个白点可以覆盖距离$d$以内的所有点 dp令$dp_{u,i}$表示当前$u$的子树内， $i\\ge 0$，能够向上额外延伸$i$的距离 $i&lt;0$，还需要一个距离为$-1-i$的白点伸进去覆盖它 合并可能存在的问题？如果$u$子树内即有点伸出去又有点没有被覆盖？ 那么记录没有被覆盖的点 因为在最优情况里，这个点一定要被另一个节点覆盖 而那个去覆盖它的点，显然比当前节点延伸出去部分覆盖的范围更大 因此$u$延伸出去的部分没有用 \\第二维出现的个数为$O(dep)$，借用树形背包的复杂度分析，因此单次复杂度上限为$O(n^2)$，实际完全不满 总复杂度为$O(n^3)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=310,P=998244353;ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int n,d,m;vector &lt;int&gt; G[N];int dp[N][N*2],g[N*2],D[N];vector &lt;int&gt; tmp;void dfs(int u,int f) &#123; // n+1 为基准偏移 rep(i,0,m) dp[u][i]=0; dp[u][n+d+2]=1,dp[u][n]=1; for(int v:G[u]) if(v!=f) &#123; dfs(v,u); cmax(D[u],D[v]+1); rep(i,0,m) g[i]=dp[u][i],dp[u][i]=0; tmp.clear(); rep(i,0,m) if(dp[v][i]) tmp.pb(i); rep(i,0,m) if(g[i]) &#123; for(int j:tmp) &#123; if(max(j-n-2,i-n-2)&gt;=max(n-i,n-j)) dp[u][max(i,j)]=(dp[u][max(i,j)]+1ll*g[i]*dp[v][j])%P; else dp[u][min(i,j)]=(dp[u][min(i,j)]+1ll*g[i]*dp[v][j])%P; &#125; &#125; &#125; rep(i,0,m) g[i]=dp[u][i],dp[u][i]=0; rep(i,1,n) dp[u][i-1]=g[i]; rep(i,n+2,m) dp[u][i-1]=g[i]; dp[u][n+1]+=g[n+1],Mod1(dp[u][n+1]);&#125;int main()&#123; n=rd(),m=n*2+2; rep(i,2,n) &#123; int u=rd(),v=rd(); G[u].pb(v),G[v].pb(u); &#125; int all=qpow(2,n),ans=0; // d枚举到n-1，正好抵消了n 和 -1的贡献 for(d=1;d&lt;n;++d) &#123; dfs(1,0); int s=all; rep(i,n+1,m) s-=dp[1][i],Mod2(s); ans=(ans+s)%P; &#125; ans=ans*qpow(all)%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF1517E - Group Photo","slug":"CF1517E - Group Photo","date":"2021-05-05T08:40:03.000Z","updated":"2021-05-22T03:54:10.852Z","comments":true,"path":"articles/2021/05/05/f2e0ee88.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/05/f2e0ee88.html","excerpt":"","text":"CF1517E - Group Photo题目大意对于一个长度为$n$的序列，每个元素有一个权值$a_i$，现在为这个序列染色，每个不是C就是P，且满足 $c_i-c_{i-1}\\leq c_{i+1}-c_i$ $p_i-p_{i-1}\\ge p_{i+1}-p_i$ \\模型分析由一个Simple的性质 对于$c$构成的连续段，只有第一段长度可能&gt;1 对于$p$构成的连续段，只有最后一段长度可能&gt;1 综合以上容易发现 中间交错段都是一个c一个p，两端可以有一段极长的 比较general的情况可以表示如下 # 1 2 3 4 5 6 7 8 9 10 11 C - - - - - (-) P (-) - - - - 比较丑哈 side 就是P在C前面且只有一个长段 那么枚举$P$的长段开头，二分/尺取前面交错部分长度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=2e5+10,P=998244353;int n,a[N];ll s[N],t[N];int Calc(int i,ll d)&#123; int ans=0; int res=-1; for(int l=0,r=(i-1)/2,mid;l&lt;=r;) if(mid=(l+r)&gt;&gt;1,d-t[i]+t[i-mid*2]-s[i-mid*2]&gt;0) r=mid-1,res=mid; else l=mid+1; if(~res) ans+=(i-1)/2-res+1; if(i==1) return ans; res=-1; for(int l=0,r=(i-2)/2,mid;l&lt;=r;) if(mid=(l+r)&gt;&gt;1,d-t[i]+t[i-mid*2]-s[i-mid*2]+2*a[1]&gt;0) r=mid-1,res=mid; else l=mid+1; if(~res) ans+=(i-2)/2-res+1; return ans;&#125;int main()&#123; rep(_,1,rd()) &#123; n=rd(); rep(i,1,n) a[i]=rd(); rep(i,1,n) s[i]=s[i-1]+a[i]; rep(i,1,n) t[i]=a[i]-t[i-1]; ll ans=0; rep(i,1,n-1) &#123; ans+=Calc(i,s[n]-s[i]); if(i&lt;n-1) ans+=Calc(i,s[n-1]-s[i]-a[n]); &#125; rep(i,1,n) if(s[i]-(s[n]-s[i])&gt;0) ans++; printf(&quot;%lld\\n&quot;,ans%P); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"ARC114 - Paper Cutting 2","slug":"ARC114 - Paper Cutting 2","date":"2021-05-05T04:22:02.000Z","updated":"2021-05-22T03:54:10.710Z","comments":true,"path":"articles/2021/05/05/c037d27a.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/05/c037d27a.html","excerpt":"","text":"ARC114 - Paper Cutting 2题目大意：在一张方格图上确定了一个矩形，每次操作选择一条两行或者两列之间的线将图切开 如果切开了矩形就停止，否则将包含矩形的一部分保留 问期望多少步停止 （如果你熟练掌握概率的独立性，这道题非常简单） 称矩形内部的横竖线为关键线 考虑对于每一个横线|竖线计算其被切的概率，以矩形右边的一条竖线为例 那么在这条竖线右边的线，以及在矩形左边的线，矩形上下的横线 都与其独立 也就是说，概率就是： 这条竖线左边且在矩形右边的线和所有关键线之中，这条线是第一个被切掉的概率 那么数一下上面提到所有线的个数$c$，概率就是$\\frac{1} {c}$ 123456789101112131415161718192021const int N=2e5+10,P=998244353;int n,m;int I[N];int a,b,c,d;int main()&#123; I[0]=I[1]=1; rep(i,2,N-1) I[i]=1ll*(P-P/i)*I[P%i]%P; n=rd(),m=rd(); a=rd(),b=rd(),c=rd(),d=rd(); if(a&gt;c) swap(a,c); if(b&gt;d) swap(b,d); int e=c-a+d-b,ans=1; rep(i,1,a-1) ans=(ans+I[a-i+e])%P; rep(i,c+1,n) ans=(ans+I[i-c+e])%P; rep(i,1,b-1) ans=(ans+I[b-i+e])%P; rep(i,d+1,m) ans=(ans+I[i-d+e])%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"ARC114 - Moving Pieces on Line","slug":"ARC114 - Moving Pieces on Line","date":"2021-05-05T04:15:24.000Z","updated":"2021-05-22T03:54:10.708Z","comments":true,"path":"articles/2021/05/05/4a154c9c.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/05/4a154c9c.html","excerpt":"","text":"ARC114 - Moving Pieces on Line题目大意：白色的数轴上有$n$个球$a_i$，给定若干递增且不交的区间$[t_i,t_{i+1})$ 每次选择一个球向左或者向右滚，且将滚过的一段反色 求最小步数恰好仅将给定区间染黑色，或者确定不存在方案 模型转化首先显然可以发现，每个小球只会滚过一段区间一次 设小球$i$最终停在$b_i$，则滚过这段数轴会被反色，且代价为$|a_i-b_i|$ 将最终颜色做异或差分，那么对于目标的反色，我们认为就是在每个$t_i$处放置了一个1 而对于所有$a_i$，就是在$a_i,b_i$处分别放置了一个1，这样就完全避免了关于$a_i,b_i$大小关系的问题 计算答案由于已经固定了$a_i$(设$a_i$已经排好序)，我们需要决策$b_i$ 那么可以预先得到哪些位置需要放置奇数个$b_i$，设这个集合为$pos$ 若$|pos|&gt;n$，显然无解 否则，$b_i$的放置仅有两种情况 1.放在某一个$pos_i$处 2.让两个$b_i$放在同一个位置 对于$a,pos$排序之后的情况，显然较小的$a_i$会匹配较小的$pos_i$，代价为$|a_i-pos_i|$ 而情况2用掉的两个$b_i$，选择使用$b_i,b_{i+1}$一定不劣，并且代价就是$a_{i+1}-a_i$ 那么令$dp_{i,j}$表示前$i$个$a_i$，已经匹配了$j$个$pos_j$的代价，如上决策即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=5010,P=998244353;int n,m;int a[N],b[N];ll dp[N][N];int h[N*2],hc;int s[N*2],t[N*2];int pos[N*2],c;int main()&#123; n=rd(),m=rd(); rep(i,1,n) a[i]=rd(),h[++hc]=a[i]; rep(i,1,m) b[i]=rd(),h[++hc]=b[i]; sort(a+1,a+n+1); sort(h+1,h+hc+1),hc=unique(h+1,h+hc+1)-h-1; rep(i,1,n) &#123; a[i]=lower_bound(h+1,h+hc+1,a[i])-h; s[a[i]]^=1; &#125; rep(i,1,m) &#123; b[i]=lower_bound(h+1,h+hc+1,b[i])-h; t[b[i]]^=1; &#125; rep(i,1,hc) if(s[i]^t[i]) pos[++c]=i; if(c&gt;n || (n-c)&amp;1) return puts(&quot;-1&quot;),0; memset(dp,63,sizeof dp),dp[0][0]=0; rep(i,1,n) rep(j,0,min(i,c)) &#123; if(j&lt;c) cmin(dp[i][j+1],dp[i-1][j]+abs(h[a[i]]-h[pos[j+1]])); if(i&lt;n) cmin(dp[i+1][j],dp[i-1][j]+h[a[i+1]]-h[a[i]]); &#125; printf(&quot;%lld\\n&quot;,dp[n][c]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"ARC114 - Sequence Scores","slug":"ARC114 - Sequence Scores","date":"2021-05-05T04:05:07.000Z","updated":"2021-05-22T03:54:10.712Z","comments":true,"path":"articles/2021/05/05/499b7a81.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/05/499b7a81.html","excerpt":"","text":"ARC114 - Sequence Scores题目大意：对于一个序列$A=a_i,a_i\\in[1,m]$，定义$f(A)$为 对于一个全零的初始序列，每次选择一个区间对于某一个值取$\\max$，最少生成$A$的步数 求所有$m^n$种$A$的$f(A)$之和 首先考虑$f(A)$的计算，显然可以采用如下方法 1234567b[i]=0Function Solve(l,r) v=min a[l..r] for i in l,r b[i]=max&#123;b[i],v&#125; Divide a[l..r] into contiguous ranges that a[i]!=b[i] , Solve(l&#x27;,r&#x27;) 那么考虑计算一个区间$[l,r]$被$\\text{Solve}$的次数 显然区间$[l,r]$被$\\text{Solve}$当且仅当 $\\min\\{a_i|i\\in[l,r]\\}&gt;\\max(a_{l-1},a_{r+1})$ 对于不同的$r-l+1$，枚举$\\min$，计算方案数即可 注意考虑$l=1\\or r=n$的边界情况 123456789101112131415161718const int N=5010,P=998244353;int n,m;int Pow[N][N],F[N][3];int main()&#123; n=rd(),m=rd(); rep(i,0,N-1) rep(j,*Pow[i]=1,N-1) Pow[i][j]=1ll*Pow[i][j-1]*i%P; rep(i,1,n) rep(j,0,2) rep(k,1,m) &#123; F[i][j]=(F[i][j]+1ll*(Pow[m-k+1][i]-Pow[m-k][i]+P)*Pow[k-1][j])%P; &#125; int ans=0; rep(i,1,n) rep(j,i,n) &#123; int c=(i&gt;1)+(j&lt;n); ans=(ans+1ll*F[j-i+1][c]*Pow[m][n-(j-i+1)-c])%P; &#125; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"联合省选2021爆零记","slug":"联合省选2021爆零记","date":"2021-05-04T14:24:33.000Z","updated":"2021-05-22T03:54:11.411Z","comments":true,"path":"articles/2021/05/04/ef3a50ed.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/04/ef3a50ed.html","excerpt":"","text":"联合省选2021爆零记Day0车程一如既往6h不眠不休 听说订了神仙酒店！ 诶门在哪里 刷脸进门！ 双层单间！ 一人一间大床房！ 100Mbs宽带！ /se/se/se/se/se/se 购买干粮*2 22:00上床 \\Day1牛肉面送到寝室，进食…. 这个雨下得和去年莫名相似 携带干粮*1，抵达学军紫荆港 抵达Linux机房 Minute -10哇居然提前10分钟开敲板子 Minute 0今天密码公布相当顺利 Minute 10 - 20嗯，是签到小贪心吗？好像是的 数据范围。。。不能二分 ok尺取 …对拍对拍对拍对拍对拍… Minute 20 - ?T2 WTF??? 谨慎分析，嗯，是一个$2n$元$n^2$方程的线性规划求可行解 啊啊啊啊啊啊 消元？击毙-&gt; 换元？击毙-&gt; 网络流？击毙-&gt; 单纯形？击毙-&gt; 诶听说这年头对偶很流行？击毙-&gt; 差分约束？方程这么长，不会。击毙-&gt; 击毙-&gt;我 $m=2$，这不硬来吗。。 贪心乱搞一手….枚举每个点然后把四周$b_{i,j}$取$\\min$放进去 对拍…. WAWAWAWA 改顺序… WAWAWAWA 换堆… WAWAWAWA 回撤! …WAWAWAWAWAWAWAWAWAWAWAWA… 全排列$nm\\leq 9$香啊 我死了 Minute 120-150完了完了T2都不会写，是不是所有人都会T2啊啊啊啊啊啊 先T3暴力开一下，说好了就暴力啊 记忆化一下模拟是不是就44pts了 \\Minute ???…自闭中… \\Minute $\\infty$出考场。。。 完了所有人都A了T3 带着愉m快d的心情回到酒店，感觉这波爆零势在必得 那就先愉悦一下自己 沙县小吃=晚饭 21:30上床(ok早一点) Day2说实话早上不知道醒了几次 内心平静地又一次来到考场 Minute -10今天没有提前10min敲板子 但是Linux机房日常不还原 Minute 0今天也是顺利公布密码的一天 Minute 10-20…脑抽中… 诶是不是要每个颜色开一个倍增（写锤子 Minute 20++很显然每个点只用开自己颜色下一个颜色的匹配倍增 终于开始敲…. 很快啊 看起来大样例挺不chuo的 \\Minute 40辛酸血泪之题目看错 啊，要求每次排名都是第一，那不是显然要记编号和分数 看起来状态也不是很多嘛，calculating 很好，完全存不下 $\\text{Hash_Table} $ GoGoGo！！ 诶怎么过不了样例，哦原来少了一个条件，没关系一样存状态 …TLE MLE TLE MLE TLE… 调参.. 求您给我多点分。。。 \\Minute ??++《关于联合省选把数据结构写进题目名字里》 真棒（淦），又出板板题 根据题意模拟中…. bitset 看起来很不错，暴力存储连通到达情况，qn^2/64，总能拿pts75吧 Minute $\\infty$今天又是打暴力的一天呢 6h 返程 \\Day?怎么才有民间数据… D1 T1 ok D1 T2 ok D1 T3 啊啊啊啊啊啊WA了 D2 T1 ok D2 T2 这个数据不行 D2 T3 啊啊啊啊啊怎么又WA了 哭爹还是喊娘 Day??++出成绩…. D1 T1 ok D1 T2 ok D1 T3 44-&gt;16pts … D2 T1 ok D2 T2 怎么就真的60pts呗 D2 T3 难道bitset它T掉了？ 371完成爆零","categories":[{"name":"游记","slug":"travel","permalink":"http://chasingdeath.github.io/categories/travel/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"游记","slug":"travel","permalink":"http://chasingdeath.github.io/categories/travel/"}]},{"title":"Codeforces1508D -  Tree Calendar","slug":"Codeforces1508D -  Tree Calendar","date":"2021-05-04T12:47:16.000Z","updated":"2021-05-22T03:54:10.931Z","comments":true,"path":"articles/2021/05/04/b684972e.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/04/b684972e.html","excerpt":"","text":"Codeforces1508D - Tree Calendar题目大意： 有一棵已知的有根树和一个未知的$\\text{dfs}$序，且做了若干次操作，每次操作是 对于所有的$(u,fa_u)\\and label_{fa_u}&lt;label_{u}$，找到最小的二元组$(label_{fa_u},lable_u)$，交换二元组的$label$ 给定最终的序列，求复原一个$\\text{dfs}$序并且给出操作次数，或者确定不存在这样的$\\text{dfs}$序 \\模拟这样的过程，容易发现： 1号节点沿着最小$\\text{dfs}$序路径走下去，直到叶子，同时将路径上的点推上来，一共推了$dep_{leaf}$次 2号节点沿着最小$\\text{dfs}$序路径走下去，直到叶子，同时将路径上的点推上来，一共推了$dep_{leaf’}$次 …. 考虑每个节点都已经推到最底下的情况，则最终所有的节点有两种情况 1.是推下来的节点，则其$label$恰好为原树上出栈序列的标号 2.剩下的点构成一个新的连通块，按照新的$\\text{dfs}$序的顺序标号 那么考虑找到当前最小的二元组$(label_{fa_u},label_u)$，就知道当前正在推的是哪个元素 考虑先复原这个元素被推下来的过程，复原的过程中注意判定是否当前的元组合法 然后容易通过当前的$label$确定一开始的$\\text{dfs}$序 具体的，设$s_u$为$u$子树中最小的$label$，按照$s_u$递增的顺序遍历每个儿子得到的$\\text{dfs}$才可能是合法的$\\text{dfs}$序 原理比较显然，已经被推的叶子按照$\\text{stack}$序遍历，剩下的按照原先的$\\text{dfs}$序遍历，最终取$\\text{min}$然后遍历即合法 然后按照上面的过程，对于得到的$\\text{dfs}$序判定是否合法即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=3e5+10;int n;int A[N],F[N];vector &lt;int&gt; G[N];ll ans;int X[N],Y[N],Z[N],C1,C2,C3,D[N];// X 原树 dfs 序// y 原树 stack 序// z 删去已经推完的点之后，剩下的点的 dfs 序int I[N],J[N];void dfs1(int u)&#123; I[u]=A[u]; for(int v:G[u]) D[v]=D[u]+1,dfs1(v),cmin(I[u],I[v]);&#125;void dfs2(int u)&#123; J[X[u]=++C1]=u; sort(G[u].begin(),G[u].end(),[&amp;](int x,int y)&#123; return I[x]&lt;I[y]; &#125;); for(int v:G[u]) dfs2(v); Y[u]=++C2;&#125;int vis[N];void dfs3(int u)&#123; if(vis[u]) return; Z[u]=++C3; for(int v:G[u]) dfs3(v);&#125;int main()&#123; n=rd(); rep(i,1,n) A[i]=rd(); int p=n+1; A[n+1]=n+1; rep(i,2,n) &#123; int u=rd(),v=rd(); G[u].pb(v),F[v]=u; if(A[u]&lt;A[v] &amp;&amp; A[p]&gt;A[u]) p=u; &#125; int f=1; if(p&lt;=n) while(F[p]) &#123; int f=F[p]; // illgal swap if(A[f]&lt;A[p]) return puts(&quot;NO&quot;),0; swap(A[p],A[F[p]]); // not optimal swap if(F[f] &amp;&amp; A[F[f]]&lt;A[f]) return puts(&quot;NO&quot;),0; for(int v:G[f]) if(A[v]&gt;A[f] &amp;&amp; A[v]&lt;A[p]) return puts(&quot;NO&quot;),0; p=F[p],ans++; &#125; dfs1(1),dfs2(1); rep(i,1,n) if(A[i]&lt;A[p]) f&amp;=A[i]==Y[i],vis[i]=1,ans+=D[i]; dfs3(1); rep(i,1,n) if(A[i]&gt;=A[p]) f&amp;=Z[i]+A[p]-1==A[i]; if(!f) puts(&quot;NO&quot;); else &#123; puts(&quot;YES&quot;); printf(&quot;%lld\\n&quot;,ans); rep(i,1,n) printf(&quot;%d &quot;,X[i]); puts(&quot;&quot;); &#125;&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"Codeforces1508D - Swap Pass","slug":"Codeforces1508D - Swap Pass","date":"2021-05-04T12:46:27.000Z","updated":"2021-05-22T03:54:10.933Z","comments":true,"path":"articles/2021/05/04/dea55e.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/04/dea55e.html","excerpt":"","text":"Codeforces1508D - Swap Pass题目大意： 给定$n$个不共线的点$p_i$，和一个排列$a_i$ 每次交换$a_i,a_j$的同时，在$p_i,p_j$之间连一条线段 求一个方案使得最后$a_i=i$，且连的线之间不交叉 \\问题解决分为两步： 1.环的交换 对于$a_i$的处理，显然可以将所有点分为若干由$(i,a_i)$边构成的环 每个环上可以随意选择一个点作为初始，设其为$o$ 每次交换$o,a_o$上的数，这样的过程就变成了$a_o$在环上走一圈 最后连出的边就是$o$向环上每一个点连接的一圈 “射线” 2.环的合并 考虑Simple的情况，交换两个环上的某一对元素可以将两个环合并在一起 我们希望通过在最终的射线里找”缝隙”连线来合并所有的环 取某一个非孤立的点为原点$o$，考虑先将所有点放到同一个环里 具体的，将所有的点按原点极角排序，除了最多一个跨过$&gt;\\pi$的位置不能连 剩下的点总可以和极角相邻的点交换，所连的线总在最终射线之间构成三角形 通过若干这样的交换就可以合并到一起 最后再对于钦定的原点进行一次环交换即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=3e5+10;int n,m,O;int A[N],I[N];struct Node&#123; int x,y; Node()&#123; &#125; Node(int x,int y):x(x),y(y)&#123; &#125; Node operator + (const Node _) const &#123; return Node(x+_.x,y+_.y); &#125; Node operator - (const Node _) const &#123; return Node(x-_.x,y-_.y); &#125; ll operator * (const Node _) const &#123; return 1ll*x*_.x+1ll*y*_.y; &#125; db angle() const &#123; return atan2(y,x); &#125;&#125; P[N];int C,X[N],Y[N],F[N];void Swap(int x,int y)&#123; swap(A[x],A[y]),X[++C]=x,Y[C]=y; &#125;int Find(int x)&#123; return F[x]==x?x:F[x]=Find(F[x]); &#125;void Union(int x,int y)&#123; F[Find(y)]=Find(x); &#125;int main()&#123; n=rd(); rep(i,1,n) P[i].x=rd(),P[i].y=rd(),A[i]=rd(); rep(i,1,n) if(A[i]!=i) O=i; if(!O) return puts(&quot;0&quot;),0; rep(i,1,n) if(i!=O) P[i]=P[i]-P[O],I[++m]=i; rep(i,1,n) F[i]=i; rep(i,1,n) if(F[i]==i) for(int j=A[i];j!=i;j=A[j]) Union(i,j); sort(I+1,I+m+1,[&amp;](int x,int y)&#123; return P[x].angle()&lt;P[y].angle(); &#125;); rep(i,1,m) if(P[I[i]]*P[I[i%m+1]]&gt;=0 &amp;&amp; Find(I[i])!=Find(I[i%m+1])) Union(I[i],I[i%m+1]),Swap(I[i],I[i%m+1]); while(A[O]!=O) Swap(A[O],O); printf(&quot;%d\\n&quot;,C); rep(i,1,C) printf(&quot;%d %d\\n&quot;,X[i],Y[i]);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"ARC117 - Zero-Sum Ranges 2","slug":"ARC117 - Zero-Sum Ranges 2","date":"2021-05-04T04:55:15.000Z","updated":"2021-05-22T03:54:10.739Z","comments":true,"path":"articles/2021/05/04/3167746e.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/04/3167746e.html","excerpt":"","text":"ARC117 - Zero-Sum Ranges 2题目大意：计算由$n$个$+1$和$n$个$-1$构成的序列，且 包含恰好$k$个和为零的区间 的数量 显然需要转化为前缀和，通过前缀和相等的二元组数确定和为0的数量 而恰好$n$个$+1,-1$可以转化为$s_{2n}=0$ 设$m=2n+1$，接下来我们要计算$m$个元素，且$s_1=s_m=0,s_{i}=s_{i-1}\\pm 1$的序列 $s_i$的变化是连续的，考虑分为$s_i\\ge 0,s_i&lt;0$的两部分 以$\\ge 0$为例，从高到低确定每个连续的峰折线的情况，折线组的位置不重要，只需要知道个数 令$dp_{i,j,c}$表示当前$i$个元素确定，且已经确定的元素分成了$j$段，得到$c$个相同对的方案数 每个段中可能包含折线组，且两端一定是当前的最低值，状态数为$O(n^4)$ 每次$dp$在当前状态上扩展下一层的情况，由于变化连续，得到新的状态 1.每个段两边应该出现新的位置 2.两个段向两边扩展时，可能共用一个位置 3.可能出现新的峰顶 根据2,3的情况，组合数转移 如果直接枚举2,3情况，复杂度为$O(n^6)$ 实际上容易发现2,3情况可以放在一起处理 具体的，对于新出现的$j+1$个位置（也就是每两个段之间的间隔）是一定会出现的，用这$j+1$个可以合并为一整个段 剩余的情况，额外插入一个元素，就是在$j+1$个位置中分配，且每额外加入一个就能额外产生一个新的段 复杂度为$O(n^5)$ 最终合并$s_i\\ge 0,s_i&lt;0$的两部分，由于$s_1=s_m=0$，所以开头结尾两端必须是0，然后两部分的段交替排列 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)enum&#123;N=62&#125;;int n,m,k;ll C[N][N],dp[N][N][910];// dp[i][j][s]// i places taken// j elements // s ranges generatedint D2(int n)&#123; return n*(n-1)/2; &#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k),m=n*2+1; rep(i,0,m) rep(j,*C[i]=1,i) C[i][j]=C[i-1][j]+C[i-1][j-1]; rep(i,0,m) if(D2(i)&lt;=k) dp[i][i][D2(i)]=1; rep(i,1,m) rep(j,1,i) rep(s,0,k) if(dp[i][j][s]) &#123; rep(d,j+1,m-i) &#123; if(s+D2(d)&gt;k) break; dp[i+d][d-j][s+D2(d)]+=dp[i][j][s]*C[d-1][j]; &#125; &#125; ll ans=0; rep(i,1,m) rep(j,1,i) rep(s,0,k) if(dp[i][j][s]) &#123; ans+=dp[i][j][s]*dp[m-i][j-1][k-s]; &#125; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[补]联合省选2021 图函数","slug":"[补]联合省选2021 图函数","date":"2021-05-04T03:15:56.000Z","updated":"2021-05-22T03:54:11.111Z","comments":true,"path":"articles/2021/05/04/732e8c7.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/04/732e8c7.html","excerpt":"","text":"[补]联合省选2021 图函数考虑将所有加入$i-m$这些边的答案一起算出来 模拟删去点的过程容易发现，删去$u$时，$u,v$在同一个强连通分量里的点满足： 存在仅包含$\\ge u$的点的路径，使得$u,v$互相连通 设$A_{u,v}$表示最大的$i$使得$u$能仅通过$\\ge u$的点到达$v$ 设$B_{u,v}$表示最大的$i$使得$v$能仅通过$\\ge u$的点到达$u$ 计算$\\min\\{A_{u,v},B_{u,v} \\}$即可确定一个点对能够贡献到的区间 考虑依次加入每一条边$(u,v)$，在正反图上计算$A,B$中每个元素第一次被确定的时间 以计算$A$为例，每次会被更新的$A_{i,..}$一定满足 $i\\ge \\min\\{u,v\\},i\\rightarrow u,i\\not \\rightarrow v$ 可以暴力$\\text{for}$这样的$i$，从$[i,v]$开始，让$v$扩展，每次扩展找到未确定的$[i,w]$ 每个元素只会被确定一次，复杂度为$O(n^2)$，暴力枚举起点为$O(nm)$ 可以用$\\text{bitset}$优化到$O(\\frac{nm} {64}+n^2)$ (扩展元素的部分复杂度可能是假的，但是没有关系) Loj Submission 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;using ull=unsigned long long;#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)int rd()&#123; int s=0; static char c; while(c=getchar(),c&lt;48); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(c^&#x27;0&#x27;); while(c=getchar(),c&gt;47); return s;&#125;enum&#123;N=1010,M=200010&#125;;int n,m,t;int A[N][N],B[N][N],U[M],V[M],ans[M];int Log(ull x)&#123; return !x?-1:__builtin_ctzll(x); &#125;struct Bitset&#123; ull a[16]; void turn(int x)&#123; a[x&gt;&gt;6]^=1ull&lt;&lt;x; &#125;&#125; X[N],Y[N];vector &lt;int&gt; G[N],E[N];void dfs1(int st,int u) &#123; if(~A[st][u]) return; A[st][u]=t,X[u].turn(st); for(int v:G[u]) if(v&gt;=st) dfs1(st,v);&#125;void dfs2(int st,int u) &#123; if(~B[st][u]) return; B[st][u]=t,Y[u].turn(st); for(int v:E[u]) if(v&gt;=st) dfs2(st,v);&#125;int main()&#123; n=rd(),m=rd(); rep(i,0,m-1) U[i]=rd(),V[i]=rd(); memset(A,-1,sizeof A),memset(B,-1,sizeof B); rep(i,1,n) A[i][i]=B[i][i]=m,X[i].turn(i),Y[i].turn(i); for(t=m-1;~t;t--) &#123; G[U[t]].pb(V[t]),E[V[t]].pb(U[t]); int L=min(U[t],V[t]); rep(i,0,L&gt;&gt;6) &#123; // bitset 优化。 for(int j;~(j=Log(X[U[t]].a[i]&amp;~X[V[t]].a[i])) &amp;&amp; (i&lt;&lt;6|j)&lt;=L;) dfs1(i&lt;&lt;6|j,V[t]); for(int j;~(j=Log(Y[V[t]].a[i]&amp;~Y[U[t]].a[i])) &amp;&amp; (i&lt;&lt;6|j)&lt;=L;) dfs2(i&lt;&lt;6|j,U[t]); &#125; &#125; rep(i,1,n) rep(j,i,n) if(~A[i][j] &amp;&amp; ~B[i][j]) ans[min(A[i][j],B[i][j])]++; drep(i,m,0) ans[i]+=ans[i+1]; rep(i,0,m) printf(&quot;%d &quot;,ans[i]);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"ARC117 - Gateau","slug":"ARC117 - Gateau","date":"2021-05-04T02:22:27.000Z","updated":"2021-05-22T03:54:10.714Z","comments":true,"path":"articles/2021/05/04/e14e6f15.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/04/e14e6f15.html","excerpt":"","text":"ARC117 - Gateau题目大意：给定一个长度为$2n$的非负环序列$x_0,x_1,\\cdots x_{2n-1}$，以及$2n$条限制，每条都是 $\\forall A_i,\\sum_{j=0}^{n-1} x_{i+j\\mod 2n}\\ge A_i $ 求最小化$\\sum x_i$ \\转化为前缀和作差之后，令人联想到差分约束，但是难以处理跨过环末的限制 于是二分答案$s=x_{2n-1}$，建立最长路图 $\\forall i&lt;n,dis_{i+n}\\ge dis_{i}+A_i$ $\\forall i\\ge n,dis_{i-n}\\ge dis_{i}+A_i-s$ $\\forall i&lt;2n-1,dis_{i+1}\\leq dis_i$ 那么无解的条件就是：存在正环或者求得$dis_{2n-1}&gt;s$ 自然无法直接通过$\\text{SPFA}$来跑。。。 考虑所有的边构成了一条$0-2n-1$的零链 和若干极小的二元环 如果二元环出现正环则无解，否则任意一条最长路路径总是可以描述为 $i&lt;j&lt;n , i(+n)\\rightarrow j(+n)$ 在中间点$k$可以选择花费0的代价向后走，或者 $k&lt;n:k\\rightarrow k+n,cost=A_k$ $k\\ge n:k\\rightarrow k-n,cost=A_k-s$ 也就是在$k,k+n$之间反复横跳，由此发现一条路径就是 从$0-n-1$进行扫描，并且允许中间$\\pm n$横跳 （当然这里漏掉了一个特殊边，即$dis_{n}\\ge dis_{n-1}$，这是构成环的边） 这样写出一个变种的$\\text{Bellman Ford}$，由于图的特殊性，只需要常数轮即可确定正环 具体的，当图上不存在正环时，扫描最多经过一次环就会停止更新 也就是这样横跳的扫描更新只会进行常数轮（2轮？） 如果若干轮后依然在更新，说明出现了正环 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;int cmax(int &amp;a,int b)&#123; return a&lt;b?a=b,1:0; &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=3e5+10,INF=1e9+10;int n;int A[N],dp[N];int Check(int s) &#123; rep(i,0,n-1) if(A[i]+A[i+n]-s&gt;0) return 0; rep(i,0,n*2-1) dp[i]=0; dp[n*2-1]=s; int f=0; rep(k,0,5) &#123; f=0; rep(i,0,n-1) &#123; f|=cmax(dp[i+n],dp[i]+A[i]); f|=cmax(dp[i],dp[i+n]+A[i+n]-s); if(i&lt;n-1) &#123; f|=cmax(dp[i+1],dp[i]); f|=cmax(dp[i+n+1],dp[i+n]); &#125; &#125; f|=cmax(dp[n],dp[n-1]); &#125; if(f || dp[n*2-1]&gt;s) return 0; return 1;&#125;int main() &#123; n=rd(); rep(i,0,n*2-1) A[i]=rd(); int res=-1; for(int l=0,r=1.05e9,mid;l&lt;=r;) Check(mid=(l+r)&gt;&gt;1)?r=mid-1,res=mid:l=mid+1; printf(&quot;%d\\n&quot;,res);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"ARC117 - Tricolor Pyramid","slug":"ARC117 - Tricolor Pyramid","date":"2021-05-03T14:26:54.000Z","updated":"2021-05-22T03:54:10.735Z","comments":true,"path":"articles/2021/05/03/5990b960.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/03/5990b960.html","excerpt":"","text":"ARC117 - Tricolor Pyramid设三种颜色分别为01,2, 容易发现原题变换$f(a,b)$的等价表达为 $f(a,b)=(-a-b)\\mod 3$ $\\mod 3$可以最后处理，那么就是一个取负操作 看成一个递推$F_{n,i}=col_i$ $F_{i,j}=-F_{i+1,j}-F_{i+1,j+1}$，求出$F_{1,1} \\mod 3$ 那么对于每个$col_i$，处理其对于$F_{1,1}$的贡献系数，容易发现贡献就是一个两边走的杨辉三角，即$\\displaystyle \\binom{n-1} {i-1}(-1)^{n-1}$ 然后我就真的暴力处理组合数 123456789101112131415161718192021222324252627282930const int N=1e6+10,INF=1e9+10;int n;char s[N];char ch[]=&quot;BWR&quot;;int F[N],cnt[N];int C(int n,int m)&#123; if(cnt[n]-cnt[m]-cnt[n-m]) return 0; return F[n]*F[m]*F[n-m]%3;&#125;int main()&#123; rep(i,F[0]=1,N-1) &#123; cnt[i]=cnt[i-1],F[i]=F[i-1]; int x=i; while(x%3==0) x/=3,cnt[i]++; F[i]=F[i]*x%3; &#125; scanf(&quot;%d%s&quot;,&amp;n,s+1); int sum=0; rep(i,1,n) &#123; int t=0; if(s[i]==&#x27;W&#x27;) t=1; if(s[i]==&#x27;R&#x27;) t=2; if(~n&amp;1) t=3-t; sum=(sum+C(n-1,i-1)*t)%3; &#125; sum%=3,putchar(ch[sum]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"ARC 117 - Miracle Tree","slug":"ARC 117 - Miracle Tree","date":"2021-05-03T14:25:16.000Z","updated":"2021-05-22T03:54:10.703Z","comments":true,"path":"articles/2021/05/03/7c4f0107.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/05/03/7c4f0107.html","excerpt":"","text":"ARC 117 - Miracle Tree话说我只能蒙结论。。。 打表或者理性分析可以发现一些性质 1.$\\nexists E_i=E_j$ 2.如果确定$E_i$从小到大的顺序$P_i$，就能确定一组最优的$E_i$ （但是对于平凡的$P_i$，这个过程会极其恶心，因此考虑特殊化$P_i$） 3.设$\\displaystyle f(P)=\\sum_{i=2}^n dis(P_{i-1},P_i)$，即遍历排列的距离和 则$\\max\\{E_i\\}\\ge \\min\\{f(P)\\}+1$ 显然 由此确定了一个下界，接下来将说明可以取到下界 1.对于一个排列$P_{i}$，如果$P_i$是一组$\\text{dfs}$序，那么满足$\\max\\{E_i\\}=f(P)+1$ (容易模拟发现) 2.$\\min\\{f(P)\\}$在$(P_1,P_n)$恰好为一条直径时取到，显然存在这样一组$\\text{dfs}$序满足要求 由此确定了答案$P$可以是任何一组以某一条直径两个端点为$P_1,P_n$的$\\text{dfs}$序 容易给出一个合法解，代码实现极为暴力 1234567891011121314151617181920212223242526272829303132333435363738394041const int N=2e5+10,INF=1e9+10;int n;vector &lt;int&gt; G[N];int F[N][20],D[N],E[N];int ma=-1,id;void dfs(int u,int f) &#123; if(D[u]&gt;ma) ma=D[u],id=u; F[u][0]=f,E[u]=D[u]; rep(i,1,18) F[u][i]=F[F[u][i-1]][i-1]; for(int v:G[u]) if(v!=f) D[v]=D[u]+1,dfs(v,u),cmax(E[u],E[v]); sort(G[u].begin(),G[u].end(),[&amp;](int x,int y)&#123; return E[x]&lt;E[y]; &#125;);&#125;int LCA(int x,int y)&#123; if(D[x]&lt;D[y]) swap(x,y); for(int del=D[x]-D[y],i=0;(1&lt;&lt;i)&lt;=del;++i) if(del&amp;(1&lt;&lt;i)) x=F[x][i]; if(x==y) return x; drep(i,18,0) if(F[x][i]!=F[y][i]) x=F[x][i],y=F[y][i]; return F[x][0];&#125;int Dis(int x,int y)&#123; return D[x]+D[y]-2*D[LCA(x,y)]; &#125;int lst;ll A[N];void dfs2(int u,int f) &#123; if(!lst) A[lst=u]=1; else A[u]=A[lst]+Dis(lst,u),lst=u; for(int v:G[u]) if(v!=f) dfs2(v,u);&#125;int main()&#123; n=rd(); rep(i,2,n) &#123; int u=rd(),v=rd(); G[u].pb(v),G[v].pb(u); &#125; dfs(1,0); int u=id; dfs(u,0),dfs2(u,0); rep(i,1,n) printf(&quot;%lld &quot;,A[i]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"%EI 笔记： 一类特殊的线性求和","slug":"%EI 笔记： 一类特殊的线性求和","date":"2021-04-08T12:35:10.000Z","updated":"2021-05-22T03:54:10.692Z","comments":true,"path":"articles/2021/04/08/64568338.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/04/08/64568338.html","excerpt":"","text":"%EI 笔记： 一类特殊的线性求和话不多说先%%%%%EI 对于给定的常数列$a_i,i\\in[0,n]$ 对于一些可以肉眼描述特征的多项式$F(x)$，以及一类特殊的$G(x)$（常见的$G(x)$为$e^x,a_i=i!$） 具体的，能够对于$F(x)$列出一条较为简单的微分方程，如$F(x)=(1-x)F’(x)+H(x)$ 对于$G(x)$，容易求得$\\sum a_i[x^i]G^k(x)$ 则可以用下面的思路求得$\\sum a_i[x^i]F(G(x))$ 设$c=G(0)$，带入$F(G(x))$在$c$上的$\\text{Taylor}$展开 $\\displaystyle F(G(x))=\\sum_{i=0}^{\\infty} F^{(i)}(c)\\frac{(G(x)-c)^i} {i!}$ 由于$[x^0]G(x)-c=0$，故仅$i\\leq n$的项对于答案有贡献 我们求出的$F^{(i)}(c)$实际上由$F(x+c)$的前$n$项决定 也就是说，只要能够截取$F(x+c)$的前$n$项，设其为$\\mathscr F(x+c)=F(x+c)\\mod x^{n+1}$ 那么我们再带入$\\displaystyle \\mathscr F(G(x))=\\sum_{i=0}^n\\mathscr F_iG^i$，根据前面提到的$\\sum a^i[x^i]G^k(x)$就能求得答案 那么通过$F(x+c)$得到$\\mathscr F(x)$，如果可以直接做就不谈 如果较复杂可以通过以下步骤 1.观察并列出$F(x)$的微分方程$\\sum p_i(x)F(x)=0$，则同样有$\\sum p_i(x+c)F^{(i)}(x+c)=0$ 2.截取微分方程，得到同样系数的的方程 $\\sum p_i(x+c)\\mathscr F^{(i)}(x+c)$ 然而由于$\\mathscr F^{(i)}(x+c)$相较于$F^{(i)}(x+c)$缺少了部分项，设 $\\sum p_i(x+c)\\mathscr F^{(i)}(x+c)=D(x)$ 如果$D(x)$较简洁，那么根据$D(x)$的形式，我们能够得到$D(x-c)$的展开 即$\\sum p_i(x)\\mathscr F^{(i)}(x)=D(x-c)$，此时再通过新的微分方程依次递推$\\mathscr F(x)$的每一项即可 例子： 「TJOI / HEOI2016」求和 题解","categories":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}]},{"title":"「TJOI / HEOI2016」求和","slug":"「TJOI   HEOI2016」求和","date":"2021-04-08T12:34:15.000Z","updated":"2021-05-22T03:54:11.249Z","comments":true,"path":"articles/2021/04/08/d9300c8a.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/04/08/d9300c8a.html","excerpt":"","text":"「TJOI / HEOI2016」求和题目大意： 求$\\displaystyle \\sum_{i=0}^n\\sum_{j=0}^i \\begin{Bmatrix}i\\\\ j\\end{Bmatrix}2^j\\cdot j!$ 由于第二类斯特林数的生成函数$S_m(x)=\\cfrac{1} {m!}(e^x-1)^m$ 所以求的东西就是$\\displaystyle F(x)=\\sum_{i=0} (2e^x-2)^i=\\frac{1} {3-2e^x}$前$n$项系数 可以暴力求逆 线性解法：思路 要求$\\displaystyle \\frac{1} {3-2e^x}$的前$n$项$[x^i]$乘$i!$的和 设$\\displaystyle G(x)=e^x,F(x)=\\frac{1} {3-2x}$ 那么我们需要求得$\\mathscr F(x+1)=F(x+1) \\mod x^{n+1}$ $\\displaystyle F(x+1)=\\frac{1} {1-2x}=\\sum_{i=0} (2x)^i$ $\\displaystyle F’(x+1)=\\sum_{i=0} 2(i+1) (2x)^i$ $F(x+1)=\\cfrac{1-2x} {2}F’(x+1)$ $\\displaystyle \\mathscr F(x+1)=\\cfrac{1-2x} {2}\\mathscr F’(x+1)+(n+1)(2x)^n$ $\\displaystyle \\mathscr F(x)=\\cfrac{3-2x} {2}\\mathscr F’(x)+(n+1)(2x-2)^n$ 那么得到 $\\displaystyle [x^k]\\mathscr F(x)=\\frac{3} {2}(k+1)[x^{k+1}]\\mathscr F(x)-k[x^k]\\mathscr F(x)+(n+1)2^{n}\\binom{n} {k}(-1)^{n-k}$ $\\displaystyle \\frac{3} {2}(k+1)[x^{k+1}]\\mathscr F(x)=(k+1)[x^k]\\mathscr F(x)-(n+1)2^{n}\\binom{n} {k}(-1)^{n-k}$ $\\displaystyle \\frac{3} {2} [x^{k+1}]\\mathscr F(x)=[x^k]\\mathscr F(x)-2^{n}\\binom{n+1} {k+1}(-1)^{n-k}$ 最后$\\displaystyle \\sum_{i=0}^n [x^i]F(G(x))=\\sum_{i=0}^n [x^i]\\mathscr F(G(x))=\\sum \\mathscr F_i \\sum_{j=0}^n j! [x^j]G^k(x)$ $\\displaystyle [x^0]\\mathscr F(x)=[x^0]\\sum_{i=0}^n(2x-2)^i=\\sum_{i=0}^n (-2)^i=\\frac{1-(-2)^{n+1} } {3}$ $\\sum_{j=0}^n j! [x^j]G^k(x)$就是一个等比数列求和，可以用线性筛$i^k$轻 松线性求得 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)const int N=1e5+10,P=998244353;int n;int I[N],J[N],Inv[N],Pow[N],q[N],F[N];ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;void Sieve_Pow(int n)&#123; static int notpri[N],pri[N],pc; rep(i,2,n) &#123; if(!notpri[i]) pri[++pc]=i,Pow[i]=qpow(i,n); for(int j=1;j&lt;=pc &amp;&amp; 1ll*i*pri[j]&lt;=n;++j) &#123; notpri[i*pri[j]]=1,Pow[i*pri[j]]=1ll*Pow[i]*Pow[pri[j]]%P; if(i%pri[j]==0) break; &#125; &#125;&#125;int C(int n,int m)&#123; return 1ll*J[n]*I[m]%P*I[n-m]%P; &#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n),Inv[0]=Inv[1]=1; rep(i,2,n+1) Inv[i]=1ll*(P-P/i)*Inv[P%i]%P; rep(i,*I=*J=1,n+1) I[i]=1ll*I[i-1]*Inv[i]%P,J[i]=1ll*J[i-1]*i%P; Sieve_Pow(n+1); ll p=qpow(2,n); q[0]=1,q[1]=n+1; rep(i,2,n) q[i]=1ll*(Pow[i]-1)*Inv[i-1]%P; F[0]=(((n&amp;1)?P-p*2%P:p*2%P)+1)*(P+1)/3%P; rep(i,0,n-1) &#123; int t=p%P*C(n+1,i+1)%P; if((n-i+1)&amp;1) t=P-t; F[i+1]=(F[i]+t)*2ll%P*(P+1)/3%P; &#125; int ans=0; rep(i,0,n) ans=(ans+1ll*F[i]*q[i])%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"JOI","slug":"JOI","permalink":"http://chasingdeath.github.io/tags/JOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"字符串的Period(周期),Border","slug":"字符串的Period(周期),Border","date":"2021-04-08T10:01:12.000Z","updated":"2021-05-22T03:54:11.359Z","comments":true,"path":"articles/2021/04/08/38d6070f.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/04/08/38d6070f.html","excerpt":"","text":"字符串的Period(周期),Border前置知识：$\\text{kmp}$，$\\text{AC}$自动机 约定：字符串$S$的长度为$|S|$，原串的长度为$n$，$[l,r]$的子串为$S_{l,r}$，下标从$1$开始，前缀$S_{1,i}=pre_i$,后缀$S_{i,n}=suf_i$，设$S$的$\\text{Border}$集合为$B(S)$，设最长的$\\text{Border}$为$\\text{LBorder}$ $\\text{Border}$: 定义字符串$S$的一个$\\text{Border}$为一个满足$pre_i=suf_{n-i+1}$的前缀，$S$和$\\empty$也是一个$\\text{Border}$ $\\text{kmp,AC}$自动机的$fail$指针均指向当前串的$\\text{LBorder}$ \\$\\text{Period}$(周期): 若$\\exists |T|\\in B(S), 2|T|\\ge n$,则$S$的一个周期是$n-|T|+1$ $\\text{Periodicity Lemma}:$ 若$p,q$是$S$的周期，且$p+q+\\gcd(p,q)\\leq |S|$,则$\\gcd(p,q)$也是$|S|$的一个周期 证明的话 \\关于$\\text{Border}$的推论: 1.$B(S)=B(\\text{LBorder})\\cup\\{S\\}$ 2.串$S$的所有$\\text{Border}$长度构成了不超过$\\log n$个等差数列 证明： 如果$S$的$\\text{LBorder}$，设其为$T$满足$2|T|\\ge |S|$，则所有$R\\in B(S),2|R|\\ge |S|$形成了一个等差数列 参过下面这张图 则长度为$|T|-(|S|-|T|)$，即标为红色的那一段，它也是原串的一个$\\text{Border}$ 更简洁的解释是，$S$有着长度为$|S|-|T|$的周期 所以实际上不止是$2|R|\\ge |S|$的串，而是所有$\\forall|R|\\equiv |S|\\pmod {|S|-|T|}$的$R$都是$S$的$\\text{Border}$ 这样的失配过程就可以归纳为： 每次$mod$最短周期$|T|-|S|$，而取模使得长度至少减半，故可以分成$\\log n$段等差数列 \\并且任意一段最大项为$x$，差为$d$的等差数列，最小项是$x\\mod d+d$ ($+d$是因为在$x\\mod d+d$下一次可能跳的位置$&gt;x\\mod d$) 应用：对于$\\text{kmp,AC}$自动机的字符集过大导致无法存储每种字符的转移，而又有类似可持久化的匹配操作时， 直接暴力跳$fail$会导致复杂度退化，但是可以用等差数列的性质来快速跳 每次形成等差数列时，周期中失配位置的下一个字符都相同 故如果在等差数列上失配，可以直接通过对于差值取模快速跳过，以保证复杂度为$O(\\log n)$ 相比于倍增处理，这样跳常数小，实现简单 具体看下面的习题代码 练习模板: Luogu P5829 求公共$\\text{Border}$ 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;enum&#123;N=1000010&#125;;char s[N];int _,i,j,nxt[N];int main()&#123; for(scanf(&quot;%s&quot;,s+1),i=2;s[i];++i)&#123; while(j &amp;&amp; s[i]!=s[j+1]) j=nxt[j]; if(s[i]==s[j+1]) j++; nxt[i]=j; &#125; for(scanf(&quot;%d&quot;,&amp;_);_--;)&#123; for(scanf(&quot;%d%d&quot;,&amp;i,&amp;j),i=nxt[i],j=nxt[j];i!=j;)&#123; if(i&lt;j) swap(i,j); if(nxt[i]&gt;i/2) &#123; // 产生等差数列，快速跳过 int d=i-nxt[i]; if(j%d==i%d) i=j; else i=i%d+d; &#125; else i=nxt[i]; &#125; printf(&quot;%d\\n&quot;,i); &#125;&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"杜教筛小记","slug":"杜教筛小记","date":"2021-04-07T12:33:24.000Z","updated":"2021-05-22T03:54:11.394Z","comments":true,"path":"articles/2021/04/07/2a9a1891.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/04/07/2a9a1891.html","excerpt":"","text":"杜教筛小记对于一个函数$F(n)$，要在较低时间内求前缀和$S_F(n)=\\sum_{i=1}^nF(i)$ 假设我们能找到一个函数$G(n)$使得$G(n),S_{F \\oplus G}(n)$能在较短时间内算出 其中$\\oplus$表示狄利克雷卷积，$(F\\oplus G)(n)=\\sum_{d|n}F(d)G(\\frac{n} {d})$ 那么就有 $\\displaystyle S_{F\\oplus G}(n)=\\sum_1^n G(i)S_F(\\lfloor\\frac{n} {i}\\rfloor)$ $\\displaystyle G(1)F(n)=S_{F\\oplus G}(n)-\\sum_2^nG(i)S_F(\\lfloor\\frac{n} {i}\\rfloor)$ 这个$\\lfloor\\frac{n} {i}\\rfloor$的个数是$O(\\sqrt n)$的，数论分段求解 由于每次从$2$开始枚举，每次子问题大小至少减半 (然而并没有分析复杂度) 当$n$较小时可以直接预处理出来前$m$个($m$为以常数) 不要存状态$\\text{dp}$，直接递归求解用$\\text{map}$维护记录即可 ps:实际上对于一个固定的$n$，每次计算$x$的答案时，可以根据当前的$\\lfloor \\cfrac{n} {x}\\rfloor$为状态编号，去掉了$\\text{map}$ 当$m=n^{\\frac{2} {3} }$时，复杂度最优为$O(n^{\\frac{2} {3} })$ 例子1：对于$F(n)=\\mu(n)$，求$S_\\mu(n)$ 由于$\\sum_{d|n}\\mu(d)=[n=1]$ 那么就知道可以构造$G(n)=1$ 则$(F\\oplus G)(n)=[n=1]$ $S_{F\\oplus G}(n)=1$ $\\displaystyle S_F(n)=S_{F\\oplus G}(n)-\\sum_2^nS_F(\\lfloor\\frac{n} {i}\\rfloor)$ 例子1.5$F(n)=\\mu(n)n^k$，求$S_F(n)$ 令$G(n)=n^k$ 则$\\displaystyle (F\\oplus G)(n)=\\sum _{d|n} \\mu(d)d^k (\\frac{n} {d})^k=n^k\\sum_{d|n} \\mu(d)=[n=1]\\cdot n^k$ $\\displaystyle S_F(n)=1-\\sum_{i=2}^n i^kS_F(\\lfloor \\frac{n} {i}\\rfloor )$ 只要通过一些手段得到$i^k$前缀和即可 例子2：对于任何$F(n)=\\sum_{d|n}\\mu(d)H(\\frac{n} {d})$，其中$H(n)$前缀和可以求 类似上面的，构造$G(n)=1$ $(F\\oplus G)(n)=\\sum_{d|n}H(d)\\sum_{k|\\frac{n} {d} }\\mu(k)=H(n)$ $\\displaystyle S_F(n)=S_{H}(n)-\\sum_2^nS_F(\\lfloor\\frac{n} {i}\\rfloor)$ \\例子3+3.5:$F(n)=\\varphi(n)\\cdot n^k$，求$S_F(n)$ 性质：$\\displaystyle \\sum_{d|n}\\varphi(d)=n$ 原理简要证明：满足$\\gcd(i,n)=\\frac{n} {d}$的$i$共有$\\varphi(d)$个，则累和就是枚举了所有$\\gcd(i,n)$进行统计 所以构造$G(n)=n^{k}$ $\\displaystyle (F\\oplus G)(n)=\\sum_{d|n}F(d)G(\\frac{n} {d})=\\sum_{d|n} \\varphi(d)d^k(\\frac{n} {d})^{k}=\\sum_{d|n} \\varphi(d) n^{k}=n^{k+1}$ 同样的只需要求出 $\\displaystyle S_{F\\oplus G}(n)=\\sum_{i=1}^n i^{k+1}$ $\\displaystyle S_G(n)=\\sum_{i=1}^n i^k$","categories":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}]},{"title":"「HAOI2018」字串覆盖","slug":"「HAOI2018」字串覆盖","date":"2021-04-07T06:09:26.000Z","updated":"2021-05-22T03:54:11.191Z","comments":true,"path":"articles/2021/04/07/33c832ae.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/04/07/33c832ae.html","excerpt":"","text":"「HAOI2018」字串覆盖这自然有后缀数组和后缀自动的写法，我写的是后缀数组 现对于$A,B$两串拼接后建立$\\text{SA}$ 对于查询的四个参数$[s,t,l,r]$，在$\\text{SA}$上找到能够匹配$[l,r]$的$\\text{rank}$区间$[l’,r’]$ 这个$[l’,r’]$就用$\\text{SA}$的$\\text{height}$数组上倍增即可$O(\\log n)$找到 由于$K&gt;n$，显然覆盖就是从左到右依次匹配每个$\\text{rank}$在$[l’,r’]$中的$i$，能放就放 数据范围提示我们切分写 Part1 $r-l\\leq 50$对于每种不同的$r-l$，倍增预处理 我们将依次匹配的过程描述成一个个跳跃 对于每个$i$找到后面第一个$j$满足$j&gt;i+r-l,\\text{LCP}(i,j)\\ge r-l+1$ 具体的，将$\\text{SA}$的$\\text{height}$数组按照$\\text{height}_p\\ge r-l+1$分成一段一段 每个连续段中的两个位置$\\text{LCP}\\ge r-l+1$ 合法的$i,j$一定出现的某个连续段中 找到每一个这样一个连续段，然后双指针得到合法的$i,j$即可 \\这样的跳跃关系，以及跳跃过程中的答案，可以通过倍增来维护出来 对于每个询问，可以先找到区间内第一个合法的点$i_0$，然后倍增查询答案即可 找到$i_0$可以用主席树二分出$\\text{rank}$在$[l’,r’]$内的第一个$i_0\\ge s$的位置 复杂度为$O(50n\\log n+q\\log n)$ \\Part2 $r-l&gt;50$根据数据范围，这里我们只要能够暴力跳每一个合法的$i$即可 那么像上面一样，用主席树每次找$[l’,r’]$内第一个$i’&gt; i+r-l$ 每次$\\log n$跳即可，复杂度为$O(\\frac{nq} {r-l}\\log n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=2e5+10,M=N*18,S=60;int n,K,q;char s[N];int cnt[N],rk[N&lt;&lt;1],tmp[N],sa[N];int st[19][N],Log[N];void Build() &#123; rep(i,1,n) cnt[(int)s[i]]++; rep(i,1,200) cnt[i]+=cnt[i-1]; drep(i,n,1) sa[cnt[(int)s[i]]--]=i; rep(i,1,n) rk[sa[i]]=rk[sa[i-1]]+(s[sa[i]]!=s[sa[i-1]]); for(int m=rk[sa[n]],k=1;k&lt;n &amp;&amp; m&lt;n;k&lt;&lt;=1,m=rk[sa[n]]) &#123; int h=0; rep(i,n-k+1,n) tmp[++h]=i; rep(i,1,n) if(sa[i]&gt;k) tmp[++h]=sa[i]-k; memset(cnt,0,(m+1)&lt;&lt;2); rep(i,1,n) cnt[rk[i]]++; partial_sum(cnt+1,cnt+m+1,cnt+1); drep(i,n,1) sa[cnt[rk[tmp[i]]]--]=tmp[i]; rep(i,1,n) tmp[sa[i]]=tmp[sa[i-1]]+(rk[sa[i]]!=rk[sa[i-1]] || rk[sa[i]+k]!=rk[sa[i-1]+k]); memcpy(rk,tmp,(n+1)&lt;&lt;2); &#125; rep(i,2,n) Log[i]=Log[i&gt;&gt;1]+1; int h=0; rep(i,1,n) &#123; int j=sa[rk[i]-1]; if(h) h--; while(s[i+h]==s[j+h]) h++; st[0][rk[i]-1]=h; &#125; rep(i,1,Log[n]) &#123; int len=1&lt;&lt;(i-1); rep(j,1,n-len+1) st[i][j]=min(st[i-1][j],st[i-1][j+len]); &#125;&#125;int ls[M],rs[M],c[M],rt[N],tcnt;void Upd(int &amp;p,int pre,int l,int r,int x)&#123; c[p=++tcnt]=c[pre]+1,ls[p]=ls[pre],rs[p]=rs[pre]; if(l==r) return; int mid=(l+r)&gt;&gt;1; x&lt;=mid?Upd(ls[p],ls[pre],l,mid,x):Upd(rs[p],rs[pre],mid+1,r,x);&#125;int Que(int p1,int p2,int l,int r,int x)&#123; if(c[p1]==c[p2] || r&lt;x) return n+1; if(l==r) return l; int mid=(l+r)&gt;&gt;1,t=Que(ls[p1],ls[p2],l,mid,x); return t&lt;=n?t:Que(rs[p1],rs[p2],mid+1,r,x);&#125;vector &lt;int&gt; G[S];int A[N],B[N],L[N],R[N],X[N];ll ans[N];ll H[20][N]; int F[20][N];int D[N],C;int main()&#123; n=rd(),K=rd(); scanf(&quot;%s&quot;,s+1),scanf(&quot;%s&quot;,s+n+1); n*=2,Build(),n/=2; rep(i,1,n*2) &#123; rt[i]=rt[i-1]; if(sa[i]&lt;=n) Upd(rt[i],rt[i],1,n,sa[i]); &#125; rep(i,1,q=rd()) &#123; A[i]=rd(),B[i]=rd(); int l=rd(),x=rd()-l+1,r=l=rk[l+n]; drep(j,18,0) &#123; if(r+(1&lt;&lt;j)&lt;=n*2 &amp;&amp; st[j][r]&gt;=x) r+=1&lt;&lt;j; if(l&gt;(1&lt;&lt;j) &amp;&amp; st[j][l-(1&lt;&lt;j)]&gt;=x) l-=1&lt;&lt;j; &#125; L[i]=l,R[i]=r,X[i]=x; if(n&lt;=5000 &amp;&amp; q&lt;=5000) &#123; int p=A[i],e=B[i]-x+1; while(p&lt;=e) &#123; while(p&lt;=e &amp;&amp; (rk[p]&lt;l || rk[p]&gt;r)) p++; if(p&gt;e) break; ans[i]+=K-p,p+=x; &#125; &#125; else if(X[i]&gt;=S) &#123; int p=A[i],e=B[i]-x+1; while(p&lt;=e) &#123; int c=0; while(++c&lt;5 &amp;&amp; p&lt;=e &amp;&amp; (rk[p]&lt;l || rk[p]&gt;r)) p++; if(p&gt;e) break; if(rk[p]&lt;l || rk[p]&gt;r) p=Que(rt[l-1],rt[r],1,n,p); if(p&gt;e) break; ans[i]+=K-p,p+=x; &#125; &#125; else G[X[i]].pb(i); &#125; rep(x,1,S-1) if(G[x].size()) &#123; rep(i,1,n) F[0][i]=n+1; rep(i,0,17) F[i][n+1]=n+1; rep(i,1,n*2) &#123; int j=i; while(j&lt;n*2 &amp;&amp; st[0][j]&gt;=x) j++; C=0; rep(k,i,j) if(sa[k]&lt;=n) D[++C]=sa[k]; if(C) &#123; sort(D+1,D+C+1); int j=1; rep(i,1,C) &#123; while(j&lt;=C &amp;&amp; D[j]-D[i]&lt;x) j++; if(j&lt;=C) F[0][D[i]]=D[j]; &#125; &#125; i=j; &#125; rep(i,1,n) H[0][i]=K-i; rep(j,1,17) rep(i,1,n) &#123; F[j][i]=F[j-1][F[j-1][i]]; H[j][i]=H[j-1][i]+H[j-1][F[j-1][i]]; &#125; rep(d,0,G[x].size()-1) &#123; int i=G[x][d],e=B[i]-x+1; int p=Que(rt[L[i]-1],rt[R[i]],1,n,A[i]); if(p&gt;e) continue; drep(j,17,0) if(F[j][p]&lt;=e) &#123; ans[i]+=H[j][p]; p=F[j][p]; &#125; ans[i]+=H[0][p]; &#125; &#125; rep(i,1,q) printf(&quot;%lld\\n&quot;,ans[i]);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"拟阵","slug":"拟阵","date":"2021-04-06T11:00:34.000Z","updated":"2021-05-22T03:54:11.366Z","comments":true,"path":"articles/2021/04/06/f66a8573.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/04/06/f66a8573.html","excerpt":"","text":"拟阵(latest updated on 2020-08-10) 大量基础定义警告，参考了wiki和2018论文《浅谈拟阵的一些拓展及其应用》，如果想看大段详细证明请移步论文 拟阵的概念比较抽象，有多种定义方法，结合这些定义方法可以更具体地了解拟阵的基础性质 前言很多问题可以转化为拟阵，但是并不是所有问题都可以通过简单的拟阵操作得到答案 在具体问题中，很多时候有着更优的算法解决拟阵运算无法解决的操作 但是对于一个奇怪的问题，如果转化为类似拟阵的操作后，就有很多性质可以拿过来套 拟阵的应用，更多还是用 诸多的性质 把复杂,抽象问题向更简单的方向转化(便于乱搞) 也可以便于简化问题的证明，所以这个东西了解一下也差不多了 (不会有人丧心病狂到专门出一个拟阵交的题吧) \\符号及约定$|S|$集合大小 $S-T$，删除$S$中在$T$中的元素 $a\\Rightarrow b$若$a$则$b$ $a\\Leftrightarrow b$，$a,b$等价 $a\\in b$元素$a$是集合$b$中的一个元素 $a\\sube b$，集合$a$是集合$b$的子集 $\\exists$ 存在 $\\forall$ 任意 幂集一个集合$S$的所有$2^{|S|}$个子集构成的集合是$S$的幂即$P(S)$或者$2^S$ 集族给定集合$S$ 的一些子集构成的类$F$叫做$S$的子集族（或称S 上的集合族）,$F \\sube 2^S$ \\用独立集定义拟阵(似乎是最直观的定义) 一个二元组$M=(E,I)$，其中$E$是基础集，$I$是$E$的一些子集构成的集族(即$I\\sube 2^S$)，称之为独立集，在独立集中的子集称之为独立的 拟阵可以用独立集$I$定义，则$I$需满足性质: 1.空集：有$\\emptyset \\in I$，所以有$I\\ne \\emptyset$ 2.遗传性：若$A\\sube B,B\\in I$，则$ A\\in I$ 3.扩充性：若$\\exists A,B\\in I,|A|&gt;|B|$，则$\\exists i\\in A,(B\\cup \\{i\\}) \\in I$ 例子：对于$S=\\{1,2,3\\}$，$\\{\\emptyset \\},\\{\\emptyset,\\{1\\} \\}$是合法的独立集，但$\\{\\emptyset,\\{1\\},\\{2\\},\\{3\\},\\{2,3\\} \\}$不是，因为它不满足扩充性 $\\{ \\{1,2\\},\\{2,3\\},\\{1\\},\\{2\\},\\{3\\},\\{\\emptyset \\} \\}$也是合法的独立集 对于$S=\\{1,2,3,4,5\\}$,$I=\\{ \\{1,2,3\\},\\{3,4,5\\},\\{1,2\\},\\{2,3\\},\\{1,3\\},\\{3,4\\},\\{3,5\\},\\{4,5\\},\\{1\\},\\{2\\},\\{3\\},\\{5\\},\\{\\emptyset\\} \\}$不是合法的独立集，因为它不满足扩充性($A=\\{1,2,3\\},B=\\{3,4\\}$时) \\用基底和基定义拟阵(似乎是最简洁的描述)基底:$E$的一个独立的极大子集称为其的一个基底，独立的极大子集即其加入任意元素得到的子集不独立 基:$E$的基$B$为其所有基底构成的集合 拟阵可以用基$B$定义，则$B$需满足性质: 1.非空：$B\\ne \\emptyset$，最小的$B=\\{\\emptyset\\}$ 2.交换公理：对于两个基底$a,b$，若用$b$中$a$没有的元素换掉一个$a$中原先的元素，得到的集合依然是基底 推论：基底等大，即$\\forall a\\in B,b\\in B,|a|=|b|$(否则就不满足扩充性) 例如：若$\\{1,2\\},\\{1,3\\}$是基底，则$\\{2,3\\}$也是基底(否则不满足扩充性) 可以得到拟阵的等价定义，且$I=\\bigcup _{T\\in B} 2^T$ \\用环路集定义拟阵环路:$S$的一个子集是环路，则这个子集是一个极小的非独立集，即去掉任意一个元素都会称为独立集 所有环路构成的集合称为环路集$C$，如对于$E=\\{1,2\\},I=\\{\\emptyset,\\{1\\} \\}$，环路集为$\\{ \\{2\\} \\}$ 拟阵可以用环路集$C$定义，则$C$需满足性质： 1.$C$可以为空(此时$I=P(S)$)，且$\\emptyset \\not \\in C$ 2.环路互相之间不是真子集，即$\\exists a\\in C,b\\in C,a\\sube b\\Rightarrow a=b$ (否则不满足遗传性) 3.若$\\exists a\\in C,b\\in C,a\\ne b$以及一个元素$i\\in a\\cap b$，则$a\\cup b-\\{i\\}$不是独立集 推论：$A\\sube I \\Leftrightarrow \\nexists B\\in C,B\\sube A$ 环路不一定等大 \\环路和基底的一些关系1.环路和基底之间不能通过加减一个元素转化 2.基底加上一个元素得到的非独立集恰好包含一个环路 \\拟阵的秩拟阵的秩：拟阵的任意一个基底的元素个数是其秩$r$ 为了同下文的秩函数相对应，也可说$\\begin{aligned}r=\\max_{R\\in I} \\{|R|\\}\\end{aligned}$，即最大的独立集大小 \\用秩函数定义拟阵对于元素集$S$ 若可以定义一个在$2^S$上的秩函数$r(T)$，满足以下性质: 1.大小有界:$r(T)\\in[0,|T|]$ 2.大小传递性:$A\\sube B\\Rightarrow r(A)\\le r(B)$ 3.次模性:$r(A\\cup B)+r(A\\cap B)\\le r(A)+r(B)$ 那么可以用这样的一个秩函数定义一个拟阵$M=(S,r)$，此时$r(T)$为$2^T$中极大的独立集大小，且拟阵的独立集就是$I=\\{T|T\\sube S,r(T)=|T|\\}$ \\例子均匀拟阵：$U_n^k=(S,I),|S|=n,I=\\{T|T\\sube S,|T|\\leq k\\}$ 图拟阵： 对于无向图$G=(V,E)$，它的生成拟阵是$M=(E,\\{T|T\\sube E,T无环\\})$ 它的最大独立子集大小为$G$的最大生成森林边数，每个最大生成森林都是基底 匹配拟阵： 对于无向图$G=(V,E)$，它的匹配拟阵是$M=(V,\\{T|T\\sube V,存在一个边匹配覆盖T\\})$ 它的最大的独立子集大小为k最大匹配数，每个最优匹配的方案都是基底 异或线性基： 对于非负整数可重集合$S$，拟阵是$M=(S,\\{T|T\\sube S,T中的元素任意异或不会得到0\\})$ (这是向量空间的线性基问题的一种) \\\\ 注意分清楚 定义需要满足的条件 和 通过条件推导得到的性质 的区别 ，上面几种拟阵定义是等价的 \\\\一些应用求最大权值独立子集对于拟阵$M=(S,I)$，给每个$S$中每个元素一个非负权值，定义一个集合的权值为所有元素权值和，要求最大权值的独立子集 这是一个非常简单的问题，直接从大到小能加入就加入即可，设最终选出的集合为$P$ 证明: 1.$P\\in B$，否则可以再加入元素 2.假设存在更优解$Q\\in B$，根据基底交换公理，一定可以用$P$中一个权值更大的元素换掉$Q$中一个元素，所以$Q$不是合法集合 在连通图拟阵上使用该算法，就是$\\text{Kruskal}$最小生成数算法 在异或线性基上使用该算法，可以求得最大权值线性基 \\拟阵交对于同基础集的拟阵$M_1=(S,I_1),M_2=(S,I_2)$，它们的交是独立集的交 但是它们的交不一定是拟阵 求解最大交:最小最大定理: $\\begin{aligned} \\max_{A\\in (I_1\\cup I_2)} \\{|T|\\}=\\min_{R\\in S} \\{r_1(R)+r_2(S-R)\\}\\end{aligned}$ 这个东西的证明分为两步: 1.证明$\\max\\leq \\min$ $|T|=|T\\cap R|+|T\\cap (S-R)|\\leq r_1(R)+r_2(S-R)$ 2.介绍找到两个最值的算法 这个算法的中心是，从空集开始扩展$T$，并且相应找到对应的$R$使得$|T|=r_1(R)+r_2(S-R)$，此时答案已经充分了 求解拟阵交的算法基于一个构造的图 对于当前的答案$T$，构造一个有向二分图，两侧点集分别为$T,S-T$ 对于分别在两侧的点$x,y$， 存在$x\\rightarrow y$的边: 当$T$中把$x$换成$y$之后是$M_1$的独立子集 存在$y\\rightarrow x$的边: 当$T$中把$y$换成$x$之后是$M_2$的独立子集 设对于$I_1,I_2$可行的增广元素集合为$X_1,X_2 $(即加入元素后依然独立的集合) 每次的增广过程可以描述为: (1.如果$X_1\\cap X_2\\ne \\emptyset$，直接都加入$T$) 2.构图，找到一条从$X_1$的点出发，到达$X_2$的的最短的路径$P$(广搜即可)，将$I$变为$I\\bigoplus P$ (这里原文是对称差，但是异或大家都懂哈) 当不存在增广时，找到了最大的$T$，此时对应合法的$R$为$\\{e\\in S|在图中存在e到达X_2的路径\\}$ 由于每次增广至少增加一个元素，该算法的复杂度上限为$O(r|S|^2)$，其中$r$为拟阵的秩，$|S|^2$为边数 \\带权拟阵交每个元素带权 在增广时，图上每个点加上点权(加入为正，删除为负)，每次求出点权最短路进行增广即可 \\拟阵交的应用二分图匹配问题二分图匹配匈牙利算法 是 求解拟阵交的问题 的一种特殊情况 对于二分图$G=(V_1,V_2,E)$，构造 $M_1=(E,I=\\{T\\sube E|T中的边在V_1上没有公共点\\})$ $M_2=(E,I=\\{T\\sube E|T中的边在V_2上没有公共点\\})$ 答案就是$M_1,M_2$交的最大值，匈牙利算法增广的过程是依次考虑$X_1$中的元素进行增广 (带权的二分图匹配问题，实际也是可以用拟阵解决的，但是好像$\\text{KM}$还是最棒的) \\拟阵交还可以解决一些看起来很抽象的 带有两个限制的 (可能带权) 的问题，比如论文里下面的这个例子 (Colorful Tree): 对于一个无向图，每条边给定一个颜色和一个权值，求颜色不能重复的最大生成树 类似这样的问题可以转化为拟阵交问题，但是这个东西的局限性实在太大，也没有人敢动 \\update: 有生之年竟然用上了这个东西？ **模拟赛有人搞了一个题: 对于一个无向图$G=(V,E),E=(u,v,w)$，其中$w$为每条边的颜色 要求选出一个最大的边集，满足： 1.每种颜色$i$选出的边不超过$c_i$条 2.选出的边不构成简单环 然后写了一次不太正规的拟阵交模板 令$M1$为个数的拟阵，$M2$为生成树拟阵 解释在代码里 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394int n,m,k;int A[N],I[N];// A为颜色个数的限制int U[N],V[N],W[N],F[N];// U,V,W为边// F 为并查集int Find(int x)&#123; return F[x]==x?x:F[x]=Find(F[x]); &#125;int X[N],Y[N],P[N];// 处理生成树的情况vector &lt;int&gt; G[N];int fa[N],fe[N],dep[N];void dfs(int u,int f)&#123; dep[u]=dep[fa[u]=f]+1; for(int i:G[u]) &#123; int v=U[i]==u?V[i]:U[i]; if(v==f) continue; fe[v]=i,dfs(v,u); &#125;&#125;int main()&#123; freopen(&quot;forget.in&quot;,&quot;r&quot;,stdin),freopen(&quot;forget.out&quot;,&quot;w&quot;,stdout); n=rd(),m=rd(),k=rd(); rep(i,1,k) A[i]=rd(); rep(i,1,m) U[i]=rd(),V[i]=rd(),W[i]=rd(); rep(i,1,n) F[i]=i; while(1) &#123; int f=0; // X, Y分别为 M1,M2的可拓展集合 // I 记录已经在选边方案里的边 rep(i,1,m) if(!I[i]) &#123; X[i]=A[W[i]]&gt;0,Y[i]=Find(U[i])!=Find(V[i]); // 如果X,Y有交，就直接加入集合 if(X[i] &amp;&amp; Y[i]) &#123; A[W[i]]--,F[Find(U[i])]=Find(V[i]); I[i]=1,f=i; &#125; &#125; else X[i]=Y[i]=0; if(f) continue; static queue &lt;int&gt; que; while(!que.empty()) que.pop(); // 预处理当前的生成树，便于处理M2的限制 rep(i,1,n) G[i].clear(); rep(i,1,m) if(I[i]) G[U[i]].pb(i),G[V[i]].pb(i); rep(i,1,n) dep[i]=0; rep(i,1,n) if(!dep[i]) dfs(i,0); // 从X中的某一个点出发 rep(i,1,m) if(X[i]) que.push(i),P[i]=-1; else P[i]=0; f=0; // 广搜找交替 替换路径 while(!que.empty()) &#123; int u=que.front(); que.pop(); // 找到一条满足X-&gt;Y的交替路径 if(Y[u])&#123; f=u; break; &#125; if(I[u]) &#123; // u-&gt;v，交换之后满足M1 rep(v,1,m) if(!P[v] &amp;&amp; !I[v] &amp;&amp; A[W[v]]+(W[u]==W[v])) P[v]=u,que.push(v); &#125; else &#123; // 满足拟阵M2，即交换这条边之后还是生成树，可以从目前生成树上的环上选取能够替换的边 int x=U[u],y=V[u]; if(Find(x)!=Find(y)) &#123; rep(v,1,m) if(!P[v] &amp;&amp; I[v]) P[v]=u,que.push(v); &#125; else &#123; while(x!=y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); int i=fe[x]; if(!P[i]) P[i]=u,que.push(i); x=fa[x]; &#125; &#125; &#125; &#125; if(!f) break; // 放置交替方案 while(~f) &#123; A[W[f]]+=I[f]?1:-1; I[f]^=1,f=P[f]; &#125; int cnt=0; rep(i,1,m) if(I[i]) cnt++; // 重构并查集 rep(i,1,n) F[i]=i; rep(i,1,m) if(I[i]) F[Find(U[i])]=Find(V[i]); &#125; int cnt=0; rep(i,1,m) if(!I[i]) cnt++; printf(&quot;%d\\n&quot;,cnt); rep(i,1,m) if(!I[i]) printf(&quot;%d &quot;,i);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"幂前缀和的生成函数","slug":"幂前缀和的生成函数","date":"2021-04-06T08:37:10.000Z","updated":"2021-05-22T03:54:11.361Z","comments":true,"path":"articles/2021/04/06/b146e91f.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/04/06/b146e91f.html","excerpt":"","text":"幂前缀和的生成函数问题描述： 对于给定的大数$m$，求$\\displaystyle k\\in[1,n],F_k=\\sum _{i=1}^m i^k$ $F_k=\\sum _{i=1}^m i^k$，每一项的组合意义即：为$k$个元素每个染上$i$种颜色中的一个 下面是用斯特林数的推导带入第二类斯特林数的组合意义，得到 $\\displaystyle F_k=\\sum_{i=1}^m \\sum_{j=0}^{\\infty} \\binom{i} {j}\\begin{Bmatrix}k\\\\ j\\end{Bmatrix}j!$ 合并外层循环的组合数前缀和 $\\displaystyle F_k=\\sum_{i=0}^{\\infty} \\binom{m+1} {i+1}\\begin{Bmatrix}k\\\\ i\\end{Bmatrix}i!$ 我们知道第二类斯特林数的$\\text{EGF}$ $\\displaystyle S(x)=\\sum \\begin{Bmatrix}i\\\\m \\end{Bmatrix}\\frac{x^i} {i!}=\\frac{1} {m!}(e^x-1)^m$ 其意义是合并每一种颜色的元素的$\\text{EGF}$，要求每种颜色个数$\\ge 1$，同时颜色之间无序，最后除掉 带入$F_k$的式子，得到$F_k$的$\\text{EGF}$ $\\displaystyle F(x)=\\sum \\binom{m+1} {i+1}(e^x-1)^i$ 带入二项展开 $\\displaystyle F(x)=\\frac{e^{(m+1)x}-1} {e^x-1}$ 停停停 这个东西不是直接根据$[x^n]e^{ax}=\\cfrac{a^n} {n!}$ 就会发现是$\\displaystyle \\sum_{i=0}^m e^{ix}=\\frac{e^{(m+1)x}-1} {e^x-1}$吗 线性解法待补。。。","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"Luogu P7445「EZEC-7」线段树","slug":"Luogu P7445「EZEC-7」线段树","date":"2021-04-05T10:53:58.000Z","updated":"2021-05-22T03:54:10.974Z","comments":true,"path":"articles/2021/04/05/9e225749.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/04/05/9e225749.html","excerpt":"","text":"Luogu P7445「EZEC-7」线段树显然一个点是否被$\\text{push_down}$仅取决于所有完全包含它的操作区间权值之和 那么可以考虑对于每个节点计算概率，然后累加 反向计算一个节点不被$\\text{push_down}$的概率，即权值之和为$0$的概率 而每个节点有自己被覆盖的概率，即$p_i=\\cfrac{l\\cdot (n-r+1)} {n(n+1)/2}$ 而覆盖的次数$c$决定了这个概率贡献的权值，即$p_i^c(1-p_i)^{m-c}$ 由此得到一个思路： 先通过计算得到$k$次覆盖权值为0的函数$A(x)$ 容易发现这样得到每个点的概率为：$A(\\cfrac{p_i} {1-p_i})(1-p_i)^m$ Naive地带入多点求值，就能暴力得到 计算$k$次被覆盖权值和为0的方案数容易发现就是 $\\displaystyle x^0^k=x^0^k$ 暴力展开这个式子会需要对于$(x^{V+2}-1)^k$有用的项只有$\\frac{k} {V+2}$项 即原式$\\displaystyle =x^k^k=\\sum_{i=0}^{k}\\binom{2k-i-1} {k-1}x^i^k$ $\\displaystyle =\\sum_{i=0}^{\\frac{k} {V+2} } \\binom{2k-i(V+2)-1)} {k-1} (-1)^i \\binom{k} {i}$ (第一个组合数是组合意义插板，第二个是二项展开) 求$k$的权值需要$O(\\frac{k} {V})$，并不好直接卷积优化 由于涉及了类似$[x^n]G^k(x)$的形式，考虑用 “另类拉格朗日反演” 求解 如果想参考一下，但是EI的课件我是真的看不懂 处理一下$x$的负指数，设$\\displaystyle F(x)=\\sum _{i=0}^{V+1}x^i$，转化为$x^0} {x})^k$ 然而不管是$F(x)$还是$\\frac{F(x)} {x}$都不存在复合逆，但是$\\frac{x} {F(x)}$有 设$G(x)$为$\\frac{x} {F(x)}$的复合逆 $\\displaystyle x^0} {x})^k=x^0})^{-k}=[x^{k}]\\frac{xG’(x)} {G(x)}$ 求解$G(x)$即可得到所有$k$的值 $G(x)$为$\\cfrac{x} {F(x)}=\\cfrac{x (x-1)} {x^{V+2}-1}$的复合逆 即满足$\\cfrac{G(G-1)} {G^{V+2}-1}=x$ $xG^{V+2}-G^2+G-x=0$ 这个形式还是比较易于进行牛顿迭代的 $f(z)=xz^{V+2}-z^2+z-x$ $f’(z)=(V+2)xz^{V+1}-2z+1$ $\\displaystyle A=B-\\frac{f(B)} {f’(B)}=B-\\frac{xB^{V+2}-B^2+B-x} {(V+2)xB^{V+1}-2B+1}$ 边界条件为$[x^0]G(x)=0$，$[x^1]G(x)=1$ 结果牛顿迭代需要多项式快速幂 有关多点求值的优化由于我们并不需要知道每个点被操作的概率，只需要一个求和，因此可以对于每一项求出 设$a_i=\\cfrac{p_i} {1-p_i},b_i=(1-p_i)^m$，容易发现实际上求出的式子是 $A(\\cfrac{p_i} {1-p_i})(1-p_i)^m=\\sum A_j\\sum_i a_i^j b_i$ 对于每个$j$求解，就是 $\\displaystyle [x^j]\\sum _i \\frac{b_i} {1-a_ix}$ 可以分治$\\text{NTT}$通分，也就是写成下式 $\\displaystyle \\frac{1} {\\prod (1-a_ix)} \\sum b_i \\prod_{i!=j} (1-a_jx)$ 右边就是一个经典的分治$\\text{NTT}$问题，再加上一次求逆即可 好像也不一定快吧 接下来就是套板板时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208const int N=1&lt;&lt;19,P=998244353;int n,m,k;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;typedef vector &lt;int&gt; V;int rev[N],w[N];int Inv[N+1],I[N+1],J[N+1];void Init_w() &#123; int N=1; while(N&lt;=max(n,m+1)*2+4) N&lt;&lt;=1; int t=qpow(3,(P-1)/N); w[N/2]=1; rep(i,N/2+1,N-1) w[i]=1ll*w[i-1]*t%P; drep(i,N/2-1,1) w[i]=w[i&lt;&lt;1]; Inv[0]=Inv[1]=1; rep(i,2,N) Inv[i]=1ll*(P-P/i)*Inv[P%i]%P; rep(i,*I=*J=1,N) &#123; I[i]=1ll*I[i-1]*Inv[i]%P; J[i]=1ll*J[i-1]*i%P; &#125;&#125;int Init(int n)&#123; int R=1,c=-1; while(R&lt;=n) R&lt;&lt;=1,c++; rep(i,1,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;c); return R;&#125;/*被隐藏的部分:!!NTToperator *operator +operator -*/V operator ~ (V a) &#123; int n=a.size(); if(n==1) return V&#123;(int)qpow(a[0],P-2)&#125;; V b=a; b.resize((n+1)/2); b=~b; int R=Init(n*2); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=(2-1ll*a[i]*b[i]%P+P)*b[i]%P; NTT(R,a,-1),a.resize(n); return a;&#125;void Exp_Solve(V &amp;A,V &amp;B,int l,int r)&#123; static int X[N],Y[N]; if(l==r) &#123; B[l]=1ll*B[l]*Inv[l]%P; return; &#125; int mid=(l+r)&gt;&gt;1; Exp_Solve(A,B,l,mid); int R=Init(r-l+2); rep(i,0,R) X[i]=Y[i]=0; rep(i,l,mid) X[i-l]=B[i]; rep(i,0,r-l-1) Y[i+1]=A[i]; NTT(R,X,1),NTT(R,Y,1); rep(i,0,R-1) X[i]=1ll*X[i]*Y[i]%P; NTT(R,X,-1); rep(i,mid+1,r) B[i]+=X[i-l],Mod1(B[i]); Exp_Solve(A,B,mid+1,r);&#125;V Deri(V a)&#123; rep(i,1,a.size()-1) a[i-1]=1ll*i*a[i]%P; a.pop_back(); return a;&#125;V Integ(V a) &#123; a.pb(0); drep(i,a.size()-1,1) a[i]=1ll*a[i-1]*Inv[i]%P; return a[0]=0,a;&#125;V operator &lt;&lt; (V A,const int &amp;x)&#123; A.resize(A.size()+x); drep(i,A.size()-1,x) A[i]=A[i-x]; rep(i,0,x-1) A[i]=0; return A;&#125;V operator &gt;&gt; (V A,const int &amp;x)&#123; rep(i,x,A.size()-1) A[i-x]=A[i]; A.resize(A.size()-x); return A;&#125;V Ln(V a)&#123; int n=a.size(); a=Deri(a)*~a,a.resize(n-1); return Integ(a);&#125;V Exp(V F)&#123; int n=F.size(); F=Deri(F); V A(n); A[0]=1; Exp_Solve(F,A,0,n-1); return A;&#125;V Pow(V x,int k) &#123; int d=0,n=x.size(); while(d&lt;n &amp;&amp; !x[d]) d++; if(1ll*d*k&gt;=n)&#123; rep(i,0,x.size()-1) x[i]=0; return x; &#125; x=x&gt;&gt;d,x.resize(n),x=Ln(x); rep(i,0,n-1) x[i]=1ll*x[i]*k%P; x=Exp(x)&lt;&lt;(d*k),x.resize(n); return x;&#125;V Evaluate(V F,V X)&#123; static int ls[N&lt;&lt;1],rs[N&lt;&lt;1],cnt; static V T[N&lt;&lt;1]; static auto TMul=[&amp;] (V F,V G)&#123; int n=F.size(),m=G.size(); reverse(G.begin(),G.end()); int R=Init(n); NTT(R,F,1),NTT(R,G,1); rep(i,0,R-1) F[i]=1ll*F[i]*G[i]%P; NTT(R,F,-1); V T(n-m+1); rep(i,0,n-m) T[i]=F[i+m-1]; return T; &#125;; static function &lt;int(int,int)&gt; Build=[&amp;](int l,int r) &#123; int u=++cnt; ls[u]=rs[u]=0; if(l==r) &#123; T[u]=V&#123;1,P-X[l]&#125;; return u; &#125; int mid=(l+r)&gt;&gt;1; ls[u]=Build(l,mid),rs[u]=Build(mid+1,r); T[u]=T[ls[u]]*T[rs[u]]; return u; &#125;; int n=F.size(),m=X.size(); cmax(n,m),F.resize(n),X.resize(n); cnt=0,Build(0,n-1); F.resize(n*2+1),T[1]=TMul(F,~T[1]); int p=0; rep(i,1,cnt) if(ls[i]) &#123; swap(T[ls[i]],T[rs[i]]); int R=Init(T[i].size()),n=T[i].size(),m1=T[ls[i]].size(),m2=T[rs[i]].size(); NTT(R,T[i],1); reverse(T[ls[i]].begin(),T[ls[i]].end()); reverse(T[rs[i]].begin(),T[rs[i]].end()); NTT(R,T[ls[i]],1); NTT(R,T[rs[i]],1); rep(j,0,R-1) &#123; T[ls[i]][j]=1ll*T[ls[i]][j]*T[i][j]%P; T[rs[i]][j]=1ll*T[rs[i]][j]*T[i][j]%P; &#125; NTT(R,T[ls[i]],-1); NTT(R,T[rs[i]],-1); rep(j,0,n-m1) T[ls[i]][j]=T[ls[i]][j+m1-1]; T[ls[i]].resize(n-m1+1); rep(j,0,n-m2) T[rs[i]][j]=T[rs[i]][j+m2-1]; T[rs[i]].resize(n-m2+1); &#125; else X[p++]=T[i][0]; X.resize(m); return X;&#125;V operator * (V A,const int &amp;x)&#123; rep(i,0,A.size()-1) A[i]=1ll*A[i]*x%P; return A;&#125;V Newton(int n)&#123; if(n==1) return V&#123;0,1&#125;; V G=Newton((n+1)/2); G.resize(n); V T=Pow(G,k+1); V A=((G*T)&lt;&lt;1)-G*G+G-V&#123;0,1&#125;,B=(T&lt;&lt;1)*(k+2)-G*2+V&#123;1&#125;; A.resize(n+1),B.resize(n+1),A=A*~B,A.resize(n+1); return G-A;&#125;V X,Y;void Build(int l,int r)&#123; if(l==r) return; int prob=1ll*l*(n-r+1)%P*Inv[n]%P*Inv[n+1]%P*2%P; Y.pb(P+1-prob); X.pb(prob*qpow(P+1-prob)%P); int mid=(l+r)&gt;&gt;1; Build(l,mid),Build(mid+1,r);&#125;int main()&#123; n=rd(),m=rd(),k=rd(),Init_w(); V F=Newton(m+1); F=Deri(F)*~(F&gt;&gt;1),F.resize(m+1); int t=1,inv=qpow(k+2); rep(i,0,m) &#123; F[i]=1ll*F[i]*t%P*J[m]%P*I[i]%P*I[m-i]%P; t=1ll*t*inv%P; &#125; Build(1,n); X=Evaluate(F,X); int ans=0; rep(i,0,X.size()-1) ans=(ans+P+1-X[i]*qpow(Y[i],m))%P; Mod2(ans),printf(&quot;%d\\n&quot;,ans);&#125; $\\displaystyle F(x,z)=\\frac{1} {\\displaystyle 1-z\\sum_{i=-1}^{V} x^i}$ 我们希望知道$[x^0]F(x,z)$，然后根据$[z^k]$就能得到$k$次操作权值和为$0$的方案数 考虑拉格朗日反演解二元函数 设$\\displaystyle G(z)=z \\sum_{i=-1}^V x^i$，转化为求$\\displaystyle [z^1]\\frac{z} {1-G(z)}$ 设$H(z)$为$G(z)$的复合逆，带入扩展拉格朗日反演 $\\displaystyle [z^1]\\frac{z} {1-G(z)}=[z^0]\\frac{1} {(1-z)^2}\\frac{z} {H(z)}$ $H(z)$满足$=z$","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"拉格朗日反演 (Lagrange Inversion) ","slug":"拉格朗日反演 (Lagrange Inversion) ","date":"2021-04-04T13:47:31.000Z","updated":"2021-05-22T03:54:11.364Z","comments":true,"path":"articles/2021/04/04/19870f1a.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/04/04/19870f1a.html","excerpt":"","text":"拉格朗日反演 (Lagrange Inversion)复合逆对于$F(G(x))=x (\\Leftrightarrow G(F(x))=x)$，则称$F(x)$与$G(x)$互为复合逆，下文中记为$\\hat F(x)$ 存在复合逆的条件为$[x^0]F(x)=0,[x^1]F(x)\\ne 0$ \\拉格朗日反演对于$G(x)=\\hat F(x)$得到关于$F(x)$的拉格朗日反演表达式 $\\displaystyle [x^n]G(x)=\\frac{1} {n}x^{-1}})^n$ 由于$[x^0]F(x)=0$无法求逆，所以上式更通用的形式是 $\\displaystyle [x^n]G(x)=\\frac{1} {n}x^{n-1}})^n$ \\求解复合逆对于给定的$F(x)$，求其复合逆$G(x)=\\hat F(x)$ 带入拉格朗日反演的式子 $\\displaystyle G(x)=\\sum \\frac{1} {i}x^{i-1}})^i x^i$ 求这个式子的核心是 分块+暴力 $i=a\\cdot S+b,S=\\sqrt n$，对于每个$a,b$卷积求出$\\displaystyle (\\frac{x} {F(x)})^{Sa},(\\frac{x} {F(x)})^b$ 然后直接对于每个位置把两个式子暴力$O(n)$合并即可 两部分复杂度总和为$O(n\\sqrt n\\log n+n^2)$ \\扩展拉格朗日反演对于$G(x)=\\hat F(x)$，有$\\displaystyle [x^n]H(G(x))=\\frac{1} {n}[x^{n-1}]H’(x) (\\frac{x} {F(x)})^n$ 特殊情况例如 $\\displaystyle [x^n]G^k(x)=\\frac{k} {n}u^{n-k}})^n=\\frac{k} {n}[u^{-k}]F(u)^{-n}$ 也就是$\\displaystyle n[x^n]G^k(x)=k[x^{-k}]F(x)^{-n}$ \\\\该式子也可以用于处理$F(G(x))=H(x)$的情况 此时，有$\\hat H(F(G(x)))=x$ $G(x)=\\widehat {\\hat G(F(x))}=H(\\hat F(x))$ 带入得到$\\displaystyle [x^n]G(x)=[x^n]H(\\hat F(x))=\\frac{1} {n}[x^{n-1}]H’(x)(\\frac{x} {F(x)})^n$ 即$\\displaystyle [x^n]G(x)=\\frac{1} {n}[u^{n-1}]H’(u)(\\frac{u} {F(u)})^n$ \\另类拉格朗日反演依然设$G(x)=\\hat F(x)$，则 $\\displaystyle [x^n]G^k(x)=[x^{-k-1}]\\frac{F’(x)} {F^{n+1}(x)}$ 改一下是 $\\displaystyle [x^n]G^k(x)=[x^{n-k}] F’(x)(\\frac{x} {F(x)})^{n+1}$ 更一般的 $\\displaystyle [x^n]H(G(x))=[x^n]H(x)F’(x)(\\frac{x} {F(x)})^{n+1}$ 用途： 你会发现对于不同的$k$，$[x^n]G^k(x)$对应的系数居然来自同一个函数$\\displaystyle \\frac{F’(x)} {F^{n+1}(x)}$ 因此用于处理求多个$k$的问题 \\\\后记： 明明自己什么都不会还要写博客。。。","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「ZJOI2018」树","slug":"「ZJOI2018」树","date":"2021-03-30T06:05:56.000Z","updated":"2021-05-22T03:54:11.278Z","comments":true,"path":"articles/2021/03/30/b3364564.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/30/b3364564.html","excerpt":"","text":"「ZJOI2018」树前言置换同构计数真是令人头大，感觉依然不是特别懂 \\分析与初步构想 设按照题意生成的$n$个节点有标号有根树族为$\\mathcal{T}_n$，对于某种树形$T$的生成方案数为$c(T)$ 则答案显然是$\\cfrac{\\sum _{T\\in \\mathcal{T}_n} c^k(T)} {(n-1)!^k}$ $k$的量级意味着我们无法完成有关$c^k(T)$的展开，因此要在最开始的计算中就将$k$这个幂次加入 为此定义$F_{i,n}=\\sum _{T\\in \\mathcal{T}_n} c^{ik}(T)$ 则我们要计算的答案就是$\\cfrac{F_{1,n} } {(n-1)!^k}$ 容易发现有意义的$F_{i,j}$规模为$O(\\sum \\sum [ij\\leq n])=O(n\\ln n)$ 关于为什么$F_{i,n}$会有第一维，会在下面出现 ps: 我的两个维度好像和别人是反的 计算过程分析 考虑递推计算$F_{i,n}$ 容易发现对于任意一个$F_{i,n}$的计算只需要令$k\\rightarrow ik$ 为了简化描述，我们先以计算$F_{1,…}$为例 对于同构树计数，子树的叠加是无序的背包问题，树形之间存在着置换同构 而每棵子树的编号之间可以任意归并，因此需要$\\text{EGF}$的背包合并每棵子树 显然同构仅出现在同种大小的子树中，因此可以对于不同大小的子树分离 假设对于大小为$n$的子树，出现了$m$种不同的树形$T_1,T_2,\\ldots T_m$，每种出现了$a_i$个 则答案应该为$\\displaystyle \\sum_{T_i\\ne T_j} \\frac{1} {(n!)^m}\\prod \\frac{c^{a_ik}(T_i)} {(a_i!)^k}$ 其中$(a_i!)^k$除去同构树之间无排列序的方案数 普通的背包计数难以处理$T_i\\ne T_j$的限制 因此考虑用$\\text{Burnside}$引理解决置换同构问题 同构出现于$m$棵树之间，因此我们置换群为对于$m$的排列置换群 显然任意一个排列置换的的结果是若干个置换环，环上的树树形相同 则对于一个置换$f$，设其生成了大小分别为$b_1,b_2,\\ldots, b_m$的置换环 理想情况下其不动点的式子计算如下 $\\displaystyle \\text{fix}(f)=\\frac{(n\\sum b_i)!} {(n!)^{\\sum b_i} }\\cdot \\frac{F_{b_i,n} } {(b_i!)^k}$ （这就是为什么要给$F$添加第一维） 其中$\\cfrac{(n\\sum b_i)!} {(n!)^{\\sum b_i} }$处理了$\\sum b_i$棵树的点编号，实际上这两个权值可以在计算的最后加入，因此下面忽略掉 而实际上，在不动点中直接加入$\\cfrac{1} {(b_i!)^k}$是错的 原因在于让这样的 置换环权值 带入$\\text{Burnside}$引理之后 最终的 同构类权值 并不是我们想要的$\\cfrac{1} {(a_i!)^k}$ 考虑 待定求解 一个置换环系数的$\\text{EGF}$，设其为$A(x)$ 相较于上面的枚举$f$的式子，这里的计算中系数还需要考虑对于每种$b_i$，等价的置换$f$个数 这同样需要对于每棵子树的$\\text{EGF}$合并，系数为$\\cfrac{1} {b_i!}$ 而一个环上的点存在一个环排列$(b_i-1)!$，两者合并即$\\cfrac{1} {b_i}$ 注意这一部分并未被加入$A(x)$中 然而这也恰好使得$\\text{Burnside}$引理的系数$\\frac{1} {m!}$和置换元素的$\\text{EGF}$系数相抵消 不妨设添加环系数$\\text{EGF}$的变换为$\\hat A_i=\\cfrac{A_i} {i}$ 所以，则最终的计算中$\\text{Burnside}$引理的答案就是$\\text{exp}(\\hat A(x))$ 我们希望最终一个 合法的同构类 的权值为$\\cfrac{1} {(a_i!)^k}$ 而容易发现实际上 最终的同构类 是由我们初始枚举的置换环 的$\\text{exp}$ 因此$\\cfrac{1} {a_i!}$应当是置换环系数经过环元素$\\text{exp}$叠加的结果 设$B(x)=\\cfrac{x^i} {(i!)^k},C_i=\\cfrac{A_i} {F_{n,i} }$ 则$B(x)=\\text{exp}(\\hat C(x))$，对于$B(x)$取$\\ln$得到$\\hat C(x)$ 加入系数得到我们前面所待定的$A(x)$，即可进行最后的$\\text{exp}(\\hat A(x))$计算 ps: 你会发现可以直接忽略环$\\text{EGF}$变换，全程只有$\\hat C(x),\\hat A(x)$，在过渡中这个变换的系数直接消失了 在这里提到这个系数是为了避免不必要的误解，同时也强调其他时候使用$\\text{Burnside}$引理需要添加这个系数 算法实现简谈 倒序枚举$F_{i,j}$的$i$，正序枚举大小$j$，边界条件自然是$F_{i,1}=1$ 确定了一个$i$后，就可以预处理$\\ln$ 求出置换环系数，这里有$\\frac{n} {i}$个 按照每个$i$，上面式子中的$k\\rightarrow ik$ 按照$j$从小到大计算$F_{i,j}$，每次得到$F_{i,j}$之后 计算关于大小为$j$的树的背包系数，这里系数的个数为$l=\\frac{n} {ij}$ 将先前的系数补上$F_{d,j}$，再做$\\text{exp}$，最后把前面扔掉的$\\cfrac{1} {(n!)^{\\sum a_i} }$补上，( $(n\\sum a_i)!$直接作为后面$\\text{EGF}$合并的系数） 然后将它补进前面累和的背包里，就能得到这一项的值 注意前面算的式子都是计算儿子的，最后还要加上自己的大小1 当然，计算$\\text{exp},\\ln$需要下面的帮助 $\\text{exp}$的$O(n^2)$方法$F(x)=\\text{exp}(G(x))$ $F’(x)=\\text{exp}(G(x))G’(x)$ $F’(x)=F(x)G’(x)$ 先计算出$G’(x)$，然后$O(n^2)$依次得到$F’(x)$的第$i$项，就能知道$F(x)$的第$i+1$项 $\\ln$的$O(n^2)$方法$F(x)=\\ln G(x)$ $F’(x)G(x)=G’(x)$ 边界$[x^0]G(x)=1,[x^0]F(x)=0$ 暴力推$F’(x)$的每一项即可 进一步优化上面的计算时，每次求得一个$\\hat A(x)$，都做一次$\\text{exp}$，然后背包合并 但是实际上，我们可以先将$\\hat A(x)$放在一起，然后一起做$\\text{exp}$ 具体的，每次得到$F_{i,j}$之和，我们就可以确定$\\sum \\hat A(x)$的第$j$项 那么在维护$\\sum \\hat A(x)$的同时，也依次递推$\\text{exp}(\\sum \\hat A(x))$的$j$项 这样不仅去掉的背包的过程，也少了很多次$\\text{exp}$ Montegomery最后是喜闻乐见的套板子时间 \\复杂度分析 未优化相对于$\\text{exp}$，求$\\ln$的复杂度可以忽略 而$\\text{exp}$每次大小是$\\frac{n} {ij}$，即$O(\\sum \\sum \\cfrac{n^2} {i^2j^2})=O(n^2)$ 最后的复杂度反而在于背包合并$\\text{EGF}$，为$O(n^2\\ln n)$ 优化后同步求$\\text{exp}$的复杂度为$O((\\cfrac{n} {i})^2)=O(n^2)$ Code1: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int N=2010;int n,k,P;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int F[N][N],T[N],H[N],C[N];int I[N],J[N],Inv[N];void Exp(int *a,int n)&#123; static int b[N]; rep(i,1,n) b[i-1]=1ll*a[i]*i%P; rep(i,0,n) a[i]=0; a[0]=1; rep(i,0,n-1) &#123; int s=0; rep(j,0,i) s=(s+1ll*a[i-j]*b[j])%P; a[i+1]=1ll*s*Inv[i+1]%P; &#125;&#125;void Ln(int *a,int n)&#123; static int b[N]; rep(i,0,n) b[i]=a[i]; rep(i,0,n-1) &#123; int s=1ll*b[i+1]*(i+1)%P; rep(j,0,i-1) s=(s-1ll*a[j]*b[i-j])%P; Mod2(s),a[i]=s; &#125; drep(i,n,1) a[i]=1ll*a[i-1]*Inv[i]%P; a[0]=0;&#125;int IK[N],JK[N];int main()&#123; n=rd(),k=rd(),P=rd(); Inv[0]=Inv[1]=1; rep(i,2,n) Inv[i]=1ll*(P-P/i)*Inv[P%i]%P; rep(i,*I=*J=1,n) I[i]=1ll*I[i-1]*qpow(Inv[i],k)%P,J[i]=1ll*J[i-1]*qpow(i,k)%P; drep(i,n,1) &#123; int m=n/i; rep(j,*H=1,m) H[j]=0; rep(j,0,m) IK[j]=qpow(I[j],i),JK[j]=qpow(J[j],i); rep(j,*C=1,m) C[j]=IK[j]; Ln(C,m); rep(j,1,m) &#123; F[i][j]=1ll*H[j-1]*JK[j-1]%P; int u=m/j; T[0]=0; rep(x,1,u) T[x]=1ll*C[x]*F[i*x][j]%P; Exp(T,u); int t=1; rep(x,1,u) t=1ll*t*IK[j]%P,T[x]=1ll*T[x]*t%P; drep(x,m,1) rep(y,1,x/j) H[x]=(H[x]+1ll*H[x-y*j]*T[y])%P; &#125; &#125; int ans=1ll*F[1][n]*I[n-1]%P; printf(&quot;%d\\n&quot;,ans);&#125; Code2: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;using namespace std;typedef long long ll;#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)enum&#123;N=2010&#125;;int n,k,P;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int H[N],F[N][N],T[N],C[N];int I[N],J[N],Inv[N],Fac[N];int IK[N],JK[N];void Ln(int *a,int n)&#123; static int b[N]; rep(i,0,n) b[i]=a[i]; rep(i,0,n-1) &#123; int s=1ll*b[i+1]*(i+1)%P; rep(j,0,i-1) s=(s-1ll*a[j]*b[i-j])%P; Mod2(s),a[i]=s; &#125; drep(i,n,1) a[i]=1ll*a[i-1]*Inv[i]%P; a[0]=0;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;P); Inv[0]=Inv[1]=1; rep(i,2,n) Inv[i]=1ll*(P-P/i)*Inv[P%i]%P; rep(i,*I=*J=1,n) I[i]=1ll*I[i-1]*qpow(Inv[i],k)%P,J[i]=1ll*J[i-1]*qpow(i,k)%P; rep(i,*Fac=1,n) Fac[i]=1ll*Fac[i-1]*i%P; drep(i,n,1) &#123; int m=n/i; rep(j,*H=1,m) H[j]=T[j]=0; rep(j,0,m) IK[j]=qpow(I[j],i),JK[j]=qpow(J[j],i); rep(j,*C=1,m) C[j]=IK[j]; Ln(C,m); rep(j,1,m) &#123; F[i][j]=1ll*H[j-1]*JK[j-1]%P; int u=m/j,t=1; T[0]=0; rep(x,1,u) t=1ll*t*IK[j]%P,T[x*j]=(T[x*j]+1ll*C[x]*F[i*x][j]%P*t%P*x*j)%P; rep(x,1,j) H[j]=(H[j]+1ll*H[j-x]*T[x])%P; H[j]=1ll*H[j]*Inv[j]%P; &#125; &#125; int ans=1ll*F[1][n]*I[n-1]%P; printf(&quot;%d\\n&quot;,ans);&#125; Code3: Loj Submission 吐槽：实际上套了板子之后已经比loj上的所有人都快了 但是由于新旧评测机的问题~~~，总时间就显得慢了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)enum&#123;N=2010&#125;;int n,k,P;using u32=uint32_t;using i32=int32_t;using u64=uint64_t;using i64=int64_t;static u32 m,m2,inv,r2;u32 getinv()&#123; u32 inv=m; for(int i=0;i&lt;4;++i) inv*=2-inv*m; return inv;&#125;struct Mont&#123;private : u32 x;public : static u32 reduce(u64 x)&#123; u32 y=(x+u64(u32(x)*inv)*m)&gt;&gt;32; return i32(y)&lt;0?y+m:y; &#125; Mont()&#123; ; &#125; Mont(i32 x):x(reduce(u64(x)*r2)) &#123; &#125; Mont&amp; operator += (const Mont &amp;rhs) &#123; return x+=rhs.x-m2,i32(x)&lt;0&amp;&amp;(x+=m2),*this; &#125; Mont&amp; operator -= (const Mont &amp;rhs) &#123; return x-=rhs.x,i32(x)&lt;0&amp;&amp;(x+=m2),*this; &#125; Mont&amp; operator *= (const Mont &amp;rhs) &#123; return x=reduce(u64(x)*rhs.x),*this; &#125; friend Mont operator + (Mont x,const Mont &amp;y) &#123; return x+=y; &#125; friend Mont operator - (Mont x,const Mont &amp;y) &#123; return x-=y; &#125; friend Mont operator * (Mont x,const Mont &amp;y) &#123; return x*=y; &#125; i32 get()&#123; u32 res=reduce(x); return res&gt;=m?res-m:res; &#125;&#125; H[N],F[N][N],T[N],C[N],I[N],J[N],Inv[N],IK[N],JK[N];Mont qpow(Mont x,ll k=P-2) &#123; Mont res(1); for(;k;k&gt;&gt;=1,x*=x) if(k&amp;1) res*=x; return res;&#125;void Init(int m) &#123; ::m=m,m2=m*2; inv=-getinv(); r2=-u64(m)%m;&#125;void Ln(Mont *a,int n)&#123; static Mont b[N]; rep(i,0,n) b[i]=a[i]; rep(i,0,n-1) &#123; Mont s=b[i+1]*(i+1); rep(j,0,i-1) s-=a[j]*b[i-j]; a[i]=s; &#125; drep(i,n,1) a[i]=a[i-1]*Inv[i]; a[0]=0;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;P),Init(P); Inv[0]=Inv[1]=1; rep(i,2,n) Inv[i]=(P-P/i)*Inv[P%i]; I[0]=J[0]=1; rep(i,1,n) I[i]=I[i-1]*qpow(Inv[i],k),J[i]=J[i-1]*qpow(i,k); drep(i,n,1) &#123; int m=n/i; rep(j,1,m) T[j]=0; rep(j,0,m) IK[j]=qpow(I[j],i),JK[j]=qpow(J[j],i); C[0]=H[0]=1; rep(j,1,m) C[j]=IK[j]; Ln(C,m); rep(j,1,m) &#123; F[i][j]=H[j-1]*JK[j-1]; Mont t=1; rep(x,1,m/j) t=t*IK[j],T[x*j]+=C[x]*F[i*x][j]*t*(x*j); H[j]=0; rep(x,1,j) H[j]+=H[j-x]*T[x]; H[j]=H[j]*Inv[j]; &#125; &#125; Mont ans=F[1][n]*I[n-1]; printf(&quot;%d\\n&quot;,ans.get());&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"JOI","slug":"JOI","permalink":"http://chasingdeath.github.io/tags/JOI/"},{"name":"各省OI","slug":"各省OI","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E7%9C%81OI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[NOI Online  3 提高组] 优秀子序列","slug":"[NOI Online  3 提高组] 优秀子序列","date":"2021-03-28T03:59:21.000Z","updated":"2021-05-22T03:54:11.075Z","comments":true,"path":"articles/2021/03/28/8d4a45a4.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/28/8d4a45a4.html","excerpt":"","text":"[NOI Online #3 提高组] 优秀子序列这个题怎么不直接取名 集合幂级数$\\text{exp}$呢 优秀的子序列中任意两个元素01位无交，这是一个标准的子集卷积形式 $\\varphi$的计算显然与$a_i$的卷积独立，可以线性筛/埃氏筛 暴力可以暴力$3^{18}$过，枚举时为了避免重复可以通过强制枚举的数包含最高位的1 注意$a_i=0$要特殊处理 1234567891011121314151617181920212223242526272829303132333435363738bool Mbe;const int N=1&lt;&lt;18,P=1e9+7;int n,cnt0=1;ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int Phi[N+1],notpri[N+1];int F[N],C[N],cnt[N];int main()&#123; Phi[1]=1; rep(i,2,N) if(!notpri[i]) &#123; Phi[i]=i-1; for(int j=i+i;j&lt;=N;j+=i) &#123; notpri[j]=1; if(!Phi[j]) Phi[j]=j; Phi[j]=Phi[j]/i*(i-1); &#125; &#125; n=rd(); rep(i,1,N-1) cnt[i]=cnt[i&amp;(i-1)]+1; F[0]=1; rep(i,1,n) &#123; int x=rd(); if(!x) F[0]*=2,Mod1(F[0]); else C[x]++; &#125; int ans=0; rep(S,0,N-1) &#123; if(S) for(int T=S;_builtin_clz(S)==__builtin_clz(T);T=(T-1)&amp;S) F[S]=(F[S]+1ll*F[S^T]*C[T])%P; ans=(ans+1ll*F[S]*Phi[S+1])%P; &#125; printf(&quot;%d\\n&quot;,ans);&#125; 集合幂级数就是直接套集合幂计数的$\\text{exp}$ 同样要特殊处理$a_i=0$的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const int N=1&lt;&lt;18,P=1e9+7;int F[N][19],Inv[20];#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char buf[200000],*p1,*p2;#define getchar() (((p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,200000,stdin))),*p1++)char IO;int rd()&#123; int s=0; static char c; while(c=getchar(),c&lt;48); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(c^&#x27;0&#x27;); while(c=getchar(),c&gt;47); return s;&#125;bool Mbe;int n,m,cnt0=1,U;ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int Phi[N+1],notpri[N+1],pri[N/4],pc;void Exp(int *a)&#123; static int b[N]; rep(i,1,n) b[i-1]=1ll*a[i]*i%P; rep(i,0,n-1) &#123; int s=b[i]; rep(j,1,i) s=(s+1ll*a[j]*b[i-j])%P; a[i+1]=1ll*s*Inv[i+1]%P; &#125;&#125;int main()&#123; Inv[0]=Inv[1]=1; rep(i,2,18) Inv[i]=1ll*(P-P/i)*Inv[P%i]%P; n=rd(); rep(i,1,n) &#123; int x=rd(); cmax(U,x); if(!x) cnt0*=2,Mod1(cnt0); else F[x][__builtin_popcount(x)]++; &#125; Phi[1]=1; for(n=1;(1&lt;&lt;n)&lt;=U;)n++; m=1&lt;&lt;n; rep(i,2,m) &#123; if(!notpri[i]) pri[++pc]=i,Phi[i]=i-1; for(int j=1;j&lt;=pc &amp;&amp; 1ll*i*pri[j]&lt;=m;++j)&#123; notpri[i*pri[j]]=1; if(i%pri[j]==0) &#123; Phi[i*pri[j]]=Phi[i]*pri[j]; break; &#125; Phi[i*pri[j]]=Phi[i]*(pri[j]-1); &#125; &#125; for(int i=1;i&lt;m;i&lt;&lt;=1) for(int l=0;l&lt;m;l+=i*2) for(int j=l;j&lt;l+i;++j) rep(k,1,n) F[j+i][k]+=F[j][k],Mod1(F[j+i][k]); rep(i,0,m-1) Exp(F[i]); for(int i=1;i&lt;m;i&lt;&lt;=1) for(int l=0;l&lt;m;l+=i*2) for(int j=l;j&lt;l+i;++j) rep(k,1,n) F[j+i][k]-=F[j][k],Mod2(F[j+i][k]); int ans=0; rep(S,1,m-1) ans=(ans+1ll*F[S][__builtin_popcount(S)]*Phi[S+1])%P; ans=1ll*(ans+1)*cnt0%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"[NOI Online 2021 提高组] 愤怒的小N","slug":"[NOI Online 2021 提高组] 愤怒的小N","date":"2021-03-28T01:47:55.000Z","updated":"2021-05-22T03:54:11.076Z","comments":true,"path":"articles/2021/03/28/4b5e1fd3.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/28/4b5e1fd3.html","excerpt":"","text":"[NOI Online 2021 提高组] 愤怒的小N暴力倍增维护$[x,x+2^d)$内部所有$b$的权值和 以及$a$的，用多项式表示 具体的，维护两个多项式$F_0(x),F_1(x)$，每次倍增的转移如下 $F_0(x)\\leftarrow F_0(x)+F_1(x+d)$ $F_1(x)\\leftarrow F_1(x)+F_0(x+d)$ 因此暴力倍增复杂度为$O(nk^2)$，实现上需要记录每次倍增之后多项式与答案的前面部分相拼接需要额外的偏移 \\优化如果你输出多项式，就会发现，倍增$k$次之后，所有$a,b$位置对应的多项式就完全相同了 形式化地理解这个过程 一开始，$F_0(x)=A(x),F_1(x)=0$，其中$A(x)$为读入的多项式 进行一次转移后，$F_0(x),F_1(x)$的第$k-1$项只受到对方的$k-1$项和自己的$k-1$项影响 因此一次转移后$[x^{k-1}]F_0(x)=[x^{k-1}]F_1(x)$ 下一次转移，第$k-2$项值只受到对方的$k-2$项，已经已经确定相同的$k-1$项影响 这个过程不断进行，第$i$次倍增会使得$[k-i,k-1]$项相同 \\对于$k$次倍增之后，后面多出来的部分，可以直接求一个多项式前缀和，然后除2得到答案 多项式前缀和容易通过拉格朗日插值解决，复杂度为$O(k^2)$ 预处理前面的多项式复杂度为$O(k^3)$，求后面的式子为$O(k^2)$，预处理$n$的值复杂度为$O(\\log n)$ 因此复杂度为$O(\\log n+k^3)$ \\123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=5e5+10,M=510,INF=1e9+10,P=1e9+7;int n,m;char s[N];int D[N],T[N];// D[i]预处理倍增求出的每项对于答案贡献时存在的偏移// T[i]预处理每个位后面1的个数int A[N],F[2][M],G[2][M],C[M][M];int Pow[N];ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int X[M],Y[M];int Lagrange(int x,int n,int *X,int *Y)&#123; int ans=0; rep(i,0,n) &#123; ll s=1; rep(j,0,n) if(i!=j) s=s*(X[i]-X[j])%P; s=qpow(s); rep(j,0,n) if(i!=j) s=s*(x-X[j])%P; ans=(ans+s*Y[i])%P; &#125; return ans;&#125;int main()&#123; freopen(&quot;angry.in&quot;,&quot;r&quot;,stdin),freopen(&quot;angry.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%s&quot;,s),n=strlen(s),reverse(s,s+n); m=rd(); rep(i,0,m-1) A[i]=F[0][i]=rd(); rep(i,0,m) rep(j,*C[i]=1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%P; int ans=0,x=2; rep(i,1,n-1) D[i-1]=x*(s[i]==&#x27;1&#x27;),x=x*2%P,T[i-1]=(s[i]==&#x27;1&#x27;); drep(i,n-1,0) D[i]+=D[i+1],Mod1(D[i]),T[i]^=T[i+1]; x=1; rep(i,0,min(m-1,n-1)) &#123; if(s[i]==&#x27;1&#x27;) &#123; int t=1; rep(j,0,m-1) &#123; ans=(ans+1ll*t*F[!T[i]][j])%P; t=1ll*t*D[i]%P; &#125; &#125; rep(d,0,1) rep(j,0,m-1) G[d][j]=F[d][j]; rep(j,*Pow=1,m-1) Pow[j]=1ll*Pow[j-1]*x%P; rep(j,0,m-1) rep(k,0,j) &#123; F[0][k]=(F[0][k]+1ll*C[j][k]*Pow[j-k]%P*G[1][j])%P; F[1][k]=(F[1][k]+1ll*C[j][k]*Pow[j-k]%P*G[0][j])%P; &#125; x=x*2%P; &#125; // 倍增到前k-1项 if(m&gt;=n) return printf(&quot;%d\\n&quot;,ans),0; // 预处理拉格朗日插值 rep(i,0,m) &#123; X[i]=i,x=1; rep(j,0,m-1) &#123; Y[i]=(Y[i]+1ll*A[j]*x)%P; x=1ll*x*i%P; &#125; if(i) Y[i]+=Y[i-1],Mod1(Y[i]); &#125; ans=(ans+1ll*Lagrange(D[m-1]-1,m,X,Y)*(P+1)/2)%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"[NOI Online 2021 提高组] 积木小赛","slug":"[NOI Online 2021 提高组] 积木小赛","date":"2021-03-27T05:28:55.000Z","updated":"2021-05-22T03:54:11.078Z","comments":true,"path":"articles/2021/03/27/7050c6bf.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/27/7050c6bf.html","excerpt":"","text":"[NOI Online 2021 提高组] 积木小赛题目大意：给定串$A$,$B$，求$B$中有多少本质不同的连续子段是$A$的子序列 $n\\leq 3000$ 暴力枚举$B$中的子段，同步维护与$A$的匹配指针$p$ 每次插入一个字符$c$，找到$A$中$p+1$之后第一个字符$c$，令匹配指针跳过去 可以预处理出这样的下一个字符$nxt_{i,c}$，完成$O(1)$匹配 除此以外，我们还需要对于本质不同去重 如果用$\\text{trie}$树去重，需要开一个$\\frac{n^2} {2}\\cdot 26$的数组，面临着内存不够的问题 你可以信仰不开这么大 也可以去学习一下$\\text{DAT(Double Array Trie)}$算法 也可以用$\\text{hash+set/map/hash table/sort unique}$ 也可以用链表暴力存储trie树的情况，每次暴力for过去找儿子 这样内存均为$O(n^2)$ 以下是链表trie树的版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=3010,M=N*N/2,INF=1e9+10;bool Mbe;int n;int nxt[N][26];char A[N],B[N];struct Edge&#123; int c,to,nxt; &#125; e[M];int head[M],cnt;bool Med;int main()&#123; //fprintf(stderr,&quot;%.2lf\\n&quot;,(&amp;Med-&amp;Mbe)/1024.0/1024.0); freopen(&quot;block.in&quot;,&quot;r&quot;,stdin),freopen(&quot;block.out&quot;,&quot;w&quot;,stdout); n=rd(),scanf(&quot;%s%s&quot;,A+1,B+1); drep(i,n,1) &#123; rep(j,0,25) nxt[i][j]=nxt[i+1][j]; nxt[i][A[i]-&#x27;a&#x27;]=i; &#125; rep(i,1,n) &#123; int u=0,p=0; rep(j,i,n) &#123; int c=B[j]-&#x27;a&#x27;; if(!(p=nxt[p+1][c])) break; int v=-1; for(int k=head[u];k;k=e[k].nxt) if(e[k].c==c) &#123; v=e[k].to; break; &#125; if(~v) u=v; else &#123; v=++cnt; e[v]=(Edge)&#123;c,v,head[u]&#125;; head[u]=v,u=v; &#125; &#125; &#125; printf(&quot;%d\\n&quot;,cnt);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「2020-2021 集训队作业」Yet Another Permutation Problem","slug":"「2020-2021 集训队作业」Yet Another Permutation Problem","date":"2021-03-26T03:50:55.000Z","updated":"2021-05-22T03:54:11.125Z","comments":true,"path":"articles/2021/03/26/6672bea.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/26/6672bea.html","excerpt":"","text":"「2020-2021 集训队作业」Yet Another Permutation Problem题目大意对于一个初始为$1,2,\\ldots n$的排列，每次操作为选择一个数放到开头或者结尾，求$k$次操作能够生成的排列数 对于$k=0,1,\\ldots ,n-1$求解 \\模型转化容易发现，对于一个排列，生成它的最小次数取决于中间保留段的长度 而保留段实际上是任何一个上升子段 设一个排列的最长上升子段为$l$，那么最少操作步骤就是$n-l$ 那么对于$k$，合法的序列就是存在一个长度$\\ge n-k$的上升子段 存在不好算，改为计算任何一个上升子段$&lt;n-k$的数量 为了便于描述，令下文的$k=n-k-1$ \\生成函数构造考虑一个序列是由若干上升段构成的，设一个长度为$l$的上升段的权值为$[l\\leq k]$ 那么排列的权值就是上升段权值之积 容易想到用$\\text{EGF}$合并上升段，但是直接的统计，我们无法保证上升段之间无法拼接 假设我们确定了一个单位上升段的$\\text{EGF}$为$G(x)$，$\\text{OGF}$为$F(x)$ 那么按照上面$\\text{Naive}$的计算，上升段之间的合并为有序拼接，即$\\displaystyle \\sum_{i=0}G^i(x)=\\frac{1} {1-G(x)}$ 容易发现，这样的计算，会导致一个长度为$l$的极长上升段被分解成若干小段 也就是被计算了$\\displaystyle x^l)=[x^l]\\frac{1} {1-F(x)}$次 在合法的计算中，我们希望，$[x^l]\\frac{1} {1-F(x)}$恰好为权值$[l\\leq k]$ 也就是说，我们希望$\\displaystyle \\frac{1} {1-F(x)}=H(x)=\\sum_{i=0}^kx^i=\\frac{x^{k+1}-1} {x-1}$ 那么可以反向由$H(x)$构造出我们想要的$F(x)$，从而得到$G(x)$，再进行求解 \\答案计算$\\displaystyle F(x)=1-\\frac{1} {H(x)}=1-\\frac{x-1} {x^{k+1}-1}=\\frac{x-x^{k+1} } {1-x^{k+1} }$ 可以爆算得到$F(x)$，从而得到$G(x)$，然后暴力求逆就是$O(n^2)$ 优化： $1-x^{k+1}$的逆，只包含$\\frac{n} {k+1}$项，所以$G(x)$只含$2\\frac{n} {k+1}$项 即$\\displaystyle F(x)=\\sum_{d=0}x^{d(k+1)+1}-\\sum_{d=1}x^{d(k+1)}$，$G(x)$就是除一个阶乘 这样暴力求逆就是$O(n^2\\ln n)$ （不是你干嘛要真的求逆，直接进行$G(x)$的叠加就可以了） 12345678910111213141516171819202122232425const int N=1010;int n,P,I[N],J[N];ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int F[N];int main()&#123; n=rd(),P=rd(); rep(i,*J=1,n) J[i]=1ll*J[i-1]*i%P; I[n]=qpow(J[n]); drep(i,n,1) I[i-1]=1ll*I[i]*i%P; drep(k,n,1) &#123; F[0]=1; rep(j,1,n) &#123; F[j]=0; for(int d=1;d&lt;=j;d+=k) F[j]=(F[j]+1ll*F[j-d]*I[d])%P; for(int d=k;d&lt;=j;d+=k) F[j]=(F[j]-1ll*F[j-d]*I[d])%P; &#125; printf(&quot;%d\\n&quot;,int((1ll*(P+1-F[n])*J[n])%P)); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"无标号有根树/无根树 计数","slug":"无标号有根树 无根树 计数","date":"2021-03-23T13:36:41.000Z","updated":"2021-05-22T03:54:11.379Z","comments":true,"path":"articles/2021/03/23/95323e25.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/23/95323e25.html","excerpt":"","text":"无标号有根树/无根树 计数当然是从有根树开始啦 树计数容易想到递归进行，设$n$个节点有根树的$\\text{OGF}$为$F(x)$ 我们考虑$F(x)$作为新根节点的子树的情况，这是一个可置换的背包问题，被称为$\\text{Euler}$变换 不妨对于$F(x)$的每一项考虑，我们从$F_k$这么多种类的数中选择一些出来，然后组成背包 设$I=x^k$，$n=F_k$，那么对于这一项的变换可以表示为 $\\displaystyle T(I,n)=\\sum_{i=0}\\binom{n} {i} (\\sum_{j=1}^{\\infty}I^j)^i=(\\sum_{j=1}^{\\infty}I^j+1)^n=\\frac{1} {(1-I)^n}$ 那么得到$\\text{Euler}$变换 $\\displaystyle \\mathcal{E}(F(x))=\\prod_{i=1}T(x^i,F_i)=\\prod \\frac{1} {(1-x^i)^{F_i} }$ 两边求$\\ln $ $\\displaystyle \\ln \\mathcal{E}(F(x))=\\sum_i F_i\\ln \\frac{1} {(1-x^i)}$ $\\displaystyle \\ln \\mathcal{E}(F(x))=\\sum_i F_i(\\sum_{j=1}\\frac{x^{ij} } {j})$ 换循环 $\\displaystyle \\ln \\mathcal{E}(F(x))=\\sum_i \\frac{1} {i}(\\sum_{j=1}F_j(x^i)^j)=\\sum \\frac{F(x^i)} {i}$ $\\displaystyle \\mathcal{E}(F(x))=\\text{exp}(\\sum \\frac{F(x^i)} {i})$ 到这里我们得到了一个比较阳间的变换形式，那么$F(x)$的递归表示就是 $F(x)=x\\cdot \\mathcal{E}(F(x))$ 考虑用牛顿迭代求解，设已经求出$G(x)=F(x)\\mod x^n$，我们要求$F(x)\\mod x^{2n}$ 而$\\displaystyle \\mathcal{E}(F(x))=\\text{exp}(\\sum \\frac{F(x^i)} {i})$中$i\\ge 2$的项都是已知的，可以在$O(n\\ln n)$时间得到，不妨这些项为常数$\\text{coef}$ 则方程为$x\\cdot \\text{exp}(F(x)+\\text{coef})-F(x)=0$ 方程函数为$f(z)=xe^{z+\\text{coef} }-z$ $f’(z)=xe^{z+\\text{coef} }-1$ 故知$\\displaystyle F(x)=G(x)-\\frac{xe^{G(x)+\\text{coef} }-G(x)} {xe^{G(x)+\\text{coef} }-1}$ (这里没有分治解法的。。。实际我也不会) \\ 下面是无根树计数，考虑令重心为根即可 可以直接减掉存在一个子树$&gt; \\frac{n} {2}$的贡献，因为不会出现置换重复，可以将这个子树从原来的树上踢掉 剩下部分依然看成一棵有根树，也就是$F_i\\cdot F_{n-i}(i&gt;\\frac{n} {2})$ 对于$2|n$的情况，重心可能有两个，此时要减去对称情况$\\displaystyle \\binom{F_{\\frac{n} {2} }} {2}$ Luogu P5900 Submission 唔-好慢 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;typedef vector &lt;int&gt; V;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int L=19,N=1&lt;&lt;L|10,P=998244353;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int I[N],J[N];int rev[N],w[N];void Init()&#123; w[1&lt;&lt;(L-1)]=1; int t=qpow(3,(P-1)&gt;&gt;L); rep(i,(1&lt;&lt;(L-1))+1,1&lt;&lt;L) w[i]=1ll*w[i-1]*t%P; drep(i,(1&lt;&lt;(L-1))-1,1) w[i]=w[i&lt;&lt;1]; rep(i,J[0]=1,N-1) J[i]=1ll*J[i-1]*i%P; I[N-1]=qpow(J[N-1]); drep(i,N-1,1) I[i-1]=1ll*I[i]*i%P;&#125;int Init(int n)&#123; int R=1,c=-1; while(R&lt;=n) R&lt;&lt;=1,c++; rep(i,0,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;c); return R;&#125;void NTT(int n,V &amp;A,int f) &#123; static ull a[N]; if((int)A.size()&lt;n) A.resize(n); rep(i,0,n-1) a[rev[i]]=A[i]; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=a[j+i]*e[j-l]%P; a[j+i]=a[j]+P-t; a[j]+=t; &#125; &#125; &#125; rep(i,0,n-1) A[i]=a[i]%P,Mod2(A[i]); if(f==-1) &#123; reverse(A.begin()+1,A.end()); ll base=1ll*I[n]*J[n-1]%P; rep(i,0,n-1) A[i]=A[i]*base%P; &#125;&#125;V operator + (V a,const V &amp;b) &#123; if(a.size()&lt;b.size()) a.resize(b.size()); rep(i,0,b.size()-1) a[i]+=b[i],Mod1(a[i]); return a;&#125;V operator - (V a,const V &amp;b) &#123; if(a.size()&lt;b.size()) a.resize(b.size()); rep(i,0,b.size()-1) a[i]-=b[i],Mod2(a[i]); return a;&#125;V operator * (V a,V b) &#123; int n=a.size()-1,m=b.size()-1; int R=Init(n+m); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=1ll*a[i]*b[i]%P; NTT(R,a,-1),a.resize(n+m+1); return a;&#125;V operator * (V a,const int &amp;x) &#123; for(int &amp;i:a) i=1ll*i*x%P; return a;&#125;V operator * (const int &amp;x,V a) &#123; return a*x; &#125;void println(const V &amp;a)&#123; for(int i:a) printf(&quot;%d &quot;,i); puts(&quot;&quot;);&#125;V read(int n)&#123; V A(n); rep(i,0,n-1) A[i]=rd(); return A;&#125;V operator ~ (V a) &#123; int n=a.size(),m=(n+1)&gt;&gt;1; if(n==1) return assert(a[0]),V&#123;(int)qpow(a[0])&#125;; V b=a; b.resize(m),b=~b; int R=Init(n*2); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=(P+2-1ll*a[i]*b[i]%P)*b[i]%P; NTT(R,a,-1),a.resize(n); return a;&#125;V Deriv(V a) &#123; rep(i,0,a.size()-2) a[i]=1ll*(i+1)*a[i+1]%P; a.pop_back(); return a;&#125;V Integ(V a)&#123; a.pb(0); drep(i,a.size()-1,1) a[i]=1ll*a[i-1]*J[i-1]%P*I[i]%P; a[0]=0; return a;&#125;V Ln(V a)&#123; int n=a.size(); a=Deriv(a)*~a; return a.resize(n-1),Integ(a);&#125;V Exp(V a) &#123; if(a.size()==1) return assert(a[0]==0),V&#123;1&#125;; int n=a.size(); V b=a; b.resize((n+1)/2),b=Exp(b),b.resize(n); a=a-Ln(b),a[0]++; a=a*b,a.resize(n); return a;&#125;V operator &lt;&lt; (V a,int x) &#123; a.resize(a.size()+x); drep(i,a.size()-1,x) a[i]=a[i-x]; rep(i,0,x-1) a[i]=0; return a;&#125;V operator &gt;&gt; (V a,int x) &#123; if((int)a.size()&lt;=x) return V&#123; &#125;; rep(i,x,a.size()-1) a[i-x]=a[i]; a.resize(a.size()-x); return a;&#125;V Newton(int n)&#123; if(n==1) return V&#123;0&#125;; if(n==2) return V&#123;0,1&#125;; V G=Newton((n+1)/2); G.resize(n); V T=G; rep(i,2,n-1) &#123; int t=1ll*I[i]*J[i-1]%P; rep(j,1,min(n/2,(n-1)/i)) T[i*j]=(T[i*j]+1ll*G[j]*t)%P; &#125; T=Exp(T)&lt;&lt;1; V F=G-(T-G)*~(T-V&#123;1&#125;); return F.resize(n),F;&#125;int main()&#123; int n=rd()+1; Init(); V F=Newton(n); int ans=F[--n]; rep(i,1,(n-1)/2) ans=(ans-1ll*F[i]*F[n-i])%P; if(~n&amp;1) ans=(ans-1ll*F[n/2]*(F[n/2]-1)/2)%P; Mod2(ans); printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"无向图的 三元环 - 四元环 计数","slug":"无向图的 三元环 - 四元环 计数","date":"2021-03-22T13:48:17.000Z","updated":"2021-05-22T03:54:11.377Z","comments":true,"path":"articles/2021/03/22/10f2c262.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/22/10f2c262.html","excerpt":"","text":"无向图的 三元环 - 四元环 计数问题描述： 给定一个$n$个点$m$条边的无向图，统计其中三元环/四元环的个数 三元环考虑枚举一条边$(u,v)$，为了避免重复我们可能令$u&lt;v$ 然后暴力枚举求出$u,v$两个点出边的交点个数 具体的，先对于$u$的出点打标记，然后查询$v$的出点中被标记的个数 tips:当然每个三元环会被算三次 这样复杂度显然是$O(nm)$的，当$v$点度数大时就可以卡掉 优化强制$deg_u&gt;deg_v\\or deg_u=deg_v,u&lt;v$ 考虑先固定$u$，预处理出标记情况，然后枚举每个合法的$(u,v)$ 再去枚举$v$的出边 考虑证明这个复杂度上限为$O(m\\sqrt m)$级别 假设对于$(u,v)$ 1.如果$deg_v\\leq \\sqrt m$，显然它们被枚举的次数总和$\\leq m$，枚举复杂度为$O(m\\sqrt m)$ 2.对于$deg_v&gt;\\sqrt m$，则显然有$deg_u\\ge deg_v&gt;\\sqrt m$ 会枚举到$v$的$u$显然不超过$\\sqrt m$个，因此这样的$v$遍历次数为$O(m\\sqrt m)$ 故复杂度为$O(m\\sqrt m)$ \\四元环类似三元环的方法，同样按照$(deg_u,u)$二元组递减的顺序设定排名 强制$u$为四元环中排名最小的点，枚举合法的边$(u,v)$，那么我们计算的实际上是每个$v$的出边的交的个数 依次枚举每个$v$的过程中，对于出边$(v,w)$维护$w$出现次数，即可求出交点个数 容易发现这样的计算不会出现重复 而复杂显然是与上面相同的，还去掉对于$u$的出点打标记的过程","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"有标号二分图计数","slug":"有标号二分图计数","date":"2021-03-22T13:08:15.000Z","updated":"2021-05-22T03:54:11.390Z","comments":true,"path":"articles/2021/03/22/82617363.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/22/82617363.html","excerpt":"","text":"有标号二分图计数求 $n$ 个点的有标号二分图数目 容易想到一个会重复的计算方法：暴力把图剖成两个集合，然后集合间随意连边 $G_n=\\displaystyle \\sum_{i=0}^n \\binom{n} {i}2^{i(n-i)}$ 而如果一个二分图包含$t$个连通块，那么在$G$中它会被计算$2^t$次 不妨设$\\text{EGF}:$ $H(x)$为$n$个点连通的二分图的数目 $G(x)$为$G_n$的生成函数 $F(x)$为$n$个点二分图生成函数 容易发现$\\displaystyle G(x)=\\sum \\frac{H^i(x)2^i} {i!}=\\text{exp}(2H(x))$ 而我们要求的答案生成函数$F(x)=\\text{exp}(H(x))$ 也就是说$F(x)=\\sqrt {G(x)}$ 而根据组合意义容易发现$\\displaystyle i(n-i)=\\binom{n} {2}-\\binom{i} {2}-\\binom{n-i} {2}$，容易通过卷积得到$G(x)$ 然后开根即可，实际做的时候注意区分什么时候算的是$\\text{EGF}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114const int L=18,N=1&lt;&lt;L|10,P=998244353;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int I[N],J[N];int rev[N],w[N];void Init()&#123; w[1&lt;&lt;(L-1)]=1; int t=qpow(3,(P-1)&gt;&gt;L); rep(i,(1&lt;&lt;(L-1))+1,1&lt;&lt;L) w[i]=1ll*w[i-1]*t%P; drep(i,(1&lt;&lt;(L-1))-1,1) w[i]=w[i&lt;&lt;1]; rep(i,J[0]=1,N-1) J[i]=1ll*J[i-1]*i%P; I[N-1]=qpow(J[N-1]); drep(i,N-1,1) I[i-1]=1ll*I[i]*i%P;&#125;int Init(int n)&#123; int R=1,c=-1; while(R&lt;=n) R&lt;&lt;=1,c++; rep(i,0,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;c); return R;&#125;void NTT(int n,V &amp;A,int f) &#123; static ll a[N]; if((int)A.size()&lt;n) A.resize(n); rep(i,0,n-1) a[rev[i]]=A[i]; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=a[j+i]*e[j-l]%P; a[j+i]=a[j]-t; a[j]+=t; &#125; &#125; &#125; rep(i,0,n-1) A[i]=a[i]%P,Mod2(A[i]); if(f==-1) &#123; reverse(A.begin()+1,A.end()); ll base=1ll*I[n]*J[n-1]%P; rep(i,0,n-1) A[i]=A[i]*base%P; &#125;&#125;V operator + (V a,const V &amp;b) &#123; if(a.size()&lt;b.size()) a.resize(b.size()); rep(i,0,b.size()-1) a[i]+=b[i],Mod1(a[i]); return a;&#125;V operator - (V a,const V &amp;b) &#123; if(a.size()&lt;b.size()) a.resize(b.size()); rep(i,0,b.size()-1) a[i]-=b[i],Mod2(a[i]); return a;&#125;V operator * (V a,V b) &#123; int n=a.size()-1,m=b.size()-1; int R=Init(n+m); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=1ll*a[i]*b[i]%P; NTT(R,a,-1),a.resize(n+m+1); return a;&#125;void println(const V &amp;a)&#123; for(int i:a) printf(&quot;%d &quot;,i); puts(&quot;&quot;);&#125;V read(int n)&#123; V A(n); rep(i,0,n-1) A[i]=rd(); return A;&#125;V operator ~ (V a) &#123; int n=a.size(),m=(n+1)&gt;&gt;1; if(n==1) return &#123;(int)qpow(a[0])&#125;; V b=a; b.resize(m),b=~b; int R=Init(n*2); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=(P+2-1ll*a[i]*b[i]%P)*b[i]%P; NTT(R,a,-1),a.resize(n); return a;&#125;int Div2(int x)&#123; return (x&amp;1?x+P:x)/2; &#125;V Sqrt(V a)&#123; if(a.size()==1) return a; int n=a.size(); V b=a; b.resize((n+1)/2),b=Sqrt(b),b.resize(n); a=a*~b; a.resize(n); rep(i,0,b.size()-1) a[i]+=b[i],Mod1(a[i]); rep(i,0,n-1) a[i]=Div2(a[i]); return a;&#125;int Pow[N],IPow[N];int main()&#123; int n=1e5; Init(); Pow[0]=Pow[1]=IPow[0]=IPow[1]=1; for(int i=2,x=2,y=(P+1)/2;i&lt;N;i++,x*=2,Mod1(x),y=Div2(y)) &#123; Pow[i]=1ll*Pow[i-1]*x%P; IPow[i]=1ll*IPow[i-1]*y%P; &#125; V F(n+1); rep(i,0,n) F[i]=1ll*I[i]*IPow[i]%P; F=F*F,F.resize(n+1); rep(i,0,n) F[i]=1ll*F[i]*Pow[i]%P; F=Sqrt(F); rep(i,1,n) printf(&quot;%d\\n&quot;,int(1ll*F[i]*J[i]%P));&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"有标号荒漠计数","slug":"有标号荒漠计数","date":"2021-03-22T13:06:11.000Z","updated":"2021-05-22T03:54:11.392Z","comments":true,"path":"articles/2021/03/22/aa3d5ccc.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/22/aa3d5ccc.html","excerpt":"","text":"有标号荒漠计数考虑随意选择一个点为根，则仙人掌的$\\text{EGF}$考虑用以下方式递归生成 令树边为二元环，则一个点周围的点都是都是与它直接相连的环 断开这个点，对于周围断开的环，环上每个点下面认为是一个仙人掌，设某个环断开之后的大小为$c$ 当$c=1$时，不需要考虑排列重复，即为$F(x)$ 当$c&gt;1$时，考虑环正反排列，即为$\\cfrac{F^c(x)} {2}$ 那么就容易得到$\\displaystyle F(x)=x \\cdot \\text{exp}(F(x)+\\sum _{i\\ge 2}\\frac{F^i(x)} {2})$ 变一下就是$\\displaystyle F=x\\cdot \\text{exp}(\\frac{F^2} {2-2F}+F)=x\\cdot \\text{exp}(\\frac{2F-F^2} {2-2F})$ 是的，我们要解这个方方方方方方程。。。牛顿迭代代代代代代代 $\\displaystyle f(F(x))=x\\cdot \\text{exp}(\\frac{2F-F^2} {2-2F})-F=0$ $\\displaystyle f(z)=x\\cdot \\text{exp}(\\frac{2z-z^2} {2-2z})-z$ $\\displaystyle f’(z)=x\\cdot \\text{exp}(\\frac{2z-z^2} {2-2z})(1+\\frac{2z-z^2} {2z^2-4z+2})-1$ $\\displaystyle =x\\cdot \\text{exp}(\\frac{2z-z^2} {2-2z})(\\frac{1} {2}+\\frac{1} {2z^2-4z+2})-1$ 设上一层的迭代结果为$G(x)$，带入牛顿迭代结论$\\displaystyle F(x)=G(x)-\\frac{f(G)} {f’(G)}$ 设$\\displaystyle H=x\\cdot \\text{exp}(\\frac{2G-G^2} {2-2G})$，那么得到Luogu题解里$\\text{N}\\color{red}\\text{aCl_Fish}$一样的式子(还要没有推错) $\\displaystyle F=G-\\frac{2H-2G} {H(1+\\frac{1} {(1-G)^2})-2}$ 最后还要变成无根，除掉$n$即可 仙人掌转荒漠您只需要一个$\\text{exp}$就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147const int L=18,N=1&lt;&lt;L|10,P=998244353;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int I[N],J[N];int rev[N],w[N];void Init()&#123; w[1&lt;&lt;(L-1)]=1; int t=qpow(3,(P-1)&gt;&gt;L); rep(i,(1&lt;&lt;(L-1))+1,1&lt;&lt;L) w[i]=1ll*w[i-1]*t%P; drep(i,(1&lt;&lt;(L-1))-1,1) w[i]=w[i&lt;&lt;1]; rep(i,J[0]=1,N-1) J[i]=1ll*J[i-1]*i%P; I[N-1]=qpow(J[N-1]); drep(i,N-1,1) I[i-1]=1ll*I[i]*i%P;&#125;int Init(int n)&#123; int R=1,c=-1; while(R&lt;=n) R&lt;&lt;=1,c++; rep(i,0,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;c); return R;&#125;void NTT(int n,V &amp;A,int f) &#123; static ull a[N]; if((int)A.size()&lt;n) A.resize(n); rep(i,0,n-1) a[rev[i]]=A[i]; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=a[j+i]*e[j-l]%P; a[j+i]=a[j]+P-t; a[j]+=t; &#125; &#125; &#125; rep(i,0,n-1) A[i]=a[i]%P,Mod2(A[i]); if(f==-1) &#123; reverse(A.begin()+1,A.end()); ll base=1ll*I[n]*J[n-1]%P; rep(i,0,n-1) A[i]=A[i]*base%P; &#125;&#125;V operator + (V a,const V &amp;b) &#123; if(a.size()&lt;b.size()) a.resize(b.size()); rep(i,0,b.size()-1) a[i]+=b[i],Mod1(a[i]); return a;&#125;V operator - (V a,const V &amp;b) &#123; if(a.size()&lt;b.size()) a.resize(b.size()); rep(i,0,b.size()-1) a[i]-=b[i],Mod2(a[i]); return a;&#125;V operator * (V a,V b) &#123; int n=a.size()-1,m=b.size()-1; int R=Init(n+m); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=1ll*a[i]*b[i]%P; NTT(R,a,-1),a.resize(n+m+1); return a;&#125;V operator * (V a,const int &amp;x) &#123; for(int &amp;i:a) i=1ll*i*x%P; return a;&#125;V operator * (const int &amp;x,V a) &#123; return a*x; &#125;void println(const V &amp;a)&#123; for(int i:a) printf(&quot;%d &quot;,i); puts(&quot;&quot;);&#125;V read(int n)&#123; V A(n); rep(i,0,n-1) A[i]=rd(); return A;&#125;V operator ~ (V a) &#123; int n=a.size(),m=(n+1)&gt;&gt;1; if(n==1) return &#123;(int)qpow(a[0])&#125;; V b=a; b.resize(m),b=~b; int R=Init(n*2); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=(P+2-1ll*a[i]*b[i]%P)*b[i]%P; NTT(R,a,-1),a.resize(n); return a;&#125;V Deriv(V a) &#123; rep(i,0,a.size()-2) a[i]=1ll*(i+1)*a[i+1]%P; a.pop_back(); return a;&#125;V Integ(V a)&#123; a.pb(0); drep(i,a.size()-1,1) a[i]=1ll*a[i-1]*J[i-1]%P*I[i]%P; a[0]=0; return a;&#125;V Ln(V a)&#123; int n=a.size(); a=Deriv(a)*~a; return a.resize(n-1),Integ(a);&#125;V Exp(V a) &#123; if(a.size()==1) return assert(a[0]==0),V&#123;1&#125;; int n=a.size(); V b=a; b.resize((n+1)/2),b=Exp(b),b.resize(n); a=a-Ln(b),a[0]++; a=a*b,a.resize(n); return a;&#125;V operator &lt;&lt; (V a,int x) &#123; a.resize(a.size()+x); drep(i,a.size()-1,x) a[i]=a[i-x]; rep(i,0,x-1) a[i]=0; return a;&#125;V operator &gt;&gt; (V a,int x) &#123; if((int)a.size()&lt;=x) return V&#123; &#125;; rep(i,x,a.size()-1) a[i-x]=a[i]; a.resize(a.size()-x); return a;&#125;V Newton(int n)&#123; if(n==1) return V&#123;0&#125;; if(n==2) return V&#123;0,1&#125;; V G=Newton((n+1)/2); G.resize(n); V IG=~(V&#123;1&#125;-G); V H=(2*G-G*G); H.resize(n),H=H*IG*((P+1)/2),H.resize(n),H=Exp(H)&lt;&lt;1; V F=IG*IG; F.resize(n),F[0]++; F=H*F,F.resize(n),F[0]-=2,Mod2(F[0]); F=G-2*(H-G)*~F; return F.resize(n),F;&#125;int main()&#123; int n=rd()+1; Init(); V F=Newton(n); rep(i,1,F.size()-1) F[i]=1ll*F[i]*I[i]%P*J[i-1]%P; F=Exp(F); printf(&quot;%d\\n&quot;,int(1ll*F.back()*J[n-1]%P));&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「雅礼集训 2018 Day8」B","slug":"「雅礼集训 2018 Day8」B","date":"2021-03-22T10:21:57.000Z","updated":"2021-05-22T03:54:11.310Z","comments":true,"path":"articles/2021/03/22/3f22c6d2.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/22/3f22c6d2.html","excerpt":"","text":"「雅礼集训 2018 Day8」BSolution1设到达一个点的时间为$T_u$，从这个点出去的时间为$T_u’$ 那么显然满足$T_u\\leq T_u’\\leq T_u+t_u$，答案就是$\\sum (t_u-(T’_u-T_u))\\cdot c_u$ 对于一条边满足$T_v\\ge T’_u$，二分答案之后，容易发现这是一个线性规划问题 可以暴力单纯形解决掉(当然是水的，但是好像还挺快。。) Loj Submission 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=630,P=1e9+7;const db eps=1e-9;int n,m,W,t[N],c[N];int U[N],V[N];db A[N][N];db Simplex(int n)&#123; srand(time(NULL)); auto Pivot=[&amp;](int x,int y) &#123; static int P[N],C; rep(i,0,n) A[y][i]=-A[x][i]/A[x][y]; A[y][x]=1/A[x][y],A[y][y]=0; rep(i,0,n) A[x][i]=0; C=0; rep(i,0,n) if(abs(A[y][i])&gt;eps) P[++C]=i; rep(i,0,n) if(abs(A[i][y])&gt;eps) &#123; db t=A[i][y]; A[i][y]=0; rep(j,1,C) A[i][P[j]]+=t*A[y][P[j]]; &#125; &#125;; vector &lt;int&gt; V; rep(i,1,n) V.pb(i); //random_shuffle(V.begin(),V.end()); while(1) &#123; int u=0,v=0; for(int i:V) if(!u || A[i][0]&lt;A[u][0]) u=i; if(A[u][0]&gt;-eps) break; for(int i:V) if(A[u][i]&gt;eps) v=i; if(!v) return puts(&quot;Infeasible&quot;),0; Pivot(u,v); &#125; while(1) &#123; int u=0,v=0; for(int i:V) if(!v || A[0][i]&gt;A[0][v]) v=i; if(A[0][v]&lt;eps) break; for(int i:V) if(A[i][v]&lt;-eps) if(!u || (A[i][0]/A[i][v] &gt; A[u][0]/A[u][v])) u=i; if(!u) return puts(&quot;Unbounded&quot;),0; Pivot(u,v); &#125; return A[0][0];&#125;int outd[N];int Check(int lim) &#123; memset(A,0,sizeof A); int cnt=n*2; rep(i,1,n) A[0][i+n]=c[i],A[0][i]=-c[i],A[0][0]-=t[i]*c[i]; rep(i,1,n) &#123; A[++cnt][i]=-1; A[cnt][i+n]=1; A[++cnt][i]=1; A[cnt][i+n]=-1; A[cnt][0]=t[i]; &#125; rep(i,1,m) A[++cnt][U[i]+n]=-1,A[cnt][V[i]]=1; rep(i,1,n) if(!outd[i]) A[++cnt][0]=lim,A[cnt][i+n]=-1; db res=-Simplex(cnt); return res&lt;=W+eps;&#125;int main()&#123; freopen(&quot;soft.in&quot;,&quot;r&quot;,stdin),freopen(&quot;soft.out&quot;,&quot;w&quot;,stdout); n=rd(),m=rd(),W=rd(); int l=0,r=0,res=-1; rep(i,1,n) t[i]=rd(),r+=t[i]; rep(i,1,n) c[i]=rd(); rep(i,1,m) U[i]=rd(),V[i]=rd(),outd[U[i]]++; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(Check(mid)) r=mid-1,res=mid; else l=mid+1; &#125; printf(&quot;%d\\n&quot;,res);&#125; \\Solution2二分答案$\\text{lim}$，问题转化为求最小花费 设每个点减少了$x_i$ 考虑限制有两种，一种是路径长度的限制，一种是每个点大小的限制 $\\text{minimize:} \\sum x_i\\cdot c_i$ $\\displaystyle \\forall p\\in paths , \\sum x_{p_i}\\ge \\sum t_{p_i}-\\text{lim}$ $-x_i\\ge -t_i$ 对偶一下，设对于路径$p$，$\\sum x_{p_i}$的对偶变量为$y_p$，$-x_i$的对偶变量为$z_i$ $\\text{maximize}:\\sum y_p\\cdot (\\sum t_{p_i}-\\text{lim})-z_i\\cdot t_i$ $\\displaystyle \\forall i\\in[1,n], \\sum_{p\\in paths,i\\in p} y_p-z_i\\leq c$ 考虑对偶变量$y_p$和$z_i$有什么意义 此时，选择一条路径$y_p$，会使得 关于路径上的点的限制+1 ， 使得答案增加$\\sum t_{p_i}-\\text{lim}$ $z_i$是关于每个单点的变量，可以用$t_i$代价使得每个$i$的限制-1 那么可以考虑转化为一个路径覆盖问题，选择一条路径覆盖路径上的点，且得到$\\sum t_{p_i}-\\text{lim}$的价值 限制式子转化为：每个点被覆盖次数大于$c$时，再选择就要付出$t_i$的代价令$z_i$加一 带权的路径覆盖容易转化为费用流模型，可以把每个点拆成入点出点，每个点被覆盖前$c_i$次，价值为$t_i$，之后就为0 因此每个点的入点向出点连$(c_i,t_i),(\\infty,0)$两条边即可，路径的$\\text{-lim}$可以在源点前加入 求一次最大费用可行流，最终得到的答案是原问题的最小代价 是我EK写得太丑的说: Loj Submission 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;enum&#123;N=10101,INF=1&lt;&lt;30&#125;;int n,m,W;int c[N],t[N],X[N],Y[N];struct Edge&#123; int to,nxt,w,c;&#125; e[N];int head[N],ecnt=1;int V,S,T;void AddEdge(int u,int v,int w,int c)&#123; e[++ecnt]=(Edge)&#123;v,head[u],w,c&#125;,head[u]=ecnt; &#125;void Link(int u,int v,int w,int c)&#123; AddEdge(u,v,w,c),AddEdge(v,u,0,-c); &#125;int pre[N],dis[N],inq[N];int SPFA(int lim)&#123; rep(i,1,V) dis[i]=-INF; static queue &lt;int&gt; que; dis[S]=-lim,que.push(S); while(!que.empty()) &#123; int u=que.front(); que.pop(),inq[u]=0; for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(!e[i].w || dis[v]&gt;=dis[u]+e[i].c) continue; dis[v]=dis[u]+e[i].c,pre[v]=i; if(!inq[v]) que.push(v),inq[v]=1; &#125; &#125; return dis[T]&gt;0;&#125;int Check(int lim)&#123; S=++V,T=++V; rep(i,1,n) &#123; Link(S,++V,INF,0); Link(V,V+1,c[i],t[i]); Link(V,V+1,INF,0); Link(++V,T,INF,0); &#125; rep(i,1,m) Link(X[i]*2+2,Y[i]*2+1,INF,0); int ans=0; while(SPFA(lim))&#123; int w=INF; for(int i=T;i!=S;i=e[pre[i]^1].to) cmin(w,e[pre[i]].w); for(int i=T;i!=S;i=e[pre[i]^1].to) e[pre[i]].w-=w,e[pre[i]^1].w+=w; ans+=dis[T]*w; &#125; rep(i,1,V) head[i]=0; ecnt=1,V=0; return ans&lt;=W;&#125;int main()&#123; freopen(&quot;soft.in&quot;,&quot;r&quot;,stdin),freopen(&quot;soft.out&quot;,&quot;w&quot;,stdout); n=rd(),m=rd(),W=rd(); int l=0,r=0,res=-1; rep(i,1,n) r+=t[i]=rd(); rep(i,1,n) c[i]=rd(); rep(i,1,m) X[i]=rd(),Y[i]=rd(); for(int mid;l&lt;=r;) Check(mid=(l+r)&gt;&gt;1)?r=mid-1,res=mid:l=mid+1; printf(&quot;%d\\n&quot;,res);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"有标号DAG计数","slug":"有标号DAG计数","date":"2021-03-22T10:15:09.000Z","updated":"2021-05-22T03:54:11.387Z","comments":true,"path":"articles/2021/03/22/31c608ff.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/22/31c608ff.html","excerpt":"","text":"有标号DAG计数题目大意：求$n$个点有标号弱连通$\\text{DAG}$数量 如果你做过类似 「CEOI2019」游乐园 这样常见的$\\text{DAG}$计数问题 就会对于统计$\\text{DAG}$数量的这个容斥方法十分熟悉 枚举图分层，设当前已经确定的层中点集为$S$，下一层点集为$T$ $dp_{S+T}\\leftarrow dp_{S}\\times 2^{|S|\\cdot |T|}(-1)^{|T|+1}$ 其中$|S|\\cdot |T|$为层间随意连的边数量，$(-1)^{|T|+1}$是针对分层不唯一的容斥 当然这样统计出的$\\text{DAG}$是不连通的 那么我们先考虑用卷积来维护这样的一个图 设分层大小为$a_i,i\\in[1,m],n=\\sum a_i$，则上式的变化形式就是 $\\displaystyle \\frac{\\displaystyle n!2^{\\binom{n} {2} }} {\\displaystyle \\prod a_i!(-1)^{a_i+1}2^{\\binom{a_i} {2} }}$ 其中$\\displaystyle \\binom{n} {2}-\\sum \\binom{a_i} {2}$就能得出层间边的数量 那么令$\\displaystyle F(x)=\\sum_{n\\ge 1}\\frac{(-1)^{n+1} } {n!2^{\\binom{n} {2} }}$ ，由于层间有序，答案是 $\\displaystyle G(x)=\\sum F^i(x)=\\frac{1} {1-F(x)}$ 求逆一次即可得到$G(x)$，然后补上式子中的系数$\\displaystyle 2^{\\binom{n} {2} }$ 显然不连通的$\\text{DAG}$转为连通$\\text{DAG}$只需要再求一次$\\ln $即可 注意计算的时候是以$\\text{EGF}$的形式，最后要补回阶乘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;typedef vector &lt;int&gt; V;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)#ifndef ONLINE_JUDGE#define LOG(...) fprintf(stderr,__VA_ARGS__)#else#define LOG(...) #endifchar IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int L=18,N=1&lt;&lt;L|10,P=998244353;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int I[N],J[N];int rev[N],w[N];void Init()&#123; w[1&lt;&lt;(L-1)]=1; int t=qpow(3,(P-1)&gt;&gt;L); rep(i,(1&lt;&lt;(L-1))+1,1&lt;&lt;L) w[i]=1ll*w[i-1]*t%P; drep(i,(1&lt;&lt;(L-1))-1,1) w[i]=w[i&lt;&lt;1]; rep(i,J[0]=1,N-1) J[i]=1ll*J[i-1]*i%P; I[N-1]=qpow(J[N-1]); drep(i,N-1,1) I[i-1]=1ll*I[i]*i%P;&#125;int Init(int n)&#123; int R=1,c=-1; while(R&lt;=n) R&lt;&lt;=1,c++; rep(i,0,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;c); return R;&#125;void NTT(int n,V &amp;A,int f) &#123; static ull a[N]; if((int)A.size()&lt;n) A.resize(n); rep(i,0,n-1) a[rev[i]]=A[i]; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=a[j+i]*e[j-l]%P; a[j+i]=a[j]+P-t; a[j]+=t; &#125; &#125; &#125; rep(i,0,n-1) A[i]=a[i]%P,Mod2(A[i]); if(f==-1) &#123; reverse(A.begin()+1,A.end()); ll base=1ll*I[n]*J[n-1]%P; rep(i,0,n-1) A[i]=A[i]*base%P; &#125;&#125;V operator + (V a,const V &amp;b) &#123; if(a.size()&lt;b.size()) a.resize(b.size()); rep(i,0,b.size()-1) a[i]+=b[i],Mod1(a[i]); return a;&#125;V operator - (V a,const V &amp;b) &#123; if(a.size()&lt;b.size()) a.resize(b.size()); rep(i,0,b.size()-1) a[i]-=b[i],Mod2(a[i]); return a;&#125;V operator * (V a,V b) &#123; int n=a.size()-1,m=b.size()-1; int R=Init(n+m); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=1ll*a[i]*b[i]%P; NTT(R,a,-1),a.resize(n+m+1); return a;&#125;void println(const V &amp;a)&#123; for(int i:a) printf(&quot;%d &quot;,i); puts(&quot;&quot;);&#125;V read(int n)&#123; V A(n); rep(i,0,n-1) A[i]=rd(); return A;&#125;V operator ~ (V a) &#123; int n=a.size(),m=(n+1)&gt;&gt;1; if(n==1) return &#123;(int)qpow(a[0])&#125;; V b=a; b.resize(m),b=~b; int R=Init(n*2); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=(P+2-1ll*a[i]*b[i]%P)*b[i]%P; NTT(R,a,-1),a.resize(n); return a;&#125;V Deriv(V a) &#123; rep(i,0,a.size()-2) a[i]=1ll*(i+1)*a[i+1]%P; a.pop_back(); return a;&#125;V Integ(V a)&#123; a.pb(0); drep(i,a.size()-1,1) a[i]=1ll*a[i-1]*J[i-1]%P*I[i]%P; a[0]=0; return a;&#125;V Ln(V a)&#123; int n=a.size(); a=Deriv(a)*~a; return a.resize(n-1),Integ(a);&#125;int Div2(int x)&#123; return (x&amp;1?x+P:x)/2; &#125;int Pow[N],IPow[N];int main()&#123; int n=rd(); Init(); Pow[0]=Pow[1]=IPow[0]=IPow[1]=1; for(int i=2,x=2,y=(P+1)/2;i&lt;N;i++,x*=2,Mod1(x),y=Div2(y)) &#123; Pow[i]=1ll*Pow[i-1]*x%P; IPow[i]=1ll*IPow[i-1]*y%P; &#125; V F(n+1); rep(i,1,n) &#123; F[i]=1ll*I[i]*IPow[i]%P; if(~i&amp;1) F[i]=-F[i],Mod2(F[i]); // 这个是容斥系数 F[i]=P-F[i];// 这个是1-F &#125; // 这个是1-F F[0]=1; F=~F; rep(i,0,n) F[i]=1ll*F[i]*Pow[i]%P; // 补回系数，然后做一次ln F=Ln(F); rep(i,0,n) F[i]=1ll*F[i]*J[i]%P; rep(i,1,n) printf(&quot;%d\\n&quot;,F[i]);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"[AtCoder Regular Contest 115]  D","slug":"[AtCoder Regular Contest 115]  D","date":"2021-03-22T07:48:58.000Z","updated":"2021-05-22T03:54:11.015Z","comments":true,"path":"articles/2021/03/22/ba67d282.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/22/ba67d282.html","excerpt":"","text":"AtCoder Regular Contest 115 #DSolution1考虑用$\\text{FWT}$来理解这个式子，容易发现$\\text{FWT}$之后求积的式子，满足 对于任意$(u_i,v_i)$ 如果$u_i,v_i$中有一者被选择，答案为0，否则权值$\\times 2$ 那么显然对于一个连通块，设其大小为$c$，放在一起考虑 在$\\text{FWT}$的式子里它们同时出现或者同时不出现 枚举最后$\\text{FWT}$回来时的项与在这$c$个位置中出现$i$个 对于选择这个连通块的情况，贡献为$(-1)^i$ 对于不选的情况，贡献为$1$ 显然只有$2|i$时贡献为2，乘上组合数完成转移，连通块之间背包合并 就能得到最终计算答案的项中出现了几个1，然后与$\\text{FWT}$的系数合并即可 \\Solution2对于一个连通块，考虑取出一个生成树 容易发现，仅使用这个生成树上的边，就能构成任何一个包含$2k$个奇点的情况 对于多余的边，类似异或线性基，它们都是可选可不选的 于是直接统计答案即可 Sol1 和 Sol2 的式子是一样的 123456789101112131415161718192021222324252627282930313233343536const int N=5010,P=998244353;int n,m,dp[N];ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;vector &lt;int&gt; G[N];int c,vis[N],C[N][N];void dfs(int u)&#123; if(vis[u]) return; vis[u]=1,c++; for(int v:G[u]) dfs(v);&#125;int main()&#123; n=rd(),m=rd(); rep(i,0,n) rep(j,*C[i]=1,i) C[i][j]=C[i-1][j]+C[i-1][j-1],Mod1(C[i][j]); rep(i,1,m) &#123; int u=rd(),v=rd(); G[u].pb(v),G[v].pb(u); &#125; dp[0]=1; rep(u,1,n) if(!vis[u]) &#123; c=0,dfs(u); drep(i,n,0) &#123; int s=0; rep(j,0,min(i,c)) if(~j&amp;1) &#123; s=(s+2ll*dp[i-j]*C[c][j])%P; &#125; dp[i]=s; &#125; &#125; int d=qpow(2,P-1-n+m); rep(i,0,n) printf(&quot;%d\\n&quot;,int(1ll*dp[i]*d%P));&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"Nimber系列略学习笔记","slug":"Nimber系列略学习笔记","date":"2021-03-17T08:18:28.000Z","updated":"2021-05-22T03:54:10.984Z","comments":true,"path":"articles/2021/03/17/248a1c21.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/17/248a1c21.html","excerpt":"","text":"Nimber系列略学习笔记前言$\\text{Nim+Number=Nimber}$ 基于我们熟悉的博弈问题$\\text{Nim}$问题，我们定义了多$\\text{Nim}$问题的和，即$\\text{Nim}$和 我们知道$\\text{Nim}$和就是异或运算，为了构成一个更完整的$\\text{Number}$域，又引入一种新的运算 即$\\text{Nim}$积 \\\\定义对于在$[0,2^{2^m})$上的整数，定义两种$\\text{Nim}$运算，构成一个封闭的域 1.$\\text{Nim}$和$\\oplus$，$\\displaystyle x\\oplus y=\\text{mex} \\{ \\{a\\oplus y|a&lt;x\\}\\cup\\{x\\oplus b|b&lt;y\\} \\}$ 其中对于非负整数集合的$\\text{mex}$运算即求不在集合中的最小非负整数 也就是$\\text{Nim}$游戏的”和” \\2.$\\text{Nim}$积$\\otimes$ 需要先介绍高维$\\text{Nim}$游戏 对于一维情况： 数轴上整点处有若干黑点$x_i$，每次操作可以选择一个黑点$x_i$，找到$a&lt;x_i$ 将线段$[a,x_i]$两端点的黑白翻转 对于二维情况： 平面上整点处有若干黑点$(x_i,y_i)$，每次选择一个黑点$(x_i,y_i)$，找到另一个点$(a,b),a&lt;x_i,b&lt;y_i$ 将矩形$(a,b)-(x_i,y_i)$四个顶点的颜色翻转 对于三维情况： 空间上整点处有若干黑点$(x_i,y_i,z_i)$，每次选择一个黑点$(x_i,y_i,z_i)$，找到另一个点$(a,b,c),a&lt;x_i,b&lt;y_i,c&lt;z_i$ 将长方体$(a,b,c)-(x_i,y_i,z_i)$八个顶点的颜色翻转 $\\ldots$ $\\text{Nim}$积是高维$\\text{Nim}$游戏的降维操作，显然各个维度之间无序，每个黑点之间可以通过$\\text{Nim}$和相加 由此定义在二维$\\text{Nim}$游戏上的$\\text{Nim}$积运算 $x\\otimes y=\\text{mex} \\{(a\\otimes y)\\oplus (x\\otimes b)\\oplus(a\\otimes b)|a&lt;x,b&lt;y\\}$ 相较于$\\text{Nim}$和，$\\text{Nim}$积运算十分复杂，需要若干性质简化运算 1.基础运算律 $x\\otimes 1=x$ $x\\otimes y=y\\otimes x$ $(x\\otimes y)\\otimes z=x\\otimes (y\\otimes z)$ 2.$2^{2^n}\\otimes 2^{2^m}=\\left\\{\\begin{aligned}2^{2^n+2^m} && n\\ne m\\\\ 3\\cdot 2^{2^n-1} && n=m\\end{aligned}\\right.$ 3.$2^{2^n}\\otimes x=2^{2^n}\\times x\\ (x&lt;2^{2^n})$ 对于$x,y\\in [0,2^{2^m})$，利用性质3，用减半的方法优化运算，令$n=2^{m-1}$ $x=a\\cdot 2^n+b,y=c\\cdot 2^n+d,a,b,c,d\\in[0,2^n)$ $x\\otimes y=(a\\otimes 2^n\\oplus b)\\otimes (c\\otimes 2^n\\oplus d)$ $=((a\\otimes c)\\otimes (3\\cdot 2^{n-1}))\\oplus (2^n\\cdot ((a\\otimes d)\\oplus (b\\otimes c))\\ ) \\oplus (b\\otimes d)$ $=((a\\otimes c)\\otimes (2^{n}\\oplus 2^{n-1}))\\oplus (2^n\\cdot ((a\\otimes d)\\oplus (b\\otimes c))\\ ) \\oplus (b\\otimes d)$ $=((a\\otimes c)\\otimes 2^{n-1})\\oplus (2^n\\cdot ((a\\otimes c)\\oplus (a\\otimes d)\\oplus (b\\otimes c))\\ ) \\oplus (b\\otimes d)$ $=((a\\otimes c)\\otimes 2^{n-1})\\oplus (2^n\\cdot ((a\\oplus b)\\otimes (c\\oplus d)\\oplus (b\\otimes d))) \\oplus (b\\otimes d)$ 由此进行暴力递归需要依次计算$a\\otimes c,(a\\otimes c)\\otimes 2^{n-1},b\\otimes d,(a\\oplus b)\\otimes (c\\oplus d)$ 复杂度为$O(4^{m})$，由于$2^{n-1}$ 对于$2^{32}$以内的运算，即$m=5$，看起来已经可以接受? \\\\应用原根的优化$\\text{Nimber}$域内是存在原根的，$[0,2^{16})$域内最小的原根是$258$ 如果预处理出$[0,2^{16})$以内所有数的原根指标和乘法表，即可$O(1)$查询$[0,2^{16})$任意数的$\\text{Nimber}$积 由此也可以仅通过一次递归计算$[0,2^{32})$域内的$\\text{Nimber}$积 \\\\更多运算对于$[0,2^{2^m})$域内的$\\text{Nimber}$，由性质$x^{2^m}=x$导出的运算有 $\\displaystyle \\frac{1} {x}=x^{2^m-2}$ $\\sqrt x=x^{2^{m-1} }$","categories":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}]},{"title":"「JOISC 2020 Day4」传奇团子师傅 (假模拟退火)","slug":"「JOISC 2020 Day4」传奇团子师傅 (假模拟退火)","date":"2021-03-17T06:58:40.000Z","updated":"2021-05-22T03:54:11.212Z","comments":true,"path":"articles/2021/03/17/9c175b12.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/17/9c175b12.html","excerpt":"","text":"「JOISC 2020 Day4」传奇团子师傅 (假模拟退火)感觉每次想写模拟退火，调着调着就不知道变成什么东西了 首先是分析原图，每个方案对应选择三个点，不同的方案之间显然存在排斥关系 将这些关系建立成边，问题就转化为一个 一般图最大独立集 问题 这怎么搞得定。。 因此考虑退火，每次操作随机选择一个点，检查周围的点是否选择，数一下如果自己被选，要弹掉的点的个数 同普通的退火，一开始温度高不停随机 到了后面就直接变成 选择答案不劣的方案（也就是交换两个点），事实证明这样的效率比较高 但是直接随机容易随机到选过的点，需要稍微加速一下 具体的，退火每若干次为一轮，每轮随机一个排列 在排列中从左到右找到前面$L$个未选点，然后在$L$个点中随机若干次进行决策 我是直接暴力bitset存答案的，但是效率好像还可以 因为是跑一个点调一次参数的，前面的代码都没存。。。 tips:代码对于不同数据需要修改前面三行的常量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100const int N=510,M=N*N/2,INF=1e9+10;const char infile[]=&quot;5.in&quot;,outfile[]=&quot;output_05.txt&quot;;const int MAX=48620;int n,m,C;char s[N][N];int chk(char x)&#123; return x==&#x27;P&#x27; || x==&#x27;G&#x27;; &#125;struct Node&#123; int x,y,t;&#125; R[M];bitset &lt;M&gt; Ansmap,Nowmap;int ans,now;int z[4][2]=&#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;-1,-1&#125;,&#123;-1,1&#125; &#125;;char S[]=&quot;-|\\\\/&quot;;vector &lt;int&gt; G[N][N],E[M];struct Naive_Simulator&#123; ~Naive_Simulator()&#123; cerr&lt;&lt;&quot;!&quot;&lt;&lt;endl; rep(i,1,C) if(Ansmap[i]) s[R[i].x][R[i].y]=S[R[i].t]; rep(i,1,n) puts(s[i]+1); &#125; int P[M],D[M],F[M],PC,counter,lst,L; void Work(db T,db d,db End,int delta) &#123; while(T&gt;End &amp;&amp; ans&lt;MAX) &#123; if(++counter%4000==0) &#123; cerr&lt;&lt;ans&lt;&lt;&#x27; &#x27;&lt;&lt;T&lt;&lt;endl; &#125; if(counter%500==0) random_shuffle(D+1,D+C+1),lst=1; PC=0; rep(i,lst,C) if(!Nowmap[D[i]]) &#123; P[++PC]=D[i]; lst=i; if(PC&gt;=L) break; &#125; if(PC&lt;L) &#123; lst=1; PC=0; rep(i,lst,C) if(!Nowmap[D[i]]) &#123; P[++PC]=D[i]; lst=i; if(PC&gt;=L) break; &#125; &#125; rep(kase,1,50) &#123; int u,v; u=P[rand()%PC+1],v=P[rand()%PC+1]; if(u==v || Nowmap[u]) &#123; kase--; continue; &#125; int cnt=0; for(int v:E[u]) cnt+=Nowmap[v]; if(cnt-delta&lt;=T) &#123; Nowmap[u]=1; for(int v:E[u]) Nowmap[v]=0; now+=1-cnt; &#125; if(kase%5==0 &amp;&amp; now&gt;ans) ans=now,Ansmap=Nowmap; &#125; T*=d; &#125; &#125; void Simulate()&#123; //srand(114514); //srand(1919810); srand(time(NULL)); now=0,Nowmap.reset(); counter=0,lst=1,L=200; rep(i,1,C) D[i]=i; rep(kase,1,10) Work(2,0.95,1e-2,1); Work(0.99,0.99993,1e-8,2); Nowmap=Ansmap,now=ans; Work(0.99,0.99999,0,1); return; &#125; Naive_Simulator()&#123; freopen(infile,&quot;r&quot;,stdin),freopen(outfile,&quot;w&quot;,stdout); n=rd(),m=rd(); rep(i,1,n) scanf(&quot;%s&quot;,s[i]+1); rep(i,1,n) rep(j,1,m) if(!chk(s[i][j])) &#123; s[i][j]=&#x27;W&#x27;; rep(d,0,3) if(chk(s[i+z[d][0]][j+z[d][1]]) &amp;&amp; chk(s[i-z[d][0]][j-z[d][1]]) &amp;&amp; s[i+z[d][0]][j+z[d][1]]!=s[i-z[d][0]][j-z[d][1]]) &#123; R[++C]=(Node)&#123;i,j,d&#125;; G[i][j].pb(C); G[i+z[d][0]][j+z[d][1]].pb(C); G[i-z[d][0]][j-z[d][1]].pb(C); &#125; &#125; rep(i,1,n) rep(j,1,m) rep(k,0,G[i][j].size()-1) rep(l,k+1,kend) &#123; E[G[i][j][k]].pb(G[i][j][l]); E[G[i][j][l]].pb(G[i][j][k]); &#125; Simulate(); &#125;&#125; Solver;int main()&#123; ; &#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"JOI","slug":"JOI","permalink":"http://chasingdeath.github.io/tags/JOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「JOISC 2020 Day4」首都城市","slug":"「JOISC 2020 Day4」首都城市","date":"2021-03-17T06:17:35.000Z","updated":"2021-05-22T03:54:11.214Z","comments":true,"path":"articles/2021/03/17/77ce1303.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/17/77ce1303.html","excerpt":"","text":"「JOISC 2020 Day4」首都城市题目大意：给定一棵树，每个点有颜色 求选择一个最小的颜色集合，使得这些颜色的点能够构成一个连通块 容易发现，选取这个颜色就必须将这个颜色连通路径上的所有其它颜色选掉 但是要纠正一个： 并不是选取的这个颜色的连通路径上的颜色就行 因为选取另一个颜色，可能导致不在当前连通路径上的其它颜色也需要被选取 \\这样的关系构成一个有向图，一条边表示选了$u$就选$v$ 因此可以考虑$\\text{tarjan}$强连通缩点，由于最终我们选择强连通分量一定没有出边（否则不优） 因此可以线性统计答案，问题在于如何建立这个图 首先考虑如何将这个连通路径提取出来，一种简单的办法是：找到这个颜色所有点的$\\text{LCA}$，路径就可以表示为$\\text{LCA}$到所有点路径的并 Solution1树剖线段树完成路径连边 点数为$O(n)$，边数为$O(n\\log ^2n)$ Solution2倍增连边 点数边数均为$O(n\\log n)$ Solution3离线，用类似$\\text{tarjan LCA}$的方式，维护一个并查集 每次并查集的父亲关系改变时，新建节点，即可完成一个类似可持久化的操作 如果再用$\\text{tarjan}$预处理$\\text{LCA}$，复杂度/点数/边数 就为$O(n\\alpha(n))$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair &lt;int,int&gt; Pii;#define pb push_back#define mp make_pair#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;char buf[200000],*p1,*p2;#define getchar() (((p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,200000,stdin))),*p1++)int rd()&#123; int s=0;static char c; while(c=getchar(),c&lt;48); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(c^&#x27;0&#x27;); while(c=getchar(),c&gt;47); return s;&#125;const int N=2e5+10,INF=1e9+10,K=N*3.5;int n,k,m;int A[N],L[N],F[N],C[N],Fir[N],I[N];vector &lt;int&gt; G[N],V[N];struct Edge&#123; int to,nxt; &#125; e[K*2];int head[K],ecnt;void AddEdge(int u,int v)&#123; if(u==v) return; e[++ecnt]=(Edge)&#123;v,head[u]&#125;; head[u]=ecnt;&#125;int Find1(int x)&#123; return F[x]==x?x:F[x]=Find1(F[x]); &#125;void pre_dfs(int u,int f)&#123; F[u]=u; if(!Fir[A[u]]) Fir[A[u]]=u; if(--C[A[u]]==0) L[A[u]]=Find1(Fir[A[u]]); for(int v:G[u]) if(v!=f) pre_dfs(v,u); F[u]=f;&#125;Pii Find(int x)&#123; if(F[x]==x) return mp(F[x],I[x]); Pii t=Find(F[x]); return AddEdge(++m,t.second),AddEdge(m,I[x]),F[x]=t.first,mp(F[x],I[x]=m);&#125;void dfs(int u,int f)&#123; F[u]=u,I[u]=A[u]; for(int v:G[u]) if(v!=f) dfs(v,u); for(int v:V[u]) AddEdge(A[v],Find(v).second); F[u]=f;&#125;int t[K],low[K],ins[K],stk[K],top,dfn;int ans=1e9,vis[N],out[K];void dfs(int u)&#123; t[u]=low[u]=++dfn,ins[stk[++top]=u]=1; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].to; if(!t[v]) dfs(v),cmin(low[u],low[v]); else if(ins[v]) cmin(low[u],t[v]); &#125; if(low[u]==t[u])&#123; int fl=1,tmp=top; for(int v=-1;v!=u;)&#123; v=stk[top--]; for(int i=head[v];i;i=e[i].nxt) if(!ins[e[i].to]) &#123; fl=0; break; &#125; &#125; rep(i,top+1,tmp) ins[stk[i]]=0; if(fl) &#123; int res=0; rep(i,top+1,tmp) &#123; int x=stk[i]; if(x&lt;=k &amp;&amp; !vis[x]) vis[x]=1,res++; &#125; rep(i,top+1,tmp) if(stk[i]&lt;=k) vis[stk[i]]=0; if(res) cmin(ans,res-1); &#125; &#125;&#125;int main()&#123; n=rd(),k=rd(); rep(i,2,n) &#123; int u=rd(),v=rd(); G[u].pb(v),G[v].pb(u); &#125; rep(i,1,n) C[A[i]=rd()]++; pre_dfs(1,0); rep(i,1,n) V[L[A[i]]].pb(i); m=k; dfs(1,0); rep(i,1,k) if(!t[i]) dfs(i); printf(&quot;%d\\n&quot;,ans); fprintf(stderr,&quot;Vertices =%d \\nEdges =%d\\n&quot;,m,ecnt);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"JOI","slug":"JOI","permalink":"http://chasingdeath.github.io/tags/JOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「ZJOI2020」抽卡","slug":"「ZJOI2020」抽卡","date":"2021-03-14T13:29:16.000Z","updated":"2021-05-22T03:54:11.282Z","comments":true,"path":"articles/2021/03/14/995ef261.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/14/995ef261.html","excerpt":"","text":"「ZJOI2020」抽卡Sub1: 从$n$张卡中选取钦定的$m$张的期望次数令$f_m$表示期望次数，显然$m&gt;0,f_m=\\frac{(n-m)f_m+mf_{m-1} } {n}+1$ 即$f_0=0,f_m=f_{m-1}+\\frac{n} {m}$ 即$\\displaystyle f_m=\\sum_{i=1}^m \\frac{n} {i}$ Minmax容斥转化回到原问题的$a_1,a_2,\\ldots,a_m$，按照连续$k$个分段，设每段开始点$A_i$ 我们要求这些$[A_i,A_i+k)$第一次有一个被满足的期望，这难以解决 用一个$\\text{minmax}$容斥处理掉 $\\displaystyle \\min\\{\\exists A_i合法\\}=(-1)^{T+1}\\sum_{T\\subset S} \\max\\{\\forall i\\in T,A_i合法\\}$ 这个$\\text{max}$显然取决于$A_i$并的长度 令$dp_{i,j}$表示当前最大的选择点为$i$，选择的总长度为$j$，容易用前缀和优化到$O(n^2)$ \\优化求解容易想到对于每个长度$\\ge k$的连续段分别求解，然后分治$\\text{NTT}$背包合并 此时我们要对于连续$n$个元素可以选择的子问题求解答案生成函数$F_n(x)$ \\推论：对于某一个长度$L \\in[k+2,2k]$的且已经确定都选择的段，其容斥系数为0考虑此时，收尾两个段必须选择，而中间的段(个数$&gt;0$)随意选择 由等式$\\sum {T\\in S} (-1)^{|T|}=[S=\\empty]$可知，其系数为0 观察一下我们能由这个推论得到什么 令$dp_{n}$表示顺次覆盖前$n$个元素的系数 $dp_{k}=-1,dp_{k+1}=-dp_{k}=1$ $\\forall i\\in[k+2,2k],dp_i=0$ $dp_{2k+1}=-dp_{k+1}=-1$ $dp_{2k+2}=-dp_{2k+1}=1$ 想必睿智的你一定已经发现了，$dp$数组$k+1$一循环 实际上根据这个性质的暴力$dp$可以多10pts 由于$dp_{k+1}=1$，也可以表示为$dp_{i}=dp_{k+1}\\cdot dp_{i-k-1}$ 因此可以把连续段的前$k+1$个分裂开来，假装不连续 此时，我们可以简单描述为： 每次选择的是一个长度为$k+1$的段 可以覆盖前$k$个，系数为$-1$ 也可以覆盖$k+1$个，系数为$1$ 并且这$k+1$个段不能相交，可以相邻 根据这样的决策，计算系数可以分为两步 $n$个元素选出$i$个长度为$k+1$的段，剩下的元素可以分配到这$i+1$个间隔中 方案数为$\\displaystyle \\binom{n-i(k+1)+i+1-1} {i+1-1}=\\binom{n-ik} {i}$ 一开始令这些段都选择前$k$个，然后对于某一些可以额外选择最后一个，乘上$-x$ 由此我们列出$\\text{OGF}$表达式 $\\displaystyle G_n(x)=\\sum_{i=0}^{\\frac{n} {k+1} } (-1)^i\\binom{n-ik} {i}x^{ik}(1-x)^i$ $\\displaystyle G_n(x)=\\sum_{i=0}^{\\frac{n} {k+1} } \\binom{n-ik} {i}x^{ik}(x-1)^i$ 注意边界情况是最后$k$个被选的情况不会算进去，因此实际上 $F_n(x)=G_n(x)-x^kG_n(n-k)$ 考虑如何计算$G_n(x)$ 我们对于所有的$i$分治，分治到区间$[l,r]$时，我们维护的是 $\\displaystyle \\sum_{i=l}^{r} \\binom{n-ik} {i}x^{(i-l)k}(x-1)^{(i-l)}$ 这样就能保证分治时，区间内多项式长度为$O((r-l+1)(k+1))$ 合并时，给右区间补上$x^{(mid-l+1)k}(x-1)^{mid-l+1}$即可 因此计算$F_n(x)$和合并$F_n(x)$的复杂度均为$O(n\\log ^2n)$ 不$sort$有80pts.jpg 代码好看就完事了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=1&lt;&lt;18|10,P=998244353;int n,k;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int rev[N],I[N],J[N];typedef vector &lt;int&gt; V;void Init()&#123; rep(i,J[0]=1,N-1) J[i]=1ll*J[i-1]*i%P; I[N-1]=qpow(J[N-1]); drep(i,N-1,1) I[i-1]=1ll*I[i]*i%P;&#125;int Init(int n)&#123; int R=1,c=-1; while(R&lt;=n) R&lt;&lt;=1,c++; rep(i,0,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;c); return R;&#125;void NTT(int n,V &amp;a,int f) &#123; static int e[N&gt;&gt;1]; rep(i,0,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int i=e[0]=1;i&lt;n;i&lt;&lt;=1) &#123; ll t=qpow(f==1?3:(P+1)/3,(P-1)/i/2); for(int j=i-2;j&gt;=0;j-=2) e[j+1]=(e[j]=e[j&gt;&gt;1])*t%P; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*e[j-l]*a[j+i]%P; a[j+i]=a[j]-t,Mod2(a[j+i]); a[j]+=t,Mod1(a[j]); &#125; &#125; &#125; if(f==-1) &#123; ll Inv=1ll*I[n]*J[n-1]%P; rep(i,0,n-1) a[i]=a[i]*Inv%P; &#125;&#125;V operator * (V a,V b)&#123; if(!a.size() || !b.size()) return &#123; &#125;; int n=a.size()+b.size()-1,R=Init(n); a.resize(R),b.resize(R); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=1ll*a[i]*b[i]%P; NTT(R,a,-1); a.resize(n); return a;&#125;V operator + (V a,V b)&#123; if(a.size()&lt;b.size()) swap(a,b); rep(i,0,b.size()-1) a[i]+=b[i],Mod1(a[i]); return a;&#125;V operator - (V a,const V &amp;b)&#123; if(a.size()&lt;b.size()) a.resize(b.size()); rep(i,0,b.size()-1) a[i]-=b[i],Mod2(a[i]); return a;&#125;V operator &lt;&lt; (V a,const int &amp;x)&#123; a.resize(a.size()+x); drep(i,a.size()-1,x) a[i]=a[i-x]; rep(i,0,x-1) a[i]=0; return a;&#125;int C(int n,int m)&#123; return n&lt;0||m&lt;0||n&lt;m?0:1ll*J[n]*I[m]%P*I[n-m]%P; &#125;V Binom(int n)&#123; V A(n+1); rep(i,0,n) A[i]=(n-i)&amp;1?P-C(n,i):C(n,i); return A;&#125;V Solve(int n,int l,int r)&#123; if(l==r) return &#123;C(n-l*k,l)&#125;; int mid=(l+r)&gt;&gt;1; return Solve(n,l,mid)+((Solve(n,mid+1,r)*Binom(mid-l+1))&lt;&lt;(k*(mid-l+1)));&#125;V GetG(int n)&#123; return Solve(n,0,n/(k+1)); &#125;V GetF(int n)&#123; return GetG(n)-(GetG(n-k)&lt;&lt;k); &#125;vector &lt;V&gt; T;V Solve(int l=0,int r=T.size()-1)&#123; if(l==r) return T[l]; int mid=(l+r)&gt;&gt;1; return Solve(l,mid)*Solve(mid+1,r);&#125;int A[N];int main()&#123; Init(),n=rd(),k=rd(); rep(i,1,n) A[i]=rd(); sort(A+1,A+n+1); rep(i,1,n) &#123; int j=i; while(A[j+1]==A[j]+1) j++; if(j-i+1&gt;=k) T.pb(GetF(j-i+1)); i=j; &#125; V Res=Solve(); int s=0,ans=0; rep(i,1,Res.size()-1)&#123; s=(s+1ll*n*I[i]%P*J[i-1])%P; ans=(ans+1ll*s*Res[i])%P; &#125; ans=(P-ans)%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"JOI","slug":"JOI","permalink":"http://chasingdeath.github.io/tags/JOI/"},{"name":"各省OI","slug":"各省OI","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E7%9C%81OI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CF Round 698 Div1. Nezzar and Chocolate Bars","slug":"CF Round 698 Div1. Nezzar and Chocolate Bars","date":"2021-03-14T07:05:05.000Z","updated":"2021-05-22T03:54:10.750Z","comments":true,"path":"articles/2021/03/14/c23c1321.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/14/c23c1321.html","excerpt":"","text":"CF Round#698 Div1. Nezzar and Chocolate Bars前言这就是大道至简吗。。 为什么和某ZJOI开关一样，到最后就是个背包。。 题目大意：给定$n,K$和一些棍子长度为$l_i(i\\in [1,n])$（实数！） 每次随机选择一根棍子，概率与$l_i$成正比，然后随机分裂成两段（实数！） 一直分裂，直到每根棍子$l_i\\leq K$，求期望分裂次数 \\根据题意容易归纳一个更直观的模型： 把这些$l_i$排在数轴上，初始时，点集为$0,l_1,l_1+l_2,\\ldots$ 每次随机在数轴上撒一个点，直到点集中相邻两点距离$\\leq K$为止 考虑从简单情况入手 \\n=1单棍情况，设长度为$L$，考虑期望的简单等价变换 $\\displaystyle E(\\text{条件第一次成立操作数})=\\sum_{i=0}^{\\infty} P(i次操作条件未成立)$ 设$P_n$为操作$n$次成立（不是恰好）的概率 (变量名重了不要介意) 设$n$次操作后的点集排列之后为$X_i$，其中$X_0=0,X_{n+1}=L$ 我们要求$\\forall i\\in[1,n+1],Z_i=X_i-X_{i-1}\\leq K$，考虑用一个二项式反演来解决这个计算 设$W=\\lfloor \\frac{L} {K}\\rfloor$ $\\displaystyle P_n=\\frac{1} {L^n}\\sum_{i=0}^{W} (-1)^i\\binom{n+1} {i}(L-iK)^n$ 其意义即为从分成的$n+1$个$Z_i$中选择$i$个强制不合法，然后剩下的随意分布，由此计算概率 \\一般情形考虑一样的期望转概率，设$p_m$为$m$次完成的概率，$q_m=1-p_m$ $\\displaystyle q_m=\\sum_{j_1+j_2+\\cdots +j_n=m} \\frac{m!} {j_1!j_2!\\cdots j_n!}\\prod (\\frac{l_i} {\\sum l_k})^{j_i}P_{i,j_i}$ 显然这里考虑用$\\text{EGF}$积的形式来表示，设$S=\\sum l_i$ 回到上一步，这里我们对于$i,l_i$计算其$P_n$加上$\\frac{l_i} {S}$系数的$\\text{EGF}$，沿用上面的$L=l_i$ $\\displaystyle F_i(x)=\\text{EGF(P)}=\\sum_{n\\ge 0}\\frac{1} {n!}(\\frac{L} {S})^n\\sum_{i=0}^W(-1)^{i}\\binom{n+1} {i}(1-i\\frac{K} {L})^{n}x^n$ $\\displaystyle F_i(x)=\\sum_{n\\ge 0}\\frac{1} {n!}\\sum_{i=0}^W(-1)^{i}\\binom{n+1} {i}(\\frac{L-iK} {S})^{n}x^n$ 设$\\displaystyle u=\\frac{L-iK} {S}x$ $\\displaystyle F_i(x)=\\sum_{i=0}^W\\frac{(-1)^{i} } {i!}\\sum_{n\\ge i-1}\\frac{n+1} {(n+1-i)!}u^n$ 令$n’=n+1-i$，$n=n’+i-1$，将$n’$带入 $\\displaystyle F_i(x)=\\sum_{i=0}^W\\frac{(-1)^{i} } {i!}\\sum_{n\\ge 0}\\frac{n+i} {n!}u^{n+i-1}$ 将$n,i$拆开 $\\displaystyle F_i(x)=\\sum_{i=0}^W \\frac{(-1)^{i} } {i!}(u^{i}\\sum_{n\\ge 0}\\frac{1} {n!}u^{n}+u^{i-1}\\sum_{n\\ge 0}\\frac{i} {n!}u^{n})$ $\\displaystyle F_i(x)=\\sum_{i=0}^W \\frac{(-1)^{i} } {i!}(u^{i}+iu^{i-1})e^u$ 容易发现我们需要多项式是$F(x)=e^x-\\prod F_i(x)$ 最终$F(x)$的每一项，都会是$x^k e^{cx}$的形式 其中$e^u$中的$u$总是$\\frac{1} {S}(L-iK)x$，合并之后$L$之和总是存在，记录$\\sum i$即可，为$O(S)$ 而每项要么是$u^ie^u$要么是$u^{i-1}e^u$，可以考虑记录一下$u^{i-1}e^u$出现的次数，为$O(n)$ 我们的多项式项数是$O(nS)$的 \\最终我们还需要对于每一项计算答案 我们要计算$\\displaystyle \\sum_{n\\ge 0}n![x^n]F(x)$，考虑形如$x^ke^{cx}$一项的贡献 $\\displaystyle \\sum_{n\\ge k}n=\\sum_{n\\ge k}\\frac{n!} {(n-k)!}c^{n-k}=k!\\sum_{n\\ge 0}\\binom{n+k} {n}c^{n}$ 由于$\\displaystyle \\binom{n+k} {n}=(-1)^{n}\\binom{-k-1} {n}$ 带入广义二项式定理得到 $\\displaystyle k!\\sum_{n\\ge 0}\\binom{n+k} {n}c^{n}=k!(1-c)^{-k-1}$ 根据是否用$\\text{NTT}$优化，复杂度会有所不同 over. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;typedef long double ldb;typedef long long ll;typedef unsigned long long ull;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,const T &amp;b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,const T &amp;b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1&lt;&lt;11|10,P=998244353;int n,m,k;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int rev[N],I[N],J[N];typedef vector &lt;int&gt; V;void Init()&#123; rep(i,J[0]=1,N-1) J[i]=1ll*J[i-1]*i%P; I[N-1]=qpow(J[N-1]); drep(i,N-1,1) I[i-1]=1ll*I[i]*i%P;&#125;int Init(int n)&#123; int R=1,c=-1; while(R&lt;=n) R&lt;&lt;=1,c++; rep(i,0,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;c); return R;&#125;void NTT(int n,V &amp;a,int f) &#123; static int e[N&gt;&gt;1]; rep(i,0,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int i=e[0]=1;i&lt;n;i&lt;&lt;=1) &#123; ll t=qpow(f==1?3:(P+1)/3,(P-1)/i/2); for(int j=i-2;j&gt;=0;j-=2) e[j+1]=(e[j]=e[j&gt;&gt;1])*t%P; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*e[j-l]*a[j+i]%P; a[j+i]=a[j]-t,Mod2(a[j+i]); a[j]+=t,Mod1(a[j]); &#125; &#125; &#125; if(f==-1) &#123; ll Inv=1ll*I[n]*J[n-1]%P; rep(i,0,n-1) a[i]=a[i]*Inv%P; &#125;&#125;V operator * (V a,V b)&#123; if(!a.size() || !b.size()) return &#123; &#125;; int n=a.size()+b.size()-1,R=Init(n); a.resize(R),b.resize(R); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=1ll*a[i]*b[i]%P; NTT(R,a,-1); a.resize(n); return a;&#125;V operator + (V a,V b)&#123; if(a.size()&lt;b.size()) swap(a,b); rep(i,0,b.size()-1) a[i]+=b[i],Mod1(a[i]); return a;&#125;V F[55],A,B;int S,L[55];int main()&#123; Init(); n=rd(),k=rd(); rep(i,1,n) S+=L[i]=rd(); sort(L+1,L+n+1); int InvS=qpow(S); F[0]=&#123;1&#125;; rep(i,1,n) &#123; int W=(L[i]-1)/k; A.clear(),A.resize(W+1); B.clear(),B.resize(W+1); // 注意 L[i]==j*k &amp;&amp; j==1 时会出现side condition // 也就是 L=k=1 的情况 rep(j,0,W) &#123; int w=1ll*(L[i]-j*k)*InvS%P; A[j]=1ll*(j&amp;1?P-I[j]:I[j])*qpow(w,j)%P; if(j) B[j]=1ll*(j&amp;1?P-I[j]:I[j])*qpow(w,j-1)%P*j%P; &#125; drep(j,i,0) &#123; if(!j) F[j]=F[j]*A; else F[j]=F[j]*A+F[j-1]*B; &#125; &#125; // 就硬乘。。 // 如果分治合并每个，复杂度变为log n int ans=0; rep(i,0,n) &#123; rep(j,max(i,1),F[i].size()-1) if(F[i][j]) &#123; int k=j-i; ans=(ans+1ll*F[i][j]*J[k]%P*qpow(1ll*j*::k*InvS%P,P-1-k-1))%P; &#125; &#125; ans=(P-ans)%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://chasingdeath.github.io/tags/Codeforces/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「JOISC 2020 Day3」收获","slug":"「JOISC 2020 Day3」收获","date":"2021-03-13T05:37:42.000Z","updated":"2021-05-22T03:54:11.206Z","comments":true,"path":"articles/2021/03/13/81e7c75e.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/13/81e7c75e.html","excerpt":"","text":"「JOISC 2020 Day3」收获分类讨论.jpg 分析一棵苹果树被不断摘掉的过程，找到第一个摘它的人$i$ 此后，每次摘它的人，就是$i$前面第一个距离它$\\ge C$的人，不妨设其为$nxt_i$ 显然，$i,nxt_i$的关系，会构成基环内向树森林，每条内向边有一个权值$w_i$ 容易$O(n)$尺取得到$nxt_i,w_i$，考虑选择环上的一个点$u$，断开$u$对应的内向边，得到一棵树 处理得到环长$len_u$，令$dis_u=w_u$，树上每个点的$dis_v=dis_{nxt_v}+w_v$ 考虑一棵苹果树被第一次摘的情况，用一个二元组表示$(v,t)$，即被$v$在$t$时刻摘掉 我们认为是苹果树在基环内向树上走 1.苹果树不跨过$u$时的贡献 此时相当于每个$(v,t)$在往根节点走，贡献来自每个查询$(x,d)$的子树 即满足$v\\in subtree_x,dis_v-dis_x+t\\leq d$ 离散之后可以用简单的 询问离线+$dfs$作差+树状数组解决 \\2.跨过$u$，先将苹果树的贡献移动到$last$上，变为$(last,t’=t+dis_v)$ 对于每个询问，显然必须满足$x$在环上 我们也可以令$d’=d-(len_u-dis_v)$，同样将$x$移动到$last$上 此时只需要考虑每个$t’$对于$d’$的贡献 按照$len_u$，我们可以将$t’,d’$分段，每段都是$[i\\cdot len_u,(i+1)\\cdot len_u)$的形式 2-1.对于不是同一段内的，每个$t’$的对于$d’$的贡献次数 就是 段编号 之差 2-2.同一段内，就是满足$t’\\leq d’$且$t’\\mod len_u\\leq d’\\mod len_u$ 的个数 将所有$d’,t’$排序后依次处理，容易通过参数分离处理2-1 对于2-2，将$t’\\mod len_u$离散后可以用树状数组处理 Loj Submission 空间复杂度为$O(n)$，时间复杂度为$O(n\\log n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;using ll=int64_t;#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)ll rd()&#123; char c;ll s=0; while(c=getchar(),c&lt;48); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(c^&#x27;0&#x27;); while(c=getchar(),c&gt;47); return s;&#125;enum&#123;N=200010&#125;;int n,m,q,nxt[N],L,C,C2,A[N*2],B[N],id[N],incir[N];vector &lt;int&gt; E[N],G[N];ll H[N],dis[N],H2[N],len[N],ans[N];void dfs(int u)&#123; for(int i:E[u]) H[++C]=dis[u]+i; vector &lt;int&gt; tmp; for(int v:G[u]) &#123; if(id[v]==id[u]) continue; tmp.pb(v),id[v]=id[u]; dis[v]+=dis[u],dfs(v); &#125; G[u]=tmp;&#125;struct Node&#123; ll d; int id; &#125;;vector &lt;Node&gt; Q[N],que;vector &lt;ll&gt; upd;struct BIT&#123; int s[N],n; void Init(int m)&#123; n=m,memset(s,0,(n+1)&lt;&lt;2); &#125; void Add(int p,int x) &#123; while(p&lt;=n) s[p]+=x,p+=p&amp;-p; &#125; int Que(int p) &#123; int res=0; while(p) res+=s[p],p-=p&amp;-p; return res; &#125;&#125; T,X;// dfs作差处理情况1void dfs2(int u)&#123; for(Node &amp;i:Q[u]) &#123; // 如果满足查询点在环上，就要加入2-1,2-2的计算 if(incir[u]) &#123; ll d=i.d-(len[id[u]]-dis[u]); if(d&gt;=0) que.pb((Node)&#123;d,i.id&#125;); &#125; // dfs作差-1 ans[i.id]-=T.Que(i.d=upper_bound(H+1,H+C+1,dis[u]+i.d)-H-1); &#125; for(int i:E[u]) T.Add(lower_bound(H+1,H+C+1,dis[u]+i)-H,1),upd.pb(dis[u]+i); for(int v:G[u]) dfs2(v); // dfs作差+1 for(Node i:Q[u]) ans[i.id]+=T.Que(i.d);&#125;int main()&#123; n=rd(),m=rd(),L=rd(),C=rd(); rep(i,0,n-1) A[i]=rd(),A[i+n]=A[i]+L; rep(i,0,m-1) B[i]=rd(); int C_=C%L,p=0; // 尺取预处理i,nxt[i],w[i] rep(i,n,n*2-1) &#123; while(p&lt;i &amp;&amp; A[i]-A[p+1]&gt;=C_) p++; nxt[i-n]=p%n,G[p%n].pb(i-n); dis[i-n]=C-C_+A[i]-A[p]; &#125; p=0; // 预处理(v,t) rep(i,0,m-1) &#123; while(p&lt;n*2-1 &amp;&amp; B[i]+L&gt;=A[p+1]) p++; E[p%n].pb(B[i]+L-A[p]); &#125; C=0; // 断环构建树 rep(i,0,n-1) id[i]=-2; rep(i,0,n-1) if(id[i]==-2) &#123; int u=i; for(;~id[u];u=nxt[u]) id[u]=-1; id[u]=u,len[u]=dis[u],incir[u]=1; for(int v=nxt[u];v!=u;v=nxt[v]) len[u]+=dis[v],incir[v]=1; dfs(u); &#125; sort(H+1,H+C+1),T.Init(C=unique(H+1,H+C+1)-H-1); // 离线询问，权值离散 rep(i,1,q=rd()) &#123; int u=rd()-1; ll d=rd(); Q[u].pb((Node)&#123;d,i&#125;); &#125; rep(i,0,n-1) if(id[i]==i) &#123; que.clear(),upd.clear(); dfs2(i); sort(upd.begin(),upd.end()),sort(que.begin(),que.end(),[&amp;](Node x,Node y)&#123; return x.d&lt;y.d; &#125;); C2=0; for(ll x:upd) H2[++C2]=x%len[i]; sort(H2+1,H2+C2+1),X.Init(C2=unique(H2+1,H2+C2+1)-H2-1); auto it=upd.begin(); ll s=0,c=0; for(Node &amp;q:que) &#123; while(it!=upd.end() &amp;&amp; *it&lt;=q.d) X.Add(lower_bound(H2+1,H2+C2+1,*it%len[i])-H2,1),s+=*(it++)/len[i],c++; // 参数分离处理2-1 ans[q.id]+=q.d/len[i]*c-s; // 树状数组查询2-2 ans[q.id]+=X.Que(upper_bound(H2+1,H2+C2+1,q.d%len[i])-H2-1); &#125; &#125; rep(i,1,q) printf(&quot;%lld\\n&quot;,ans[i]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"JOI","slug":"JOI","permalink":"http://chasingdeath.github.io/tags/JOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「JOISC 2020 Day3」星座 3 (Dp)","slug":"「JOISC 2020 Day3」星座 3 (dp)","date":"2021-03-13T03:52:54.000Z","updated":"2021-05-22T03:54:11.210Z","comments":true,"path":"articles/2021/03/13/dc335e53.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/13/dc335e53.html","excerpt":"","text":"「JOISC 2020 Day3」星座 3 (dp)考虑根据$A_i$的值建立笛卡尔树，此时平面被划分为个矩形空间 下称选择一个点为保留一个星星 具体的，对于笛卡尔树上的节点$(u,l,r)$，它的矩形就是父节点矩形以下，且满足$x\\in[l,r],y&gt;A_u$的部分 可以用一个线段树来查询矩形内部的点，线段树上每个节点维护$y_{max}$，每次剥掉$y_{max}&gt;A_u$的部分 复杂度为均摊$O(n\\log n)$ \\观察笛卡尔树的树形，容易发现， 1.笛卡尔树左右子树的矩形之间不会产生贡献 2.每个节点对应的矩形区间内最多选择一个点 3.如果一个节点$(u,l,r)$的祖先中有一个$x_i\\in[l,r]$的点选择了，那么自己的矩形内不能选择点 那么令$dp_{u,i}$表示父节点传下来的点$x=i$时，$u$子树内的答案 对于$i\\in[l,r]$的情况，可以直接将儿子的值合并，加上自己区间内部的权值总和$C_i$ 对于$i\\not \\in[l,r]$的情况，这一部分答案相同 可以从自己子区间内选择一个点$(x_i,y_i,c_i)$下传，此时沿用上面合并得到的$dp$值 $outans=\\min\\{dp_{x_i}+sum-c_i\\}$ 如何实现这个奇怪的$dp$过程？ 考虑子树的区间不交，因此对于$(u,l,r)$，只维护$l,r$内部的答案，对于$i\\not \\in[l,r]$的部分额外记录一个值$dp_u$ 考虑用一棵静态的线段树维护$dp$，线段树上存储$i\\in[l,r]$的答案 合并左右儿子时，两个儿子的区间不交 因此，实际上答案就是将$dp_{ls}$加到$[u,r]$上，将$dp_{rs}$加到$[l,u]$上 处理出$sum$之后，区间修改$[l,r]$的答案，对于$dp_u$直接按照上面的方法枚举$(x_i,y_i,c_i)$来计算即可 复杂度为$O(n\\log n)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394int n,A[N];struct SegFinder&#123; vector &lt;Pii&gt; V[N]; int s[N&lt;&lt;2]; void Build(int p,int l,int r)&#123; if(l==r) &#123; sort(V[l].begin(),V[l].end()); s[p]=V[l].empty()?0:V[l].back().first; return; &#125; int mid=(l+r)&gt;&gt;1; Build(p&lt;&lt;1,l,mid),Build(p&lt;&lt;1|1,mid+1,r); s[p]=max(s[p&lt;&lt;1],s[p&lt;&lt;1|1]); &#125; void Get(int p,int l,int r,int ql,int qr,int x,vector &lt;Pii&gt; &amp;Res)&#123; if(s[p]&lt;x) return; if(l==r) &#123; while(!V[l].empty() &amp;&amp; V[l].back().first&gt;=x) Res.pb(mp(l,V[l].back().second)),V[l].pop_back(); s[p]=V[l].empty()?0:V[l].back().first; return; &#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) Get(p&lt;&lt;1,l,mid,ql,qr,x,Res); if(qr&gt;mid) Get(p&lt;&lt;1|1,mid+1,r,ql,qr,x,Res); s[p]=max(s[p&lt;&lt;1],s[p&lt;&lt;1|1]); &#125;&#125; Finder;int ls[N],rs[N],stk[N],top,mk[N];int rt[N];ll dp[N],s[N&lt;&lt;2],t[N&lt;&lt;2];ll Que(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) return s[p]; int mid=(l+r)&gt;&gt;1; ll res=1e18; if(ql&lt;=mid) cmin(res,Que(p&lt;&lt;1,l,mid,ql,qr)); if(qr&gt;mid) cmin(res,Que(p&lt;&lt;1|1,mid+1,r,ql,qr)); return res+t[p];&#125;void Upd(int p,int l,int r,int ql,int qr,ll x)&#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; s[p]+=x,t[p]+=x; return; &#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) Upd(p&lt;&lt;1,l,mid,ql,qr,x); if(qr&gt;mid) Upd(p&lt;&lt;1|1,mid+1,r,ql,qr,x); s[p]=min(s[p&lt;&lt;1],s[p&lt;&lt;1|1])+t[p];&#125;// 线段树内存储的是 如果父节点有下传下来的答案// dp 存储没有父节点下传的答案void Solve(int p,int l,int r)&#123; vector &lt;Pii&gt; V; Finder.Get(1,1,n,l,r,A[p]+1,V); // 拿出我的决策矩形 if(l&lt;p) Solve(ls[p],l,p-1); if(p&lt;r) Solve(rs[p],p+1,r); if(rs[p]) Upd(1,1,n,l,p,dp[rs[p]]); if(ls[p]) Upd(1,1,n,p,r,dp[ls[p]]); ll sum=0; for(Pii i:V) sum+=i.second; if(sum) Upd(1,1,n,l,r,sum); // 如果父节点有下传，那么自己必须被清空 // 否则考虑选择一个下传下去，这样就能得到 没有父节点下传时的值 dp[p]=Que(1,1,n,l,r); for(Pii i:V) cmin(dp[p],Que(1,1,n,i.first,i.first)-i.second);&#125;int main()&#123; n=rd(); rep(i,1,n) &#123; A[i]=rd(); while(top &amp;&amp; A[stk[top]]&lt;=A[i]) ls[i]=stk[top--]; stk[++top]=i; &#125; top=0; drep(i,n,1) &#123; while(top &amp;&amp; A[stk[top]]&lt;A[i]) rs[i]=stk[top--]; stk[++top]=i; &#125; rep(i,1,n) mk[ls[i]]=mk[rs[i]]=1; rep(_,1,rd()) &#123; int x=rd(),y=rd(),c=rd(); Finder.V[x].pb(mp(y,c)); &#125; Finder.Build(1,1,n); rep(i,1,n) if(!mk[i]) &#123; Solve(i,1,n); printf(&quot;%lld\\n&quot;,dp[i]); return 0; &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"JOI","slug":"JOI","permalink":"http://chasingdeath.github.io/tags/JOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「GXOI / GZOI2019」宝牌一大堆","slug":"「GXOI   GZOI2019」宝牌一大堆","date":"2021-03-13T03:17:32.000Z","updated":"2021-05-22T03:54:11.188Z","comments":true,"path":"articles/2021/03/13/238e9b8c.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/13/238e9b8c.html","excerpt":"","text":"「GXOI / GZOI2019」宝牌一大堆麻将.jpg 观察牌型和计算方法可知，选择一个杠与选择一个面子对于牌型的贡献是等价的 而选择一个杠的答案一定没有选择一个刻子优，因此是没有任何意义的 除去 “七对子” “国士无双” 的特殊情况后，此外的情况就是选择 4个面子 + 1个雀头 容易想到对于每个花色dp得到选择$i$个面子$j$个雀头的答案，然后背包合并 为了$dp$顺子的情况，可以存储前面两个位置作为顺子头的个数 令$dp_{i,j,a,b}$表示当前选了$i$个面子，$j$个雀头，上两个位置选了$a$个顺子，上一个位置选了$b$个顺子 暴力维护dp即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127const int INF=1e9+10;int min(int x,int y,int z)&#123; return min(min(x,y),z); &#125;int n,m;int C[5][5],c[4][12],mk[4][12];ll ans,val[5][2];void Check7()&#123; static int val[40],cnt; cnt=0; rep(i,0,3) rep(j,0,9) if(c[i][j]&gt;=2) val[++cnt]=C[c[i][j]][2]&lt;&lt;(mk[i][j]*2); if(cnt&lt;7) return; sort(val+1,val+cnt+1,greater&lt;int&gt;()); ll res=7; rep(i,1,7) res*=val[i]; cmax(ans,res);&#125;void Check13()&#123; ll res=13,x=0,y=0; auto chk=[&amp;](ll a,ll b) &#123; if(!x) x=a,y=b; if(x*b&lt;a*y) x=a,y=b; &#125;; rep(i,0,2) &#123; if(!c[i][0] || !c[i][8]) return; res*=c[i][0]*c[i][8]; res&lt;&lt;=(mk[i][0]+mk[i][8]); if(c[i][0]&gt;=2) chk(C[c[i][0]][2]&lt;&lt;(mk[i][0]*2),c[i][0]&lt;&lt;mk[i][0]); if(c[i][8]&gt;=2) chk(C[c[i][8]][2]&lt;&lt;(mk[i][8]*2),c[i][8]&lt;&lt;mk[i][8]); &#125; rep(i,0,6) &#123; if(!c[3][i]) return; res&lt;&lt;=mk[3][i]; res*=c[3][i]; if(c[3][i]&gt;=2) chk(C[c[3][i]][2]&lt;&lt;(mk[3][i]*2),c[3][i]&lt;&lt;mk[3][i]); &#125; if(!x) return; cmax(ans,res*x/y);&#125;void Work(int *cnt,int *mk,ll res[5][2])&#123; static ll dp[2][5][2][5][5],w[5]; int cur=0; memset(dp,0,sizeof dp),dp[cur][0][0][0][0]=1; rep(t,0,8) &#123; int x=cnt[t]; ll val; memset(dp[!cur],0,sizeof dp[!cur]); rep(i,0,x) w[i]=C[x][i]&lt;&lt;(mk[t]*i); rep(i,0,4) rep(j,0,1) rep(a,0,x) rep(b,0,x-a) if((val=dp[cur][i][j][a][b])) &#123; int d=a+b,y=x-d,u=min(cnt[t+1]-b,cnt[t+2]); rep(k,0,min(3-i,y-3,u)) cmax(dp[!cur][i+k+1][j][b][k],val*w[d+k+3]); // 刻 + 顺 rep(k,0,min(4-i,y,u)) cmax(dp[!cur][i+k][j][b][k],val*w[d+k]); // 顺 if(j) continue; rep(k,0,min(4-i,y-2,u)) cmax(dp[!cur][i+k][j+1][b][k],val*w[d+k+2]); // 雀 + 顺 &#125; cur^=1; &#125; drep(i,4,0) drep(j,1,0) if(res[i][j]) &#123; rep(a,0,4-i) rep(b,0,1-j) if(dp[cur][a][b][0][0]) cmax(res[i+a][j+b],res[i][j]*dp[cur][a][b][0][0]); &#125;&#125;Pii Read()&#123; static char O[5]; scanf(&quot;%s&quot;,O); if(*O==&#x27;0&#x27;) return mp(-1,0); if(isalpha(*O)) &#123; if(*O==&#x27;E&#x27;) return mp(3,0); if(*O==&#x27;S&#x27;) return mp(3,1); if(*O==&#x27;W&#x27;) return mp(3,2); if(*O==&#x27;N&#x27;) return mp(3,3); if(*O==&#x27;Z&#x27;) return mp(3,4); if(*O==&#x27;B&#x27;) return mp(3,5); if(*O==&#x27;F&#x27;) return mp(3,6); return mp(-1,-1); &#125; if(O[1]==&#x27;m&#x27;) return mp(0,*O-&#x27;1&#x27;); if(O[1]==&#x27;p&#x27;) return mp(1,*O-&#x27;1&#x27;); if(O[1]==&#x27;s&#x27;) return mp(2,*O-&#x27;1&#x27;); return mp(-1,-1);&#125;void Solve()&#123; ans=0,memset(val,0,sizeof val),memset(mk,0,sizeof mk),val[0][0]=1; rep(i,0,2) rep(j,0,8) c[i][j]=4; rep(i,0,6) c[3][i]=4; while(1) &#123; Pii T=Read(); if(T.first==-1) break; c[T.first][T.second]--; &#125; while(1) &#123; Pii T=Read(); if(T.first==-1) break; mk[T.first][T.second]=1; &#125; Check7(),Check13(); rep(i,0,2) Work(c[i],mk[i],val); rep(i,0,6) &#123; static ll w[5]; int x=c[3][i]; rep(j,0,x) w[j]=C[x][j]&lt;&lt;(j*mk[3][i]); drep(a,4,0) drep(b,1,0) if(val[a][b]) &#123; if(b&lt;1 &amp;&amp; x&gt;=2) cmax(val[a][b+1],val[a][b]*w[2]); // 雀 if(a&lt;4 &amp;&amp; x&gt;=3) cmax(val[a+1][b],val[a][b]*w[3]); // 刻 if(a&lt;4 &amp;&amp; x&gt;=4) cmax(val[a+1][b],val[a][b]*w[4]); // 杠 &#125; &#125; cmax(ans,val[4][1]); printf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; rep(i,0,4) rep(j,C[i][0]=1,i) C[i][j]=C[i-1][j]+C[i-1][j-1]; int T; scanf(&quot;%d&quot;,&amp;T); while(T--) Solve();&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"[Codechef March Challenge 2021 Random Walk Queries(RWALKS) (动态点分治) ]","slug":"[Codechef March Challenge 2021 Random Walk Queries(RWALKS) (动态点分治) ]","date":"2021-03-11T06:11:35.000Z","updated":"2021-05-22T03:54:11.039Z","comments":true,"path":"articles/2021/03/11/9b5e688c.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/11/9b5e688c.html","excerpt":"","text":"Codechef March Challenge 2021 Random Walk Queries(RWALKS) (动态点分治) 题目大意： 对于给定的无根树$T$，要求强制在线维护两种操作 1.游走$(u,d)$，以$u$为根在树上游走，从$u$开始，最多走$d$步，每次随机从儿子中选择一个点 2.查询$u$，当前$u$被遍历的期望次数 \\灵光一闪想到这么个憨批树上结构 对于更新$(u,d)$，考虑$u$ 跨过当前点分根 到达其他点分子树里的贡献 一个点由当前点分根到达的概率是一个定值，可以预处理出来，并在查询时计算 因此更新贡献时，可以描述为$dep\\leq d$的点接受到 以$x$的概率访问当前点分根 可以简单用树状数组维护 为了剔除对于自己所在子树的非法贡献，需要额外开一些树状数组来维护 一个节点有$\\log n$个点分父节点，每次需要两次树状数组查询 因此查询部分复杂度为$O(m\\log ^2n)$，预处理以及空间复杂度为$O(n\\log n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110const int N=2e5+10,K=19,P=1e9+7;int n,m,I[N];struct Edge&#123; int to,nxt;&#125;e[N&lt;&lt;1];int head[N],ecnt,deg[N];void AddEdge(int u,int v)&#123; e[++ecnt]=(Edge)&#123;v,head[u]&#125;; head[u]=ecnt,deg[v]++;&#125;#define erep(u) for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to)struct BIT&#123; int n; vector &lt;int&gt; s; BIT()&#123; &#125;; BIT(int n):n(n)&#123; s.resize(n+1); &#125; void Add(int p,int x)&#123; for(cmin(p,n);p;p-=p&amp;-p) s[p]+=x,Mod1(s[p]); &#125; int Que(int p)&#123; int res=0; while(p&lt;=n) res+=s[p],Mod1(res),p+=p&amp;-p; return res; &#125;&#125; T[N];vector &lt;BIT&gt; G[N];// Dep:点分树上的dep，id:节点在每层的编号， dep:节点在每层的dep，s:节点在每层由根到达的系数int Dep[N],id[K][N],dep[K][N],s[K][N],vis[N],sz[N],fa[N],Root;int mi,rt;void FindRt(int n,int u,int f)&#123; int ma=0; sz[u]=1; erep(u) if(v!=f &amp;&amp; !vis[v]) &#123; FindRt(n,v,u); sz[u]+=sz[v],cmax(ma,sz[v]); &#125; cmax(ma,n-sz[u]); if(mi&gt;ma) mi=ma,rt=u;&#125;int D,maxd;void dfs(int u,int f,int id)&#123; cmax(maxd,dep[D][u]=dep[D][f]+1),::id[D][u]=id; erep(u) if(v!=f &amp;&amp; !vis[v]) &#123; s[D][v]=1ll*s[D][u]*I[deg[u]-1]%P; dfs(v,u,id); &#125;&#125;// 预处理点分治，开树状数组int Divide(int n,int u)&#123; mi=1e9,FindRt(n,u,0),u=rt; int sonc=0; vis[u]=s[Dep[u]=D][u]=1,id[D][u]=-1; int t=0; erep(u) if(!vis[v]) &#123; maxd=0; s[D][v]=1,dfs(v,u,sonc); G[u].pb(BIT(maxd)); sonc++; cmax(t,maxd); &#125; T[u]=BIT(t); erep(u) if(!vis[v]) &#123; if(sz[v]&gt;sz[u]) sz[v]=n-sz[u]; D++,fa[Divide(sz[v],v)]=u,D--; &#125; return u;&#125;int sum[N];int Que(int u)&#123; ll ans=sum[u]; for(int v=u,d=Dep[v];(d--,v=fa[v]);) ans=(ans+ 1ll* (T[v].Que(dep[d][u])+G[v][id[d][u]].Que(dep[d][u])) *s[d][u])%P; return (ans%P+P)%P;&#125;void Upd(int u,int d)&#123; sum[u]++,Mod1(sum[u]),T[u].Add(d,I[deg[u]]); for(int v=fa[u],D=Dep[u]-1;v;v=fa[v],D--) &#123; if(d&lt;dep[D][u]) continue; int x=1ll*I[deg[u]]*s[D][u]%P; sum[v]+=x,Mod1(sum[v]); x=1ll*x*I[deg[v]-1]%P; T[v].Add(d-dep[D][u],x),G[v][id[D][u]].Add(d-dep[D][u],P-x); &#125;&#125;int lst;int Get() &#123; return (rd()+lst)%n+1; &#125;int main()&#123; I[0]=I[1]=1; rep(i,2,N-1) I[i]=1ll*(P-P/i)*I[P%i]%P; n=rd(),m=rd(); rep(i,2,n)&#123; int u=rd(),v=rd(); AddEdge(u,v),AddEdge(v,u); &#125; Root=Divide(n,1); while(m--) &#123; int opt=rd(); if(opt==1) &#123; int u=Get(),d=Get(); Upd(u,d); &#125; else printf(&quot;%d\\n&quot;,lst=Que(Get())); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"},{"name":"Codechef","slug":"Codechef","permalink":"http://chasingdeath.github.io/tags/Codechef/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[「BalticOI 2020」村庄 (贪心)]","slug":"[「BalticOI 2020」村庄 (贪心)]","date":"2021-03-11T05:53:05.000Z","updated":"2021-05-22T03:54:11.097Z","comments":true,"path":"articles/2021/03/11/546a1ee9.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/11/546a1ee9.html","excerpt":"","text":"「BalticOI 2020」村庄 (贪心)Subtask1: Min考虑链上的情况，最优解肯定是两两相邻的交换，如果还有多，就再多交换一次 因此树上的也是类似，实际上就是求解一个最小边覆盖问题，选择一条边就是交换边两端的点编号 可以$O(n)$贪心/dp求解树上最小边覆盖 \\Subtask2: Max考虑理想的最优情况：对于任意一条边，我们要求它被经过次数尽可能多 如果这条边两端子树大小分别为$a,b$，则它被经过的最多次数显然是$2\\min\\{a,b\\}$ 考虑找到树的重心，以它为根，此时任意一颗真子树的大小$\\leq \\frac{n} {2}$ 为了构造最优答案，只需要每棵子树的集合相互错开即可 一种简单的构造方法是：取$\\text{dfs}$序，平移$\\frac{n} {2}$即可得到解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=1e5+10,INF=1e9+10;int n;vector &lt;int&gt; G[N];ll Min,Max;int ans1[N],ans2[N];int dep[N],fa[N],vis[N];// 最小边覆盖贪心法void pre_dfs(int u,int f)&#123; ans1[u]=u,fa[u]=f; for(int v:G[u]) if(v!=f) &#123; pre_dfs(v,u); if(!vis[v]) vis[v]=vis[u]=1,swap(ans1[u],ans1[v]),Min+=2; &#125; if(!vis[u] &amp;&amp; !f) vis[u]=1,swap(ans1[u],ans1[G[u][0]]),Min+=2;&#125;int A[N],C;int mi=1e9,rt,sz[N];// 找重心void dfs(int u,int f)&#123; sz[u]=1; int ma=0; for(int v:G[u]) if(v!=f) &#123; dfs(v,u); cmax(ma,sz[v]),sz[u]+=sz[v]; Max+=2*min(n-sz[v],sz[v]); &#125; cmax(ma,n-sz[u]); if(mi&gt;ma) mi=ma,rt=u;&#125;// 遍历dfs序void dfs_get(int u,int f) &#123; A[++C]=u; for(int v:G[u]) if(v!=f) dfs_get(v,u);&#125;int main()&#123; n=rd(); rep(i,2,n) &#123; int u=rd(),v=rd(); G[u].pb(v),G[v].pb(u); &#125; pre_dfs(1,0),dfs(1,0),dfs_get(rt,0); rep(i,1,n) ans2[A[i]]=A[(i+n/2-1)%n+1]; printf(&quot;%lld %lld\\n&quot;,Min,Max); rep(i,1,n) printf(&quot;%d &quot;,ans1[i]); puts(&quot;&quot;); rep(i,1,n) printf(&quot;%d &quot;,ans2[i]); puts(&quot;&quot;);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"Codechef March Challenge 2021 Div2 Consecutive Adding(CONSADD)","slug":"Codechef March Challenge 2021 Div2 Consecutive Adding(CONSADD)","date":"2021-03-11T05:43:47.000Z","updated":"2021-05-22T03:54:10.920Z","comments":true,"path":"articles/2021/03/11/ed997fae.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/11/ed997fae.html","excerpt":"","text":"Codechef March Challenge 2021 Div2 Consecutive Adding(CONSADD)题目大意： 给定两个$n\\times m$矩阵$A$，$B$和一个常数$x$ 现在对于$A$操作，每次可以选择一行或者一列连续的$x$个，一起改变同一个数值$v\\in \\Z$ 判断是否可以由$A$变成$B$ 显然可以先将$A,B$作差，转化为操作成0矩阵 进一步，我们将$A$矩阵行内差分，使得每次行操作变为一个单点$A_{i,j}+v$，一个单点$A_{i,j+x}-v$ 在此基础上，继续差分即可将行列操作都转化为单点操作 此时容易发现，$A_{i,j}$的数值有关联的部分都是$A_{i,j},A_{i+x,j},A_{i,j+x}\\cdots A_{i+ax,j+bx}$ 也就是相差$x$的，考虑可以将这一部分子矩形提取出来，这样问题变成了 每次操作一个数$A_{i,j}+v$，可以选择相邻一个数$A_{i,j+1}$或$A_{i+1,j}$去$-v$ 对于每个这样的子问题，容易发现有解的充要条件：子矩阵元素和为0 （可以依次考虑每个元素贪心构造方案） 如此可以$O(nm)$判定 1234567891011121314151617181920212223242526272829const int N=1010,INF=1e9+10;int n,m,k;ll A[N][N],B[N][N];int V[N][N];int main()&#123; rep(kase,1,rd()) &#123; n=rd(),m=rd(),k=rd(); rep(i,1,n+1) rep(j,1,m+1) A[i][j]=V[i][j]=0; rep(i,1,n) rep(j,1,m) A[i][j]=rd(); rep(i,1,n) rep(j,1,m) A[i][j]-=rd(); rep(i,1,n+1) drep(j,m+1,1) A[i][j]-=A[i][j-1]; drep(i,n+1,1) rep(j,1,m+1) A[i][j]-=A[i-1][j]; // 3 次作差 int f=1; rep(i,1,n+1) rep(j,1,m+1) if(!V[i][j]) &#123; ll s=0; // 子问题判定 for(int a=i;a&lt;=n+1;a+=k) for(int b=j;b&lt;=m+1;b+=k) &#123; V[a][b]=1; s+=A[a][b]; &#125; f&amp;=s==0; &#125; puts(f?&quot;Yes&quot;:&quot;No&quot;); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"Codechef","slug":"Codechef","permalink":"http://chasingdeath.github.io/tags/Codechef/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"组合数公式","slug":"组合数公式","date":"2021-03-11T03:18:33.000Z","updated":"2021-05-22T03:54:11.408Z","comments":true,"path":"articles/2021/03/11/1783d9b2.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/11/1783d9b2.html","excerpt":"","text":"组合数公式 组合数$\\displaystyle C(n,m)=C_n^m=\\binom{n} {m}$ 递推式C(n,m)=C(n-1,m-1)+C(n-1,m) 组合数完全累和\\displaystyle \\sum_{i=0}^n C(n,i) =2^n 奇偶累和\\displaystyle \\sum_0^n (-1)^i C(n,i)=[n=0] $\\sum\\cdots\\sum \\rightarrow C() $型我们熟知的有 \\displaystyle \\sum_{i=1}^{n}1=n = C(n,1)\\displaystyle\\sum _{i=1}^{n} \\sum_{j=i+1}^{n} 1= \\frac{n(n-1)} {2}更一般的 \\displaystyle\\underbrace {\\sum \\sum ... \\sum} 1 =C(n,k)(k个\\sum) \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ $ … \\ \\cdot C(n,i)$型$\\displaystyle \\sum i \\cdot C(n,i) $ $\\displaystyle = \\sum {i \\cdot \\frac{n!} {i! \\cdot (n-i)!} }$ $\\displaystyle = \\sum { \\frac{n!} {(i-1)! \\cdot (n-i)!} }$ $\\displaystyle=\\sum {n \\cdot \\frac {(n-1)!} {(i-1)! \\cdot (n-i)!} }$ $\\displaystyle=n\\cdot \\sum C(n-1,i-1)$ 同理的 \\sum i\\cdot (i-1)\\cdot C(n,i)=n \\cdot (n-1) \\cdot \\sum C(n-2,i-2)带入还能得到 \\sum i^2 \\cdot C(n,i) = n \\cdot (n-1) \\cdot \\sum C(n-2,i-2)+n \\cdot \\sum C(n-1,i-1)更一般的，可以表示成 \\sum C(i,k) \\cdot C(n,i) =C(n,k) \\cdot \\sum C(n-k,i-k) 多组合数相乘型$\\displaystyle \\sum_{i=0}^{k} C(n,i)\\cdot C(m,k-i) = C(n+m,k)$ 其实就是两个组合问题的组合，可以直接通过实际意义得到 Lucas定理$ C(n,m) \\mod p = C(n \\mod p,m \\mod p) \\cdot C(\\lfloor\\frac{n} {p}\\rfloor, \\lfloor \\frac{m} {p}\\rfloor) \\mod p$ 预处理阶乘逆元后，可以用于解决模数较小而$n,m$较大的组合数问题 前缀和列$\\displaystyle \\sum_{i=0}^n \\binom{i} {m}=\\binom{n+1} {m+1}$ 由递推式$\\displaystyle \\binom{i} {m}=\\binom{i-1} {m}+\\binom{i-1} {m-1}$容易迭代发现 \\行令 $S(n,m)=\\sum_{i=0}^{m} C(n,i)$ $S(n,m)+S(n,m+1)$ $=\\sum_{i=0}^{m}(C(n,i)+C(n,i+1))+C(n,0)$ $=\\sum C(n+1,i+1)+C(n,0)$ (带入递推公式) $=S(n+1,m+1)$ 又$\\because S(n,m)+S(n,m+1)=2S(n,m+1)-C(n,m+1)$ $\\therefore S(n,m)=2S(n-1,m)-C(n-1,m)$ (待补。。。)","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"多项式运算 (求逆/Ln/exp等)","slug":"多项式运算 (求逆 ln exp等)","date":"2021-03-11T02:38:44.000Z","updated":"2021-05-22T03:54:11.424Z","comments":true,"path":"articles/2021/03/11/2cdf6809.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/11/2cdf6809.html","excerpt":"","text":"多项式运算 (求逆/ln/exp等)(latest updated on 2021.02.23) 前置知识NTT 所有操作均在对$P=\\text{998244353}$取模下进行 代码在最下面，由于板子实在有一点长，所以。。。 下文中$\\pmod {x^n}$表示求出了多项式的前$n$项 $[x^i]F(x)$表示$F(x)$第$i$项的系数 每个小问题的模板题都可以在洛谷上找到 \\1.多项式求乘法逆(为什么叫做乘法逆?因为还有求复合逆和模逆元的) 求 $G(x)\\equiv \\frac{1} {F(x)} \\pmod {x^n}$ 形象化的理解就是$F(x)\\cdot G(x) \\pmod {x^n}$只有第一项是$1$，其他项都是$0$ 这个由于是第一个操作，很多人还并不是很能理解多项式操作到底是什么东西，所以讲多一点 Part1 O($n^2$)为了便于理解这个问题，先考虑一个最简单的模拟 $[x^i]F\\cdot G(x)=\\sum [x^j]F(x)[x^{i-j}]G(x)$ 第一项$[x^0]G(x)=\\frac{1} {[x^0]F(0)} \\pmod P$，因此求逆的前提条件是$[x^0]F(x)\\ne 0$ 考虑从$1$到$n-1$依次求出每一项，先从前面的项中得到所有$j&gt;0$的和$Sum$，然后带入$j=0$时知道 [x^i]G(x)=-\\frac{Sum=\\sum_{j=1}^{j\\leq i}[x^j]F(x)[x^{i-j}]G(x)} {[x^0]F(0)}\\ Part2 O($n\\log^2n$)上面这个式子是一个类似$dp$转移的东西，可以直接分治NTT优化掉 \\ Part3 $O(n\\log n)$考虑倍增求解，设已经求出了 H(x)\\equiv \\frac{1} {F(x)},\\pmod {x^{\\frac{n} {2} }}其中递归边界是$n=1$时,$[x^0]G(x)=\\frac{1} {[x^0]F(0)} \\pmod P$，因此求逆的前提条件是$[x^0]F(x)\\ne 0$ 则 H(x)\\equiv G(x)\\pmod {x^{\\frac{n} {2} }}H(x)-G(x)\\equiv 0\\pmod {x^{\\frac{n} {2} }}我们对于$H(x)-G(x)$平方，结果的前$n$项不可能由两个$\\ge \\frac{n} {2}$的项相乘得到，而前$\\frac{n} {2}$项都是$0$，所以 (H(x)-G(x))^2\\equiv 0\\pmod {x^n}所以通过平方可以扩大模数，这很常用 展开平方的式子 H(x)^2-2G(x)H(x)+G(x)^2\\equiv 0\\pmod {x^n}两边乘上$F(x)$ H(x)^2F(x)-2H(x)+G(x)\\equiv 0\\pmod {x^n}G(x)\\equiv 2H(x)-H(x)^2F(x)\\pmod {x^n}带入这个式子倍增求解即可 分析复杂度，每次有一个$H(x)^2F(x)$，可以通过$NTT$求出，倍增过程中访问的长度是$O(n+\\frac{n} {2}+\\frac{n} {4}…)=O(n)$ 所以总复杂度就是$O(n\\log n)$ \\ 2.多项式开根号求$G(x)^2\\equiv F(x) \\pmod {x^n}$ 同样的，递归求解，边界是$[x^0]=\\sqrt{[x^0]F(x)} \\pmod P$ 可以发现我们需要求二次剩余。。。但是一般题目保证了$[x^0]F(x)\\in\\{0,1\\}$ 设已经求出$H(x)^2\\equiv F(x) \\pmod{ x^{\\lceil \\frac{n} {2} \\rceil} }$ H(x)\\equiv G(x) \\pmod {x^{\\lceil \\frac{n} {2}\\rceil} }H(x)^2-2G(x)H(x)+G(x)^2\\equiv 0\\pmod {x^n}H(x)^2-2G(x)H(x)+F(x)\\equiv 0 \\pmod {x^n}G(x)\\equiv \\frac{H(x)^2+F(x)} {2H(x)} \\pmod {x^n}带入这个式子倍增求解即可 复杂度为$O(n\\log n)$，由于需要求逆，实际可能会比较难写 \\ 3.多项式求$\\ln$对$\\begin{aligned} G(x)\\equiv \\ln F(x) \\pmod {x^n} \\end{aligned} $ 两边求导，注意这里是复合函数求导!!! $\\begin{aligned} G'(x)\\equiv F'(x)\\frac{1} {F(x)} \\pmod {x^n}\\end{aligned}$ 求出$G’(x)$，然后求原函数即可 通常保证$[x^0]F(x)=1$，否则不好求$\\ln 1$，所以求出原函数后首项为0 复杂度为$O(n\\log n)$ \\ 4.多项式求exp多项式求$\\text{exp}$即求$G(x)=e^{F(x)} \\mod x^n$ 多项式求$\\text{exp}$常见的解法有两种 CDQ分治+$\\text{NTT}$要求$G(x)=e^{F(x)}$ 式子两边求导(右边要复合函数求导)，$G’(x)=F’(x) e^{F(x)}$ 也就是说，$G’(x)=F’(x)G(x)$ 两边同时积分得到$\\begin{aligned} G(x)=\\int{F'(x)G(x)}\\end{aligned}$ 我们知道，$ [x^i] \\begin{aligned}\\int H(x) =\\frac{ [x^{i-1}]H(x)} {i}\\end{aligned} $ 带入上面的式子得到$\\displaystyle i\\cdot [x^i]G(x)= \\sum_{j=0}^{i-1}[x^j]F’(x)\\cdot [x^{i-1-j}]G(x)$ 那么对于这个式子，直接使用分治NTT求解，其复杂为$O(n\\log n)$ \\牛顿迭代这是一种渐进意义上更优的做法，但实际在$10^6$以下几乎不可能更快，而且代码难写 但是不管平时用不用，牛顿迭代的知识学习一下肯定是最好的 把题目转化为，对于函数$f(G)=\\ln G-F$ 求出在$\\mod x^n$意义下的零点 其中$f(x)=\\ln x-c$ 考虑迭代求解，设已经求出$H(x)=e^{F(x)}\\pmod {x^{\\frac{n} {2} }}$ 边界条件是$[x^0]H(x)=e^{[x^0]F(x)}$(由于没有办法求$e^x$在模意义下的值，所以通常必须要满足$[x^0]F(x)=0$) 带入牛顿迭代的结果 G=H-\\frac{f(H)} {f'(H)}=H(F-\\ln H+1)每次求$\\ln$ 复杂度和$\\text{NTT}$相同，所以总复杂度为$O(n\\log n)$ 事实上这个还有优化的余地，就是在求$\\ln$的时候，多项式逆的部分可以同步倍增求出，不需要每次都倍增一下(但是好像效果并不是特别明显) \\\\ 5.多项式$k$次幂$G(x)\\equiv F(x)^k\\pmod {x^n}$ $\\ln G(x)=k \\ln F(x) \\pmod {x^n}$ 求出$\\ln G(x)$之后，$\\exp$回来即可 由于要求$\\ln$，所以这样求的条件是$[x^0]F(x)=1$ (可以通过平移和系数变换来调整为$[x^0]F(x)=1$) 很显然这个方法对于开根号也是适用的 复杂度$O(n\\log n)$ \\\\\\ 6.多项式带余除法问题：给定$F(x),G(x)$，其次数为$n,m,n&gt;m$ 求$F(x)=G(x)P(x)+R(x)$，其中$P(x)$次数为$n-m$，$R(x)$次数为$m-1$ 考虑先求解$P(x)$，下面引入一种翻转运算 $F^R(x)=x^nF(\\frac{1} {x})$，即将$F(x)$的系数翻转排列 用$\\frac{1} {x}$带入问题的式子，得到 $\\displaystyle F(\\frac{1} {x})=G(\\frac{1} {x})P(\\frac{1} {x})+R(x)$ $\\displaystyle x^nF(\\frac{1} {x})=x^mG(\\frac{1} {x})\\cdot x^{n-m}P(\\frac{1} {x})+x^nR(x)$ $\\displaystyle F^R(x)=G^R(x)\\cdot P^R(x)+x^{n-m+1}R^R(x)$ 要求的$P(x)$是$n-m$次的，所以$R^R(x)\\cdot x^{n-m+1}$并没有贡献 此时可以认为$\\displaystyle P^R(x)=\\frac{F^R(x)} {G^R(x)}$，求逆即可得到 得到$P(x)$之后，带入$R(x)=F(x)-G(x)P(x)$即可 \\\\应用：多项式多点求值，常系数线性齐次递推 \\以上是基本运算，如果不想继续吸多项式请直接跳到最下面的代码 多项式与点值式 下降幂多项式初步 \\\\ \\\\\\ 所有的操作均用$\\text{vector} $来实现，主要是为了理清思路，并且清零问题上会比较容易解决，同时对于每次计算完多项式的长度的要求会显得更加严格 实际在UOJ/Luogu上会非常慢，在LOJ上不错 稍微整理了一下，没怎么卡过常，所以应该还是比较可读的 代码总览(请使用C++11,O2编译运行) 基本运算的总模板题Loj - 150 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef unsigned long long ull;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1&lt;&lt;17,P=998244353;int n,k;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;/*void NTT(int n,int *a,int f)&#123; rep(i,1,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int w=qpow(3,(P-1)/i/2); for(int l=0;l&lt;n;l+=i*2) &#123; int e=1; for(int j=l;j&lt;l+i;++j,e=1ll*e*w%P) &#123; int t=1ll*a[j+i]*e%P; a[j+i]=a[j]-t,((a[j+i]&lt;0)&amp;&amp;(a[j+i]+=P)); a[j]+=t,((a[j]&gt;=P)&amp;&amp;(a[j]-=P)); &#125; &#125; &#125; if(f==-1) &#123; reverse(a+1,a+n); int Inv=qpow(n); rep(i,0,n-1) a[i]=1ll*a[i]*Inv%P; &#125;&#125;int e[N];void NTT(int n,int *a,int f)&#123; rep(i,1,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); e[0]=1; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int w=qpow(3,(P-1)/i/2); for(int j=1;j&lt;i;++j) e[j]=1ll*e[j-1]*w%P; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,((a[j+i]&lt;0)&amp;&amp;(a[j+i]+=P)); a[j]+=t,((a[j]&gt;=P)&amp;&amp;(a[j]-=P)); &#125; &#125; &#125; if(f==-1) &#123; reverse(a+1,a+n); int Inv=qpow(n); rep(i,0,n-1) a[i]=1ll*a[i]*Inv%P; &#125;&#125;int e[N];void NTT(int n,int *a,int f)&#123; rep(i,1,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); e[0]=1; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int w=qpow(3,(P-1)/i/2); for(int j=i-2;j&gt;=0;j-=2) e[j+1]=1ll*w*(e[j]=e[j&gt;&gt;1])%P; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,((a[j+i]&lt;0)&amp;&amp;(a[j+i]+=P)); a[j]+=t,((a[j]&gt;=P)&amp;&amp;(a[j]-=P)); &#125; &#125; &#125; if(f==-1) &#123; reverse(a+1,a+n); int Inv=qpow(n); rep(i,0,n-1) a[i]=1ll*a[i]*Inv%P; &#125;&#125;int w[N];void Init(int N)&#123; w[N&gt;&gt;1]=1; int t=qpow(3,(P-1)/N); rep(i,(N&gt;&gt;1)+1,N-1) w[i]=1ll*w[i-1]*t%P; drep(i,(N&gt;&gt;1)-1,1) w[i]=w[i&lt;&lt;1];&#125;void NTT(int n,int *a,int f)&#123; rep(i,1,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,((a[j+i]&lt;0)&amp;&amp;(a[j+i]+=P)); a[j]+=t,((a[j]&gt;=P)&amp;&amp;(a[j]-=P)); &#125; &#125; &#125; if(f==-1) &#123; reverse(a+1,a+n); int Inv=qpow(n); rep(i,0,n-1) a[i]=1ll*a[i]*Inv%P; &#125;&#125;*//*namespace MTT&#123; const double PI=acos((double)-1); int rev[N]; struct Cp&#123; double x,y; Cp()&#123; ; &#125; Cp(double _x,double _y): x(_x),y(_y)&#123; &#125; inline Cp operator + (const Cp &amp;t) const &#123; return (Cp)&#123;x+t.x,y+t.y&#125;; &#125; inline Cp operator - (const Cp &amp;t) const &#123; return (Cp)&#123;x-t.x,y-t.y&#125;; &#125; inline Cp operator * (const Cp &amp;t) const &#123; return (Cp)&#123;x*t.x-y*t.y,x*t.y+y*t.x&#125;; &#125; &#125;A[N],B[N],C[N],w[N/2];#define E(x) ll(x+0.5)%P void FFT(int n,Cp *a,int f)&#123; rep(i,0,n-1) if(rev[i]&lt;i) swap(a[i],a[rev[i]]); w[0]=Cp(1,0); for(reg int i=1;i&lt;n;i&lt;&lt;=1) &#123; Cp t=Cp(cos(PI/i),f*sin(PI/i)); for(reg int j=i-2;j&gt;=0;j-=2) w[j+1]=t*(w[j]=w[j&gt;&gt;1]); // 上面提到的最优板子 for(reg int l=0;l&lt;n;l+=2*i) &#123; for(reg int j=l;j&lt;l+i;j++) &#123; Cp t=a[j+i]*w[j-l]; a[j+i]=a[j]-t; a[j]=a[j]+t; &#125; &#125; &#125; if(f==-1) rep(i,0,n-1) a[i].x/=n,a[i].y/=n; &#125; void Multiply(int n,int m,int *a,int *b,int *res,int P)&#123; // [0,n-1]*[0,m-1]-&gt;[0,n+m-2] int S=(1&lt;&lt;15)-1; int R=1,cc=-1; while(R&lt;=n+m-1) R&lt;&lt;=1,cc++; rep(i,1,R) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;cc); rep(i,0,n-1) A[i]=Cp((a[i]&amp;S),(a[i]&gt;&gt;15)); rep(i,0,m-1) B[i]=Cp((b[i]&amp;S),(b[i]&gt;&gt;15)); rep(i,n,R-1) A[i]=Cp(0,0); rep(i,m,R-1) B[i]=Cp(0,0); FFT(R,A,1),FFT(R,B,1); rep(i,0,R-1) &#123; int j=(R-i)%R; C[i]=Cp((A[i].x+A[j].x)/2,(A[i].y-A[j].y)/2)*B[i]; B[i]=Cp((A[i].y+A[j].y)/2,(A[j].x-A[i].x)/2)*B[i]; &#125; FFT(R,C,-1),FFT(R,B,-1); rep(i,0,n+m-2) &#123; ll a=E(C[i].x),b=E(C[i].y),c=E(B[i].x),d=E(B[i].y); res[i]=(a+((b+c)&lt;&lt;15)+(d&lt;&lt;30))%P; &#125; &#125;#undef E&#125;*/namespace Polynomial&#123; typedef vector &lt;int&gt; Poly; void Show(Poly a,int k=0)&#123; if(!k)&#123; for(int i:a) printf(&quot;%d &quot;,i); puts(&quot;&quot;); &#125; else for(int i:a) printf(&quot;%d\\n&quot;,i); &#125; int rev[N],w[N]; int Inv[N+1],Fac[N+1],FInv[N+1]; void Init_w() &#123; int t=qpow(3,(P-1)/N); w[N&gt;&gt;1]=1; rep(i,(N&gt;&gt;1)+1,N-1) w[i]=1ll*w[i-1]*t%P; drep(i,(N&gt;&gt;1)-1,1) w[i]=w[i&lt;&lt;1]; Inv[0]=Inv[1]=Fac[0]=Fac[1]=FInv[0]=FInv[1]=1; rep(i,2,N) &#123; Inv[i]=1ll*(P-P/i)*Inv[P%i]%P; FInv[i]=1ll*FInv[i-1]*Inv[i]%P; Fac[i]=1ll*Fac[i-1]*i%P; &#125; &#125; int Init(int n)&#123; int R=1,c=-1; while(R&lt;n) R&lt;&lt;=1,c++; rep(i,1,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;c); return R; &#125;#define NTTVersion1#ifdef NTTVersion1 void NTT(int n,Poly &amp;a,int f)&#123; rep(i,0,n-1) if(rev[i]&lt;i) swap(a[i],a[rev[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,Mod2(a[j+i]); a[j]+=t,Mod1(a[j]); &#125; &#125; &#125; if(f==-1) &#123; reverse(a.begin()+1,a.begin()+n); ll base=Inv[n]; rep(i,0,n-1) a[i]=a[i]*base%P; &#125; &#125; void NTT(int n,int *a,int f)&#123; rep(i,0,n-1) if(rev[i]&lt;i) swap(a[i],a[rev[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,Mod2(a[j+i]); a[j]+=t,Mod1(a[j]); &#125; &#125; &#125; if(f==-1) &#123; reverse(a+1,a+n); ll base=Inv[n]; rep(i,0,n-1) a[i]=a[i]*base%P; &#125; &#125;#else void NTT(int n,Poly &amp;a,int f)&#123; static int e[N&gt;&gt;1]; rep(i,0,n-1) if(rev[i]&lt;i) swap(a[i],a[rev[i]]); e[0]=1; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int t=qpow(f==1?3:(P+1)/3,(P-1)/i/2); for(int j=i-2;j&gt;=0;j-=2) e[j+1]=1ll*t*(e[j]=e[j&gt;&gt;1])%P; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,Mod2(a[j+i]); a[j]+=t,Mod1(a[j]); &#125; &#125; &#125; if(f==-1) &#123; ll base=Inv[n]; rep(i,0,n-1) a[i]=a[i]*base%P; &#125; &#125; void NTT(int n,int *a,int f)&#123; static int e[N&gt;&gt;1]; rep(i,0,n-1) if(rev[i]&lt;i) swap(a[i],a[rev[i]]); e[0]=1; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int t=qpow(f==1?3:(P+1)/3,(P-1)/i/2); for(int j=i-2;j&gt;=0;j-=2) e[j+1]=1ll*t*(e[j]=e[j&gt;&gt;1])%P; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,Mod2(a[j+i]); a[j]+=t,Mod1(a[j]); &#125; &#125; &#125; if(f==-1) &#123; ll base=Inv[n]; rep(i,0,n-1) a[i]=a[i]*base%P; &#125; &#125;#endif Poly operator * (Poly a,Poly b)&#123; int n=a.size()+b.size()-1; int R=Init(n); a.resize(R),b.resize(R); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=1ll*a[i]*b[i]%P; NTT(R,a,-1); a.resize(n); return a; &#125; Poly operator + (Poly a,Poly b) &#123; int n=max(a.size(),b.size()); a.resize(n),b.resize(n); rep(i,0,n-1) a[i]+=b[i],Mod1(a[i]); return a; &#125; Poly operator - (Poly a,Poly b) &#123; int n=max(a.size(),b.size()); a.resize(n),b.resize(n); rep(i,0,n-1) a[i]-=b[i],Mod2(a[i]); return a; &#125; Poly Poly_Inv(Poly a) &#123; // 多项式乘法逆，注意这里求出的是前a.size()项 int n=a.size(); if(n==1) return Poly&#123;(int)qpow(a[0],P-2)&#125;; Poly b=a; b.resize((n+1)/2); b=Poly_Inv(b); int R=Init(n&lt;&lt;1); a.resize(R),b.resize(R); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=(2-1ll*a[i]*b[i]%P+P)*b[i]%P; NTT(R,a,-1); a.resize(n); return a; &#125; Poly operator / (Poly a,Poly b)&#123; // 多项式带余除法 reverse(a.begin(),a.end()),reverse(b.begin(),b.end()); int n=a.size(),m=b.size(); a.resize(n-m+1),b.resize(n-m+1),b=Poly_Inv(b); a=a*b,a.resize(n-m+1); reverse(a.begin(),a.end()); return a; &#125; Poly operator % (Poly a,Poly b) &#123; // 多项式取模 int n=b.size()-1; if((int)a.size()&lt;=n) return a; Poly t=a/b; if((int)t.size()&gt;n) t.resize(n); t=t*b; t.resize(n); a.resize(n); return a-t; &#125; int Quad(int a,int k=0) &#123; // 二次剩余(不是原根法),用于求Sqrt if(a&lt;=1) return a; ll x; while(1) &#123; x=1ll*rand()*rand()%P; if(qpow((x*x-a+P)%P,(P-1)/2)!=1) break; &#125; ll w=(x*x-a+P)%P; Pii res=mp(1,0),t=mp(x,1); auto Mul=[&amp;](Pii a,Pii b)&#123; int x=(1ll*a.first*b.first+1ll*a.second*b.second%P*w)%P,y=(1ll*a.first*b.second+1ll*a.second*b.first)%P; return mp(x,y); &#125;; int d=(P+1)/2; while(d) &#123; if(d&amp;1) res=Mul(res,t); t=Mul(t,t); d&gt;&gt;=1; &#125; ll r=(res.first%P+P)%P; if(k) r=min(r,(P-r)%P); return r; &#125; Poly Sqrt(Poly a)&#123; // 多项式开根号 int n=a.size(); if(n==1) return Poly&#123;Quad(a[0],1)&#125;; Poly b=a; b.resize((n+1)/2),b=Sqrt(b),b.resize(n); Poly c=Poly_Inv(b); int R=Init(n*2); a.resize(R),c.resize(R); NTT(R,a,1),NTT(R,c,1); rep(i,0,R-1) a[i]=1ll*a[i]*c[i]%P; NTT(R,a,-1); a.resize(n); rep(i,0,n-1) a[i]=1ll*(P+1)/2*(a[i]+b[i])%P; return a; &#125; Poly Deri(Poly a)&#123; //求导 rep(i,1,a.size()-1) a[i-1]=1ll*i*a[i]%P; a.pop_back(); return a; &#125; Poly IDeri(Poly a) &#123; //原函数 a.pb(0); drep(i,a.size()-1,1) a[i]=1ll*a[i-1]*Inv[i]%P; a[0]=0; return a; &#125; Poly Ln(Poly a)&#123; // 多项式求Ln int n=a.size(); a=Poly_Inv(a)*Deri(a),a.resize(n-1); return IDeri(a); &#125; Poly Exp(Poly a)&#123; // 多项式Exp int n=a.size(); if(n==1) return Poly&#123;1&#125;; Poly b=a; b.resize((n+1)/2),b=Exp(b); b.resize(n); Poly c=Ln(b); rep(i,0,n-1) c[i]=a[i]-c[i],Mod2(c[i]); c[0]++,b=b*c; b.resize(n); return b; &#125; void Exp_Solve(Poly &amp;A,Poly &amp;B,int l,int r)&#123; static int X[N],Y[N]; if(l==r) &#123; B[l]=1ll*B[l]*Inv[l]%P; return; &#125; int mid=(l+r)&gt;&gt;1; Exp_Solve(A,B,l,mid); int R=Init(r-l+2); rep(i,0,R) X[i]=Y[i]=0; rep(i,l,mid) X[i-l]=B[i]; rep(i,0,r-l-1) Y[i+1]=A[i]; NTT(R,X,1),NTT(R,Y,1); rep(i,0,R-1) X[i]=1ll*X[i]*Y[i]%P; NTT(R,X,-1); rep(i,mid+1,r) B[i]+=X[i-l],Mod1(B[i]); Exp_Solve(A,B,mid+1,r); &#125; Poly CDQ_Exp(Poly F)&#123; int n=F.size(); F=Deri(F); Poly A(n); A[0]=1; Exp_Solve(F,A,0,n-1); return A; &#125; Poly Pow(Poly x,int k) &#123; // 多项式k次幂 x=Ln(x); rep(i,0,x.size()-1) x[i]=1ll*x[i]*k%P; return Exp(x); &#125; Poly EvaluateTemp[N&lt;&lt;1]; void EvaluateSolve1(Poly &amp;a,int l,int r,int p=1)&#123; if(l==r) &#123; EvaluateTemp[p]=Poly&#123;P-a[l],1&#125;; return; &#125; int mid=(l+r)&gt;&gt;1; EvaluateSolve1(a,l,mid,p&lt;&lt;1),EvaluateSolve1(a,mid+1,r,p&lt;&lt;1|1); EvaluateTemp[p]=EvaluateTemp[p&lt;&lt;1]*EvaluateTemp[p&lt;&lt;1|1]; &#125; void EvaluateSolve2(Poly &amp;res,Poly F,int l,int r,int p=1)&#123; if(l==r)&#123; res[l]=F[0]; return; &#125; int mid=(l+r)&gt;&gt;1; EvaluateSolve2(res,F%EvaluateTemp[p&lt;&lt;1],l,mid,p&lt;&lt;1); EvaluateSolve2(res,F%EvaluateTemp[p&lt;&lt;1|1],mid+1,r,p&lt;&lt;1|1); &#125; Poly Evaluate(Poly a,Poly b,int flag=1)&#123; // 多项式多点求值 Poly res(b.size()); if(flag) EvaluateSolve1(b,0,b.size()-1); EvaluateSolve2(res,a,0,b.size()-1); return res; &#125; Poly InterpolationSolve(Poly &amp;T,int l,int r,int p=1)&#123; if(l==r) return Poly&#123;T[l]&#125;; int mid=(l+r)&gt;&gt;1; return InterpolationSolve(T,l,mid,p&lt;&lt;1)*EvaluateTemp[p&lt;&lt;1|1]+InterpolationSolve(T,mid+1,r,p&lt;&lt;1|1)*EvaluateTemp[p&lt;&lt;1]; &#125; Poly Interpolation(Poly X,Poly Y)&#123; // 多项式快速插值 int n=X.size(); EvaluateSolve1(X,0,n-1); Poly T=Evaluate(Deri(EvaluateTemp[1]),X,0); rep(i,0,n-1) T[i]=Y[i]*qpow(T[i])%P; return InterpolationSolve(T,0,n-1); &#125; void FFPTrans(Poly &amp;a,int f)&#123; // FFP&lt;-&gt;EGF int n=a.size(); Poly b(n); if(f==1) rep(i,0,n-1) b[i]=FInv[i]; else rep(i,0,n-1) b[i]=(i&amp;1)?P-FInv[i]:FInv[i]; a=a*b; a.resize(n); &#125; Poly FFPMul(Poly a,Poly b)&#123; // FFP卷积 int n=a.size()+b.size()-1; a.resize(n),b.resize(n); FFPTrans(a,1),FFPTrans(b,1); rep(i,0,n-1) a[i]=1ll*a[i]*b[i]%P*Fac[i]%P; FFPTrans(a,-1); return a; &#125; Poly PolyToFFP(Poly F)&#123; // 多项式转FFP int n=F.size(); Poly G(n); rep(i,0,n-1) G[i]=i; G=Evaluate(F,G); rep(i,0,n-1) F[i]=1ll*G[i]*FInv[i]%P; FFPTrans(F,-1); return F; &#125; Poly FFPToPoly(Poly F)&#123; // FFP转多项式 FFPTrans(F,1); int n=F.size(); Poly X(n); rep(i,0,n-1) X[i]=i,F[i]=1ll*F[i]*Fac[i]%P; EvaluateSolve1(X,0,n-1); rep(i,0,n-1) &#123; F[i]=1ll*F[i]*FInv[i]%P*FInv[n-i-1]%P; if((n-i-1)&amp;1) F[i]=(P-F[i])%P; &#125; return InterpolationSolve(F,0,n-1); &#125;&#125;using namespace Polynomial;Poly Lag(int n,Poly X,Poly Y)&#123; Poly T(n+1),R(n+1),A(n+1); T[0]=1; rep(i,0,n) drep(j,i+1,0) T[j]=(1ll*T[j]*(P-X[i])+(j?T[j-1]:0))%P; rep(i,0,n) &#123; ll t=1; rep(j,0,n) if(i!=j) t=t*(X[i]-X[j]+P)%P; t=qpow(t)*Y[i]%P,R[n+1]=T[n+1]; drep(j,n,0) A[j]=(A[j]+t*R[j+1])%P,R[j]=(T[j]+1ll*R[j+1]*X[i]%P+P)%P; &#125; return A;&#125;int main()&#123; int n=rd(); Init_w(); Poly F(n); rep(i,0,n-1) F[i]=rd(); Show(CDQ_Exp(F));&#125; \\\\\\","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"CodeChef 2020 November - Challenge Chef and the Combination Lock (多项式)","slug":"CodeChef 2020 November - Challenge Chef and the Combination Lock (多项式)","date":"2021-03-10T10:29:06.000Z","updated":"2021-05-22T03:54:10.901Z","comments":true,"path":"articles/2021/03/10/783a8969.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/10/783a8969.html","excerpt":"","text":"CodeChef 2020 November - Challenge Chef and the Combination Lock (多项式)题目大意：给定了$n$个随机变量$x_i\\in{0,1,\\cdots,A_i}$，令$\\Chi=\\min_i\\lbrace x_i,A_i-x_i\\rbrace$，求$E(\\Chi)$ 我们知道$E(\\Chi)=\\sum_{i=0}^{\\infty} P(\\Chi&gt;i)$ 不妨考虑计算$P(\\Chi&gt;i)$，先计算方案数，发现方案数可以用一个多项式来表示 令$F(x)$为$\\Chi&gt;x$的方案数，则$\\begin{aligned}F(x)=\\prod_{i=1}^n (A_i-1-2x) \\end{aligned}$ 显然$\\Chi \\leq \\min\\lbrace \\frac{A_i} {2} \\rbrace$，不妨设这个上界为$U$，也就是说我们要求$\\sum_{i=0}^U F(i)$ 常识：一个$n$次多项式前缀和可以用一个不超过$n+1$次的多项式来表示 如果暴力求出$F(x)$在$x=0,1,\\cdots,n+1$处的值，累前缀和，然后用拉格朗日插值法求出解 暴力求值复杂度为$O(n^2)$，拉格朗日插值复杂度为$O(n)$ 可以用分治$\\text{NTT}$优化$F(x)$的求解，然后用多项式多点求值求得点值 复杂度为$O(n\\log ^2n)$，实际在CodeChef上的运行时间为0.53s 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef unsigned long long ull;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1&lt;&lt;18,P=998244353;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;typedef vector &lt;int&gt; Poly;void Show(Poly a,int k=0)&#123; if(!k)&#123; for(int i:a) printf(&quot;%d &quot;,i); puts(&quot;&quot;); &#125; else for(int i:a) printf(&quot;%d\\n&quot;,i);&#125;int rev[N],w[N];int Inv[N+1],Fac[N+1],FInv[N+1];void Init() &#123; int t=qpow(3,(P-1)/N); w[N&gt;&gt;1]=1; rep(i,(N&gt;&gt;1)+1,N-1) w[i]=1ll*w[i-1]*t%P; drep(i,(N&gt;&gt;1)-1,1) w[i]=w[i&lt;&lt;1]; Inv[0]=Inv[1]=Fac[0]=Fac[1]=FInv[0]=FInv[1]=1; rep(i,2,N) &#123; Inv[i]=1ll*(P-P/i)*Inv[P%i]%P; FInv[i]=1ll*FInv[i-1]*Inv[i]%P; Fac[i]=1ll*Fac[i-1]*i%P; &#125;&#125;int Init(int n)&#123; int R=1,c=-1; while(R&lt;n) R&lt;&lt;=1,c++; rep(i,1,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;c); return R;&#125;void NTT(int n,int *a,int f)&#123; rep(i,0,n-1) if(rev[i]&lt;i) swap(a[i],a[rev[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,Mod2(a[j+i]); a[j]+=t,Mod1(a[j]); &#125; &#125; &#125; if(f==-1) &#123; reverse(a+1,a+n); ll base=Inv[n]; rep(i,0,n-1) a[i]=a[i]*base%P; &#125;&#125;void NTT(int n,Poly &amp;a,int f)&#123; static int A[N]; if((int)a.size()&lt;n) a.resize(n); rep(i,0,n-1) A[i]=a[i]; NTT(n,A,f); rep(i,0,n-1) a[i]=A[i];&#125;Poly operator * (Poly a,Poly b)&#123; int n=a.size()+b.size()-1; int R=Init(n); a.resize(R),b.resize(R); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=1ll*a[i]*b[i]%P; NTT(R,a,-1); a.resize(n); return a;&#125;Poly operator + (Poly a,Poly b) &#123; int n=max(a.size(),b.size()); a.resize(n),b.resize(n); rep(i,0,n-1) a[i]+=b[i],Mod1(a[i]); return a; &#125;Poly operator - (Poly a,Poly b) &#123; int n=max(a.size(),b.size()); a.resize(n),b.resize(n); rep(i,0,n-1) a[i]-=b[i],Mod2(a[i]); return a; &#125;Poly Poly_Inv(Poly a) &#123; int n=a.size(); if(n==1) return Poly&#123;(int)qpow(a[0],P-2)&#125;; Poly b=a; b.resize((n+1)/2); b=Poly_Inv(b); int R=Init(n&lt;&lt;1); a.resize(R),b.resize(R); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=(2-1ll*a[i]*b[i]%P+P)*b[i]%P; NTT(R,a,-1); a.resize(n); return a;&#125;// 应用转置原理优化的多项式多点求值Poly Evaluate(Poly F,Poly X)&#123; static int ls[N&lt;&lt;1],rs[N&lt;&lt;1],cnt; static Poly T[N&lt;&lt;1]; static auto TMul=[&amp;] (Poly F,Poly G)&#123; int n=F.size(),m=G.size(); if(n&lt;=20 &amp;&amp; m&lt;=20)&#123; rep(i,0,n-m) &#123; int t=0; rep(j,0,m-1) t=(t+1ll*F[i+j]*G[j])%P; F[i]=t; &#125; F.resize(n-m+1); return F; &#125; reverse(G.begin(),G.end()); int R=Init(n); NTT(R,F,1),NTT(R,G,1); rep(i,0,R-1) F[i]=1ll*F[i]*G[i]%P; NTT(R,F,-1); Poly T(n-m+1); rep(i,0,n-m) T[i]=F[i+m-1]; return T; &#125;; static function &lt;int(int,int)&gt; Build=[&amp;](int l,int r) &#123; int u=++cnt; ls[u]=rs[u]=0; if(l==r) &#123; T[u]=Poly&#123;1,P-X[l]&#125;; return u; &#125; int mid=(l+r)&gt;&gt;1; ls[u]=Build(l,mid),rs[u]=Build(mid+1,r); T[u]=T[ls[u]]*T[rs[u]]; return u; &#125;; int n=F.size(),m=X.size(); cmax(n,m),F.resize(n),X.resize(n); cnt=0,Build(0,n-1); F.resize(n*2+1),T[1]=TMul(F,Poly_Inv(T[1])); int p=0; rep(i,1,cnt) if(ls[i]) &#123; swap(T[ls[i]],T[rs[i]]); int R=Init(T[i].size()),n=T[i].size(),m1=T[ls[i]].size(),m2=T[rs[i]].size(); NTT(R,T[i],1); reverse(T[ls[i]].begin(),T[ls[i]].end()); reverse(T[rs[i]].begin(),T[rs[i]].end()); NTT(R,T[ls[i]],1); NTT(R,T[rs[i]],1); rep(j,0,R-1) &#123; T[ls[i]][j]=1ll*T[ls[i]][j]*T[i][j]%P; T[rs[i]][j]=1ll*T[rs[i]][j]*T[i][j]%P; &#125; NTT(R,T[ls[i]],-1); NTT(R,T[rs[i]],-1); rep(j,0,n-m1) T[ls[i]][j]=T[ls[i]][j+m1-1]; T[ls[i]].resize(n-m1+1); rep(j,0,n-m2) T[rs[i]][j]=T[rs[i]][j+m2-1]; T[rs[i]].resize(n-m2+1); &#125; else X[p++]=T[i][0]; X.resize(m); return X;&#125;int n;int A[N];int I[N],J[N];int F[N],L[N],R[N];Poly Solve(int l,int r) &#123; if(l==r) return Poly&#123;A[l]-1,P-2&#125;; int mid=(l+r)&gt;&gt;1; return Solve(l,mid)*Solve(mid+1,r);&#125;int main() &#123; Init(); rep(i,J[0]=1,N-1) J[i]=1ll*J[i-1]*i%P; I[N-1]=qpow(J[N-1]); drep(i,N-1,1) I[i-1]=1ll*I[i]*i%P; rep(kase,1,rd()) &#123; int x=P,All=1; n=rd(); rep(i,1,n+1) F[i]=0; F[0]=1; int f=0; rep(i,1,n) &#123; A[i]=rd(); f|=!A[i]; cmin(x,(A[i]-1)/2),All=1ll*All*(A[i]+1)%P; &#125; if(f)&#123; puts(&quot;0&quot;); continue; &#125; Poly Y=Solve(1,n),X(n+2); rep(i,0,n+1) X[i]=i; Y=Evaluate(Y,X); rep(i,1,n+1) Y[i]=(Y[i]+Y[i-1])%P; int ans=0; if(x&lt;=n+1) ans=Y[x]; else &#123; // 拉格朗日插值 L[0]=x; rep(i,1,n+1) L[i]=1ll*L[i-1]*(x-i)%P; R[n+2]=1; drep(i,n+1,0) R[i]=1ll*R[i+1]*(x-i)%P; rep(i,0,n+1) &#123; int t=1ll*Y[i]*(i?L[i-1]:1)%P*R[i+1]%P*I[i]%P*I[n+1-i]%P; if((n+1-i)&amp;1) t=P-t; ans=(ans+t)%P; &#125; &#125; ans=ans*qpow(All)%P; printf(&quot;%d\\n&quot;,ans); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"Codechef","slug":"Codechef","permalink":"http://chasingdeath.github.io/tags/Codechef/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「BalticOI 2020」病毒","slug":"「BalticOI 2020」病毒","date":"2021-03-10T01:59:43.000Z","updated":"2021-05-22T03:54:11.156Z","comments":true,"path":"articles/2021/03/10/5ddd8536.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/10/5ddd8536.html","excerpt":"","text":"「BalticOI 2020」病毒设点集大小为$N$，边集总长度$\\sum k=M$，模板串总长$L=\\sum ℓ$ 涉及到多串匹配的转移问题，容易想到$\\text{AC}$自动机 因为本题状态非常少，可以暴力矩阵维护转移，暴力计算由状态$i$转移至状态$j$，且中途不匹配的最小长度 有$NL^2$个状态 给定的是一张有向图，可以用奇怪的$\\text{Bellman-Ford,Dijkstra}$完成暴力转移 复杂度未知。。。上界应该比较高，但是鉴于常数小可以通过 \\\\优化的转移：把每一条边的前缀拆出来，建立虚点 这样以来，所有状态转移可以归纳为 虚点+实点 $\\to$ 虚点/实点 一共有$(N+M)L^2$个状态，$(N+M)L^2$种转移，每种转移涉及两个元素，产生$L$个元素 故对于每种转移的每一方，被遍历时都要枚举依次转移，共有$2(N+M)L^3$次转移 因此可以认为建立的图有$(N+M)L^2$个点，$2(N+M)L^3$条边 对此运行 类似 最短路算法即可 因此用$\\text{Dijkstra}$维护转移的复杂度为$O(\\ (N+M)L^3\\ \\log ((N+M)L^2)\\ )$ \\—-以下是未优化Bellman-Ford代码—— 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=110,M=54;int n,m,k;typedef vector &lt;int&gt; V;int trie[M][2],fail[M],mk[M],cnt;void Ins(const V &amp;S)&#123; int now=0; for(int i:S) &#123; int &amp;nxt=trie[now][i]; if(!nxt) nxt=++cnt; now=nxt; &#125; mk[now]=1;&#125;void Build()&#123; static queue &lt;int&gt; que; rep(i,0,1) if(trie[0][i]) que.push(trie[0][i]); while(!que.empty()) &#123; int u=que.front(); que.pop(); mk[u]|=mk[fail[u]]; rep(i,0,1)&#123; int &amp;v=trie[u][i]; if(v) que.push(v); (!v?v:fail[v])=trie[fail[u]][i]; &#125; &#125; // delete illegal state rep(i,0,cnt) rep(j,0,1) if(mk[trie[i][j]]) trie[i][j]=cnt+1;&#125;V Read()&#123; V Res; rep(i,1,rd()) Res.pb(rd()); return Res;&#125;vector &lt;V&gt; G[N];int E[N][N];const ll INF=-1;ll dis[N][M][M],ans[N];int fl=1;void Work(int u)&#123; static ll F[M][M],G[M][M]; ll f=INF; for(V S:(::G[u])) &#123; memset(F,255,sizeof F); rep(i,0,cnt) F[i][i]=0; for(int c:S) &#123; rep(i,0,cnt) rep(j,0,cnt) G[i][j]=F[i][j],F[i][j]=INF; rep(i,0,cnt) rep(j,0,cnt) if(G[i][j]&lt;INF) rep(k,0,cnt) if(G[i][j]+dis[c][j][k]&gt;=max(G[i][j],dis[c][j][k])) cmin(F[i][k],G[i][j]+dis[c][j][k]); &#125; rep(i,0,cnt) rep(j,0,cnt) if(dis[u][i][j]&gt;F[i][j]) dis[u][i][j]=F[i][j],cmin(f,F[i][j]); &#125; if(f!=INF) fl=1;&#125;int main()&#123; n=rd()-1,m=rd(),k=rd(); rep(i,1,m) &#123; int u=rd(); V w=Read(); G[u].pb(w); for(int v:w) E[v][u]=1; &#125; rep(i,1,k) Ins(Read()); Build(); memset(dis,255,sizeof dis),memset(ans,255,sizeof ans); rep(u,0,1) rep(i,0,cnt) if(!mk[i]) dis[u][i][trie[i][u]]=1; while(fl)&#123; fl=0; rep(i,2,n) Work(i); &#125; rep(i,2,n) rep(j,0,cnt) if(!mk[j]) cmin(ans[i],dis[i][0][j]); rep(i,2,n) &#123; if(ans[i]==INF) puts(&quot;YES&quot;); else printf(&quot;NO %llu\\n&quot;,ans[i]); &#125;&#125; ——以下是无比垃圾的优化代码—— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;#define pb push_backtypedef pair &lt;int,int&gt; Pii;#define mp make_pair#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=210,M=52;const ll INF=-1;int n,m,k,c;typedef vector &lt;int&gt; V;int trie[M][2],fail[M],mk[M],cnt;void Ins(const V &amp;S)&#123; int now=0; for(int i:S) &#123; int &amp;nxt=trie[now][i]; if(!nxt) nxt=++cnt; now=nxt; &#125; mk[now]=1;&#125;void Build()&#123; static queue &lt;int&gt; que; rep(i,0,1) if(trie[0][i]) que.push(trie[0][i]); while(!que.empty()) &#123; int u=que.front(); que.pop(); mk[u]|=mk[fail[u]]; rep(i,0,1)&#123; int &amp;v=trie[u][i]; if(v) que.push(v); (!v?v:fail[v])=trie[fail[u]][i]; &#125; &#125; mk[cnt+1]=1; rep(i,0,cnt) rep(j,0,1) if(mk[i] || mk[trie[i][j]]) trie[i][j]=cnt+1;&#125;V Read()&#123; V Res; rep(i,1,rd()) Res.pb(rd()); return Res;&#125;vector &lt;Pii&gt; G[N];ll dis[N][M][M];struct Node&#123; int u,s,t; ll d; bool operator &lt; (const Node &amp;__) const &#123; return d&gt;__.d; &#125;&#125;;priority_queue &lt;Node&gt; que;void Upd(int u,int s,int t,ll d)&#123; if(mk[s]||mk[t]||dis[u][s][t]&lt;=d) return; dis[u][s][t]=d,que.push((Node)&#123;u,s,t,d&#125;);&#125;int main()&#123; c=n=rd()-1,m=rd(),k=rd(); ++c; // 建立一个空虚点 rep(i,1,m) &#123; int u=rd(); V w=Read(); int lst=n+1; rep(j,0,w.size()-1) &#123; if(j==jend) G[lst].pb(mp(w[j],u)),G[w[j]].pb(mp(lst,u)); else G[lst].pb(mp(w[j],++c)),G[w[j]].pb(mp(lst,c)),lst=c; &#125; &#125; rep(i,1,k) Ins(Read()); Build(); memset(dis,255,sizeof dis); rep(i,0,cnt) if(!mk[i]) dis[n+1][i][i]=0; // 单位矩阵 rep(u,0,1) rep(i,0,cnt) Upd(u,i,trie[i][u],1); while(!que.empty()) &#123; int u=que.top().u,s=que.top().s,t=que.top().t; ll d=que.top().d; que.pop(); if(d&gt;dis[u][s][t]) continue; for(auto i:G[u]) &#123; int v=i.first,to=i.second; if(u&lt;=n) &#123; rep(i,0,cnt) if(dis[v][i][s]&lt;INF) Upd(to,i,t,dis[v][i][s]+d); &#125; else &#123; rep(i,0,cnt) if(dis[v][t][i]&lt;INF) Upd(to,s,i,d+dis[v][t][i]); &#125; &#125; &#125; rep(i,2,n) &#123; ll ans=-1; rep(j,0,cnt) if(!mk[j]) ans=min(ans,dis[i][0][j]); if(ans==INF) puts(&quot;YES&quot;); else printf(&quot;NO %llu\\n&quot;,ans); &#125;&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「BalticOI 2020」小丑","slug":"「BalticOI 2020」小丑","date":"2021-03-09T03:46:39.000Z","updated":"2021-05-22T03:54:11.150Z","comments":true,"path":"articles/2021/03/09/9347360f.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/09/9347360f.html","excerpt":"","text":"「BalticOI 2020」小丑Analysis问题即考虑加入一个边集，判断是否是二分图 容易想到用带权并查集/LCT 之类的结构维护 考虑对于每个左端点/右端点 维护最长的有解区间$R_i/L_i$ $L_i,R_i$显然具有单调性 就可以$O(1)$完成查询 下文认为$n,m$同阶 Sol1 LCT考虑尺取，同时用$\\text{LCT}$暴力维护答案合法性，下面只讲$\\text{LCT}$实现 考虑对于所有的边，优先加入树上，对于每一个环，只保留最后被删除的边 这样可以保证一条边被删除时，两个连通块之间没有边 同时，维护每一个连通块内的奇环边 最优集合 即可 复杂度为$O(n\\log n)$，速度。。。。 Sol2 分治决策单调性/整体二分考虑用并查集维护二分图，求出$R_i$，对于$i\\in [l,r]$，已知答案区间为$[L,R]$ 通过枚举来找到$[l,r]$中答案分别为$[L,mid),[mid,R]$的两部分的界点$p$ 为此我们加入$[mid+1,m]$的边，然后依次加入$[1,r]$的边，直到出现方案 直接维护复杂度显然是错的 因此考虑在分治过程中，保证分治$[l,r],[L,R]$时，$[1,l-1],[R+1,m]$的边集已经加入 此时每次操作需要移动的范围在$[l,r],[L,R]$以内 分治共$\\log n$层，每层长度总和为$n$，因此移动次数为$O(n\\log n)$ 由于需要维护简单的回撤操作，可以用按秩合并并查集，因此总复杂度为$O(n\\log ^2n)$ Loj Submission","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「BalticOI 2020」混合物 ","slug":"「BalticOI 2020」混合物 ","date":"2021-03-09T03:06:54.000Z","updated":"2021-05-22T03:54:11.152Z","comments":true,"path":"articles/2021/03/09/971ed4ac.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/09/971ed4ac.html","excerpt":"","text":"「BalticOI 2020」混合物题目大意： 对于给定的向量$\\vec{O}=(x,y,z)$ 动态维护一个集合$S=\\{(x_i,y_i,z_i)\\}$ 求出最少用几个$S$中的元素能够 实数正系数 线性组合得到$O$ 考虑令$\\displaystyle x’=\\frac{x} {x+y+z},y’=\\frac{y} {x+y+z}$，显然$x,y$能够完成组合，$z$就一定成立 此时，问题转化为了一个平面问题，答案分为几种情况 1.$S$包含$O$，答案显然为1 2.$O$在$S$中两点构成的线段上，显然答案为2 3.$O$被某一个三角形包含，答案为3 4.无解 不妨令$T=\\{P-O|P\\in S\\}$，此时 情况1即$T$包含原点 情况2即$T$中某两点与原点共线且在原点两端 情况3即$S$构成的凸包包含原点 因为只需要判断是否包含，所以其实和凸包并没有关系 考虑不包含的情况，则显然可以用一个 以原点为界的半平面 包住$S$中的所有点 因此可以维护每个点的极角，判断是否可以用半平面完全包含 实现上，完全包含可以认为是$\\max-\\min&lt;\\pi$ 或者是半平面跨过极角为$0$的位置，此时令$x,y$分别为$&lt;\\pi$最大值，$&gt;\\pi$最小值 能包含即$x+2\\pi-y&lt;\\pi$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;typedef long double db;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=2e5+10,INF=1e9+10;const db eps=1e-9,PI=acos((db)-1);int n;struct Node&#123; db x,y; Node()&#123; &#125; Node(db x,db y):x(x),y(y)&#123; &#125; Node operator - (const Node &amp;t) const &#123; return Node(x-t.x,y-t.y); &#125; db angle()&#123; db t=atan2(y,x); if(t&lt;-eps) t+=2*PI; return t; &#125;&#125; O,A[N];Node Read() &#123; db a=rd(),b=rd(),c=rd(),s=a+b+c; return Node(a/s,b/s);&#125;int cnt1,cnt2;char op[2];struct cmp&#123; bool operator () (const db &amp;x,const db &amp;y) const &#123; return x+eps&lt;y; &#125; &#125;;multiset &lt;db,cmp&gt; st;db Go(db x)&#123; x+=PI; if(x&gt;=2*PI) x-=2*PI; return x;&#125;void Ins(Node x)&#123; if(fabs(x.x)&lt;eps &amp;&amp; fabs(x.y)&lt;eps) return void(cnt1++); db y=x.angle(); if(st.find(y)==st.end() &amp;&amp; st.find(Go(y))!=st.end()) cnt2++; st.insert(y);&#125;void Del(Node x)&#123; if(fabs(x.x)&lt;eps &amp;&amp; fabs(x.y)&lt;eps) return void(cnt1--); db y=x.angle(); st.erase(st.find(y)); if(st.find(y)==st.end() &amp;&amp; st.find(Go(y))!=st.end()) cnt2--;&#125;int main()&#123; O=Read(); rep(_,1,rd()) &#123; scanf(&quot;%s&quot;,op); if(*op==&#x27;A&#x27;) Ins(A[++n]=(Read()-O)); else Del(A[rd()]); if(cnt1) puts(&quot;1&quot;); else if(cnt2) puts(&quot;2&quot;); else &#123; int f=1; if(st.empty()) f=0; else &#123; if(*st.rbegin()-*st.begin()&lt;PI+eps) f=0; else &#123; auto y=st.upper_bound(PI),x=y; x--; if(*x+2*PI-*y&lt;PI+eps) f=0; &#125; &#125; puts(f?&quot;3&quot;:&quot;0&quot;); &#125; &#125;&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"K短路","slug":"k短路","date":"2021-03-08T03:09:38.000Z","updated":"2021-05-22T03:54:11.117Z","comments":true,"path":"articles/2021/03/08/766aa3c0.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/08/766aa3c0.html","excerpt":"","text":"k短路好像是一个比较简单的东西 对于 正权有向图，$\\displaystyle G=(V,E),V=\\{V_i\\}_{i=1}^nE=\\{(u_i,v_i,w_i)\\}_{i=1}^m$ 求$s$到$t$的前$k$短路 考虑建立反图$G’=(V,E’)$，容易$\\text{Dijkstra}$求得$t$的单源最短路$dis_i$，并且建立一棵最短路树 考虑$s\\rightarrow t$的最短路，一定是走了一些树边和非树边 选择一条非树边$(u,v,w)$会使长度增加$w’=w-(dis_u-dis_v)$，称$w’$为额外长度 考虑我们选择的非树边序列$(u_i,v_i,w_i)$，显然有：$u_{i+1}$是$v_i$在最短路树上的祖先 考虑用搜索扩展的方式来遍历所有路径情况 记录当前的节点$u$，产生的额外长度$d$，则每次的扩展可以归纳为 1.从$u$所有祖先中取出边的集合$S_u$ 2.依次遍历$S_u$中的所有边$(u_i,v_i,w’_i)$，进入递归$u’=v_i,d’=d+w’_i$ 每次扩展会产生一个新的状态，且恰好可以遍历每一个状态一次 \\然而，为了求出前$k$短路，我们必须按照答案从小到大遍历 那么我们首先需要将集合$S_u$排序，从小到大遍历，其次要对于不同的递归情况按照大小扩展 容易想到用一个堆维护扩展的顺序，为了保存遍历$S_u$集合的过程，记录一个指针$p$ 此时，用堆维护扩展的方法显然： 1.取出堆顶状态$(u,d,p)$ 2.转移 2-1.在当前递归栈中移动$p\\leftarrow p+1$，改变$d$ 2-2.模拟上面，建立新的递归栈，同时令指针为$0$ 得到$u’=v_{u,p},d’=d+w’_{v,0},p’=0$ 如果暴力处理出$S_u$，则预处理复杂度为$O(nm\\log m)$，状态扩展复杂度为$O(2k\\log k)$ 用可持久化可并堆处理$S_u$，$p$记录当前堆顶节点指针 每次扩展$p\\leftarrow lson_p$或者$p\\leftarrow rson_p$，增加一个扩展状态 则预处理复杂度以及空间复杂度为$O(m\\log m)$，状态扩展复杂度为$O(3k\\log k)$ Luogu P2483 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;using namespace std;typedef double db;typedef pair &lt;db,int&gt; Pair;#define mp make_pair#define fi first#define se second#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=5010,M=2e5+10;const db eps=1e-7,INF=1e18;template &lt;class T&gt; class Heap&#123;public: T val; int h; Heap *ls,*rs; T top()&#123; return val; &#125; Heap()&#123; &#125; Heap(Heap *x):val(x-&gt;val),h(x-&gt;h),ls(x-&gt;ls),rs(x-&gt;rs)&#123; ; &#125; Heap(T val):val(val),h(0),ls(0),rs(0)&#123; ; &#125; friend Heap* Union(Heap *x,Heap *y)&#123; if(!x) return y; if(!y) return x; if(y-&gt;val&lt;x-&gt;val) swap(x,y); Heap* u=new Heap(x); u-&gt;rs=Union(u-&gt;rs,y); if(u-&gt;rs &amp;&amp; (!u-&gt;ls || u-&gt;rs-&gt;h&gt;u-&gt;ls-&gt;h)) swap(u-&gt;ls,u-&gt;rs); u-&gt;h=u-&gt;rs?u-&gt;rs-&gt;h+1:1; return u; &#125; Heap* pop()&#123; return Union(ls,rs); &#125; friend Heap* push(Heap *u,T val)&#123; return Union(u,new Heap(val)); &#125;&#125;;typedef Heap &lt;Pair&gt; Node;Node *rt[N];struct Edge&#123; int to;db w; Edge *nxt; Edge()&#123; &#125; Edge(int to,db w,Edge* nxt):to(to),w(w),nxt(nxt)&#123; ; &#125;&#125;;Edge *head[N],*pre[N];void AddEdge(int u,int v,db w)&#123; Edge* t=new Edge(v,w,head[u]); head[u]=t;&#125;int n,m,fa[N];db E,dis[N];void Dijkstra(int u)&#123; static priority_queue &lt;Pair,vector&lt;Pair&gt;,greater&lt;Pair&gt;&gt; que; rep(i,1,n) dis[i]=INF; dis[u]=0,que.push(&#123;0,u&#125;); while(!que.empty())&#123; int u=que.top().se;db d=que.top().fi; que.pop(); if(dis[u]&lt;d-eps) continue; for(Edge *i=head[u];i;i=i-&gt;nxt) &#123; int v=i-&gt;to; if(dis[v]&gt;dis[u]+i-&gt;w+eps) pre[v]=i,fa[v]=u,que.push(&#123;dis[v]=dis[u]+i-&gt;w,v&#125;); &#125; &#125;&#125;void Construct()&#123; static int I[N]; rep(i,1,n) I[i]=i; sort(I+1,I+n+1,[&amp;](int x,int y)&#123; return dis[x]&lt;dis[y]; &#125;); rep(u,1,n) &#123; for(Edge *i=head[u];i;i=i-&gt;nxt) &#123; int v=i-&gt;to; if(pre[v]==i) continue; rt[v]=push(rt[v],mp(i-&gt;w-(dis[v]-dis[u]),u)); &#125; &#125; rt[n]=0; rep(j,1,n) &#123; int u=I[j]; rt[u]=Union(rt[u],rt[fa[u]]); &#125;&#125;struct State&#123; db s; Node *rt; bool operator &lt; (const State &amp;__) const &#123; return s&gt;__.s; &#125;&#125;;int ans;void Kth_Path()&#123; static priority_queue &lt;State&gt; que; if(dis[1]&gt;E+eps) return void(puts(&quot;0&quot;)); ans=1,E-=dis[1]; if(rt[1]) que.push(&#123;dis[1]+rt[1]-&gt;val.fi,rt[1]&#125;); while(!que.empty()) &#123; State u=que.top(); que.pop(); if(u.s&gt;E+eps) break; int v=u.rt-&gt;val.se; ans++,E-=u.s; if(rt[v]) que.push(&#123;u.s+rt[v]-&gt;top().fi,rt[v]&#125;); u.s-=u.rt-&gt;val.fi; if(u.rt-&gt;ls) &#123; Pair w=u.rt-&gt;ls-&gt;val; que.push(&#123;u.s+w.fi,u.rt-&gt;ls&#125;); &#125; if(u.rt-&gt;rs) &#123; Pair w=u.rt-&gt;rs-&gt;val; que.push(&#123;u.s+w.fi,u.rt-&gt;rs&#125;); &#125; &#125; printf(&quot;%d\\n&quot;,ans);&#125;int main()&#123; n=rd(),m=rd(),scanf(&quot;%lf&quot;,&amp;E); rep(i,1,m)&#123; int u=rd(),v=rd();db w; scanf(&quot;%lf&quot;,&amp;w); AddEdge(v,u,w); &#125; Dijkstra(n); Construct(); Kth_Path();&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「JSOI2019」神经网络","slug":"「JSOI2019」神经网络","date":"2021-03-04T01:35:41.000Z","updated":"2021-05-22T03:54:11.216Z","comments":true,"path":"articles/2021/03/04/7d33ee6f.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/04/7d33ee6f.html","excerpt":"","text":"「JSOI2019」神经网络考虑一个合法的哈密顿路可以表示为什么样子： 按照不同树的编号，分割为一段段，相邻两段属于不同树 同时，如果最后一段和第一段同编号，将最后一段移动到第一段前面 由此，一个哈密顿路可以由唯一表示： 1号点在第一个段中，此后每一段和上一个属于不同树，且最后一段不属于1树 由此，问题分解为两部分： Part1 求解树路径分段考虑树形$dp$求解，每个点记录$dp_{i,j,0/1}$表示当前$i$子树内已经产生$j$条路径，$i$自己是否可以向父亲连边 容易用类似树形背包的方式合并，每次决策儿子是否连接到自己上面 注意：一个长度$&gt;1$的段，需要考虑正反方向的排放 复杂度为$O(\\sum k_i^2)$ \\Part2 合并每棵树的段相邻两段不同色，考虑容斥求解 枚举这棵树中的$i$个段自己生成了$j$个不合法的相邻，$i$个段合并生成$i-j$个段，且乘上容斥系数$(-1)^j$ $i$个并掉$j$个，方案数计算如下： 先把$i$个排好，乘上$i!$，然后选择$j$个间隔合并掉$\\binom{i-1} {j}$，然后对于剩下的$i-j$个元素无序，需要除掉$(i-j)!$ 背包合并容斥之后的结果，对于当前的$i$个元素，任意排列即可 然而上面是理想情况，还需要考虑$1$号元素不能被排列，要强制最后一个段不是1树的段 这一部分，在树1的容斥以及最终背包合并时特殊处理即可，即少排列一个元素，且最后合并时先选一个放在最后面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=5e3+10,P=998244353;int n,m;int I[N],J[N],C[N][N];ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;struct Edge&#123; int to,nxt;&#125; e[N&lt;&lt;1];int head[N],ecnt;void AddEdge(int u,int v)&#123; e[++ecnt]=(Edge)&#123;v,head[u]&#125;; head[u]=ecnt;&#125;int dp[N][N][2]; // 0,1 是否向上连int G[N][3],H[N][3],sz[N];void dfs(int u,int f)&#123; sz[u]=0; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].to; if(v==f) continue; dfs(v,u); &#125; G[0][0]=1,G[0][1]=G[0][2]=0; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].to; if(v==f) continue; rep(i,0,sz[u]+sz[v]) rep(j,0,2) H[i][j]=G[i][j],G[i][j]=0; rep(i,0,sz[u]) rep(a,0,2) if(H[i][a]) rep(j,0,sz[v]) rep(b,0,min(1,2-a)) G[i+j][a+b]=(G[i+j][a+b]+1ll*H[i][a]*dp[v][j][b])%P; sz[u]+=sz[v]; &#125; rep(i,0,sz[u]+1) dp[u][i][0]=dp[u][i][1]=0; rep(i,0,sz[u]) &#123; dp[u][i+1][0]=(0ll+dp[u][i+1][0]+G[i][0]+2*G[i][1]+2*G[i][2])%P; // 长度&gt;1的段可以翻转 dp[u][i][1]=(0ll+dp[u][i][1]+G[i][0]+G[i][1])%P; // 如果连了两个儿子，就无法向上连了 &#125; sz[u]++;&#125;int F[N],T[N];void Get()&#123; n=rd(); rep(i,1,n) head[i]=0; ecnt=0; rep(i,2,n) &#123; int u=rd(),v=rd(); AddEdge(u,v),AddEdge(v,u); &#125; dfs(1,0); rep(i,1,n) &#123; F[i]=dp[1][i][0],T[i]=0; ll t=1ll*F[i]*J[i]%P; rep(j,1,i) &#123; T[j]=(T[j]+((i-j)&amp;1?P-1:1)*t%P*C[i-1][i-j]%P*I[j])%P; &#125; &#125;&#125;int S[N],c;int main()&#123; rep(i,J[0]=1,N-1) J[i]=1ll*J[i-1]*i%P; I[N-1]=qpow(J[N-1]); drep(i,N-1,1) I[i-1]=1ll*I[i]*i%P; rep(i,0,N-1) rep(j,C[i][0]=1,i) C[i][j]=C[i-1][j]+C[i-1][j-1],Mod1(C[i][j]); m=rd(); if(m==1) return n=rd(),printf(&quot;%d\\n&quot;,n&lt;=2),0; S[0]=1; rep(t,1,m-1) &#123; Get(); drep(i,n+c,0) &#123; S[i]=0; rep(j,1,min(i,n)) S[i]=(S[i]+1ll*S[i-j]*T[j])%P; &#125; c+=n; &#125; Get(); rep(i,1,n) &#123; F[i]=dp[1][i][0],T[i]=0; ll t=1ll*F[i]*J[i-1]%P; // 特殊处理，不允许排列第一段 rep(j,1,i) T[j]=(T[j]+((i-j)&amp;1?P-1:1)*t%P*C[i-1][i-j]%P*I[j-1])%P; &#125; int ans=0; // 不允许改变第一段的位置 // 且强制最后一段不能属于第一棵树 rep(i,1,c) if(S[i]) rep(j,1,n) if(T[j]) &#123; // 强制前面的最后一个在最后 int t=1ll*J[i]*J[j-1]%P*C[i-1+j-1][j-1]%P; ans=(ans+1ll*t*S[i]%P*T[j])%P; &#125; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各省OI","slug":"各省OI","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E7%9C%81OI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「CCO 2020」购物计划","slug":"「CCO 2020」购物计划","date":"2021-03-03T08:34:03.000Z","updated":"2021-05-22T03:54:11.160Z","comments":true,"path":"articles/2021/03/03/d5909bf7.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/03/d5909bf7.html","excerpt":"","text":"「CCO 2020」购物计划核心思想：堆+调整临近 $x_i=y_i=1$ 这个限制相当于每一组内的权值排名可以确定，设组内为$A_{i,j}(j\\ge 1)$ 那么我们一个方案的选择可以用$M$个指针$P_i$表示，和为$\\displaystyle \\sum A_{i,P_i}$ 考虑用调整的方式解决这个问题，大体思路上，我们可以记录当前移动指针$P_p$ 每次可以选择移动$P_p$，或者某一个$P_{i},i&gt;p$ 如果直接进行，每次移动的指针数量是$O(m)$级别的，显然不可行 考虑优化一下进行，每次只能选取$i=p+1$ 此时，编号小的会先被移动 为了保证答案单调性，我们需要将$A_{i,2}-A_{i,1}$较小的组先移动 同时，并不是每一个组都会被移动，因此转移还要支持一个特殊回撤操作，来撤回当前组的指针 也就是说，若$P_p=2$，可以选择把$P_p$回撤为$1$，然后将$P_{p+1}$改为$2$ 由此，每个点状态可以选择： 1.移动自己 2.移动下一个 3.若$P_p=2$，回撤自己，同时移动下一个 这样的调整法，可以保证每一个状态恰好有一个前驱，且转移过程中值不断变大 由此可以$O(k)$状态数进行调整，用堆维护，复杂度为$O(k\\log k)$ \\组内调整一个组内会选择若干个数$A_{b_i},i\\in [1,c]$ 初始最小值，显然满足$b_i=i$ 类似的，我们记录当前指针$p$，前驱指针$l$，后继指针$r$ 显然$p$要往后移，且不能达到$r$，因此决策只有两种 1.移动前驱$l$，并将当前指针变为前驱 2.移动自己$p$ 这样的调整是固定个数的，因此，一开始就把$c\\in[x_i,y_i]$的所有情况插入即可 \\最后，将两部分一同进行，每次组间调整时，通过组内调整查询答案 总的组内和组间调整次数均为$O(k)$，状态数分别不超过$2k,3k$ 复杂度为$O(k\\log k)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;enum&#123;N=200010,LINF=1ll&lt;&lt;60&#125;;int n,m,k,I[N]; ll L;struct Group&#123; vector &lt;int&gt; A; int l,r,c; struct Node&#123; int l,p,r; ll s; bool operator &lt; (const Node &amp;__) const &#123; return s&gt;__.s; &#125; &#125;; priority_queue &lt;Node&gt; que; vector &lt;ll&gt; V; void Init()&#123; l=rd(),r=rd(),sort(A.begin(),A.end()),c=A.size(); if(c&lt;l) &#123; rep(i,1,k) puts(&quot;-1&quot;); exit(0); &#125; r=min(r,c); rep(i,0,l-1) L+=A[i]; ll s=0; if(!l) V.pb(0); rep(i,0,c-1) &#123; if(i&gt;=r) break; s+=A[i]; if(i&gt;=l-1) que.push((Node)&#123;i-1,i,c-1,s&#125;); &#125; &#125; void Next()&#123; if(que.empty()) return V.pb(LINF); Node t=que.top(); que.pop(); V.pb(t.s); if(t.p&lt;t.r) que.push((Node)&#123;t.l,t.p+1,t.r,t.s-A[t.p]+A[t.p+1]&#125;); // Move current point if(~t.l &amp;&amp; t.l&lt;t.p-1) que.push((Node)&#123;t.l-1,t.l+1,t.p-1,t.s-A[t.l]+A[t.l+1]&#125;); // Move previous point &#125; // get kth sum ll operator [] (const int &amp;k)&#123; while((int)V.size()&lt;k) Next(); return V[k-1]; &#125;&#125; S[N];struct Node&#123; int x,y; ll s; bool operator &lt; (const Node &amp;__) const &#123; return s&gt;__.s; &#125;&#125;;priority_queue &lt;Node&gt; que;int main()&#123; n=rd(),m=rd(),k=rd(); rep(i,1,n) &#123; int x=rd(); S[x].A.pb(rd()); &#125; rep(i,1,m) S[i].Init(); printf(&quot;%lld\\n&quot;,L),k--; rep(i,1,m) I[i]=i; sort(I+1,I+m+1,[&amp;](int x,int y)&#123; return S[x][2]-S[x][1]&lt;S[y][2]-S[y][1]; &#125;); que.push((Node)&#123;1,2,L-S[I[1]][1]+S[I[1]][2]&#125;); while(k) &#123; Node t=que.top(); que.pop(); if(t.s&gt;=LINF) break; k--,printf(&quot;%lld\\n&quot;,t.s); int i=I[t.x],j=I[t.x+1]; que.push((Node)&#123;t.x,t.y+1,t.s-S[i][t.y]+S[i][t.y+1]&#125;);// Move current point if(j) que.push((Node)&#123;t.x+1,2,t.s-S[j][1]+S[j][2]&#125;); // Move next point if(t.y==2 &amp;&amp; j) que.push((Node)&#123;t.x+1,2,t.s-S[i][2]+S[i][1]-S[j][1]+S[j][2]&#125;); // Back current point ,and move next point &#125; while(k--) puts(&quot;-1&quot;);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"CCO","slug":"CCO","permalink":"http://chasingdeath.github.io/tags/CCO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「NOI2020」时代的眼泪","slug":"「NOI2020」时代的眼泪","date":"2021-03-03T06:20:42.000Z","updated":"2021-05-22T03:54:11.219Z","comments":true,"path":"articles/2021/03/03/d1e79365.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/03/d1e79365.html","excerpt":"","text":"「NOI2020」时代的眼泪前言这种东西看到就给人一种 分块分块分块分块分块分块! 啊啊啊啊啊啊啊啊啊啊啊 \\问题分析这是一个二维区间顺序对问题，对于普通的区间顺序对问题，我们有简单分块解法 预处理整块的答案，有$n\\sqrt n$个数要插入预处理，也就是有$O(\\sqrt n)$个区间查询 对于散点暴力求，也是$n\\sqrt n$个区间查询问题 那么离线+分块就可以做到$O(\\sqrt n)$插入一个数，$O(\\sqrt 1)$查询，并且有办法将空间实现到$O(n)$ 那么对于二维区间考虑部分沿用上面的思路 \\Solution首先对于散块的部分，是完全一样的处理，可以$O(n)$内存实现 具体的： 散点之间可以暴力$for$答案，每次还需要一个二维区间个数查询 每次需要查询的散点又是一段区间 可以描述为$O(m)$个查询，总共查询$O(m\\sqrt n)$个散点 \\问题在于整块部分的查询$[p1,p2],[u,d]$ 对于同一个块内的答案，可以暴力预处理出来 \\而块之间，可以转化为$[1,d]-[1,u-1]-[1,u-1]\\times [u,d]$ 前面两个前缀型问题，可以用如下方法实现： 按照$p_i$从小到大插入，同时维护每个块内已经出现的个数 每次插入$i$后，对于$i$前面的块，会产生$O(\\sqrt n)$对 顺序对 我们要查询的是一个块编号$[p1,p2]$内块的关系，这是一个二维前缀和 可以把两个维度的前缀和分开给插入和查询 具体的，在插入时，处理$S_{l,r}=\\sum_{i\\ge l} C_{i,r}$ 查询$[p1,p2]$时，就可以暴力求$S_{l,i}i\\in[l,r]$的和 这样可以分摊复杂度为$O(n\\sqrt n)$，并且内存为$O(n)$，常数较小 \\对于$[1,u-1]\\times [u,d]$，从左到右一段段 查询过来，每次查询块内$[1,u-1]$$，[u,d]$个数即可 这个统计和上面的块内答案统计都需要预处理每个数在块内排名 但是也可以通过离线去掉这个步骤，避免了一个$O(n\\sqrt n)$的数组 \\实际实现时，发现散块暴力的部分枚举起来实在太慢，所以块开大了一点，加了一点底层玄学优化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;typedef vector &lt;int&gt; V;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1e5+10,M=2e5+10,S=1000;int n,m,A[N],len,P[N];struct Blocker&#123; int s[M],t[N]; void clear()&#123; memset(s,0,(n+1)&lt;&lt;2),memset(t,0,(n+1)&lt;&lt;2); &#125; void Add(int x)&#123; int p=x/len; rep(i,x,(p+1)*len-1) s[i]++; rep(i,p+1,n/len) t[i]++; &#125; int operator [](const int &amp;x) const&#123; return s[x]+t[x/len]; &#125;&#125; B;int L[M],R[M],U[M],D[M],p1[M],p2[M],I[M],T[M];ll Ans[M];struct Que&#123; int l,r,k,id; &#125;;vector &lt;Que&gt; Q[N];// 处理散点void SolvePoints()&#123; rep(i,1,n) &#123; B.Add(A[i]); for(Que x:Q[i]) &#123; rep(j,x.l,x.r) &#123; int u=U[x.id],d=D[x.id]; if(A[j]&lt;u || A[j]&gt;d) continue; if(j&gt;i) cmin(d,A[j]-1); else cmax(u,A[j]+1); Ans[x.id]+=x.k*(B[d]-B[u-1]); &#125; &#125; &#125;&#125;vector &lt;Pii&gt; E[N];// 处理块区间的 前缀逆序对void SolveB1()&#123; static ll s[S][S],c[S]; rep(k,1,n) &#123; int i=P[k],t=0,p=i/len; c[p]++; drep(j,p-1,0) t+=c[j],s[j][p]+=t; for(Pii x:E[k]) &#123; int u=x.first,l=p1[u]+1,r=p2[u]-1; rep(j,l+1,r) Ans[u]+=s[l][j]*x.second; &#125; &#125;&#125;//处理块内答案void SolveB2()&#123; static int s[S][S],C[N]; rep(i,0,n/len) &#123; int l=max(1,i*len),r=min(n,(i+1)*len-1); rep(j,1,n) C[j]=C[j-1]+(l&lt;=P[j] &amp;&amp; P[j]&lt;=r); int L=C[n]; rep(a,1,L+1) rep(b,a-1,L+1) s[a][b]=0; rep(a,l,r) rep(b,a+1,r) if(A[a]&lt;=A[b]) s[C[A[a]]][C[A[b]]]++; drep(a,L,1) rep(b,a,L) s[a][b]+=s[a+1][b]+s[a][b-1]-s[a+1][b-1]; rep(j,1,m) if(p1[j]&lt;i &amp;&amp; i&lt;p2[j]) &#123; Ans[j]+=s[C[U[j]-1]+1][C[D[j]]]; Ans[j]-=1ll*T[j]*(C[D[j]]-C[U[j]-1]); T[j]+=C[U[j]-1]; &#125; &#125;&#125;// 本来是暴力for l,r内的逆序对的，但是太慢，加了一点底层优化int Que(int i,int l,int r,int u,int d)&#123; if(r-l&gt;45) &#123; int mid=(l+r*3)/4; Q[l-1].pb(&#123;mid+1,r,-1,i&#125;); Q[mid].pb(&#123;mid+1,r,1,i&#125;); return Que(i,l,mid,u,d)+Que(i,mid+1,r,u,d); &#125; int ans=0; rep(i,l,r) if(u&lt;=A[i] &amp;&amp; A[i]&lt;=d) rep(j,i+1,r) ans+=A[i]&lt;=A[j] &amp;&amp; A[j]&lt;=d; return ans;&#125;int main()&#123; freopen(&quot;tears.in&quot;,&quot;r&quot;,stdin),freopen(&quot;tears.out&quot;,&quot;w&quot;,stdout); n=rd(),m=rd(),len=ceil(sqrt(n/4.0)); fprintf(stderr,&quot;Block len=%d ,Block Count=%d\\n&quot;,len,n/len); rep(i,1,n) P[A[i]=rd()]=i; clock_t ti=clock(); rep(i,1,m) &#123; I[i]=i,L[i]=rd(),R[i]=rd(),U[i]=rd(),D[i]=rd(); p1[i]=L[i]/len,p2[i]=R[i]/len; if(p1[i]==p2[i])&#123; Ans[i]=Que(i,L[i],R[i],U[i],D[i]); continue; &#125; Ans[i]=Que(i,L[i],(p1[i]+1)*len-1,U[i],D[i])+Que(i,p2[i]*len,R[i],U[i],D[i]); Q[L[i]-1].pb(&#123;p2[i]*len,R[i],-1,i&#125;); Q[p2[i]*len-1].pb(&#123;p2[i]*len,R[i],1,i&#125;); if(p1[i]&lt;p2[i]-1) &#123; Q[(p1[i]+1)*len-1].pb(&#123;L[i],(p1[i]+1)*len-1,-1,i&#125;); Q[p2[i]*len-1].pb(&#123;L[i],(p1[i]+1)*len-1,1,i&#125;); E[D[i]].pb(mp(i,1)); E[U[i]-1].pb(mp(i,-1)); &#125; &#125; fprintf(stderr,&quot;Part0 %d\\n&quot;,int(clock()-ti)),ti=clock(); SolvePoints(); fprintf(stderr,&quot;Part1 %d\\n&quot;,int(clock()-ti)),ti=clock(); sort(I+1,I+m+1,[&amp;](int x,int y)&#123; return L[x]&lt;L[y]; &#125;); SolveB1(); fprintf(stderr,&quot;Part2 %d\\n&quot;,int(clock()-ti)),ti=clock(); SolveB2(); fprintf(stderr,&quot;Part3 %d\\n&quot;,int(clock()-ti)),ti=clock(); rep(i,1,m) printf(&quot;%lld\\n&quot;,Ans[i]);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「CCO 2020」千山万壑","slug":"「CCO 2020」千山万壑","date":"2021-03-03T02:43:07.000Z","updated":"2021-05-22T03:54:11.159Z","comments":true,"path":"articles/2021/03/03/9721906c.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/03/9721906c.html","excerpt":"","text":"「CCO 2020」千山万壑性质推演推论1:不选择非树边时，答案为$2(n-1)-$直径长比较明显就不证了 推论2:最多只会选择一条非树边考虑如果选择两条非树边，此时必然有答案$\\ge n-1+3\\lceil\\frac{n} {3}\\rceil$ 因为能够选择这样的非树边，则必然存在一条长度$&gt;\\frac{n} {3}$的路径，也就是说 直径长度$&gt;\\frac{n} {3}$，故此时选择直径更优 因此不会选择两条非树边 \\答案计算下称起点终点路径$(s,t)$，选择的边为$(u,v,w)$ 如果$(s,t)$与$(u,v)$无交，则无序额外计算贡献，此时贡献为 $2(n-1)-dis(s,t)-(dis(u,v)-w)$ 当$(s,t)$与$(u,v)$有交时，设交长度为$len$，则需要额外花费$2(len-1)$的代价取遍历交部分的点 \\求解显然我们需要先知道$dis(u,v)$，可以$O(n)$预处理，我们选择的非树边一定满足$dis(u,v)&gt;w$ 考虑抽直径构成序列$L_i$，然后考虑每一条非树边$(u,v,w)$的贡献，设$u,v$在直径上对应根的编号为$x,y$ 如果$x=y$，显然可以选择直径，下面讨论$x&lt;y$的情况 1.$(s,t)$与$(u,v)$无交 1-1.对于$(u,v)$之间的部分可以区间查询最值 1-2.两边预处理前缀/后缀最值 1-3.直径连接到$u$，$v$子树的部分的答案可以换根$dp$预处理 2.$(s,t)$与$(u,v)$有交，设交部分在直径上的区间为$[l,r]$ 2-1. 相交跨过直径上多个点 2-1-1.若$x&lt;l&lt;r&lt;y$，此时容易用线段树维护答案 2-1-2. 若$x&lt;y , \\text{and } (l=x \\text{ or } r=y)$，此时显然两边部分最优一定是选择在直径上的部分 以下情况一定不优 另一边的答案可以在线段树上查询出来，是一个区间的前缀/后缀 2-2.若$l=r$，此时$l=x$或$l=y$，且在$[u,x],[v,y]$部分有交 容易发现，此时确定$(s,t)$一边一定在直径的一端，另一端$x,y$对应的子树中 同样可以通过换根$dp$解决 区间查询，如果使用线段树解决，复杂度为$O(n+m\\log n)$ 如果用奇怪数据结构（猫树），复杂度为$O(n\\log n+m)$ 「CCO 2020」千山万壑性质推演推论1:不选择非树边时，答案为$2(n-1)-$直径长比较明显就不证了 推论2:最多只会选择一条非树边考虑如果选择两条非树边，此时必然有答案$\\ge n-1+3\\lceil\\frac{n} {3}\\rceil$ 因为能够选择这样的非树边，则必然存在一条长度$&gt;\\frac{n} {3}$的路径，也就是说 直径长度$&gt;\\frac{n} {3}$，故此时选择直径更优 因此不会选择两条非树边 \\答案计算下称起点终点路径$(s,t)$，选择的边为$(u,v,w)$ 如果$(s,t)$与$(u,v)$无交，则无序额外计算贡献，此时贡献为 $2(n-1)-dis(s,t)-(dis(u,v)-w)$ 当$(s,t)$与$(u,v)$有交时，设交长度为$len$，则需要额外花费$2(len-1)$的代价取遍历交部分的点 \\求解显然我们需要先知道$dis(u,v)$，可以$O(n)$预处理，我们选择的非树边一定满足$dis(u,v)&gt;w$ 考虑抽直径构成序列$L_i$，然后考虑每一条非树边$(u,v,w)$的贡献，设$u,v$在直径上对应根的编号为$x,y$ 确定非树边之后，我们需要选择一个最优的$(s,t)$，答案计算上面已经提及 如果$x=y$，显然可以选择直径，下面讨论$x&lt;y$的情况 1.$(s,t)$与$(u,v)$无交 1-1.对于$(u,v)$之间的部分可以区间查询子树最值 1-2.两边预处理前缀/后缀最值 1-3.直径连接到$u$，$v$子树的部分的答案 就是一棵树剔除根到一个点路径之后的直径长度，可以换根$dp$预处理 2.$(s,t)$与$(u,v)$有交，设交部分在直径上的区间为$[l,r]$ 容易参分转化为求解：$dis(s,t)+dis(u,v)-w-2(r-l)+2$最大值 2-1. 相交跨过直径上多个点 2-1-1.若$x&lt;l&lt;r&lt;y$，此时容易用线段树维护答案 合并时减去跨过长度的贡献即可 2-1-2. 若$x&lt;y , \\text{and } (l=x \\text{ or } r=y)$，此时显然两边部分最优一定是选择在直径上的部分 以下情况一定不优 另一边的答案可以在线段树上查询出来，是一个区间的前缀/后缀 2-2.若$l=r$，此时$l=x$或$l=y$，且在$[u,x],[v,y]$部分有交 容易发现，此时确定$(s,t)$一边一定在直径的一端，另一端$x,y$对应的子树中 同样可以通过换根$dp$解决 区间查询，如果使用线段树解决，复杂度为$O(n+m\\log n)$ 如果用奇怪数据结构（猫树），复杂度为$O(n\\log n+m)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=5e5+10,M=2e6+10,INF=1e9+10;int n,m;int U[M],V[M],W[M],D[M],vis[N];struct Edge&#123; int to,nxt;&#125; e[N&lt;&lt;1];int head[N],ecnt;void AddEdge(int u,int v)&#123; e[++ecnt]=(Edge)&#123;v,head[u]&#125;; head[u]=ecnt;&#125;int ma,num,fa[N],dep[N];vector &lt;Pii&gt; G[N];int Find(int x)&#123; return fa[x]==x?x:fa[x]=Find(fa[x]); &#125;void dfs1(int u,int f)&#123; if(dep[u]&gt;ma) ma=dep[u],num=u; vis[fa[u]=u]=1; for(Pii v:G[u]) if(vis[v.first]) D[v.second]=dep[u]+dep[v.first]-2*dep[Find(v.first)]; for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(v==f) continue; dep[v]=dep[u]+1,dfs1(v,u); &#125; fa[u]=f;&#125;void dfs2(int u,int f)&#123; if(dep[u]&gt;ma) ma=dep[u],num=u; fa[u]=f; for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(v==f) continue; dep[v]=dep[u]+1,dfs2(v,u); &#125;&#125;int id[N],L[N],C,dp[N][2],dp2[N],g[N],h[N];int subid[N];void dfs3(int u,int f)&#123; fa[u]=f; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].to; if(id[v]||v==f) continue; dfs3(v,u); cmax(dp2[u],dp2[v]); int t=dp[v][0]+1; if(t&gt;dp[u][0]) dp[u][1]=dp[u][0],dp[u][0]=t; else cmax(dp[u][1],t); &#125; cmax(dp2[u],dp[u][0]+dp[u][1]);&#125;void dfs4(int u,int f,int d=0)&#123; dep[u]=d,subid[u]=d&lt;=1?u:subid[f]; int tg[2]=&#123;-INF,-INF&#125;,th[2]=&#123;0,0&#125;; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].to; if(id[v]||v==f) continue; int x=dp[v][0]+1-(d?d:1e9); if(x&gt;tg[0]) tg[1]=tg[0],tg[0]=x; else cmax(tg[1],x); x=max(dp2[v],dp[v][0]+1); if(x&gt;th[0]) th[1]=th[0],th[0]=x; else cmax(th[1],x); &#125; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].to; if(id[v]||v==f) continue; h[v]=max(h[u],th[0]==max(dp2[v],dp[v][0]+1)?th[1]:th[0]); g[v]=max(g[u],tg[0]==dp[v][0]+1-(d?d:1e9)?tg[1]:tg[0]); id[v]=id[u],dfs4(v,u,d+1); &#125; if(f) cmax(g[u],dp[u][0]-d); cmax(h[u],dp2[u]);&#125;struct Node&#123; int len,ans,l,r; Node operator + (const Node __) const &#123; Node res; res.len=len+__.len; res.ans=max(ans,__.ans); res.l=max(l,__.l-len),res.r=max(r-__.len,__.r); cmax(res.ans,r+__.l+1); return res; &#125;&#125; s[N&lt;&lt;2];void Build(int p,int l,int r) &#123; if(l==r) &#123; s[p]=(Node)&#123;1,max(dp2[L[l]],dp[L[l]][0]),dp[L[l]][0],dp[L[l]][0]&#125;; return; &#125; int mid=(l+r)&gt;&gt;1; Build(p&lt;&lt;1,l,mid),Build(p&lt;&lt;1|1,mid+1,r); s[p]=s[p&lt;&lt;1]+s[p&lt;&lt;1|1];&#125;Node Que(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) return s[p]; int mid=(l+r)&gt;&gt;1; if(qr&lt;=mid) return Que(p&lt;&lt;1,l,mid,ql,qr); if(ql&gt;mid) return Que(p&lt;&lt;1|1,mid+1,r,ql,qr); return Que(p&lt;&lt;1,l,mid,ql,qr)+Que(p&lt;&lt;1|1,mid+1,r,ql,qr);&#125;int ls[N],rs[N];int main()&#123; n=rd(); rep(t,1,rd())&#123; int u=rd()+1,v=rd()+1,w=rd(); if(w==1) AddEdge(u,v),AddEdge(v,u); else U[++m]=u,V[m]=v,W[m]=w,G[u].pb(mp(v,m)),G[v].pb(mp(u,m)); &#125; ma=-1,dfs1(1,0); ma=-1,dep[num]=0,dfs2(num,0); for(int u=num;u;u=fa[u]) L[id[u]=++C]=u; rep(i,1,C) dfs3(L[i],0),g[L[i]]=-INF,dfs4(L[i],0); rep(i,1,C) ls[i]=max(ls[i-1],i-1+dp[L[i]][0]); drep(i,C,1) rs[i]=max(rs[i+1],C-i+dp[L[i]][0]); Build(1,1,C); int ans=C-1; rep(i,1,m) if(D[i]&gt;W[i]) &#123; int u=U[i],v=V[i],d=0; if(id[u]&gt;id[v]) swap(u,v); if(id[u]==id[v]) d=C-1; else &#123; if(fa[u]) &#123; cmax(d,h[u]); int f=subid[u],t=fa[f]; cmax(d,id[u]-1+(dp[f][0]+1==dp[t][0]?dp[t][1]:dp[t][0])); cmax(d,id[u]-1+g[u]+2); &#125; else cmax(d,dp[u][0]+id[u]-1); if(fa[v]) &#123; cmax(d,h[v]); int f=subid[v],t=fa[f]; cmax(d,C-id[v]+(dp[f][0]+1==dp[t][0]?dp[t][1]:dp[t][0])); cmax(d,C-id[v]+g[v]+2); &#125; else cmax(d,dp[v][0]+C-id[v]); cmax(d,ls[id[u]-1]),cmax(d,rs[id[v]+1]); int g1=id[u]-1,g2=C-id[v]; cmax(d,g1+g2-(id[v]-id[u])+2); if(id[u]+1&lt;id[v]) &#123; Node t=Que(1,1,C,id[u]+1,id[v]-1); cmax(d,t.ans); cmax(d,t.l+g1+1); cmax(d,t.r+g2+1); &#125; &#125; cmax(ans,D[i]-W[i]+d); &#125; printf(&quot;%d\\n&quot;,2*(n-1)-ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"CCO","slug":"CCO","permalink":"http://chasingdeath.github.io/tags/CCO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「USACO 2021.1 Platinum」Paint by Letters","slug":"「USACO 2021.1 Platinum」Paint by Letters","date":"2021-03-02T05:29:25.000Z","updated":"2021-05-22T03:54:11.269Z","comments":true,"path":"articles/2021/03/02/3fc2b39f.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/02/3fc2b39f.html","excerpt":"","text":"「USACO 2021.1 Platinum」Paint by Letters统计连通块问题，暴力是$O(qn^2)$，而且常数大 容易想到 平面图的欧拉定理 优化 下文和代码中，$V,E,F$分别为点集，边集，区域集合 其中$|V|$可以直接得到，$|E|$可以$O(n^2)$前缀和预处理出来，$O(1)$查询 下面处理区域个数 Solution1前缀和所有大小为1（即被四个点包住的）区域，暴力预处理所有大小$&gt;1$的区域，个数为$O(\\frac{nm} {4})$ 然后可以转化为一个对于给定矩形查询包含的 矩形个数 的问题 实际上这个题目$q$小直接枚举就是了。。 复杂度为$O(nm+q\\frac{nm} {4})$，足够通过时限 写的够丑可以得到这个代码 矩形区间查询问题 ，不知道有没有什么更好的方法 ps:垃圾数据没有卡，因此实际上数据中的空白块数量非常少，预处理写得稍微好一点可能还比下面的做法常数小 \\Solution2用$(x,y)$表示$(x,y),(x+1,y),(x,y+1),(x+1,y+1)$中间的一个空白区域 这些空白块会被染色块之间的边隔开，但是依然可以形成四联通块 预处理出所有空白区域的连通块，每个连通块选取一个代表点$S_i$ 我们要统计一个区域中的空白连通块个数，注意到 跨出区域范围的空白点，并不是断开了，而是和最外层的无穷空白区合并在一起 因此可以先求出在区域中存在的连通块个数，然后将连通到区域外的部分去掉 具体实现上： 前缀和预处理出$S_i$的位置，每次查询区域中的$S_i$个数（这样的统计不完全） 然后将$S_i$在区域中，且跨出区域的白色连通块删掉即可 跨出部分枚举四条边界即可 每次查询枚举边界，因此复杂度为$O(nm+q(n+m))$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)const int N=1e3+10,INF=1e9+10;const int dx[]=&#123;0,0,1,-1&#125;,dy[]=&#123;1,-1,0,0&#125;;int n,m,q;char A[N][N];int vis[N*N],I[N][N],E[4][N][N],S[N][N];// B,C预处理上/左边个数int B[N][N],C[N][N];int X[N*N],Y[N*N],cnt;// 搜索空白连通块void dfs(int x,int y)&#123; I[x][y]=cnt; rep(i,0,3) if(E[x][y][i]) &#123; int x1=x+dx[i],y1=y+dy[i]; if(!x1 || !y1||x1&gt;=n || y1&gt;=m || I[x1][y1]) continue; dfs(x1,y1); &#125;&#125;int Sum(const int A[N][N],int x1,int y1,int x2,int y2)&#123; x1--,y1--; return A[x2][y2]-A[x1][y2]-A[x2][y1]+A[x1][y1];&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); rep(i,1,n) scanf(&quot;%s&quot;,A[i]+1); rep(i,1,n) rep(j,1,m) &#123; E[0][i][j-1]=E[1][i][j]=A[i][j]!=A[i+1][j]; E[2][i-1][j]=E[3][i][j]=A[i][j]!=A[i][j+1]; // 处理一下空白点之间的边 if(A[i-1][j]==A[i][j]) B[i][j]++; if(A[i][j]==A[i][j-1]) C[i][j]++; &#125; // 预处理空白点之间的集合 rep(i,1,n-1) rep(j,1,m-1) if(!I[i][j]) &#123; X[++cnt]=i,Y[cnt]=j,vis[cnt]=q+1; dfs(i,j),S[i][j]++; &#125; rep(i,1,n) rep(j,1,m) &#123; B[i][j]+=B[i-1][j]+B[i][j-1]-B[i-1][j-1]; C[i][j]+=C[i-1][j]+C[i][j-1]-C[i-1][j-1]; S[i][j]+=S[i-1][j]+S[i][j-1]-S[i-1][j-1]; &#125; while(q--) &#123; int lx,ly,rx,ry; scanf(&quot;%d%d%d%d&quot;,&amp;lx,&amp;ly,&amp;rx,&amp;ry); int V=(rx-lx+1)*(ry-ly+1); int E=Sum(B,lx+1,ly,rx,ry)+Sum(C,lx,ly+1,rx,ry); int F=Sum(S,lx,ly,rx-1,ry-1); auto Check=[&amp;](int i)&#123; if(vis[i]!=q &amp;&amp; lx&lt;=X[i] &amp;&amp; X[i]&lt;rx &amp;&amp; ly&lt;=Y[i] &amp;&amp; Y[i]&lt;ry) vis[i]=q,F--; &#125;; rep(i,lx,rx-1) &#123; if(::E[0][i][ry-1]) Check(I[i][ry-1]); if(::E[1][i][ly]) Check(I[i][ly]); &#125; rep(i,ly,ry-1) &#123; if(::E[2][rx-1][i]) Check(I[rx-1][i]); if(::E[3][lx][i]) Check(I[lx][i]); &#125; printf(&quot;%d\\n&quot;,V-E+F); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"USACO","slug":"USACO","permalink":"http://chasingdeath.github.io/tags/USACO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「USACO 2021.1 Platinum」Sum of Distances","slug":"「USACO 2021.1 Platinum」Sum of Distances","date":"2021-03-02T04:29:57.000Z","updated":"2021-05-22T03:54:11.271Z","comments":true,"path":"articles/2021/03/02/b64c0f69.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/02/b64c0f69.html","excerpt":"","text":"「USACO 2021.1 Platinum」Sum of Distances设在$G_i$中$j_i$点可行的距离集合为$D_{j_i}$ 注意到一个点的$(j_1,j_2,\\ldots,j_k)$的$dis$可以用如下方式确定 $\\displaystyle dis(j_1,j_2,\\ldots,j_k)=\\min\\{\\bigcap D_{j_i} \\}$ 而$D_{j_i}$有一个简单的描述方法： 求出奇数和偶数的最小值，然后再最小值往上+$2k$的部分均存在（不停来回） 这样我们用两个值$odd_{j_i},even_{j_i}$描述了$D_{j_i}$ 同时也容易得到$\\displaystyle dis(j_1,j_2,\\ldots,j_k)=\\min\\{\\max\\{odd_{j_i} \\},\\max\\{even_{j_i} \\} \\}$ 也就是说要在奇偶的$\\max$之间取$\\min$ 考虑$odd_{j_i},even_{j_i}$是$O(N_i)$级别的，可以暴力合并，但是无法处理外层的$\\min$，因此考虑用一个简单的$\\text{minmax}$容斥解决 $\\min\\{a,b\\}=a+b-\\max\\{a,b\\}$ 这样就只有$\\max$要计算了，用简单的前缀和优化取$\\max$操作 注意要按照$N_i$排序之后依次合并每一个$G_i$保证复杂度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair &lt;int,int&gt; Pii;#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=2e5+10,P=1e9+7;int n;int C[N],R[N],D[N][2],I[N],M[N],S[N*2];vector &lt;int&gt; G[N];int dis[N][2],U,F[N],H[N];int Solve(int S)&#123; F[U=0]=1; rep(k,1,n) &#123; int i=I[k]; rep(j,U+1,M[i]) F[j]=F[j-1]; cmax(U,M[i]); rep(j,0,U) H[j]=0; rep(j,R[i-1]+1,R[i]) &#123; int d=-1; if(S&amp;1) cmax(d,D[j][0]); if(S&amp;2) cmax(d,D[j][1]); if(d==P) continue; H[d]++; &#125; rep(j,1,U) H[j]+=H[j-1]; rep(j,0,U) F[j]=1ll*F[j]*H[j]%P; &#125; drep(j,U,1) F[j]-=F[j-1],Mod2(F[j]); int ans=0; rep(j,0,U) ans=(ans+1ll*j*F[j])%P; return ans;&#125;int main()&#123; n=rd(); rep(i,1,n) &#123; I[i]=i,C[i]=rd(),R[i]=R[i-1]+C[i]; rep(j,1,C[i]) G[j].clear(); rep(j,1,rd())&#123; int u=rd(),v=rd(); G[u].pb(v),G[v].pb(u); &#125; rep(j,1,C[i]) dis[j][0]=dis[j][1]=P; dis[1][0]=0; static queue &lt;Pii&gt; que; que.push(mp(1,0)); while(!que.empty())&#123; int u=que.front().first,d=que.front().second; que.pop(); cmax(M[i],dis[u][d]); for(int v:G[u]) if(dis[v][!d]&gt;dis[u][d]+1) dis[v][!d]=dis[u][d]+1,que.push(mp(v,!d)); &#125; rep(j,1,C[i]) &#123; rep(k,0,1) &#123; D[R[i-1]+j][k]=dis[j][k]; if(dis[j][k]!=P) cmax(M[i],dis[j][k]); &#125; &#125; &#125; sort(I+1,I+n+1,[&amp;](int x,int y)&#123; return C[x]&lt;C[y]; &#125;); int ans=((Solve(1)+Solve(2)-Solve(3))%P+P)%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"USACO","slug":"USACO","permalink":"http://chasingdeath.github.io/tags/USACO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「2020noip模拟题-蒋凌宇」幂","slug":"「2020noip模拟题-蒋凌宇」幂","date":"2021-03-01T05:08:21.000Z","updated":"2021-05-22T03:54:11.127Z","comments":true,"path":"articles/2021/03/01/4b4b3132.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/03/01/4b4b3132.html","excerpt":"","text":"「2020noip模拟题-蒋凌宇」幂Analysis计算$x$出现的次数，可以转化为枚举每一个$x$，计算剩余$n-1$个位置合法括号序列个数 因此我们只需要计算合法括号序列个数 定义一个辅助计数：不可分割 的合法括号序列 这样的括号序列，满足：其恰好为$x$，或者序列两端是一对匹配的左右括号 而实际要求的括号序列 的就是这样的 不可分割括号序列 去掉两端的匹配括号 \\Solution设$a_n$为长度为$n$的不可分割 的合法括号序列数量 括号序列并非排列问题，因此我们用普通生成函数计算 设$\\text{OGF(a)}=A(x)$，$A(x)$容易发现$A(x)$满足下面的递归式 $\\displaystyle A(x)=x^2(\\sum_{i=0}^{\\infty} A^i(x))+x^1$ 其中$x^2$表示在外层加一对匹配括号，$\\sum_{i=0}^{\\infty} A^i(x)$枚举子括号中的分裂段，$x^1$表示单个$x$ 容易得到下面的化简过程 $\\displaystyle A(x)=\\frac{x^2} {1-A(x)}+x$ $A(x)-A^2(x)=x^2+xA(x)$ $A^2(x)-(x+1)A(x)+x^2+x=0$ 带入求根公式，得到$A(x)$的 收敛形式 $\\displaystyle A_1(x)=\\frac{x+1+\\sqrt{-3x^2-2x+1} } {2},A_2(x)=\\frac{x+1-\\sqrt{-3x^2-2x+1} } {2}$ 令$\\displaystyle F(x)=-3x^2-2x+1,G(x)=\\sqrt{F(x)}$ 容易手玩发现：$[x^0]G(x)=1$ 而根据定义，我们知道$[x^0]A(x)=0$，因此$A(x)=A_2(x)$ 接下来我们要求$\\displaystyle G(x)=F^\\frac{1} {2}(x)$ \\下面介绍对于短多项式$F(x)$，设$\\text{deg}(F(x))=m$，有理数$k(k\\ne 1)$ 求解$G(x)=F^k(x)$的前$n$项的$O(m^2+nm)$递推做法 变形$G(x)=F^k(x)$ $\\displaystyle G’(x)=kF^{k-1}(x)F’(x)$ $G’(x)F(x)=kF^k(x)F’(x)$ $G’(x)F(x)=kG(x)F’(x)$ \\求解递推式对于等号两边，考虑$[x^n]$一项的系数，容易求出$F’(x)=-6x-2$ $\\displaystyle \\sum_{i=0}^m [x^{n-i}]G’(x)F_i=k\\sum_{i=0}^{m-1}[x^{n-i}]G(x)F’_i$ $\\displaystyle \\sum_{i=0}^m x^{n-i+1}G(x)F_i=k\\sum_{i=0}^{m-1}[x^{n-i}]G(x)F’_i$ $\\displaystyle (n+1)[x^{n+1}]G(x)=k\\sum_{i=0}^{m-1}[x^{n-i}]G(x)F’_i-\\sum_{i=1}^m x^{n-i+1}G(x)F_i$ 带入这题的$k$，得到 $\\displaystyle [x^n]=\\frac{3(n-3)[x^{n-2}]+(2n-3)[x^{n-1}]} {n}$ 递推边界$[x^0]G(x)=1,[x^1]G(x)=-1$ 然后由$G(x)$得到$A(x)$再得到最终答案即可","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://chasingdeath.github.io/tags/NOIP/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"【UER  9】赶路","slug":"【UER  9】赶路","date":"2021-02-28T02:26:06.000Z","updated":"2021-05-22T03:54:11.314Z","comments":true,"path":"articles/2021/02/28/96f8d511.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/28/96f8d511.html","excerpt":"","text":"【UER #9】赶路——-一定有解。。 $x_1\\leq x_i\\leq x_n$将中间的点按照$(x_i,y_i)$排序，然后依次连过去即可 \\$x_1=y_1=0$，四个象限均存在点将所有点极角排序，然后走一圈即可 \\$O(n\\log n)$不妨设$x_1&lt;x_n$ 将$1,n$以外所有点分成三部分，即左边| 1 | 中间 | n | 右边 左边右边考虑极角排序转圈走，中间按照$(x_i,y_i)$走 发现两边极角排序之后转圈走不一定能够走到中间去，可能会与转圈时的路径相交 但是实际上画图就会发现，如果顺时针走的路径会相交，逆时针走一定不相交 因此对于左右枚举顺时针还是逆时针即可，4中情况，每种$O(n)$检查线段相交 总能构造一组合法解 预处理需要排序，因此复杂度为$O(n\\log n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=510,INF=1e9+10;const db eps=1e-7;int n,m;struct Node&#123; db x,y; Node()&#123; &#125; Node(db x,db y):x(x),y(y)&#123; &#125; bool operator &lt; (const Node __) const &#123; return x!=__.x?x&lt;__.x:y&lt;__.y; &#125; Node operator - (const Node &amp;t) const &#123; return Node(x-t.x,y-t.y); &#125; db operator * (const Node &amp;t) const &#123; return x*t.x+y*t.y; &#125; db operator ^ (const Node &amp;t) const &#123; return x*t.y-y*t.x; &#125; void turn(db t)&#123; db a=x*cos(t)-y*sin(t),b=x*sin(t)+y*cos(t); x=a,y=b; &#125; db tan() const &#123; return atan2(x,y); &#125;&#125; A[N];int Cross(int x,int y,int a,int b)&#123; if(((A[x]-A[y])^(A[a]-A[b]))==0) return 0; db l=(A[a]-A[x])^(A[y]-A[x]),r=(A[b]-A[x])^(A[y]-A[x]); if((l&lt;0)^(r&gt;0)) return 0; swap(a,x),swap(b,y); l=(A[a]-A[x])^(A[y]-A[x]),r=(A[b]-A[x])^(A[y]-A[x]); if((l&lt;0)^(r&gt;0)) return 0; return 1;&#125;int L[N],LC,R[N],RC,T[N],TC;int P[N];int Work()&#123; int C=0; P[++C]=1; rep(i,1,LC) P[++C]=L[i]; rep(i,1,TC) P[++C]=T[i]; rep(i,1,RC) P[++C]=R[i]; P[++C]=n; if(LC) rep(i,2,LC) if(Cross(P[LC+1],P[LC+2],P[i],P[i-1])) return 0; if(RC) drep(i,n,n-RC+2) if(Cross(P[n-RC],P[n-RC-1],P[i],P[i-1])) return 0; return 1;&#125;void Solve()&#123; rep(i,0,1) &#123; rep(j,0,1) &#123; if(Work()) &#123; rep(i,1,n) printf(&quot;%d &quot;,P[i]); puts(&quot;&quot;); return; &#125; reverse(R+1,R+RC+1); &#125; reverse(L+1,L+LC+1); &#125;&#125;int main()&#123; rep(kase,1,rd())&#123; rep(i,1,n=rd()) A[i].x=rd(),A[i].y=rd(); db t=1.0*(rand()+2)/(rand()+2); rep(i,1,n) A[i].turn(t); if(A[1].x&gt;A[n].x) rep(i,1,n) A[i].x=-A[i].x; LC=RC=TC=0; rep(i,2,n-1) if(A[i].x&lt;A[1].x-eps) L[++LC]=i; else if(A[i].x-eps&gt;A[n].x) R[++RC]=i; else T[++TC]=i; sort(T+1,T+TC+1,[&amp;](int x,int y)&#123; return A[x].x&lt;A[y].x; &#125;); sort(L+1,L+LC+1,[&amp;](int x,int y)&#123; return (A[x]-A[1]).tan()&lt;(A[y]-A[1]).tan(); &#125;); sort(R+1,R+RC+1,[&amp;](int x,int y)&#123; return (A[x]-A[n]).tan()&lt;(A[y]-A[n]).tan(); &#125;); Solve(); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"【UER  9】知识网络","slug":"【UER  9】知识网络","date":"2021-02-28T01:56:37.000Z","updated":"2021-05-22T03:54:11.312Z","comments":true,"path":"articles/2021/02/28/199b51c1.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/28/199b51c1.html","excerpt":"","text":"【UER #9】知识网络bitset写错没调出来。。。 $O(n(n+m))$暴力枚举起点，建立转移虚点，得到一个边权为$0/1$，点数$n+k$，边数为$O(n+m)$的图 然后广搜双端队列维护即可 \\$O(k(n+m)+\\frac{n(n+m)} {w})$考虑枚举颜色$k$，对于所有这种颜色的点，假设一开始$dis_u$均为$2$ 并由此广搜预处理一个最短路图，复杂度为$O(k(n+m))$ 由于图上有0边无0环，因此最短路图是拓扑图 那么选定其中一个点为起点，会将这个点的$dis\\rightarrow dis-1$，其他同色点$dis$不变 同时，这个点在最短路图上的所有后记节点$dis\\rightarrow dis-1$ 那么对于最短路图上所有点，统计有多少个起点能够到达它，就能够知道以这种颜色点为起点时，这个点不同的$dis$出现次数 这是一个拓扑图$dp$问题，不好处理，因此考虑用$\\text{bitset}$暴力存储所有能够转移的状态 由于需要维护的起点总数为$n$，单次只维护一个集合，因此无法直接用$\\text{std::bitset}$ 复杂度为$O(\\frac{nm} {w})$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=51000,INF=1e9+10;int n,m,k;struct Edge&#123; int to,nxt,w;&#125; e[N*4];int head[N],ecnt;void AddEdge(int u,int v,int w=1)&#123; e[++ecnt]=(Edge)&#123;v,head[u],w&#125;; head[u]=ecnt;&#125;int Q[N*4],D[N*4],L,R,dis[N];unsigned Ans[N];vector &lt;int&gt; G[200];int len;struct BITSET&#123; ull a[N/128]; int count()&#123; int c=0; rep(i,0,len) c+=__builtin_popcountll(a[i]); return c; &#125; void set(int x)&#123; a[x&gt;&gt;6]|=1ull&lt;&lt;x; &#125; void clear()&#123; memset(a,0,(len+1)&lt;&lt;3); &#125; void copy(const BITSET &amp;t)&#123; memcpy(a,t.a,(len+1)&lt;&lt;3); &#125; void operator |= (const BITSET &amp;t) &#123; rep(i,0,len) a[i]|=t.a[i]; &#125;&#125; BS[N];int cnt,vis[N],ind[N];void Topo(int sz)&#123; rep(i,1,n+k) ind[i]=0; rep(u,1,n+k) for(int i=head[u];i;i=e[i].nxt) if(dis[e[i].to]==dis[u]+e[i].w) ind[e[i].to]++; L=1,R=0; rep(i,1,n+k) if(dis[i]&lt;1e6 &amp;&amp; !ind[i]) Q[++R]=i; while(L&lt;=R)&#123; int u=Q[L++]; if(u&lt;=n) &#123; int t=BS[u].count(); Ans[dis[u]]+=sz-t; Ans[dis[u]-1]+=t; &#125; for(int i=head[u];i;i=e[i].nxt) if(dis[e[i].to]==dis[u]+e[i].w) &#123; BS[e[i].to]|=BS[u]; if(--ind[e[i].to]==0) Q[++R]=e[i].to; &#125; &#125;&#125;void Bfs(int c)&#123; if(!G[c].size()) return; memset(dis,63,(n+k+2)&lt;&lt;2); L=2*(n+k),R=2*(n+k)-1; rep(i,0,G[c].size()-1) Q[++R]=G[c][i],D[R]=dis[G[c][i]]=2; while(L&lt;=R)&#123; int u=Q[L++]; for(reg int i=head[u];i;i=e[i].nxt)&#123; reg int v=e[i].to,w=e[i].w; if(dis[v]&lt;=dis[u]+w) continue; dis[v]=dis[u]+w; if(!w) Q[--L]=v,D[L]=dis[v]; else Q[++R]=v,D[R]=dis[v]; &#125; &#125; len=G[c].size()/64; if(len&gt;=N/128)&#123; len=N/128-1; rep(i,1,n+k) BS[i].clear(); rep(i,0,G[c].size()-1) if(i&lt;len*64) BS[G[c][i]].set(i); Topo(len*64); int tmp=len*64; len=(G[c].size()-tmp)/64; rep(i,1,n+k) BS[i].clear(); rep(i,0,G[c].size()-1) if(i&gt;=tmp) BS[G[c][i]].set(i-tmp); Topo(G[c].size()-tmp); &#125; else &#123; rep(i,1,n+k) BS[i].clear(); rep(i,0,G[c].size()-1) BS[G[c][i]].set(i); Topo(G[c].size()); &#125;&#125;int col[N];int main()&#123; n=rd(),m=rd(),k=rd(); rep(i,1,n) &#123; int x=col[i]=rd(); AddEdge(n+x,i,0),AddEdge(i,n+x); G[x].pb(i); &#125; rep(i,1,m) &#123; int u=rd(),v=rd(); if(col[u]==col[v]) continue; ind[u]++,ind[v]++; AddEdge(u,v),AddEdge(v,u); &#125; rep(i,1,k) Bfs(i); Ans[1]=0; rep(i,2,k*2) Ans[i]/=2; Ans[k*2+1]=1ll*n*(n-1)/2; rep(i,1,k*2+1) printf(&quot;%u &quot;,Ans[i]),Ans[k*2+1]-=Ans[i];&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「WC2021」表达式求值","slug":"「WC2021」表达式求值","date":"2021-02-27T10:19:45.000Z","updated":"2021-05-22T03:54:11.274Z","comments":true,"path":"articles/2021/02/27/aec7f7f4.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/27/aec7f7f4.html","excerpt":"","text":"「WC2021」表达式求值直接枚举每一位求值显然至少是$O(n|S|)$的，为了减少计算次数，考虑对于$n$个不同数组的情况归纳出一些通用情况 对于一个数组，考虑计算答案$\\ge A_i$的方案数，那么有一部分数$\\ge A_i$ 直接状压$\\ge A_i$的数的集合，对于的数不同二进制表示就可以得到$2^m$种不同的状态 在计算时，只需要考虑是否$\\ge A_i$，分为两种值，$O(1)$合并即可 预处理出每个二进制对应的值，然后对于每个$A_i$计算答案即可 复杂度为$O(|S|2^m+nm\\log m)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=5e4+10,P=1e9+7;int n,m;int A[N][10];char s[N];struct Node&#123; int a[2]; Node()&#123; &#125; Node(int x)&#123; a[!x]=0,a[x]=1; &#125; Node operator &lt; (const Node x) const &#123; Node res; res.a[0]=(1ll*a[0]*(x.a[0]+x.a[1])+1ll*a[1]*x.a[0])%P; res.a[1]=1ll*a[1]*x.a[1]%P; return res; &#125; Node operator &gt; (const Node x) const &#123; Node res; res.a[0]=1ll*a[0]*x.a[0]%P; res.a[1]=(1ll*a[1]*(x.a[0]+x.a[1])+1ll*a[0]*x.a[1])%P; return res; &#125; Node operator + (const Node x) const &#123; int l=a[0]+a[1],r=x.a[0]+x.a[1]; Node res; rep(i,0,1) res.a[i]=(1ll*a[i]*r+1ll*l*x.a[i])%P; return res; &#125;&#125; X[N];int I[10],Y[N],T,val[N];void Work(int S)&#123; T=0; for(int i=1;s[i];++i) &#123; if(isdigit(s[i])) X[++T]=Node((S&gt;&gt;(s[i]-&#x27;0&#x27;))&amp;1),Y[T]=0; else if(s[i]==&#x27;&lt;&#x27;) Y[++T]=1; else if(s[i]==&#x27;&gt;&#x27;) Y[++T]=2; else if(s[i]==&#x27;?&#x27;) Y[++T]=3; else if(s[i]==&#x27;(&#x27;) Y[++T]=4; else X[T-1]=X[T],Y[T-1]=Y[T],T--; if(T&gt;2 &amp;&amp; !Y[T] &amp;&amp; !Y[T-2])&#123; if(Y[T-1]==1) X[T-2]=X[T-2]&lt;X[T]; if(Y[T-1]==2) X[T-2]=X[T-2]&gt;X[T]; if(Y[T-1]==3) X[T-2]=X[T-2]+X[T]; T-=2; &#125; &#125; val[S]=X[1].a[1];&#125;int main()&#123; n=rd(),m=rd(); rep(i,0,m-1) rep(j,1,n) A[j][i]=rd(); scanf(&quot;%s&quot;,s+1); rep(S,1,(1&lt;&lt;m)-1) Work(S); int ans=0; rep(i,1,n) &#123; rep(j,0,m-1) I[j]=j; sort(I,I+m,[&amp;](int x,int y)&#123; return A[i][x]&lt;A[i][y]; &#125;); int S=0; for(int j=m-1;~j;--j)&#123; S|=1&lt;&lt;I[j]; ans=(ans+1ll*(A[i][I[j]]-(j?A[i][I[j-1]]:0))*val[S])%P; &#125; &#125; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"WC","slug":"WC","permalink":"http://chasingdeath.github.io/tags/WC/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[补]「WC2021」括号路径 ","slug":"[补]「WC2021」括号路径 ","date":"2021-02-27T08:05:57.000Z","updated":"2021-05-22T03:54:11.109Z","comments":true,"path":"articles/2021/02/27/b92c6052.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/27/b92c6052.html","excerpt":"","text":"[补]「WC2021」括号路径注意到到达关系是相互的，因此可以把能够互相到达的点放到同一集合中 因此只需要考虑最简单的到达情况，发现实际上当一个点有两条同色入边时，可以将这两条边对应的点合并 对于每个集合，维护一个颜色出边的集合，可以用$\\text{std::map}$实现，每次合并两个点用并查集处理集合关系 然后用启发式合并的方式维护集合的边，即可做到$O(m\\log^2 m)$ 用线段树合并的方式维护同样的东西即可做到$O(m\\log k)$ 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;enum&#123;N=300010&#125;;int n,m,i,u,v,w,F[N],S[N];int Find(int x)&#123; return F[x]==x?x:F[x]=Find(F[x]); &#125;map &lt;int,int&gt; M[N];void U(int x,int y)&#123; x=Find(x),y=Find(y); if(x==y) return; if(M[x].size()&gt;M[y].size()) swap(x,y); F[x]=y,S[y]+=S[x]; for(auto i:M[x]) M[y].emplace(i); for(auto i:M[x]) U(M[y][i.first],i.second);&#125;main()&#123; for(scanf(&quot;%d%d%*d&quot;,&amp;n,&amp;m),i=1;i&lt;=n;++i) S[F[i]=i]=1; while(m--)&#123; scanf(&quot;%d%d%d&quot;,&amp;v,&amp;u,&amp;w),u=Find(u),v=Find(v); if(M[u].count(w)) U(M[u][w],v); else M[u][w]=v; &#125; int64_t ans=0; for(i=1;i&lt;=n;++i) if(Find(i)==i) ans+=1ll*S[i]*(S[i]-1)/2; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"WC","slug":"WC","permalink":"http://chasingdeath.github.io/tags/WC/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「CEOI2020」星际迷航","slug":"「CEOI2020」星际迷航","date":"2021-02-27T05:45:59.000Z","updated":"2021-05-22T03:54:11.168Z","comments":true,"path":"articles/2021/02/27/cd246478.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/27/cd246478.html","excerpt":"","text":"「CEOI2020」星际迷航首先是最简单的判断是否必胜的$dp$转移$\\displaystyle dp_u=\\bigcup_{v\\in son_u} \\text{not } dp_{v}$ 考虑第$i+1$层对于第$i$层的贡献，实际上只和$i+1$层有多少个点$dp$值为0/1有关 下面称$dp$值为0/1的点为 败/胜 点 考虑对于确定第$i$层的根为某一节点$root$之后 在某一个点下面接一个胜点，或者在一个胜点下面接一个点，对于胜败情况没有影响 在一个败点下面接一个败点，可能会导致一段连续祖先段的胜败翻转 考虑对于每个$u$作为根求出： 1.没有接上下一层时的胜败情况 ： $dp_u$ 2.有多少个节点接上一个败点之后，会导致根的胜败情况翻转：$R_u$ 这是一个换根$dp$问题 具体来说，$R_u$的值，根据子节点中败点的个数可以得到转移： 1.没有败点，那么就是所有子节点$R$之和+自己 2.恰好有一个败点，那么就是败点的$R$ 对此，每个点维护子节点中败点的个数，然后换根$dp$即可 求出每个$root$的1，2后，可以用一个矩阵维护每层的转移，就不再赘述 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=1e5+10,INF=1e9+10,P=1e9+7;int n;ll m;struct Mat&#123; int a[2][2]; void clear()&#123; memset(a,0,sizeof a); &#125; Mat operator * (const Mat x) const &#123; Mat res; res.clear(); rep(i,0,1) rep(j,0,1) rep(k,0,1) res.a[i][k]=(res.a[i][k]+1ll*a[i][j]*x.a[j][k])%P; return res; &#125;&#125; Res,X;int F[N],FC[N],FR[N],son[N][2],SR[N];// F子树胜败，FC子节点败点个数，FR子树翻转点个数，son存储两个儿子中的败点，SR存储儿子中的FR之和int G[N],GC[N],GR[N];// F,GC,GR是子树外的int dp[N],R[N],fa[N];// dp,R即上文所述vector &lt;int&gt; E[N];void dfs1(int u,int f) &#123; // 子树处理 fa[u]=f; for(int v:E[u]) if(v!=f) &#123; dfs1(v,u); FC[u]+=!F[v]; if(!F[v]) &#123; if(!son[u][0]) son[u][0]=v; else son[u][1]=v; &#125; SR[u]+=FR[v]; &#125; F[u]=FC[u]&gt;0; FR[u]=!F[u]; if(FC[u]&lt;=1) for(int v:E[u]) if(v!=f &amp;&amp; F[u]!=F[v]) FR[u]+=FR[v];&#125;//换根dpvoid dfs2(int u,int f) &#123; if(f) GC[u]=G[u]=!G[f],GR[u]=GR[f]+!G[u]; else GC[u]=G[u]=0,GR[u]=1; dp[u]=F[u]|G[u]; if(!dp[u]) R[u]=FR[u]+GR[u]-1; else if(FC[u]+G[u]==1) &#123; if(G[u]) R[u]=GR[u]; else R[u]=FR[u]; &#125; for(int v:E[u]) if(v!=f) &#123; GC[u]=FC[u]-!F[v]+(f?!G[f]:0); G[u]=GC[u]&gt;0; GR[u]=0; if(!G[u]) GR[u]=GR[f]+SR[u]-FR[v]+1; else if(GC[u]==1) &#123; if(son[u][0] &amp;&amp; son[u][0]!=v) GR[u]=FR[son[u][0]]; else if(son[u][1] &amp;&amp; son[u][1]!=v) GR[u]=FR[son[u][1]]; else GR[u]=GR[f]; &#125; dfs2(v,u); &#125;&#125;int cnt[2];int main()&#123; n=rd(),scanf(&quot;%lld&quot;,&amp;m); rep(i,2,n) &#123; int u=rd(),v=rd(); E[u].pb(v),E[v].pb(u); &#125; dfs1(1,0),dfs2(1,0); // 矩阵处理 rep(i,1,n) &#123; cnt[dp[i]]++; X.a[1][dp[i]]=(X.a[1][dp[i]]+n)%P; X.a[0][!dp[i]]=(X.a[0][!dp[i]]+R[i])%P; X.a[0][dp[i]]=(X.a[0][dp[i]]+n-R[i])%P; &#125; m--,Res.a[0][0]=Res.a[1][1]=1; while(m) &#123; if(m&amp;1) Res=Res*X; X=X*X; m&gt;&gt;=1; &#125; int x=(1ll*Res.a[0][0]*cnt[0]+1ll*Res.a[1][0]*cnt[1])%P; int y=(1ll*Res.a[0][1]*cnt[0]+1ll*Res.a[1][1]*cnt[1])%P; // 得到第一层败/胜 的个数，与第0层合并 int ans=0; if(!dp[1]) ans=1ll*x*R[1]%P; else ans=(1ll*x*(n-R[1])+1ll*n*y)%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"CEOI","slug":"CEOI","permalink":"http://chasingdeath.github.io/tags/CEOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「CEOI2018」斐波那契表示法","slug":"「CEOI2018」斐波那契表示法","date":"2021-02-26T06:28:10.000Z","updated":"2021-05-22T03:54:11.164Z","comments":true,"path":"articles/2021/02/26/f401e880.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/26/f401e880.html","excerpt":"","text":"「CEOI2018」斐波那契表示法思路：维护当前数值的唯一表示法，然后根据唯一表示法来确定答案 Part1 唯一表示法任何一个数$x$有唯一表示$P_i$，满足$x=\\sum F_{P_i},P_i&lt;P_{i+1}-1$ 即不会出现相邻两项 依次插入每一个数$x$，考虑可能出现的情况 1.$x$一位以及前后为空，那么直接插入 2.$x$一位为空，且$x-1$为空，$x+1$已经出现 删除$x+1$，插入$x+2$ 3.$x$一位为空，且$x+1$为空，$x-1$已经出现 删除$x-1$，插入$x+1$ 4.$x$一位有 先删除$x$，然后插入$x+1,x-2$ 对于操作1,2,3以及4中的$x+1$，每次操作增加$O(1)$个元素，每次递归进行删除$O(1)$个元素 操作次数为均摊$O(n)$ 对于$4$操作中的$x-2$，如果$x-2$已经出现就会不断进行递归 最终的效果就是所有被操作到的$x-2,x-4,x-6\\ldots$向右平移了一位 大致如此，实际情况比较复杂，要讨论x-2=0,x-2&lt;0等等情况 用一棵平衡树维护$P_i-P_{i-1}$的值即可，4操作可以二分左边第一个&gt;2的元素，然后进行平移 最终复杂度为$O(n\\log n)$ \\Part2 dp求答案令边界$P_0=0$，根据上面维护的$\\delta_i=P_i-P_{i-1}$ 考虑根据$\\delta_i$求解答案 显然一个数$x$可以下分为$x$或者$x-1,x-2$ 或 $x-1,x-3,x-4$ 或$x-1,x-3,x-5,x-6\\ldots$ 且不能碰到前面的数 简单分析发现$P_i$有$\\lceil \\frac{\\delta_i} {2}\\rceil $种下分方案 然而，$P_{i-1}$如果被下分，那么$P_{i-1}$这一位会消失，变成$P_{i-1}-1$作为限制点 也就是说，$P_{i-1}$的下分会影响到$\\delta_i$，使得$\\delta_i\\rightarrow \\delta_i+1$ 那么依次考虑每个$\\delta_i$，令$dp_{i,f}$表示前$i$个，最后一个是否下分的方案数，可以$dp$求解 由于要动态维护，因此可以考虑用一个类似矩阵的东西来维护区间的dp情况 在平衡树中$up$维护答案即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=4e5+10,P=1e9+7;int n;struct Node&#123; int l,r,ma,len; int a[2][2]; void clear()&#123; memset(a,0,sizeof a); &#125; Node()&#123; &#125; Node(int x)&#123; l=r=ma=len=x; rep(i,0,1) &#123; a[i][0]=1; a[i][1]=(x-1+i)/2; &#125; &#125; Node operator + (const Node _) const &#123; Node res; res.l=l,res.r=_.r,res.ma=max(ma,_.ma),res.len=len+_.len; res.a[0][0]=(1ll*a[0][0]*_.a[0][0]+1ll*a[0][1]*_.a[1][0])%P; res.a[1][0]=(1ll*a[1][0]*_.a[0][0]+1ll*a[1][1]*_.a[1][0])%P; res.a[0][1]=(1ll*a[0][0]*_.a[0][1]+1ll*a[0][1]*_.a[1][1])%P; res.a[1][1]=(1ll*a[1][0]*_.a[0][1]+1ll*a[1][1]*_.a[1][1])%P; return res; &#125;&#125; s[N],val[N];int rt,ls[N],rs[N],key[N];void Up(int x)&#123; s[x]=val[x]; if(ls[x]) s[x]=s[ls[x]]+s[x]; if(rs[x]) s[x]=s[x]+s[rs[x]];&#125;int U(int x,int y)&#123; if(!x||!y) return x|y; if(key[x]&lt;key[y]) return rs[x]=U(rs[x],y),Up(x),x; return ls[y]=U(x,ls[y]),Up(y),y;&#125;Pii Lower(int x,int len)&#123; if(len&lt;=0 || !x) return mp(0,x); if(s[x].len&lt;=len) return mp(x,0); if(s[ls[x]].len&gt;=len) &#123; Pii y=Lower(ls[x],len); return ls[x]=y.second,Up(x),mp(y.first,x); &#125; else &#123; Pii y=Lower(rs[x],len-s[ls[x]].len-val[x].len); return rs[x]=y.first,Up(x),mp(x,y.second); &#125;&#125;void EraseEnd(int &amp;x)&#123; if(!rs[x])&#123; x=ls[x]; return; &#125; static int T[N],C; for(int y=x;y;y=rs[y]) T[++C]=y; rs[T[C-1]]=ls[T[C]]; drep(i,C-1,1) Up(T[i]); C=0;&#125;void AddR(int x,int y)&#123; if(!x) return; if(rs[x]) return AddR(rs[x],y),Up(x); val[x]=Node(val[x].len+y),Up(x);&#125;void AddL(int x,int y)&#123; if(!x) return; if(ls[x]) return AddL(ls[x],y),Up(x); val[x]=Node(val[x].len+y),Up(x);&#125;Pii Split(int x)&#123; if(s[x].ma&lt;=2) return mp(0,x); if(val[x].ma&lt;=2 &amp;&amp; s[rs[x]].ma&lt;=2) &#123; Pii y=Split(ls[x]); return ls[x]=y.second,Up(x),mp(y.first,x); &#125; else &#123; Pii y=Split(rs[x]); return rs[x]=y.first,Up(x),mp(x,y.second); &#125;&#125;Pii Split2(int x)&#123; if(s[x].ma&lt;=2) return mp(x,0); if(s[ls[x]].ma&gt;2 || val[x].ma&gt;2) &#123; Pii y=Split2(ls[x]); return ls[x]=y.second,Up(x),mp(y.first,x); &#125; else &#123; Pii y=Split2(rs[x]); return rs[x]=y.first,Up(x),mp(x,y.second); &#125;&#125;int New(int x)&#123; return key[++n]=rand(),s[n]=val[n]=Node(x),n; &#125;void Ins(int x)&#123; if(x&lt;0) return; cmax(x,1); if(!rt) &#123; rt=New(x); return; &#125; if(s[rt].len&lt;x-1) &#123; rt=U(rt,New(x-s[rt].len)); return; &#125; if(s[rt].len==x-1) &#123; EraseEnd(rt); return Ins(x+1); &#125; Pii t=Lower(rt,x); if(s[t.first].len!=x) &#123; if(x&gt;1) &#123; Pii y=Lower(t.first,x-1); if(s[y.first].len==x-1) &#123; AddR(y.first,s[y.second].len),rt=U(y.first,t.second); return Ins(x+1); &#125; t.first=U(y.first,y.second); &#125; if(s[t.first].len==x+1) &#123; Pii y=Split2(t.second); AddL(y.second,-1); int d=s[t.first].r+s[y.first].len+1; EraseEnd(t.first); rt=U(U(t.first,New(d)),y.second); return; &#125; int d=s[t.first].len-x; AddR(t.first,-d); rt=U(U(t.first,New(d)),t.second); return; &#125; if(s[t.second].l==2) return AddL(t.second,s[t.first].r),EraseEnd(t.first),rt=U(t.first,t.second),Ins(x+1),Ins(x-2); Pii y=Split(t.first); AddL(t.second,-1); if(!y.first) &#123; if(s[y.second].l==1) &#123; AddL(y.second,1),rt=U(y.second,t.second); return; &#125; rt=U(U(New(1),y.second),t.second); return; &#125; if(s[y.first].len&gt;3 &amp;&amp; s[y.first].r==3) &#123; EraseEnd(y.first),AddR(y.first,2); rt=U(U(U(y.first,New(2)),y.second),t.second); return; &#125; AddR(y.first,-2); rt=U(U(U(y.first,New(3)),y.second),t.second);&#125;int main()&#123; rep(kase,1,rd()) Ins(rd()),printf(&quot;%d\\n&quot;,(s[rt].a[0][0]+s[rt].a[0][1])%P);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"CEOI","slug":"CEOI","permalink":"http://chasingdeath.github.io/tags/CEOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「CEOI2019」建造摩天楼","slug":"「CEOI2019」建造摩天楼","date":"2021-02-25T05:19:23.000Z","updated":"2021-05-22T03:54:11.166Z","comments":true,"path":"articles/2021/02/25/9e30ae5d.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/25/9e30ae5d.html","excerpt":"","text":"「CEOI2019」建造摩天楼显然是倒着考虑删除每个大楼，此时每次面临的情况都是一个子问题 下文称当前局面未被删除的大楼为黑点，其余为白点 子问题有解的充要条件是：黑点之间能 8-连通 当前一个点能够被删掉的条件是： 1.这个点能够连通到无穷处 2.这个点不是当前8-连通图的割点 \\考虑用一个简单的方法维护条件1： 将一开始每个黑点周围的白点取出，按照白点之间4-连通构建连通块 能够4-连通接触到最外层连通块的黑点满足条件1 每次删除黑点之后，增加能够连通的白点，每个白点只会增加一次 ps:寻找最外层4-连通白点的一个方法：找到x最大的白点 \\接下来考虑如何判定一个点$u$是否是割点： 首先删除$u$之后，周围8连通内能够构成多个连通块，可以发现大致可以归结为以下几种情况，其中x,y为黑点 多个$x$表示$x$在其中任何一个位置都可以 1. x ① y x u y x ② y 2. x ① y ② u y y y y 对于这两种情况，只要白点1和白点2在同一4-连通块，割掉$u$就会分开x和$y$ 由此，每次插入一个白点，可以$O(1)$检测一个点是否合法 简单讨论可以发现，会被影响合法性的点，一定在新加入最外层连通块的白点周围 这样总共check了$O(n)$次，每次用一个堆/set维护能选的最大编号的点即可 ps:代码非常丑非常垃圾。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair &lt;int,int&gt; Pii;#define mp make_pair#define pb push_back#define x first#define y second#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1.3e6+10,INF=1e9+10;const int z[5][4]=&#123; &#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;0,1&#125; &#125;;const int Z[9][4]=&#123; &#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,-1&#125;,&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;,&#123;0,1&#125; &#125;;int n,m,k;int F[N];int Find(int x)&#123; return F[x]==x?x:F[x]=Find(F[x]);&#125;void Union(int x,int y)&#123; F[Find(x)]=Find(y); &#125;map &lt;Pii,int&gt; B,W;set &lt;int&gt; st;vector &lt;int&gt; ans;Pii A[N],P[N];int ma=-1e9,maxid;int G[N][4];void Ins(int x,int y)&#123; // Insert white point Pii T=mp(x,y); if(B.count(T)) return ; if(!W.count(T)) P[W[T]=++m]=T,F[m]=m; int u=W[T]; if(x&gt;ma) ma=x,maxid=u; rep(i,0,3) &#123; int x1=x+z[i][0],y1=y+z[i][1]; if(W.count(mp(x1,y1))) &#123; int v=W[mp(x1,y1)]; G[u][i]=v; G[v][(i+2)%4]=u; Union(u,v); &#125; &#125;&#125;int del[N],vis[N],reach[N];int Check(int u)&#123; if(del[u]||!reach[u]) return 0; static int I[8]; int c=0; rep(i,0,7) &#123; Pii T=mp(A[u].x+Z[i][0],A[u].y+Z[i][1]); if(W.count(T)) I[i]=Find(W[T]); else I[i]=0,c++; &#125; for(int i=1,t=0;t&lt;4;t++,i=(i+2)%8)&#123; int j=(i+2)%8; if(I[i] &amp;&amp; I[i]==I[j] &amp;&amp; !I[(i+1)%8] &amp;&amp; c&gt;1) return 0; &#125; if((!I[0]||!I[1]||!I[2]) &amp;&amp; (!I[4]||!I[5]||!I[6]) &amp;&amp; I[3] &amp;&amp; I[3]==I[7]) return 0; if((!I[2]||!I[3]||!I[4]) &amp;&amp; (!I[6]||!I[7]||!I[0]) &amp;&amp; I[1] &amp;&amp; I[5]==I[1]) return 0; return 1;&#125;void ReCheck(int u)&#123; auto it=st.find(u); if(it!=st.end()) st.erase(it); if(Check(u)) st.insert(u);&#125;vector &lt;int&gt; tmp;void dfs(int u)&#123; if(!u) return; if(vis[u]) return; vis[u]=1; rep(i,0,3) &#123; if(G[u][i]) dfs(G[u][i]); Pii T=mp(P[u].x+z[i][0],P[u].y+z[i][1]); if(B.count(T)) reach[B[T]]=1; &#125; rep(dx,-1,1) rep(dy,-1,1) if(dx||dy) &#123; Pii T=mp(P[u].x+dx,P[u].y+dy); if(B.count(T)) tmp.pb(B[T]); &#125;&#125;void Dfs(int u)&#123; dfs(u); sort(tmp.begin(),tmp.end()),tmp.erase(unique(tmp.begin(),tmp.end()),tmp.end()); for(int i:tmp) ReCheck(i); tmp.clear();&#125;void Del(int u)&#123; // delete black point del[u]=1; B.erase(A[u]),Ins(A[u].x,A[u].y); Dfs(W[A[u]]);&#125;int main()&#123; n=rd(),rd(); rep(i,1,n) A[i].x=rd(),A[i].y=rd(),B[A[i]]=i; rep(i,1,n) F[i]=i; // Check NO rep(i,1,n) &#123; rep(dx,-1,1) rep(dy,-1,1) &#123; Pii T=mp(A[i].x+dx,A[i].y+dy); if(B.count(T)) Union(i,B[T]); &#125; &#125; rep(i,1,n) if(Find(i)!=Find(1)) return puts(&quot;NO&quot;),0; rep(i,1,n) rep(dx,-1,1) rep(dy,-1,1) if(dx||dy) Ins(A[i].x+dx,A[i].y+dy); Dfs(maxid); rep(i,1,n) &#123; int u=*st.rbegin(); auto it=st.end(); --it;st.erase(it); Del(u),ans.pb(u); &#125; reverse(ans.begin(),ans.end()); puts(&quot;YES&quot;); for(int i:ans) printf(&quot;%d\\n&quot;,i);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"CEOI","slug":"CEOI","permalink":"http://chasingdeath.github.io/tags/CEOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「JOI 2021 Final」地牢 3 ","slug":"「JOI 2021 Final」地牢 3 ","date":"2021-02-24T05:41:23.000Z","updated":"2021-05-22T03:54:11.200Z","comments":true,"path":"articles/2021/02/24/12d17016.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/24/12d17016.html","excerpt":"","text":"「JOI 2021 Final」地牢 3判定无解无解即：$\\exists i\\in[S,T-1],A_i&gt;U$ 是一个简单的区间最值问题 \\$O(nm)$关于用单调队列之类的东西维护每个点权值的方法这里就不提了 形式化地，我们把一层层点放到数轴上，令$X_i=\\sum_{j&lt;i}A_j$ 在数轴上坐标每$+1$消耗一点能量，我们要从$X_S$走到$X_T$ 考虑每个点的情况，不妨看做是用$B_i$去覆盖$(X_S,X_T]$，求最小权值 发现对于$B_i$，它能够合法覆盖的区间一定是$(X_i,X_i+U]$ 暴力地，可以直接让$B_i$更新这段区间的最小权值，然后暴力求和 \\进一步分析每个$B_i$覆盖的区间，可以发现是合法区间$(X_i,X_i+U]$中的某一连续段$(L_i,R_i]$ 而$L_i$取决于$B_i$前面第一个$B_{pre}&lt;B_i$，$R_i$取决于后面第一个$B_{nxt}\\leq B_i$ 关于$pre,nxt$的求解显然只是一个单调栈解决 得到$(L_i,R_i]$简单的描述 $L_i=\\max\\{X_i,X_{pre}+U\\}$ $R_i=\\min\\{X_i+U,X_{nxt} \\}$ (ps:这样求得的$L_i$不一定$&lt;R_i$) 暴力枚举即可$O(n)$查询 \\\\$T_i=n+1$ 从这里开始需要一些数据结构？考虑倒着从$n$到$1$计算每一个$S_i$的答案 发现在刚插入$i$的时候，$pre_i$还未出现，可以看做$-\\infty$，$nxt_i$已经确定 当$pre_i$出现时可以重新进行一次插入 每次插入可以用三元组表示$(i,pre,nxt)$，为了便于叙述这里$pre,nxt$直接是坐标 考虑对于$L_i,R_i$进行参数分离计算，首先要考虑何时满足$L_i&lt;R_i$ 显然条件就是$nxt-pre&gt;U$ $\\displaystyle L_i=\\max\\{X_i,X_{pre}+U\\}=X_{pre}+\\max\\{X_i-X_{pre},U\\}$ $\\displaystyle R_i=\\min\\{X_i+U,X_{nxt} \\}=X_i+\\min\\{U,X_{nxt}-X_i\\}$ $\\displaystyle Answer=\\sum_{nxt-pre&gt;U} (R_i-L_i)\\cdot B_i$ 离线询问，离散之后可以用树状数组维护上述式子，对于不合法部分不要加入即可 \\\\$O(n\\log n)$上面已经能计算$T_i=n+1$的询问，考虑将$S,T$转化为$T_{i}=n+1$的问题 如果直接$S,T$相减显然不合法，不妨找到在$(S,n+1)$的方案中，覆盖的$T$的点$T’$ $(S,n+1)-(T’,n+1)$会抵消掉在$S$的方案中$T$右边的部分，而$(X_{T’},X_T]$显然仍然是由$B_{T’}$覆盖，补回来即可 由此完成分离操作，而根据上面区间覆盖的定义，$T’$实际上就是$(X_T-U,X_T]$中最小的$B_i$ 所有操作都可以$O(n\\log n)$完成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=2e5+10,INF=1e9+10;int n,m,A[N],B[N],nxt[N],stk[N],top,C;ll ans[N],X[N],H[N];struct Node&#123; int U,k,id; &#125;;vector &lt;Node&gt; Q[N];vector &lt;int&gt; G[N];struct BIT&#123; ll s[N]; void Add(int p,ll x)&#123; while(p&lt;=C) s[p]+=x,p+=p&amp;-p; &#125; ll Que(int p)&#123; ll res=0; while(p) res+=s[p],p-=p&amp;-p; return res; &#125;&#125; T1,T2;// T1维护式子中含U项的和// T2维护式子中常数和struct MaxTree&#123; int s[N&lt;&lt;2],bit; void Build()&#123; for(bit=1;bit&lt;=n+1;bit&lt;&lt;=1) ; rep(i,1,n) s[bit+i]=A[i]; drep(i,bit,1) s[i]=max(s[i&lt;&lt;1],s[i&lt;&lt;1|1]); &#125; int Que(int l,int r)&#123; if(l==r) return s[l+bit]; int res=0; for(l+=bit-1,r+=bit+1;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1)&#123; if(~l&amp;1) cmax(res,s[l^1]); if(r&amp;1) cmax(res,s[r^1]); &#125; return res; &#125;&#125; Max;struct MinTree&#123; int s[N&lt;&lt;2],bit; int Min(int x,int y)&#123; return mp(B[x],x)&lt;mp(B[y],y)?x:y; &#125; void Build()&#123; B[0]=1e9; for(bit=1;bit&lt;=n+1;bit&lt;&lt;=1) ; rep(i,1,n) s[bit+i]=i; drep(i,bit,1) s[i]=Min(s[i&lt;&lt;1],s[i&lt;&lt;1|1]); &#125; int Que(int l,int r)&#123; if(l==r) return s[l+bit]; int res=0; for(l+=bit-1,r+=bit+1;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1)&#123; if(~l&amp;1) res=Min(res,s[l^1]); if(r&amp;1) res=Min(res,s[r^1]); &#125; return res; &#125;&#125; Min;// Min 用于寻找T&#x27;void Add(int i,ll pre,ll nxt,int k)&#123; int p=lower_bound(H+1,H+C+1,X[i]-pre)-H,r=lower_bound(H+1,H+C+1,nxt-pre)-H; // -L T1.Add(p,-B[i]*k), T1.Add(r,B[i]*k); T2.Add(p,k*B[i]*(X[i]-pre)), T2.Add(r,-k*B[i]*(X[i]-pre)); // +R p=lower_bound(H+1,H+C+1,nxt-X[i])-H; T1.Add(1,k*B[i]),T1.Add(p,-k*B[i]); T2.Add(p,k*(nxt-X[i])*B[i]),T2.Add(r,-k*(nxt-X[i])*B[i]);&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,n) A[i]=rd(),X[i+1]=X[i]+A[i]; rep(i,1,n) B[i]=rd(); drep(i,n+1,1) &#123; while(top &amp;&amp; B[stk[top]]&gt;=B[i]) G[i].pb(stk[top--]); nxt[i]=stk[top],stk[++top]=i; &#125; Min.Build(),Max.Build(); rep(i,1,m) &#123; int S=rd(),T=rd(),U=rd(); if(Max.Que(S,T-1)&gt;U)&#123; ans[i]=-1; continue; &#125; H[++C]=U,Q[S].pb((Node)&#123;U,1,i&#125;); int l=lower_bound(X+1,X+n+2,X[T]-U)-X; cmax(l,S); int t=Min.Que(l,T); ans[i]+=(X[T]-X[t])*B[t]; Q[t].pb((Node)&#123;U,-1,i&#125;); &#125; sort(H+1,H+C+1),C=unique(H+1,H+C+1)-H-1; drep(i,n,1)&#123; Add(i,-1e9,X[nxt[i]],1); for(int j:G[i]) Add(j,-1e9,X[nxt[j]],-1),Add(j,X[i],X[nxt[j]],1); for(Node j:Q[i])&#123; int p=lower_bound(H+1,H+C+1,j.U)-H; ans[j.id]+=j.k*(j.U*T1.Que(p)+T2.Que(p)); &#125; &#125; rep(i,1,m) printf(&quot;%lld\\n&quot;,ans[i]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"JOI","slug":"JOI","permalink":"http://chasingdeath.github.io/tags/JOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"多项式复合+拉格朗日反演","slug":"多项式复合+拉格朗日反演","date":"2021-02-23T07:12:14.000Z","updated":"2021-05-22T03:54:11.352Z","comments":true,"path":"articles/2021/02/23/7bf66bf6.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/23/7bf66bf6.html","excerpt":"","text":"多项式复合+拉格朗日反演多项式复合多项式复合形如$F(G(x))$，即复合函数，较为数学的形式可以写作$u=F(v),v=G(x)$ 在符号上，记做$F\\circ G=F(G(x))$ 稍微展开一下就是$\\begin{aligned} F(G(x))=\\sum_i [x^i]F(x)\\cdot G^i(x)\\end{aligned}$ \\拉格朗日(Lagrange)反演数学上，拉格朗日反演揭示了幂函数的反函数的形式 OI上，拉格朗日反演是复合逆/反函数的反演 对于多项式$F(x),G(x)$，若他们的复合满足$F(G(x))=x$，则$F(x)$与$G(x)$互为复合逆(若在非模意义下，$y=F(x),y=G(x)$的图像关于直线$y=x$对称，即反函数)，此时也有$G(F(x))=x$ 拉格朗日反演用于求解复合逆的一项的值: $\\begin{aligned} [][x^n]F(x)=\\frac{1} {n}[x^{-1}](\\frac{1} {G(x)})^n\\end{aligned} $ 显然，存在复合逆的多项式必然没有常数项 所以上式写成更阳间的样子就是$\\begin{aligned}[] [x^n]F(x)=\\frac{1} {n}[x^{n-1}](\\frac{x} {G(x)})^n\\end{aligned} $ 由于证明太~~，咕了 另外还有扩展拉格朗日反演 $\\begin{aligned} [][x^n]H(F(x))=\\frac{1} {n}[x^{n-1}]H'(x)(\\frac{x} {G(x)})^n\\end{aligned}$ \\多项式复合逆对于给定的$F(x)$，求其复合逆 带入拉格朗日反演的式子 $\\begin{aligned} F(x)=\\sum \\frac{1} {i}[x^{i-1}](\\frac{x} {G(x)})^i x^i\\end{aligned} $ 求这个式子的核心是 分块+暴力 $i=a\\cdot S+b$，求出$(\\frac{x} {G(x)})^{Sa},(\\frac{x} {G(x)})^b$，然后直接对于每个位置把两个式子暴力合并即可 两部分复杂度总和为$O(n\\sqrt n\\log n+n^2)$","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「JOI 2021 Final」机器人","slug":"「JOI 2021 Final」机器人","date":"2021-02-23T06:54:50.000Z","updated":"2021-05-22T03:54:11.203Z","comments":true,"path":"articles/2021/02/23/a184a2b4.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/23/a184a2b4.html","excerpt":"","text":"「JOI 2021 Final」机器人原问题中颜色什么时候改没有影响 显然不能记录每条边的颜色，显然在行走过程中不会回到原先的点 因此考虑简化状态 从一个点出去时，走了一条边$(u,v,c,w)$，从$u$出发颜色为$c$的边$w$之和为$S_{u,c}$，则有两种转移： 1.走过来时的边被改变了，权值$w$ 2.改变了其他同种颜色的边，权值$S_{u,c}-w$ 对于2情况在前面修改的边，在后面不会产生贡献（否则可以直接通过这条边过去，而不需要绕路） 可以直接转移到对应节点 1类转移的贡献相当于下次走这种颜色时，可以少改变一条边的颜色 即下一次转移2时，权值变为$S_{v,c}-w-w’$ 可以增加一个额外权值$-w$，然后对于下一个点$v$所有颜色为$c$的出边转移，这可以通过构建虚点解决 实际上总权值就是$0$ 考虑到一种不合法的情况，即走回$u$，但是这样的转移权值就是$S_{v,c}-w’\\ge 0$ 非法情况无影响 最终得到的转移就是一个非负边权的最短路图，可以跑$Dijkstra$解决 总点数$\\leq n+2m$，总边数$\\leq 6m$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=5e5+10,INF=1e9+10;int n,m,k;struct Edge&#123; int v,c,w;&#125;;vector &lt;Edge&gt; G[N];int U[N],V[N],C[N],W[N];struct Node&#123; int u; ll d; bool operator &lt; (const Node __) const &#123; return d&gt;__.d; &#125;&#125;;priority_queue &lt;Node&gt; que;ll dis[N],S[N];void Upd(int u,ll d)&#123; if(dis[u]&lt;=d) return; dis[u]=d,que.push((Node)&#123;u,d&#125;);&#125;map &lt;int,int&gt; st[N];void AddEdge(int u,int v,int c,int w)&#123; if(!st[u].count(c)) &#123; st[u][c]=++k; G[u].pb((Edge)&#123;k,0,0&#125;); &#125; int t=st[u][c]; G[t].pb((Edge)&#123;v,c,w&#125;),S[t]+=w;&#125;void Dijkstra()&#123; memset(dis,63,sizeof dis); dis[1]=0,que.push((Node)&#123;1,0&#125;); while(!que.empty()) &#123; int u=que.top().u; ll d=que.top().d; que.pop(); if(dis[u]&lt;d) continue; if(u&lt;=n) &#123; for(Edge dd:G[u]) &#123; int t=dd.v; for(Edge i:G[t]) &#123; Upd(i.v,d+min((ll)i.w,S[t]-i.w)); Upd(st[i.v][i.c],d); &#125; &#125; &#125; else for(Edge i:G[u]) Upd(i.v,d+S[u]-i.w); &#125; printf(&quot;%lld\\n&quot;,dis[n]&lt;1e17?dis[n]:-1);&#125;int main()&#123; freopen(&quot;robot.in&quot;,&quot;r&quot;,stdin),freopen(&quot;robot.out&quot;,&quot;w&quot;,stdout); n=rd(),m=rd(),k=n; rep(i,1,m) &#123; int u=rd(),v=rd(),c=rd(),w=rd(); AddEdge(u,v,c,w),AddEdge(v,u,c,w); &#125; Dijkstra();&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"JOI","slug":"JOI","permalink":"http://chasingdeath.github.io/tags/JOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「USACO 2020.12 Platinum」Cowmistry ","slug":"「USACO 2020.12 Platinum」Cowmistry ","date":"2021-02-22T04:08:09.000Z","updated":"2021-05-22T03:54:11.253Z","comments":true,"path":"articles/2021/02/22/b99a6032.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/22/b99a6032.html","excerpt":"","text":"「USACO 2020.12 Platinum」Cowmistry看到样例解释突然就有了思路.jpg 令$m=\\min\\{2^t|2^t&gt;k\\}$，也就是$k$最高位+1 对于数轴，按照$[im,(i+1)m)$分组，显然跨过分组的数之间异或$\\ge m&gt;k$，不合法，扔掉 对于每组，直接看做是$[0,m-1]$，此时令$d=\\frac{m} {2}$ 将$[0,m-1]$分为$[0,d-1],[d,m-1]$，显然两段之内的数相互异或的结果$&lt;d$，一定合法 也就是说，长度为$d$的段内随意选3个都合法 下面考虑跨过$d$的贡献，显然是一边选一个，一边选两个，此时这些数之间的异或和$\\ge d$ 以左边选一个为例，令$k’=k-d$ $O(k\\log k)$考虑异或和中一定有$d$这一位，下面只需要对于$i\\in[0,d-1]$暴力统计出$[d,m]$中有多少个数$j$满足$i\\oplus j\\leq k’$ 可以前缀和之后$\\log k$做到，从高到低依次考虑$k$每一个为1的二进制位$i$，如果查询的数这一位和$x$相同，那么下面可以任意选择 否则将$x\\rightarrow x\\oplus 2^i$ 实现如下 123456789int Que(int x,int *A,int k)&#123; int ans=0; drep(i,19,0) if(k&amp;(1&lt;&lt;i)) &#123; int l=x&amp;(~((1&lt;&lt;i)-1)),r=l+(1&lt;&lt;i)-1; ans+=A[r]-A[l-1]; x^=1&lt;&lt;i; &#125; return ans+A[x]-A[x-1];&#125; 得到个数$c$之后，接下来就是为$x$在$c$里选择两个匹配，就是$\\sum \\frac{c(c-1)} {2}$ 由此得到一个$O(k\\log k)$做法，可以通过前三档数据 1234567891011121314151617181920212223242526272829303132333435namespace part_klogk&#123; const int N=1&lt;&lt;20|10; int m,A[N],B[N],ans; int Que(int x,int *A,int k)&#123; int ans=0; drep(i,19,0) if(k&amp;(1&lt;&lt;i)) &#123; int l=x&amp;(~((1&lt;&lt;i)-1)),r=l+(1&lt;&lt;i)-1; ans+=A[r]-A[l-1]; x^=1&lt;&lt;i; &#125; return ans+A[x]-A[x-1]; &#125; void Solve(int l,int r) &#123; int mid=(l+r)&gt;&gt;1; int c1=0,c2=0; rep(i,l,mid) c1+=A[i]; rep(i,mid+1,r) c2+=A[i]; ans=(ans+D3(c1))%P,ans=(ans+D3(c2))%P; rep(i,l,mid) if(A[i]) &#123; int c=Que(i-l,B+mid+2,k-(m/2)); ans=(ans+1ll*c*(c-1)/2)%P; &#125; rep(i,mid+1,r) if(A[i]) &#123; int c=Que(i-mid-1,B+l+1,k-(m/2)); ans=(ans+1ll*c*(c-1)/2)%P; &#125; &#125; void Solve() &#123; for(m=1;m&lt;=k;) m&lt;&lt;=1; rep(i,1,n) rep(j,L[i],R[i]) A[j]++; rep(i,1,N-1) B[i]=B[i-1]+A[i-1]; rep(i,0,R[n]/m) Solve(i*m,(i+1)*m-1); printf(&quot;%d\\n&quot;,ans); &#125;&#125; \\$O(n\\log k-n\\log ^2 k)$考虑对于$k’$，问题降阶为求区间$a$中的每一个数 ， 在区间$b$中查询合法的个数$cnt_a$ 其中$a,b$区间可以认为对应相同的$[0,L-1]$，但是出现元素不同 此时，继续采用上面的方法进行分组，分组对象变为两组区间 令$m’=\\min\\{2^t|2^t&gt;k’\\},d’=\\frac{m} {2}$，分组之后 对于$[0,d’-1],[d’,m-1]$，显然两段之内异或$\\leq d$，一定合法，加入答案$cnt_a$中 对于跨过区间的贡献，用下面的方法处理 左边区间对于右边区间继续递归进行查询，将得到的结果加上左边区间中数的个数 右边区间继续对于左边区间递归进行查询，将得到的结果加上右边区间中数的个数 问题不断降阶为子问题，会有$\\log k$层子问题 每层子问题所有的区间可以分为$O(n)$段 特殊 的段 其他的部分要么完全覆盖要么为空，这些部分可以快速求出 发现答案如果用$(num,cnt)$表示当前查询结果为$num$的个数为$cnt$ 每层可以用$O(n)$个不同的二元对表示结果 如此求得后，再自底向上合并得到答案 \\\\关于实现如果真的按照上面的方法，一层层向下分裂区间，会面临着常数大，难以实现的问题 考虑将每个区间$[L_i,R_i]$插入线段树$[0,2^{30}-1]$ 显然得到$O(n\\log k)$个节点，在底层完全覆盖的节点打上标记 先递归进行第一层的分裂区间操作，对于打上标记的节点可以分成$\\frac{r-l+1} {m}$个完全覆盖区间 这些完全覆盖区间的答案可以$O(1)$求出 \\分裂完成后，每次查询的区间对用$(a,b,L,k,f1,f2)$表示 其中$a$表示查询区间对应节点，$b$表示被查询区间对应节点 $L$表示区间长度，$f1,f2$表示$a,b$是否继承到上层的完全覆盖标记 如此每次合并$(ls_a,rs_b),(rs_a,ls_b)$的查询结果，加上另一边的贡献 即可 当$b$为空或者为完全覆盖时，答案可以$O(1)$得到 当$a$为空时，可以得到空答案 从这样的底层向上合并，每个元素被合并次数$O(\\log k)$ \\没有仔细分析复杂度，应该就是$O(n\\log k-n\\log ^2 k)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair &lt;int,int&gt; Pii;#define mp make_pair#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=2e4+10,P=1e9+7,I2=(P+1)/2,I3=(P+1)/3,U=1&lt;&lt;30;int n,m,k;int L[N],R[N];int Check()&#123; for(int i=k;i;i&gt;&gt;=1) if(~i&amp;1) return 0; return 1;&#125;int D3(int n)&#123; return 1ll*n*(n-1)/2%P*(n-2)%P*I3%P; &#125;int D2(int n)&#123; return 1ll*n*(n-1)/2%P; &#125;const int M=N*60;int s[M],ls[M],rs[M],t[M],cnt,rt;//在线段树上插入节点，打上标记，同时处理出size便于下面计算void Ins(int &amp;p,int l,int r,int ql,int qr)&#123; if(!p) p=++cnt; s[p]+=min(qr,r)-max(ql,l)+1; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; t[p]=1; return; &#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) Ins(ls[p],l,mid,ql,qr); if(qr&gt;mid) Ins(rs[p],mid+1,r,ql,qr);&#125;int ans;// O(1)求出mint Up(int k)&#123; return 1&lt;&lt;(32-__builtin_clz(k)); &#125;typedef vector &lt;Pii&gt; V;V Union(const V &amp;A,const V &amp;B)&#123; int p1=0,p2=0,s1=A.size(),s2=B.size(); V R; // 这里是否归并并不影响复杂度 while(p1&lt;s1 || p2&lt;s2) &#123; if(p1&lt;s1 &amp;&amp; (p2==s2||A[p1]&lt;B[p2])) &#123; if(R.size() &amp;&amp; R.back().first==A[p1].first) R.back().second+=A[p1].second; else R.pb(A[p1]); p1++; &#125; else &#123; if(R.size() &amp;&amp; R.back().first==B[p2].first) R.back().second+=B[p2].second; else R.pb(B[p2]); p2++; &#125; &#125; return R;&#125;V Calc(int a,int b,int L,int k,int f1,int f2)&#123; f1|=t[a],f2|=t[b]; V Res; // 底层情况O(1)解决 if(!f1 &amp;&amp; !a) return Res; if(f2) return Res.pb(mp(k+1,f1?L:s[a])),Res; if(!b) return Res.pb(mp(0,f1?L:s[a])),Res; int m=Up(k); // L&gt;m说明还要继续进行分裂 if(L&gt;m) return Union(Calc(ls[a],ls[b],L/2,k,f1,f2),Calc(rs[a],rs[b],L/2,k,f1,f2)); // 进入降阶子问题，左查右，右查左 k-=m/2; V A=Calc(ls[a],rs[b],L/2,k,f1,f2); for(auto &amp;i:A) i.first+=f2?L/2:s[ls[b]]; V B=Calc(rs[a],ls[b],L/2,k,f1,f2); for(auto &amp;i:B) i.first+=f2?L/2:s[rs[b]]; return Union(A,B);&#125;int cm;// 第一次分裂void Solve(int p,int L)&#123; if(!p) return; // 完全覆盖的部分答案可以快速求出 if(t[p]) &#123; cm+=L/m; return; &#125; // 已经完成分裂，此时进入第一层子问题 if(L==m) &#123; // 贡献分为 // 左选3 ， 右选 3 ans=(ans+D3(s[ls[p]]))%P,ans=(ans+D3(s[rs[p]]))%P; // 左1，右2 V A=Calc(ls[p],rs[p],m/2,k-m/2,0,0); // 左2，右1 V B=Calc(rs[p],ls[p],m/2,k-m/2,0,0); for(auto i:A) ans=(ans+1ll*D2(i.first)*i.second)%P; for(auto i:B) ans=(ans+1ll*D2(i.first)*i.second)%P; return; &#125; Solve(ls[p],L/2),Solve(rs[p],L/2);&#125;int main()&#123; n=rd(),k=rd(); rep(i,1,n) &#123; int l=rd(),r=rd(); Ins(rt,0,U-1,l,r); &#125; m=Up(k),Solve(rt,U); // O(1)求得完全覆盖部分的答案 int t=(2ll*D3(m/2)+1ll*D2(k-m/2+1)*m)%P; ans=(ans+1ll*cm*t)%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"USACO","slug":"USACO","permalink":"http://chasingdeath.github.io/tags/USACO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「USACO 2020.12 Platinum」Spaceship","slug":"「USACO 2020.12 Platinum」Spaceship","date":"2021-02-22T03:12:20.000Z","updated":"2021-05-22T03:54:11.261Z","comments":true,"path":"articles/2021/02/22/c4a72629.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/22/c4a72629.html","excerpt":"","text":"「USACO 2020.12 Platinum」Spaceship看到题目第一个想到的是：按照路径长度可以确定按钮次数和路径次数 然而路径长度是$2^k$级别的。。 下文认为$n,q,k$同阶 既然无法考虑长度，那么就直接在$dp$时将路径作为状态压入 令$dp_{i,s,t}$表示前面$i$个按钮未按过，从$s$走到$t$的路径数 显然$dp_{i}$可以看做一个类似矩阵的转移，设邻接矩阵为$E$ 那么得到$dp_{i}=dp_{i-1}+dp_{i-1}\\cdot E\\cdot dp_{i-1}$ ($dp_i$不一定按了$i$这个按钮，所以考虑按或者不按) 那么对于$b_s,b_t$的情况，考虑把操作序列分成两段 显然操作序列有唯一一个按过恰好一次的最大的按钮$max$，可以在这里将操作序列分成两段 处理出$b_s$到$max$和$max$到$b_t$的两部分方案数合并即可 以处理$b_s\\rightarrow max$为例 类似上面的操作，令$F_{i,j}$表示最大按钮为$i$，且按过$i$之后没有按过其他按钮，停留在$j$的方案数 ($F_i$是一个向量) 初始显然有$F_{b_s,s}=1$ $\\displaystyle i&gt;b_s,F_{i}=\\sum_{j&lt;i} F_{j}\\cdot dp_{j-1}\\cdot E$(按过$j$之后可以继续按$[1,j-1]$) 前缀和即可，复杂度为$O(n^3)$ 同理处理出$max\\rightarrow b_t$的权值合并即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)const int N=62,P=1e9+7,INF=1e9+10;int n,m,q;struct Mat&#123; int a[N][N]; void clear()&#123; memset(a,0,sizeof a); &#125; Mat operator * (const Mat &amp;x) const &#123; Mat res; res.clear(); rep(i,1,n) rep(j,1,n) if(a[i][j]) rep(k,1,n) res.a[i][k]=(res.a[i][k]+1ll*a[i][j]*x.a[j][k])%P; return res; &#125; Mat operator + (const Mat &amp;x) const &#123; Mat res; rep(i,1,n) rep(j,1,n) res.a[i][j]=a[i][j]+x.a[i][j],Mod1(res.a[i][j]); return res; &#125;&#125; I,E,dp[N];int F[N][N],G[N][N];int S[N][N];int main()&#123; freopen(&quot;spaceship.in&quot;,&quot;r&quot;,stdin),freopen(&quot;spaceship.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); rep(i,1,n) I.a[i][i]=1; rep(i,1,n) rep(j,1,n) scanf(&quot;%1d&quot;,&amp;E.a[i][j]); dp[0]=I; rep(i,1,m) dp[i]=dp[i-1]+dp[i-1]*E*dp[i-1]; while(q--) &#123; int bs,s,bt,t; scanf(&quot;%d%d%d%d&quot;,&amp;bs,&amp;s,&amp;bt,&amp;t); memset(F,0,sizeof F),memset(G,0,sizeof G); memset(S,0,sizeof S); F[bs][s]=1; rep(i,1,n) S[bs][i]=dp[bs-1].a[s][i]; rep(i,bs+1,m) &#123; rep(a,1,n) if(S[i-1][a]) rep(b,1,n) F[i][b]=(F[i][b]+1ll*S[i-1][a]*E.a[a][b])%P; rep(a,1,n) S[i][a]=S[i-1][a]; rep(a,1,n) if(F[i][a]) rep(b,1,n) S[i][b]=(S[i][b]+1ll*F[i][a]*dp[i-1].a[a][b])%P; &#125; memset(S,0,sizeof S); G[bt][t]=1; rep(i,1,n) S[bt][i]=dp[bt-1].a[i][t]; rep(i,bt+1,m) &#123; rep(a,1,n) rep(b,1,n) G[i][a]=(G[i][a]+1ll*S[i-1][b]*E.a[a][b])%P; rep(a,1,n) S[i][a]=S[i-1][a]; rep(a,1,n) rep(b,1,n) S[i][a]=(S[i][a]+1ll*G[i][b]*dp[i-1].a[a][b])%P; &#125; int ans=0; rep(i,1,m) rep(j,1,n) ans=(ans+1ll*F[i][j]*G[i][j])%P; printf(&quot;%d\\n&quot;,ans); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"USACO","slug":"USACO","permalink":"http://chasingdeath.github.io/tags/USACO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「USACO 2020.12 Platinum」Sleeping Cows","slug":"「USACO 2020.12 Platinum」Sleeping Cows","date":"2021-02-22T02:55:07.000Z","updated":"2021-05-22T03:54:11.256Z","comments":true,"path":"articles/2021/02/22/998fe0.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/22/998fe0.html","excerpt":"","text":"「USACO 2020.12 Platinum」Sleeping Cows写容斥就输了。。 为每个牛棚考虑牛，从大到小，考虑每一个牛棚是否匹配 $dp_{i,j,f}$表示后$i$个牛棚中有$j$个钦定要匹配但是还未匹配的牛棚，$f=0/1$表示是否存在一个牛棚未选 每次移动$i$，会有一部分牛不能继续匹配 如果$f=1$，那么这部分牛必须被全部后面的$j$个牛棚中某一些匹配，否则不合法 如果$f=0$，这一部分可以随便匹配一定数量的牛 用组合数维护转移权值即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const int N=3010,P=1e9+7;int n;int dp[N][N][2],I[N],J[N],C[N][N];int A[N],B[N];void Add(int &amp;u,int x)&#123; u+=x,Mod1(u);&#125;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int main()&#123; freopen(&quot;cow.in&quot;,&quot;r&quot;,stdin),freopen(&quot;cow.out&quot;,&quot;w&quot;,stdout); n=rd(); rep(i,1,n) B[i]=rd(); rep(i,1,n) A[i]=rd(); sort(A+1,A+n+1),sort(B+1,B+n+1); int p=n; dp[n+1][0][0]=1; rep(i,0,n) rep(j,C[i][0]=1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%P; rep(i,J[0]=1,n) J[i]=1ll*J[i-1]*i%P; I[n]=qpow(J[n]); drep(i,n,1) I[i-1]=1ll*I[i]*i%P; drep(i,n,0) &#123; int c=0; while(p &amp;&amp; B[p]&gt;A[i]) c++,p--; rep(j,0,n-i) &#123; rep(k,0,min(j,c)) &#123; int t=1ll*dp[i+1][j][0]*C[c][k]%P*C[j][k]%P*J[k]%P; Add(dp[i][j-k][1],t),Add(dp[i][j-k+1][0],t); if(k==c) &#123; t=1ll*dp[i+1][j][1]*C[j][k]%P*J[k]%P; Add(dp[i][j-k][1],t),Add(dp[i][j-k+1][1],t); &#125; &#125; &#125; &#125; int ans=(dp[0][0][0]+dp[0][0][1])%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"USACO","slug":"USACO","permalink":"http://chasingdeath.github.io/tags/USACO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「ROI 2016 Day2」二指禅 ","slug":"「ROI 2016 Day2」二指禅 ","date":"2021-02-21T06:08:14.000Z","updated":"2021-05-22T03:54:11.231Z","comments":true,"path":"articles/2021/02/21/a2107955.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/21/a2107955.html","excerpt":"","text":"「ROI 2016 Day2」二指禅考虑对于每个点，有前缀和后缀两种转移 对于两种转移分别建立$\\text{trie}$树，并且维护最小权值，对于$dp_i$，可以匹配一段后缀从$j&lt;i$得到 也可以匹配一段前缀更新$j&gt;i$，分别$O(n)$枚举在两棵树上匹配即可完成转移 暴力转移复杂度为$O(n^2)$ 考虑优化转移效率，以$dp_i$匹配某一段前缀向$dp_j(j&gt;i)$转移为例 Part1 考虑求出最大的$j$这个问题实际上就是求出每一个后缀的最大前缀匹配，也就是一个$\\text{exkmp}$问题 而且这题是一个多模板串版本，并不能用$\\text{exkmp}$解决 Solution 1是把所有前缀hash值取出来，放到$\\text{hash_table}$里，然后二分长度+$\\text{hash_table}$查询，复杂度为$O(\\log L)$ Solution 2树剖+hash 对于$\\text{trie}$树树剖并且预处理hash值，重链上二分hash匹配，轻儿子暴力走，复杂度为$O(\\log ^2L)$ 如果使用全局平衡二叉树，可以做到单次查询复杂度为$O(\\log L)$，常数应该远小于$\\text{hash_table}$ \\\\Part2 在$j_{max}$基础上转移考虑先求出最大的$j$之后，得到其对应的$\\text{trie}$树节点$u$，在的祖先$u$中，每一种不同的权值更新一次 显然每一个祖先长度不同，因此最多只有$O(\\sqrt L)$中不同的权值 因此可以for过去更新每一种权值，每次更新是一段区间，可以用树状数组维护 但是实际上极限情况下段极短，可以暴力枚举区间，所以并不是真的$O(\\sqrt L\\log L)$ 比较容易说明复杂度的优化方法是： 采用分块$O(1)$更新，$O(\\sqrt L)$查询 这样可以做到稳定$O(\\sqrt L)$完成转移 \\因此预处理复杂度为$O(m\\log L-m\\log ^2L)$，转移复杂度为$O(m\\sqrt L-m\\sqrt L\\log L)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;const int N=3e5+10,INF=1e9+10,D=6;int n,m;char T[N];int Pow1[N],Pow2[N];int S[N];const ll K1=19260817,P1=114514;const ll K2=1e9+13,P2=1919810;struct Solver&#123; int S[N]; int trie[N][2],s[N],cnt,H1[N],H2[N]; int fa[N],top[N],sz[N],h1[N],h2[N],son[N],lst[N],bot[N],L[N],id[N],dfn,dep[N]; // lst[i] 记录祖先中第一个s[f]!=s[i]的节点 void dfs(int u)&#123; sz[u]=1; if(s[u]==s[fa[u]]) lst[u]=lst[fa[u]]; else lst[u]=fa[u]; rep(i,0,1) &#123; int v=trie[u][i]; if(!v) continue; fa[v]=u,dep[v]=dep[u]+1; h1[v]=(h1[u]*K1+i+1)%P1; h2[v]=(h2[u]*K2+i+1)%P2; dfs(v); sz[u]+=sz[v]; if(son[u]==0 || sz[v]&gt;sz[son[u]]) son[u]=v; &#125; &#125; void dfs(int u,int t)&#123; id[L[u]=++dfn]=u; bot[top[u]=t]=u; if(son[u]) dfs(son[u],t); for(int v:trie[u]) if(v&amp;&amp;v!=son[u]) dfs(v,v); &#125; void Ins(char *T,int l,int w)&#123; int now=0; rep(i,1,l) &#123; int c=T[i]-&#x27;0&#x27;; if(!trie[now][c]) s[trie[now][c]=++cnt]=2e9; cmin(s[now=trie[now][c]],w); &#125; &#125; void Init()&#123; rep(i,1,n) &#123; H1[i]=(H1[i-1]*K1+S[i]+1)%P1; H2[i]=(H2[i-1]*K2+S[i]+1)%P2; &#125; dfs(0),dfs(0,0); &#125; int Que(int i) &#123; // 求i 的最长匹配位置 int u=0; while(i&lt;=n) &#123; if(!trie[u][S[i]]) break; if(trie[u][S[i]]!=son[u])&#123; u=trie[u][S[i++]]; continue; &#125; int l=1,r=min(n-i+1,dep[bot[top[u]]]-dep[u]),res=1; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if( (H1[i+mid-1]-1ll*H1[i-1]*Pow1[mid]%P1+P1)%P1 == (h1[id[L[u]+mid]]-1ll*h1[u]*Pow1[mid]%P1+P1)%P1 &amp;&amp; (H2[i+mid-1]-1ll*H2[i-1]*Pow2[mid]%P2+P2)%P2 == (h2[id[L[u]+mid]]-1ll*h2[u]*Pow2[mid]%P2+P2)%P2) l=mid+1,res=mid; else r=mid-1; &#125; i+=res,u=id[L[u]+res]; &#125; return u; &#125;&#125; X,Y;struct BIT&#123; ll s[N]; void Init()&#123; memset(s,127,sizeof s); &#125; void Add(int p,ll x)&#123; while(p) cmin(s[p],x),p-=p&amp;-p; &#125; ll Que(int p)&#123; ll res=1e18; while(p&lt;=n) cmin(res,s[p]),p+=p&amp;-p; return res; &#125;&#125; TX,TY;ll dp[N];int main()&#123; rep(i,Pow1[0]=Pow2[0]=1,N-1) &#123; Pow1[i]=Pow1[i-1]*K1%P1; Pow2[i]=Pow2[i-1]*K2%P2; &#125; scanf(&quot;%d%d%*d&quot;,&amp;n,&amp;m); rep(i,1,n) scanf(&quot;%1d&quot;,S+i),X.S[i]=Y.S[n-i+1]=S[i]; rep(t,1,m) &#123; int w,l; scanf(&quot;%d%s&quot;,&amp;w,T+1),l=strlen(T+1); X.Ins(T,l,w),reverse(T+1,T+l+1),Y.Ins(T,l,w); &#125; X.Init(),Y.Init(); rep(i,1,n) dp[i]=1e18; TX.Init(),TY.Init(); TY.Add(1,0); rep(i,0,n) &#123; // 暴力维护转移 if(i) &#123; cmin(dp[i],TX.Que(i)); int u=Y.Que(n-i+1); while(u) &#123; int l=Y.dep[Y.lst[u]]+1,r=Y.dep[u]; if(r-l+1&lt;=D) rep(j,l,r) cmin(dp[i],dp[i-j]+Y.s[u]); else cmin(dp[i],TY.Que(i-r+1)+Y.s[u]); u=Y.lst[u]; &#125; &#125; TY.Add(i+1,dp[i]); if(i==n||dp[i]==1e18) continue; int u=X.Que(i+1); while(u) &#123; int l=X.dep[X.lst[u]]+1,r=X.dep[u]; if(r-l+1&lt;=D) rep(j,l,r) cmin(dp[i+j],dp[i]+X.s[u]); else TX.Add(i+r,dp[i]+X.s[u]); u=X.lst[u]; &#125; &#125; printf(&quot;%lld\\n&quot;,dp[n]&lt;1e18?dp[n]:-1);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"ROI","slug":"ROI","permalink":"http://chasingdeath.github.io/tags/ROI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「ROI 2016 Day1」人烟之山 ","slug":"「ROI 2016 Day1」人烟之山 ","date":"2021-02-20T05:52:16.000Z","updated":"2021-05-22T03:54:11.227Z","comments":true,"path":"articles/2021/02/20/45fb920a.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/20/45fb920a.html","excerpt":"","text":"「ROI 2016 Day1」人烟之山题目大意： 有$n$段折线，$m$个查询点$A$（在折线以上），设折线拐点为$X_i$ 求折线上在查询点投影两边最近的位置$B$，且直线$AB$与折线有非边缘的交点 (即从$A$点看过来会被折线遮住) 题目分析： $B,C$点满足的条件就是其旁边的直线$L$在$x_A$处的值$&gt;y_A$ 即找到最近的红色直线 Solution1 $O(n\\log ^2n)$以求左边为例 考虑二分答案，求出拐点为$X_i,i\\ge mid$的直线中是否存在红色直线 也就是求最大值是否$&gt;y_A$，维护直线最大值，并且区间查询，可以暴力可持久化李超树来解决 因为是求左边的，所以每条直线更新的范围$&gt;X_i$，李超树区间更新复杂度为$O(\\log ^2n)$ 李超树查询复杂度为$O(\\log n)$,加上二分，查询为$O(\\log ^2n)$ \\Solution2 $O(n\\log n)$依然考虑二分，但是这次考虑在线段树上二分 对于所有的$X_i$建立线段树，区间$[L,R]$内维护一个$X_i,i\\in [L,R]$的上凸包，静态维护最大值 凸包可以归并子节点来建立，预处理复杂度为$O(n\\log n)$ 如果查询直接在凸包上二分，复杂度会增加一个$\\log n$ 解决方法是：将所有查询的$x_A$排序，然后在凸包上查询时就可以做到线性 因此复杂度为$O(n\\log n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)char buf[200000],*p1,*p2;#define getchar() (((p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,200000,stdin))),*p1++)char IO;int rd()&#123; int s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=4e5+10,U=1e9+10;int n,m,K[N],X[N],L[N],R[N];ll Y[N];struct Que&#123; int x,y,id; bool operator &lt; (const Que __) const &#123; return x&lt;__.x; &#125;&#125; Q[N];struct Node&#123; int k; ll b; ll operator [] (const ll x) const &#123; return 1ll*k*x+b; &#125; friend db Cross(Node x,Node y)&#123; return 1.0*(y.b-x.b)/(x.k-y.k); &#125; bool operator &lt; (const Node __) const &#123; return k&lt;__.k||(k==__.k &amp;&amp; b&lt;__.b); &#125;&#125;; vector &lt;Node&gt; H[N&lt;&lt;2];vector &lt;Node&gt; ::iterator P[N&lt;&lt;2];void Build(int p,int l,int r)&#123; if(l==r) return H[p].pb((Node)&#123;K[l],Y[l]-1ll*K[l]*X[l]&#125;),P[p]=H[p].begin(),void(); int mid=(l+r)&gt;&gt;1; Build(p&lt;&lt;1,l,mid),Build(p&lt;&lt;1|1,mid+1,r); int p1=0,s1=H[p&lt;&lt;1].size(),p2=0,s2=H[p&lt;&lt;1|1].size(),R=-1; auto Ins=[&amp;](Node L) &#123; while(~R &amp;&amp; H[p][R].b&lt;=L.b) R--,H[p].pop_back(); while(R&gt;0 &amp;&amp; Cross(H[p][R],H[p][R-1])&gt;=Cross(H[p][R],L)-1e-8) R--,H[p].pop_back(); H[p].pb(L),R++; &#125;; while(p1&lt;s1 || p2&lt;s2) &#123; if(p1&lt;s1 &amp;&amp; (p2==s2 || H[p&lt;&lt;1][p1]&lt;H[p&lt;&lt;1|1][p2])) Ins(H[p&lt;&lt;1][p1++]); else Ins(H[p&lt;&lt;1|1][p2++]); &#125; P[p]=H[p].begin();&#125;ll Que(int p,int x)&#123; while(P[p]+1!=H[p].end() &amp;&amp; (*(P[p]+1))[x]&gt;=(*P[p])[x]) P[p]++; return (*P[p])[x];&#125;int QueL(int p,int l,int r,int x,int qx,int y)&#123; if(x&lt;l || Que(p,qx)&lt;=y) return 0; if(l==r) return l; int mid=(l+r)&gt;&gt;1,t; if(x&gt;mid &amp;&amp; (t=QueL(p&lt;&lt;1|1,mid+1,r,x,qx,y))) return t; return QueL(p&lt;&lt;1,l,mid,x,qx,y);&#125;int QueR(int p,int l,int r,int x,int qx,int y)&#123; if(x&gt;r || Que(p,qx)&lt;=y) return n+1; if(l==r) return l; int mid=(l+r)&gt;&gt;1,t; if(x&lt;=mid &amp;&amp; (t=QueR(p&lt;&lt;1,l,mid,x,qx,y))&lt;=n) return t; return QueR(p&lt;&lt;1|1,mid+1,r,x,qx,y);&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,n) &#123; X[i]=X[i-1]+rd(),K[i]=rd(); Y[i]=Y[i-1]+1ll*(X[i]-X[i-1])*K[i]; &#125; rep(i,1,m) Q[i].x=rd(),Q[i].y=rd(),Q[i].id=i; sort(Q+1,Q+m+1); Build(1,1,n); int p=1; rep(i,1,m) &#123; while(p&lt;=n &amp;&amp; X[p]&lt;Q[i].x) p++; L[Q[i].id]=QueL(1,1,n,p-1,Q[i].x,Q[i].y); R[Q[i].id]=QueR(1,1,n,p+(X[p]==Q[i].x),Q[i].x,Q[i].y); &#125; rep(i,1,m) printf(&quot;%d %d\\n&quot;,X[L[i]],X[R[i]-1]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"ROI","slug":"ROI","permalink":"http://chasingdeath.github.io/tags/ROI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「GDOI2020模拟赛day2」我的朋友们","slug":"「GDOI2020模拟赛day2」我的朋友们","date":"2021-02-18T06:05:40.000Z","updated":"2021-05-22T03:54:11.185Z","comments":true,"path":"articles/2021/02/18/2c8a1d3d.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/18/2c8a1d3d.html","excerpt":"","text":"「GDOI2020模拟赛day2」我的朋友们默认翻转了$a_i$顺序，下文多项式省略$(x)$ 设当前区间为$(i-L,i]$到最终结束的期望步数为$dp_i$ 令$A_i=a_ix+1-a_i$ 令$P_i=\\prod_{j\\in(i-L,i]}A_j$ 令$F_i=\\sum_{j=1}^i dp_jx^j$ 令$\\displaystyle G_i=F_{i-1}P_i,dp_i=\\frac{[x^i]G_i} {coef_i}$ 其中常数$coef_i=1-[x^0]P_i=1-\\prod_{j\\in(i-L,i]}(1-a_j)$，容易预处理得到 用分治$\\text{NTT}$，过程中维护 $P_{l,r}=\\prod_{j\\in(r-L,l]}A_j$ $\\displaystyle G_{l,r}=F_{l-1}P_{l,r}$ 显然$G_{i,i}=G_i$ 分治转移如下： $\\displaystyle G_{l,mid}=G_{l,r}\\prod_{j\\in (mid-L,min(l,r-L)]} A_j$ $P_{l,mid}=P_{l,r}\\prod_{j\\in (mid-L,min(l,r-L)]} A_j$ 先求出$G_{l,mid}$ $P_{mid+1,r}=P_{l,r}\\prod_{j\\in (max(r-L,l),mid+1]} A_j$ $\\displaystyle G_{mid+1,r}=(G_{l,r}+(F_{mid}-F_{l-1})P_{l,r})\\prod_{j\\in (max(r-L,l),mid+1]} A_j$ 归纳上述过程，发现实际上同步维护的部分只需要维护 $G_{l,r}$的$[l-(r-l),r]$项，$P_{l,r}$的$[0,r-l]$项 只需要实现 通过$G_{l,r}$的$[l-(r-l),r]$项得到$G_{l,mid}$的$[l-(mid-l),mid]$，以及$G_{mid+1,r}$的$[l,r]$ 通过$P_{l,r}$的$[0,r-l]$得到$P_{l,mid}$的$[0,mid-l]$，$P_{mid+1,r}$的$[0,r-mid-1]$ 初始状态 $P_{L,n}=\\prod_{j\\in(n-L,L]}A_j$ $G_{L,n}=0$ 在分治过程中有非常多的$P_{l,r}$都是空的。。 可以分治$\\text{NTT}$预处理出转移系数$\\displaystyle \\prod_{i=l}^r A_i$，或者用记忆化暴力求出，复杂度为$O(n\\log ^2n)$ 在转移过程中维护的部分长度与$r-l$同阶，因此复杂度为$O(n\\log^2 n)$","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各省OI","slug":"各省OI","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E7%9C%81OI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「ROI 2019 Day2」模式串查找 (口胡)","slug":"「ROI 2019 Day2」模式串查找 (口胡)","date":"2021-02-17T08:31:32.000Z","updated":"2021-05-22T03:54:11.245Z","comments":true,"path":"articles/2021/02/17/75009384.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/17/75009384.html","excerpt":"","text":"「ROI 2019 Day2」模式串查找 (口胡)设$S=\\sum |w_i|$ 显然我们需要一个树形数据结构来维护题目中添加字符的操作 归纳一下，需要实现的操作就是： 1.添加一个新串 2.在当前串中分裂一段区间$[L,R]$ 3.将一个串复制$k$次 将每一个单字符视为一个节点，考虑用一个可持久化的平衡树来维护上述操作，比如可持久化非旋$\\text{Treap}$ 题解中给出的2-3-Tree不知道效果怎么样 2,3操作增加的数量为$\\log$级别，最终的节点总数为$O(S+n\\log S)$ 接下来需要实现的操作是合并两个子串的信息，显然在合并时计算跨过两个节点的串匹配模板串的次数 容易想到记录后缀匹配的$kmp$指针，但是这样的指针难以完成合并操作 为了计算这个，我们需要维护这个串的前缀/后缀 在 原串上最长的匹配子段 此时一个节点的信息可以用$(l1,r1),(l2,r2),k$来表示，其中$k$标记了这个串是否整个出现在模板串中 合并子串$A,B$信息： 1.求出前缀/后缀匹配，以前缀为例： 1-1.如果$A$无法完全匹配，则匹配前缀为$A$的匹配前缀 1-2.$A$能够完全匹配，设$A$在原串对应$L,R$，$B$的最长匹配前缀在模板串匹配起始位置为$P$ 我们需要在$[L,R]$之后借上$P$开始的一段后缀，而$[L,R]$出现在模板串中的位置对应着后缀数组上一段$rank$区间 取模板串反向后缀数组，求出与$R$匹配长度超过$R-L+1$的$rank$区间$[l,r]$ 则我们需要找到$[l,r]$中$sa[i]+1$与$P$最长的$LCP$，显然是一个求临近$rank$的问题，可以在线主席树二分解决 由此得到最长前缀为$A$串再加上额外匹配得到的部分 $O(\\log m)$完成 \\2.求出跨过两个串的完美匹配个数 容易得到前串后缀对应的$\\text{kmp}$指针，后串前缀对应反向的$\\text{kmp}$指针 实际上就是求出这两个指针不断失配时相加恰好完全匹配的个数 注意到，实际上这个询问是完全可以离线的 可以通过在线得到的匹配情况，离线得到询问得到询问答案，再从叶子开始重新计算每个节点的答案 比较暴力的做法是： 建立两棵$\\text{kmp}$树，在第一棵树上$\\text{dfs}$，加入祖先对应的位置，然后再第二棵树上查询祖先匹配的个数 可以用$\\text{dfs}$序+差分树状数组维护，复杂度为$O(\\log m)$ \\因此总体复杂度为$O((S+n\\log S)\\log m)$ 实际上常数非常大？","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"ROI","slug":"ROI","permalink":"http://chasingdeath.github.io/tags/ROI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「ROI 2018 Day 2」无进位加法","slug":"「ROI 2018 Day 2」无进位加法","date":"2021-02-16T02:03:27.000Z","updated":"2021-05-22T03:54:11.237Z","comments":true,"path":"articles/2021/02/16/2e6ebc78.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/16/2e6ebc78.html","excerpt":"","text":"「ROI 2018 Day 2」无进位加法题目大意： 给出二进制数$a_1,\\ldots a_n$，对于$b_1\\ldots b_n$ 满足$a_i\\leq b_i$，$\\bigoplus b_i=\\sum b_i$，其中$\\bigoplus $为异或和 求$\\sum b_i$最小值 设长度量级为$N=\\sum len(a_i)$ $O(N^2-N^3)$ ， 从高到低确定答案的每一个位枚举当前位为0，下面的位为1，贪心确定是否存在方案 检查一个答案是否合法： 动态维护一个倒序的$a_i$集合，从高到低考虑每一个位置 1.如果当前位为0： 如果$a_i$中存在大于等于这一位的数，非法 2.如果当前位为1： 2-1.如果$a_i$中存在2个当前位为1的数，非法 2-2.如果$a_i$中存在恰好一个，则将这个1用于这个$a_i$，并将$a_i$去掉最高位后放回集合 2-3.不存在，用这个$1$删除最大的一个$a_i$ 实际看来，这个贪心本身效率并不高 \\优化1：快速确定答案最高位的可能范围令$B=\\max\\{ len(a_i)+i-1\\}$ 则$len(Ans)\\in[B,B+1]$ 上下界均可以由上面的贪心模拟得到 \\优化2：快速维护$a_i$倒序显然在不断更改的过程中，当前的$a_i$一定是原先的某一个$a_i$的一段后缀 考虑将所有这样的后缀排序，为了方便，用每一个最高的1来表示一个合法的后缀 显然可以先按照后缀长度分类，同长度的后缀，按照后缀中下一个1出现的位置排序 也就是一个类似基数排序个过程，额外维护每一个后缀中下一个出现的$1$所对应的后缀即可 预处理复杂度为$O(N\\log N)$ 同时，也可以用线段树快速维护插入/删除的排名，得到$B$的值，单次操作复杂度$O(\\log N)$ \\优化3称满足$len(a_i)+i-1=B$的$i$为$\\text{critical number}$ 令$p$为最小的$\\text{critical number}$，也就是在贪心过程中第一个出现情况2-1./2-2.的位置 决策答案为$B$还是为$B+1$，也就是决策 是用$len(a_p)$这个位置删除$a_p$的最高位，还是用$len(a_p)+1$的位置删除$a_p$ ($[1,p-1]$的部分一定会被删掉) $\\text{intended solution}$采用暴力递归来完成确定每一位的这个操作 12345678910111213Function Solve(Limit) Limit为当前可以使用的最高位的1 求得 B,p 删除 a[1,p-1] 删除 a[p]最高位 if B&lt;=Limit and Solve(p-1) then ans[len(a[p]),B]=1 return True 删除a[p] if B+1&lt;=Limit and Solve(p) then ans[len(a[p])+1,B+1]=1 return True else return Falseend 至于复杂度，官方题解给出为$O(N)$次递归和删除/加入操作，最终复杂度为$O(N\\log N)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,const T &amp;b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,const T &amp;b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;typedef vector &lt;int&gt; V;const int N=3e5+10,INF=1e9+10;int n,m,I[N],L;char s[N];int fir[N],nxt[N],rk[N],len[N],id[N];V A[N];struct Affirmation_Of_My_Existence&#123; int s[N&lt;&lt;2],t[N&lt;&lt;2]; void Down(int p)&#123; rep(v,p&lt;&lt;1,p&lt;&lt;1|1) t[v]+=t[p],s[v]+=t[p]; t[p]=0; &#125; void Upd(int p,int l,int r,int ql,int qr,int x) &#123; if(ql&gt;qr) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; s[p]+=x,t[p]+=x; return; &#125; Down(p); int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) Upd(p&lt;&lt;1,l,mid,ql,qr,x); if(qr&gt;mid) Upd(p&lt;&lt;1|1,mid+1,r,ql,qr,x); s[p]=max(s[p&lt;&lt;1],s[p&lt;&lt;1|1]); &#125; void Build(int p,int l,int r)&#123; s[p]=len[id[l]]-INF; if(l==r) return; int mid=(l+r)&gt;&gt;1; Build(p&lt;&lt;1,l,mid),Build(p&lt;&lt;1|1,mid+1,r); &#125; void Add(int x,int k)&#123; x=rk[x]; Upd(1,1,m,x,x,INF*k),Upd(1,1,m,x+1,m,k); &#125; // Find the first critical position &quot;p&quot;, and return all the bits in [1,p] void Get(int p,int l,int r,int x,V &amp;R)&#123; if(s[p]&lt;0) return; if(l==r) return R.pb(id[l]); Down(p); int mid=(l+r)&gt;&gt;1; Get(p&lt;&lt;1,l,mid,x,R); if(s[p&lt;&lt;1]!=x) Get(p&lt;&lt;1|1,mid+1,r,x,R); &#125;&#125; T;int Solve(int L)&#123; // L denotes the maxmium bit we can use int B=T.s[1]; if(B&lt;0) return 1; if(B&gt;L) return 0; V R; T.Get(1,1,m,B,R); int p=*R.rbegin(),l=len[p]; for(int i:R) T.Add(i,-1); // Try ans B , so we use bit [nxt,B] to delete the number [1,p-1] // and the number a[p] will be set to a[p]-2^l if(nxt[p]) T.Add(nxt[p],1); if(Solve(l-1)) &#123; rep(i,l,B) s[i]=1; return B+1; &#125; // Try ans B+1 , so we use bit [nxt+1,B+1] to delete the [1,p] if(nxt[p]) T.Add(nxt[p],-1); if(B&lt;L &amp;&amp; Solve(l)) &#123; rep(i,l+1,B+1) s[i]=1; return B+2; &#125; for(int i:R) T.Add(i,1); return 0;&#125;int main()&#123; rep(i,1,n=rd()) &#123; scanf(&quot;%s&quot;,s); int l=strlen(s); cmax(L,l); drep(j,l-1,0) if(s[j]==&#x27;1&#x27;) &#123; nxt[++m]=fir[i]; A[len[m]=l-j-1].pb(m); fir[i]=m; &#125; &#125; rk[0]=1e9; int k=m; rep(i,0,L-1) &#123; k-=A[i].size(); sort(A[i].begin(),A[i].end(),[&amp;](int x,int y)&#123; return rk[nxt[x]]&lt;rk[nxt[y]]; &#125;); for(int j:A[i]) id[rk[j]=++k]=j; k-=A[i].size(); &#125; T.Build(1,1,m); rep(i,1,n) T.Add(fir[i],1); memset(s,0,sizeof s); drep(i,Solve(INF)-1,0) putchar(s[i]^48);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"ROI","slug":"ROI","permalink":"http://chasingdeath.github.io/tags/ROI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「ROI 2019 Day1」运输 20/19","slug":"「ROI 2019 Day1」运输 20 19","date":"2021-02-16T01:53:14.000Z","updated":"2021-05-22T03:54:11.239Z","comments":true,"path":"articles/2021/02/16/8fa685a3.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/16/8fa685a3.html","excerpt":"","text":"「ROI 2019 Day1」运输 20/19题目大意： 给定一个带权$DAG$，$1$为起始点，给定小常数$p$ 每次查询一个点$u$，一个权值$r$，问是否存在一条路径$1\\ldots u$，其长度$x$满足$r\\leq x\\leq \\frac{p} {p-1}\\cdot r$ 转换一下，$dp$每个点是否存在$r$，那么对于路径的权值$x$，合法的$r$即为$[\\frac{p-1} {p}\\cdot x,x]$ 对于任意两个区间，如果其相交，则可以合并，并且用两个区间中最小和最大的$x$来表示这个区间 而不相交的区间最多只有$\\log_{\\frac{p} {p-1} } w$段，大概$700$段 任意时刻，每个点的$dp$情况可以用$700$段不交的区间表示，转移可以归并数组进行 因此维护$dp$复杂度为$O(m\\log_{\\frac{p} {p-1} } w)$常数极小，单次查询复杂度为$O(\\log \\log_{\\frac{p} {p-1} } w)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=5e5+10;int n,m,q,p;struct Interval&#123; ll l,r,x,y; Interval(ll a,ll b)&#123; x=a,y=b; l=(x*(p-1)+p-1)/p,r=y; &#125; void Add(ll c)&#123; x+=c,y+=c; l=(x*(p-1)+p-1)/p,r=y; &#125; bool operator &amp; (const Interval &amp;__) const &#123; return min(r,__.r)&gt;=max(l,__.l)-1; &#125; Interval operator + (const Interval &amp;__) const &#123; return Interval(min(x,__.x),max(y,__.y)); &#125; bool operator &lt; (const ll &amp;x) const &#123; return r&lt;x; &#125;&#125;;vector &lt;Interval&gt; dp[N];struct Edge&#123; int to,nxt; ll w;&#125; e[N];int head[N],ecnt;void AddEdge(int u,int v,ll w)&#123; e[++ecnt]=(Edge)&#123;v,head[u],w&#125;; head[u]=ecnt;&#125;void Trans(vector &lt;Interval&gt; &amp;x,vector &lt;Interval&gt; y,ll c)&#123; for(auto &amp;i:y) i.Add(c); vector &lt;Interval&gt; res; int p1=0,p2=0,s1=x.size(),s2=y.size(); while(p1&lt;s1 || p2&lt;s2) &#123; if(p1&lt;s1 &amp;&amp; (p2==s2 || x[p1].l&lt;=y[p2].l)) &#123; if(res.size() &amp;&amp; *res.rbegin()&amp;x[p1]) res[res.size()-1]=*res.rbegin()+x[p1++]; else res.pb(x[p1++]); &#125; else &#123; if(res.size() &amp;&amp; *res.rbegin()&amp;y[p2]) res[res.size()-1]=*res.rbegin()+y[p2++]; else res.pb(y[p2++]); &#125; &#125; x=res;&#125;int main()&#123; rep(kase,1,rd()) &#123; n=rd(),m=rd(),q=rd(),p=rd(); rep(i,1,n) head[i]=ecnt=0; rep(i,1,m)&#123; int u=rd(),v=rd(); ll w=rd&lt;ll&gt;(); AddEdge(u,v,w); &#125; rep(i,1,n) dp[i].clear(); dp[1].pb(Interval(0,0)); rep(u,1,n) &#123; for(int i=head[u];i;i=e[i].nxt) &#123; Trans(dp[e[i].to],dp[u],e[i].w); &#125; &#125; while(q--)&#123; int x=rd(); ll y=rd&lt;ll&gt;(); auto p=lower_bound(dp[x].begin(),dp[x].end(),y); if(p!=dp[x].end() &amp;&amp; p-&gt;l&lt;=y) putchar(&#x27;1&#x27;); else putchar(&#x27;0&#x27;); &#125; puts(&quot;&quot;); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"ROI","slug":"ROI","permalink":"http://chasingdeath.github.io/tags/ROI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「ROI 2018 Day 1」量子隐形传态","slug":"「ROI 2018 Day 1」量子隐形传态","date":"2021-02-16T00:51:47.000Z","updated":"2021-05-22T03:54:11.235Z","comments":true,"path":"articles/2021/02/16/65b0974a.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/16/65b0974a.html","excerpt":"","text":"「ROI 2018 Day 1」量子隐形传态题目大意： 在$N\\times M$的网格上给定$K$个点$1\\ldots K$，定义两点间的距离为$\\displaystyle 2^{\\max\\{|x_i-x_j|,|y_i-y_j|\\} }$ $N,M,K\\leq 10^4$，求$1$到$k$的最短路，下文认为$N,M$同阶 如何存储距离显然距离是一个不超过$10^4$位的二进制数，用$\\text{bitset}$存下来 每一次转移需要维护一个位+1操作，比较大小操作，都可以$O(\\frac{N} {w})$实现，其中$\\text{w}$为压位数 \\Lemma:对于点$A(x,y)$，将平面分为$8$个部分 注意对于$x’=x$或者$y’=y$的区域一定要分离 则有：在任意一个平面区域中，有效的转移点一定是距离$(x,y)$最近的点 简要证明： 对于$A$来说，切比雪夫距离相同的的点构成一条带 设最近的点为$B$，那么对于任意一个其它点$C$，显然有$dis(A,C)&gt;dis(B,C),dis(A,C)&gt;dis(A,B)$ 故走$A\\rightarrow B\\rightarrow C$不劣 快速完成转移这样的$B$显然不唯一存在，每次转移需要的是$\\text{L}$形的段 故可以对于每行每列用线段树优化区间连边 故得到一个$O(K)$点数，$O(K\\log K)$边数的图 用$\\text{Dijkstra}$完成最短路，复杂度为$O(K\\log ^2 K\\frac{N} {W})$ ps: 这里没有考虑找到最近点的过程 ，下面的代码是直接暴力找的。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,const T &amp;b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,const T &amp;b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=30011,INF=1e9+10,U=10000,D=6;bool Mbe;int n,m,k;int X[N],Y[N],pre[N],vis[N];vector &lt;Pii&gt; E[N];typedef unsigned long long ull;struct Bitset&#123; ull a[N/64+10]; int l; void Add(int x)&#123; while(1) &#123; ull t=a[x&gt;&gt;D]; a[x&gt;&gt;D]+=1ull&lt;&lt;(x&amp;63); if(t&gt;a[x&gt;&gt;D]) x=((x&gt;&gt;D)+1)&lt;&lt;D; else break; &#125; cmax(l,((x&gt;&gt;D)&lt;&lt;D)+63-__builtin_clzll(a[x&gt;&gt;D])); &#125; bool operator &lt; (const Bitset &amp;__) const &#123; if(__.l&gt;10009) return 1; if(l!=__.l) return l&lt;__.l; drep(i,(l&gt;&gt;D)+1,0) if(a[i]!=__.a[i]) return a[i]&lt;__.a[i]; return 0; &#125;&#125; dis[N];struct Queue&#123; int s[N&lt;&lt;2],bit; void Up(int p) &#123; s[p]=dis[s[p&lt;&lt;1]]&lt;dis[s[p&lt;&lt;1|1]]?s[p&lt;&lt;1]:s[p&lt;&lt;1|1]; &#125; void Build()&#123; for(bit=1;bit&lt;=n+1;bit&lt;&lt;=1); s[bit+1]=1; for(int p=bit+1;p;p&gt;&gt;=1) s[p]=1; &#125; void push(int p) &#123; for(s[p+bit]=p,p+=bit;p&gt;&gt;=1;) Up(p); &#125; int top()&#123; int res=s[1],p=s[1]; for(s[p+=bit]=0;p&gt;&gt;=1;) Up(p); return res; &#125;&#125; que;int Dis(int x,int y) &#123; return max(abs(X[x]-X[y]),abs(Y[x]-Y[y])); &#125;int Ans[N],Ac;int Min[N][8];int Dir(int u,int v)&#123; int x=X[v]-X[u],y=Y[v]-Y[u]; if(y==0) return x&gt;0?0:4; if(y&gt;0) return x==0?2:(x&gt;0?1:3); return x==0?6:(x&gt;0?7:5);&#125;typedef vector &lt;int&gt; V;V A[N],B[N];int rtx[N],rty[N],ls[N],rs[N];int Build(const V &amp;vec,int l,int r)&#123; if(l==r) return vec[l]; int mid=(l+r)&gt;&gt;1,u=++n; ls[u]=Build(vec,l,mid),rs[u]=Build(vec,mid+1,r); E[u].pb(mp(ls[u],-1)),E[u].pb(mp(rs[u],-1)); return u;&#125;V Res;void Que(const V &amp;vec,int p,int l,int r,int ql,int qr)&#123; if(!p) return; if(ql&lt;=vec[l] &amp;&amp; vec[r]&lt;=qr) return Res.pb(p); int mid=(l+r)&gt;&gt;1; if(ql&lt;=vec[mid]) Que(vec,ls[p],l,mid,ql,qr); if(qr&gt;=vec[mid+1]) Que(vec,rs[p],mid+1,r,ql,qr);&#125;void AddX(int u,int x,int l,int r)&#123; int d=abs(x-X[u]); if(rtx[x]) Que(A[x],rtx[x],0,A[x].size()-1,l,r); for(int v:Res) &#123; E[u].pb(mp(v,d)); &#125; Res.clear();&#125;void AddY(int u,int y,int l,int r)&#123; int d=abs(y-Y[u]); if(rty[y]) Que(B[y],rty[y],0,B[y].size()-1,l,r); for(int v:Res) &#123; E[u].pb(mp(v,d)); &#125; Res.clear();&#125;void Init()&#123; rep(i,1,k) A[X[i]].pb(i),B[Y[i]].pb(i); rep(i,1,U) &#123; if(A[i].size()) &#123; sort(A[i].begin(),A[i].end(),[&amp;](int x,int y)&#123; return Y[x]&lt;Y[y]; &#125;); rtx[i]=Build(A[i],0,A[i].size()-1); for(int &amp;j:A[i]) j=Y[j]; &#125; if(B[i].size()) &#123; sort(B[i].begin(),B[i].end(),[&amp;](int x,int y)&#123; return X[x]&lt;X[y]; &#125;); rty[i]=Build(B[i],0,B[i].size()-1); for(int &amp;j:B[i]) j=X[j]; &#125; &#125; rep(i,1,k) rep(j,0,7) Min[i][j]=INF; rep(i,1,k) rep(j,i+1,k)&#123; int d=Dir(i,j),dis=Dis(i,j); cmin(Min[i][d],dis); cmin(Min[j][(d+4)&amp;7],dis); &#125; rep(i,1,k) &#123; if(Min[i][0]!=INF) AddX(i,X[i]+Min[i][0],Y[i],Y[i]); if(Min[i][1]!=INF) &#123; AddX(i,X[i]+Min[i][1],Y[i]+1,Y[i]+Min[i][1]); AddY(i,Y[i]+Min[i][1],X[i]+1,X[i]+Min[i][1]); &#125; if(Min[i][2]!=INF) AddY(i,Y[i]+Min[i][2],X[i],X[i]); if(Min[i][3]!=INF) &#123; AddX(i,X[i]-Min[i][3],Y[i]+1,Y[i]+Min[i][3]); AddY(i,Y[i]+Min[i][3],X[i]-Min[i][3],X[i]-1); &#125; if(Min[i][4]!=INF) AddX(i,X[i]-Min[i][4],Y[i],Y[i]); if(Min[i][5]!=INF) &#123; AddX(i,X[i]-Min[i][5],Y[i]-Min[i][5],Y[i]-1); AddY(i,Y[i]-Min[i][5],X[i]-Min[i][5],X[i]-1); &#125; if(Min[i][6]!=INF) AddY(i,Y[i]-Min[i][6],X[i],X[i]); if(Min[i][7]!=INF) &#123; AddX(i,X[i]+Min[i][7],Y[i]-Min[i][7],Y[i]-1); AddY(i,Y[i]-Min[i][7],X[i]+1,X[i]+Min[i][7]); &#125; &#125;&#125;bool Med;int main()&#123; fprintf(stderr,&quot;%.2lf\\n&quot;,(&amp;Med-&amp;Mbe)/1024.0/1024.0); n=rd(),m=rd(),k=rd(),n=k; rep(i,1,k) X[i]=rd(),Y[i]=rd(); Init(); que.Build(); dis[0].Add(10111); rep(i,2,n) dis[i].Add(10110); while(que.s[1]) &#123; int u=que.top(); vis[u]=1; for(auto t:E[u]) &#123; int v=t.first; Bitset w=dis[u]; if(~t.second) w.Add(t.second); if(w&lt;dis[v]) dis[v]=w,que.push(v),pre[v]=u; &#125; &#125; for(int u=k;u;u=pre[u]) if(u&lt;=k) Ans[++Ac]=u; printf(&quot;%d\\n&quot;,Ac); drep(i,Ac,1) printf(&quot;%d &quot;,Ans[i]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"ROI","slug":"ROI","permalink":"http://chasingdeath.github.io/tags/ROI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"求导/泰勒展开","slug":"求导 泰勒展开","date":"2021-02-05T23:53:37.000Z","updated":"2021-05-22T03:54:11.396Z","comments":true,"path":"articles/2021/02/06/f395be43.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/06/f395be43.html","excerpt":"","text":"求导/泰勒展开前言:求导是为泰勒展开铺路的。。 求导$f’(x)$为$f(x)$的导数，即$f(x)$在$x$上的变化率 $\\begin{aligned} f'(x)=\\lim_{\\Delta x\\rightarrow 0} \\frac{f(x+\\Delta x)-f(x)} {\\Delta x}\\end{aligned}$ $f(x)$在$x$上可导的前提是$f(x)$在$x$上是连续的 一种不完善的判定条件是$\\begin{aligned} \\lim_{\\Delta x\\rightarrow 0^+} \\frac{f(x+\\Delta x)-f(x)} {\\Delta x}=\\lim_{\\Delta x\\rightarrow 0^+} \\frac{f(x)-f(x-\\Delta x)} {\\Delta x}\\end{aligned}$ \\求导法则$1.(x^n)’=n \\cdot x^{n-1}$$(n\\in \\R$,但是要注意定义域) $2.(\\sin x)’=\\cos x,(\\cos x)’=-\\sin x$ $3.(e^x)’=e^x$ $4.(a^x)’=\\ln a\\cdot a^x$ $5.(\\ln x)’=\\frac{1} {x}$ $6.\\log_a x=\\frac{1} {x\\ln a}$ $7.(f(x)g(x))’=f’(x)g(x)+f(x)g’(x)$ $8.\\displaystyle (\\frac{f(x)} {g(x)})’=\\frac{f’(x)g(x)-f(x)g’(x)} {g^2(x)}$ $9.(f(g(x)))’=f’(g(x))\\cdot g’(x)$ 如$f(x)=\\ln x,g(x)=ax-1$ $f’(x)=\\frac{1} {x},f’(g(x))=\\frac{1} {ax-1}$ $g’(x)=a$ $(\\ln (ax-1))’=\\frac{a} {ax-1}$ \\泰勒 Taylor 展开$\\text{Taylor}$展开是用函数$f(x)$在某个点$x_0$上不断求导之后的函数值表示出函数本身 从而将任何一个函数表示成(可能不是有穷的)多项式函数形式 $\\begin{aligned} f(x)=\\sum _{i=0}^{\\infty}\\frac{f^{(i)}(x_0)} {i!}(x-x_0)^i\\end{aligned}$ 其中$f^{(i)}$表示$f$的$i$阶导数 当$x_0=0$时，这个展开被称为麦克劳林 $\\text{Maclaurin}$展开，即 $\\begin{aligned} f(x)=\\sum _{i=0}^{\\infty}\\frac{f^{(i)}(0)} {i!}x^i\\end{aligned}$ Taylor 展开的证明为了便于描述，下面直接对于$\\text{Maclaurin}$ 展开叙述 ， $\\text{Taylor}$展开相当于平移了$x_0$ 不妨设$f(x)$展开后的多项式函数系数为$a_i$，即设$\\begin{aligned} f(x)=\\sum_{i=0}^{\\infty}a_ix^i\\end{aligned}$ 不断对于$f(x)$求导得到下式 $\\begin{aligned} f^{(0)}(x)= a_0+a_1x+a_2x^2+a_3x^3\\cdots \\end{aligned}$ $\\begin{aligned} f^{(1)}(x)= a_1+2a_2x+3a_3x^2+4a_4x^3\\cdots \\end{aligned}$ $\\begin{aligned} f^{(2)}(x)= 2a_2+6a_3x^1+12a_4x^2+20a_5x^3\\cdots \\end{aligned}$ $\\cdots$ $\\begin{aligned} f^{(n)}(x)= n!a_n+\\prod_{i=2}^{n+1}i\\cdot a_{n+1}x^1+\\prod_{i=3}^{n+2}i\\cdot a_{n+2}x^2\\cdots \\end{aligned}$ 带入这些函数在0上的取值，得到 $f^{(i)}(0)=i!\\cdot a_i$ 因此$\\begin{aligned} f(x)=a_ix^i=\\sum _{i=0}^{\\infty}\\frac{f^{(i)}(0)} {i!}x^i\\end{aligned}$ \\常见的Taylor展开如果你是数学生$\\displaystyle e^x= 1+x+\\frac{x^2} {2}+\\ldots+ \\frac{x^n} {n!}+\\theta\\frac{x^{n+1} } {(n+1)!},\\theta\\in (0,1)$ 所以实际上是 $\\left\\{\\begin{aligned}e^x\\ge 1+x+\\frac{x^2} {2}+\\ldots+\\frac{x^n} {n!}&& 2\\not |n\\text{ or }\\ge 0\\\\ e^x\\leq 1+x+\\frac{x^2} {2}+\\ldots+\\frac{x^n} {n!}&& \\text{otherwise}\\end{aligned}\\right.$ $\\ln x\\leq x-1$ 诸如此类，常用于$e^x,\\ln x$的放缩处理 \\如果你是OIer/ACMer带入$f(x)=e^x,x_0=0$，得到 $\\begin{aligned} f(x)=e^x=\\sum _{i=0}^{\\infty}\\frac{x^i} {i!}\\end{aligned}$ 类似的 1+\\frac{x^2} {2!}+\\frac{x^4} {4!}+\\frac{x^6} {6!} ... =\\frac{e^x+e^{-x} } {2}\\frac{x^1} {1!}+\\frac{x^3} {3!}+\\frac{x^5} {5!}...=\\frac{e^x-e^{-x} } {2}$\\displaystyle [x^n]e^{ax}=\\frac{a^n} {n!}$ 还有很多都可以自己代入一下，比如 $\\begin{aligned} \\frac{1} {1-x}=\\sum_{i=0}^{\\infty} x^i\\end{aligned}$ $\\begin{aligned} -\\ln (1-x)=\\ln \\frac{1} {1-x}=\\sum_{i=1}^{\\infty}\\frac{x^i} {i}\\end{aligned}$ $\\begin{aligned}\\sin x =\\sum_{i=1}(-1)^{i+1}\\frac{x^{2i+1} } {(2i+1)!}\\end{aligned}$ $\\begin{aligned}\\cos x=\\sum_{i=0}(-1)^{i}\\frac{x^{2i} } {(2i)!}\\end{aligned}$ 应用:牛顿迭代法","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"FFT&NTT(以及扩展)","slug":"FFT&NTT(以及扩展)","date":"2021-02-05T10:38:38.000Z","updated":"2021-05-22T03:54:11.422Z","comments":true,"path":"articles/2021/02/05/e2229676.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/05/e2229676.html","excerpt":"","text":"FFT&amp;NTT(以及扩展)预备知识：用于NTT NTT/FFT其实本质相同，用途是快速求解 多项式乘积 前言FT: 傅里叶变换: 这是一个工程上的概念，可以简述为：一个周期性的信号波段可以用 若干个正弦曲线 的带权和表示 DFT: 离散傅里叶变换，这是傅里叶变换在离散情况下的变种 FFT: 快速傅里叶变换 NTT: 快速数论变换 \\谈及核心思想1.单位根: 构造$\\omega_n$为$n$阶单位根(不知道$\\omega_n$的值域)，满足性质$\\omega_n^n=\\omega_n^0=1$ 对于$2|n$,$\\omega _n^{\\frac{n} {2} }=-1$ 显然$\\omega_n$满足一个非常简单的性质：折半引理 $\\begin{aligned} \\forall 2|i\\and 2|n , \\omega_n^i=\\omega_{\\frac{n} {2} }^{\\frac{i} {2} }\\end{aligned}$ $\\omega_n$实际上是一个在幂次上呈现$n$元循环的数值 2.多项式与点值式的转化 一个$n$阶多项式最普通的表示就是$F(x)=\\sum_{i=0}^{n-1} a_ix^i$ 然而，多项式也可以用$n$个互不相关的点表示，即$(x_0,y_0),(x_1,y_1),\\cdots,(x_{n-1},y_{n-1})$ 两者可以互相转化 对于同$x_i$的点值，两个多项式卷积时，其$y_i$可以直接对应相乘 FFT/NTT的核心过程是 多项式$\\longrightarrow$ 点值式$\\longrightarrow$点值式对应相乘$\\longrightarrow$多项式 而用单位根来构造快速的多项式与点值式的转化 3.分治思想 用于降低多项式与点值式转换的复杂度 \\FFT的单位根$(x,y)$指复数$i=\\sqrt{-1},(x,y)=x+yi$ 基本运算$(x,y)+(a,b)=(x+a,y+b),(x,y)\\cdot (a,b)=(ax-by,ay+bx)$ FFT的单位根是:$\\omega_n$=$(cos(\\frac{2\\pi} {n}),sin(\\frac{2\\pi} {n}))$ 而$\\omega _n^i=(cos(\\frac{2\\pi} {n}\\cdot i),sin(\\frac{2\\pi} {n}\\cdot i))$ (展开发现就是三角函数求和公式) 显然满足单位根的性质​ (实际上可以发现，这个说是点值其实就是信号序列的三角函数表示) \\NTT相信您已经了解了原根的一些性质，$\\text{NTT}$的单位根常用原根构造 $\\text{NTT}$的单位根实际有较大的局限性，对于质数$P$只能构造出$n|P-1,\\omega_n=g^{\\frac{P-1} {n} }$ 计算在模意义下就能满足单位根的性质 通常我们$P$取$998244353$，$2^{23}|(P-1)$，它的一个原根是3 实际上，为了满足下面分治需要，构造的模数通常满足$P-1=s\\cdot 2^t$的$t$较大，这类模数我们常称作$\\text{NTT}$模数 \\\\以上部分均为基础知识，相对来说应该不会太难，下面是主要难点 \\多项式转点值式接下来我们考虑如何将多项式转化为点值式 对于点值式，我们构造的点横坐标为$x_i=\\omega_n^i$ 具体目标是对于函数$F(x)$，求出在$x_0,x_1,\\cdots ,x_{n-1}$上的函数值 即求出$F(x_i)=a_0\\omega_n^0+a_1\\omega_n^{i}+a_2\\omega_n^{2i}+\\cdots$ 接下来就是核心的分治思想，注意，这里的分治是子问题严格等大的 对于当前问题，分成两部分子问题求解(实际是可以分成多部分的，但是这个是特殊情况暂时不予讨论)，即求解 令$m=\\frac{n} {2}$ $\\begin{aligned} 2|i,G(x_i)=a_0\\omega_{m}^0+a_2\\omega_{m}^{\\frac{i} {2} }+a_4\\omega_{m}^{\\frac{i} {2}\\cdot 2}+\\cdots\\end{aligned}$ $\\begin{aligned} 2|i,H(x_i)=a_1\\omega_{m}^0+a_3\\omega_{m}^{\\frac{i} {2} }+a_5\\omega_{m}^{\\frac{i} {2}\\cdot 2}+\\cdots\\end{aligned}$ 更简洁的描述为 $i&lt;m,G(x_i’)=a_0\\omega_{m}^0+a_2\\omega_{m}^{i}+a_4\\omega_{m}^{2i}+\\cdots$ $i&lt;m,H(x_i’)=a_1\\omega_{m}^0+a_3\\omega_{m}^{i}+a_5\\omega_{m}^{2i}+\\cdots$ 由于$G(x’_i),H(x’_i)$计算的是$[0,m-1]$项，而求$F(x_i)$时用到的是$0,2,4,\\cdots$项，实际需要访问$G(x^2_i),H(x^2_i)$ 和$F(x_i)$的式子比较，我们得到合并的式子为 $F(x_i)=G(x^2_i)+x_i H(x^2_i)$ 带入折半引理，实际等价于 $F(x_i)=G(x’_i)+x_i H(x’_i)$ 注意$x_i=x’_{i\\mod m}$ 为了保证复杂度，尽量使得每次分治的子问题都分为两部分，这样的复杂度为$O(n\\log n)$ 附:实际上，分为$d$个子问题时，每次合并的复杂度为$O(n\\cdot d)$，因此复杂度为 保证每次分治为两个严格等大的子问题，可以从一开始就把$n$扩充为$2$的幂次 12int N=1;while(N&lt;=n+m) N&lt;&lt;=1; 附:$d$个子问题时，设子问题答案为$G_j(x_i)$，则合并的式子为 $\\begin{aligned} F(x_i)=\\sum_{j=0}^{d-1}x_i^jG_j(x_i^d)=\\sum_{i=0}^{d-1}x_i^jG_j(x'_{i\\mod \\frac{n} {d} })\\end{aligned}$ 点值式转多项式一个简单的性质：单位根反演 $\\sum_{j=0}^{n-1}\\omega_n^{ij}= \\left\\{\\begin{aligned} \\frac{\\omega_n^{in}-1} {\\omega_n^i-1}=0 && i\\ne 0\\\\ n && i=0\\end{aligned} \\right.$ 设点值式对应$y_i$的序列为$b_i$ 则$n\\cdot a_i=\\sum_{j=0}^{n-1}\\omega_n^{-ij} b_j$ 证明 $\\begin{aligned} \\sum_{j=0}^{n-1}\\omega_n^{-ij}b_j=\\sum_{j=0}^{n-1} \\omega_n^{-ij}(\\sum_{k=0}^{n-1}a_k\\omega_n^{jk})\\end{aligned}$ $\\begin{aligned} \\sum_{j=0}^{n-1}\\omega_n^{-ij}b_j= \\sum_{k=0}^{n-1}a_k\\sum_{j=0}^{n-1}\\omega_n^{j(k-i)} \\end{aligned}$ 由上面的式子，发现只有$k-i=0$时右边的求和式有值，所以上式成立 因此点值式转多项式直接把系数改为$\\omega_n^{-i}$即可 \\\\Tips:1.由于单位根的循环特性，溢出会直接溢出到本来的式子里 因此，如果乘法过后的多项式产生了超过$&gt;n$的项$x^i$，会溢出到$x^{i\\mod n}$ 2.点值式并不是不满足除法，只是除法得到的多项式并不一定是一个$n$元以内的多项式，除了恰好整除的情况，得到的通常是一个无穷级数的式子，如$\\begin{aligned} \\frac{1} {1-x}=\\frac{1-x^{\\infty} } {1-x}=\\sum_{i=0}^{\\infty}x^i\\end{aligned}$ 真正要求除法，通常是求前$n$项的结果，即需要用到多项式乘法逆 \\代码实现与优化模板题传送门 然后我们得到一份优美的代码(FFT) (Complex是C++库自带的复数,M_PI是C++自带$\\pi$常量) 123456789101112131415161718void FFT(int n,Complex *a,int f) &#123; if(n==1) return; Complex tmp[N]; int m=n/2; rep(i,0,m-1) tmp[i]=a[i&lt;&lt;1],tmp[i+m]=a[i&lt;&lt;1|1]; // 按照奇偶分类 memcpy(a,tmp,sizeof(Complex) * n); FFT(m,a,f),FFT(m,a+m,f); // 分两半，算g(x),h(x) Complex w(cos(2*M_PI/n),f*sin(2*M_PI/n)),e(1,0); // w=x^1,e=x^i rep(i,0,m-1) &#123; tmp[i]=a[i]+e*a[i+m]; // f(x_i)=g(x_i)+e*h(x_i) e=e*w; &#125; rep(i,m,n-1) &#123; tmp[i]=a[i-m]+e*a[i]; e=e*w; &#125; memcpy(a,tmp,sizeof(T)*n);&#125; 由于$(\\omega_n)^{\\frac{n} {2} }=-1$，所以还可以简化为 123456Complex w(cos(2*M_PI/n),f*sin(2*M_PI/n)),e(1,0);rep(i,0,m-1) &#123; tmp[i]=a[i]+e*a[i+m]; tmp[i+m]=a[i]-e*a[i+m]; e=e*w;&#125; 由于用了double，最后输出要取整 蝴蝶优化我们加一点优化，取代递归的分治过程 可以看到，分治时我们按照$i \\mod 2$分成两组，然后继续分 这个过程中，实际上我们就是将$i$的二进制位前后翻转 所以我们可以暴力处理出$i$分治底层的位置 1234567rep(i,0,n-1) &#123; int x=i,s=0; for(int j=1;(j&lt;&lt;c)&lt;=n;++j) &#123; s=(s&lt;&lt;1)|(x&amp;1); x&gt;&gt;=1; &#125; // s就是最终位置&#125; 当然也是有$O(n)$处理方法的 123int N=1,c=-1;while(N&lt;=n+m) N&lt;&lt;=1,c++;rep(i,1,N-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;c); (建议自己模拟一下) 有了这个翻转数组，我们可以直接从分治底层开始解决整个问题，每次合并操作完全相同 每次分治问题的大小，依次合并每一个子问题区间即可 为了在一个数组上完成操作，还需要注意合并顺序 代码解释$i$:分治子问题大小为$2i$，$l$:合并区间的左端点为$l$，右端点为$l+2i$，$j$枚举合并位置 1234567891011121314void FFT(int n,Complex *a)&#123; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; Complex w(cos(2*M_PI/n),f*sin(2*M_PI/n)); for(int l=0;l&lt;n;l+=i*2) &#123; Complex e(1,0); for(int j=l;j&lt;l+i;++j,e=e*w) &#123; Complex t=a[j+m]*e; // a&#x27;[j]=a[j]+e*a[j+m] // a&#x27;[j+i]=a[j]-e*a[j+m] a[j+m]=a[j]-t; a[j]=a[j]+t; &#125; &#125; &#125;&#125; 事实上我们还有更快的写法，就是将$\\omega_n^i$预处理出来 (注意这个$\\text{FFT}$的预处理很考验double精度，不能每次都直接累乘上去，隔几个就要重新调用依次三角函数) 当然如果自己写复数会更快 \\关于点值式转多项式的优化由于每次求得点值是$\\omega_n^{-i}=\\omega_n^{n-i}$ 所以可以直接用 多项式转点值式的函数， 最后把$[1,n-1]$这一段翻转，每个数除掉$n$即可 \\对于加减运算取模的优化三目运算 12a+=b,a=a&gt;=P?a-P:a;a-=b,a=a&lt;0?a+P:a; 逻辑运算优化(原理是逻辑预算会在第一个确定表达式值的位置停下) 12a+=b,((a&gt;=P)&amp;&amp;(a-=P));a-=b,((a&lt;0)&amp;&amp;(a+=P)); \\关于系数预处理优化(以NTT为例)带入上面已经提到的优化，无预处理系数的$\\text{NTT}$大概是这样的 12345678910111213141516171819202122232425ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int a[N];void NTT(int n,int *a,int f)&#123; rep(i,1,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int w=qpow(3,(P-1)/i/2); for(int l=0;l&lt;n;l+=i*2) &#123; int e=1; for(int j=l;j&lt;l+i;++j,e=1ll*e*w%P) &#123; int t=1ll*a[j+i]*e%P; a[j+i]=a[j]-t,((a[j+i]&lt;0)&amp;&amp;(a[j+i]+=P)); a[j]+=t,((a[j]&gt;=P)&amp;&amp;(a[j]-=P)); &#125; &#125; &#125; if(f==-1) &#123; reverse(a+1,a+n); int Inv=qpow(n); rep(i,0,n-1) a[i]=1ll*a[i]*Inv%P; &#125;&#125; 一种简单的预处理是，每次对于每个分治大小，预处理依次系数 12345678910111213141516171819202122232425262728ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int a[N],e[N];void NTT(int n,int *a,int f)&#123; rep(i,1,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); e[0]=1; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int w=qpow(3,(P-1)/i/2); for(int j=1;j&lt;i;++j) e[j]=1ll*e[j-1]*w%P; //for(int j=i-2;j&gt;=0;j-=2) e[j+1]=1ll*w*(e[j]=e[j&gt;&gt;1])%P; //这个版本是沿用上一次预处理的结果，实际(只有)用这种预处理方法可以极大程度上加强FFT的精度 for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,((a[j+i]&lt;0)&amp;&amp;(a[j+i]+=P)); a[j]+=t,((a[j]&gt;=P)&amp;&amp;(a[j]-=P)); &#125; &#125; &#125; if(f==-1) &#123; reverse(a+1,a+n); int Inv=qpow(n); rep(i,0,n-1) a[i]=1ll*a[i]*Inv%P; &#125;&#125; 另一种是在一开始就把所有的系数用一个数组存下来，具体过程可以描述为 对于每个分治长度$n$，我们只需要访问$\\omega_n^{0},\\omega_n^{1},\\cdots,\\omega_n^{\\frac{n} {2}-1}$ 那么对于分治长度$n$，我们在$w$数组的第$\\frac{n} {2}$ ~ $n-1$项依次存储这些值 优化:我们只需要对于最大的分治长度处理，剩下的部分发现可以直接用折半引理访问得到 12345678910111213141516171819202122232425262728293031ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;const int N=1&lt;&lt;21;int a[N],w[N];void Init()&#123; w[N&gt;&gt;1]=1; int t=qpow(3,(P-1)/N); rep(i,(N&gt;&gt;1)+1,N-1) w[i]=1ll*w[i-1]*t%P; drep(i,(N&gt;&gt;1)-1,1) w[i]=w[i&lt;&lt;1];&#125;void NTT(int n,int *a,int f)&#123; rep(i,1,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,((a[j+i]&lt;0)&amp;&amp;(a[j+i]+=P)); a[j]+=t,((a[j]&gt;=P)&amp;&amp;(a[j]-=P)); &#125; &#125; &#125; if(f==-1) &#123; reverse(a+1,a+n); int Inv=qpow(n); rep(i,0,n-1) a[i]=1ll*a[i]*Inv%P; &#125;&#125; 三份代码在duck.ac上的评测结果表明，不预处理系数将近慢一倍 单组数据来看，预处理系数会慢一点 多组来看，预处理系数会快 实际差距不大，都可以使用 但是在某些层面来说，下面这份板子才是最好的(适用NTT,FFT且精度较高)，不需要预处理 1234567891011121314151617181920212223242526ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int a[N],e[N];void NTT(int n,int *a,int f)&#123; rep(i,1,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); e[0]=1; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int w=qpow(3,(P-1)/i/2); for(int j=i-2;j&gt;=0;j-=2) e[j+1]=1ll*w*(e[j]=e[j&gt;&gt;1])%P; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,((a[j+i]&lt;0)&amp;&amp;(a[j+i]+=P)); a[j]+=t,((a[j]&gt;=P)&amp;&amp;(a[j]-=P)); &#125; &#125; &#125; if(f==-1) &#123; reverse(a+1,a+n); int Inv=qpow(n); rep(i,0,n-1) a[i]=1ll*a[i]*Inv%P; &#125;&#125; \\拓展1.分治+NTT常用于处理多个计数背包的快速合并 (实际无权值01背包也是可以的) 我们可以用NTT$n\\log n$合并两个大小为$n$的背包 分治时，每次合并两个分治子问题，总共的时间就是$\\sum size\\log n$ 每个背包的$size$会被计算$\\log n$次，所以总共复杂度是$n \\log ^2 n$ \\2.CDQ+NTT模板题传送门 对于形如$dp_i=\\sum_{j=0}^{i-1}dp_jg_{i-j}$的$dp$转移(就是dp转移与差值有关) 由于求$dp_i$时，需要保证$dp_0,dp_1,\\cdots,dp_{i-1}$才能卷积，这个限制，我们可以用CDQ分治解决 对于当前分治区间$[L,R]$ 依次考虑$[L,mid]$内部转移，$[L,mid]$向$[mid+1,R]$的转移(用FFT/NTT解决)，$[mid+1,R]$内部转移 算法流程 1234567void Solve(l,r)&#123; if(l==r) return; mid=(l+r)&gt;&gt;1; Solve(l,mid); (l,mid)-&gt;(mid+1,r); Solve(mid+1,r);&#125; \\3.MTT(任意模数NTT)\\4.$n$元点值式\\练习建议： 1.高精度乘法 2.简单应用：HDU-4609 题解 3.卷积构造模板： BZOJ-3527 题解 4.拓展卷积构造：HDU-5885 题解 5.构造卷积的应用：HDU-6061 题解 6.$CDQ$分治+$FFT$：HDU-5730 题解 7.$CDQ$+NTT/降次前缀和优化$dp$：HDU-5332 题解 8.容斥+$MTT$：HDU-6088 题解 9.图上$dp$： 联通图个数：BZOJ-3456 题解 带环联通图个数：HDU-5552 题解 森林数量和带限制森林数量：HDU - 5279 题解 10.点分治+FFT：CodeChef-PRIMEDST 题解 \\\\\\更多应用和优化参见毛啸2016论文(如：两次FFT做卷积，4次FFT做MTT。。。)","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「GDOI2020模拟赛day1」Permutation              ","slug":"「GDOI2020模拟赛day1」Permutation              ","date":"2021-02-03T06:28:22.000Z","updated":"2021-05-22T03:54:11.181Z","comments":true,"path":"articles/2021/02/03/ef70be87.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/03/ef70be87.html","excerpt":"","text":"「GDOI2020模拟赛day1」Permutation为了便于叙述，设原题中的 $n$ 为$N$ 题目分析要求一个$1-n$的环排列，看成是一个环遍历 发现每条边的权值限制了遍历过程中穿过这条边的次数 取$1$为根，强制从$1$开始遍历，考虑以一个个自由段（即未确定前后连接关系的子段）的形式维护$u$子树中的序列段 那么，只需要满足$u$子树中自由段的个数为$\\frac{w(u,fa_u)} {2}$ （每一个自由段的两端均对应一次跨越）即可 分析即可发现$w(u,fa_u)$显然是$O(size_u)$级别的，因此考虑树形背包 那么我们就需要支持合并两组自由段 \\$O(N^3-N^2\\log N)$设当前$1\\ldots n$个自由端，合并上$m$个自由段(从子树合并上来是恰好$m$个) 注意这些自由段之间是无序的 先考虑一个简单的模型： 把$n$个无序自由段拼接成$m$个无序自由段，设方案数为$W(n,m)$，则考虑 先把$n$个自由段排列，然后选出$n-m$个间隔连接，然后除掉得到的$m$个段之间的排列 得到$\\begin{aligned} W(n,m)=\\frac{n!} {m!}\\binom{n-1} {n-m} \\end{aligned}$ 类似的，可以把$n+m$个自由段排成一排，合并成若干段 但是显然存在的问题就是：可能在两组自由段之间形成了连接，这样的连接是非法的 因此考虑容斥 $\\begin{aligned} dp'_{d}\\longleftarrow\\sum_{i=1}^ndp_{u,i}\\sum_{j=1}^idp_v (-1)^{i-j}W(i,j) \\sum_{k=1}^m (-1)^{m-k}W(m-1,k)\\sum_{d=1}^{j+k}W(j+k,d)\\end{aligned}$ 将上式分解为四步转移 $n,i\\rightarrow j,O(n^2)$ $m\\rightarrow k,O(m)$ $j,k\\rightarrow j+k,O(nm)$ $j+k\\rightarrow d,O((n+m)^2)$ 其中$O(n^2,(n+m)^2)$的部分如果用卷积优化，即可做到$O(N^2\\log N)$ 但是$O(N^3)$就$pts75$了… Tips:注意在将$1$号节点加入序列时，用上面的方法无法保证它在序列首 需要特殊处理，始终强制它在第一个 $O(N^2)$当我发现这个做法不需要任何优化就可以做到$O(N^2)$的时候。。。。 把这个容斥的过程爆开 先对于每个儿子的$dp$值按照容斥系数进行上文中$m\\rightarrow k$的变换，复杂度为$O(size_u)$ 然后进行背包合并，由树形背包的复杂度分析，总复杂度为$O(N^2)$ 最后发现其实我们只需要知道$dp_{u,w(u,fa_u)}$，因此这里也只需要$O(size_u)$ 综上，复杂度为$O(N^2)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T&amp; a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T&amp; a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;const int DEBUG=1;#define Log(...) (DEBUG&amp;&amp;(fprintf(stderr,__VA_ARGS__)))char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;bool Mbe;const int N=5010;int n,P;ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int I[N],J[N],C[N][N],W[N][N];struct Edge&#123; int to,nxt,w;&#125; e[N&lt;&lt;1];int head[N],ecnt;void AddEdge(int u,int v,int w)&#123; e[++ecnt]=(Edge)&#123;v,head[u],w&#125;; head[u]=ecnt;&#125;int sz[N],w[N],dp[N][N],T[N];int A[N],B[N];void dfs(int u,int f)&#123; sz[u]=0,dp[u][0]=1; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].to; if(v==f) continue; w[v]=e[i].w,dfs(v,u); rep(a,0,sz[u]) T[a]=dp[u][a],dp[u][a]=0; rep(a,0,sz[u]) rep(b,1,sz[v]) dp[u][a+b]=(dp[u][a+b]+1ll*T[a]*dp[v][b])%P; sz[u]+=sz[v]; &#125; int s=0; rep(i,w[u],sz[u]+1) &#123; int e=W[i][w[u]]; if(u==1) e=1ll*C[i-1][i-w[u]]*J[i-1]%P*I[w[u]-1]%P; s=(s+1ll*e*dp[u][i-1])%P; &#125; // 求出我们需要的点值 rep(i,w[u]+1,sz[u]) dp[u][i]=0; if(!s) puts(&quot;0&quot;),exit(0); // 容斥系数变换 rep(i,1,w[u]) &#123; dp[u][i]=1ll*s*W[w[u]][i]%P; if((w[u]-i)&amp;1) dp[u][i]=P-dp[u][i]; &#125; sz[u]=w[u];&#125;bool Med;int main()&#123; Log(&quot;Memory taken %.2lf\\n&quot;,(&amp;Med-&amp;Mbe)/1024.0/1024.0); n=rd(),P=rd(); rep(i,J[0]=1,n) J[i]=1ll*J[i-1]*i%P; I[n]=qpow(J[n]); drep(i,n,1) I[i-1]=1ll*I[i]*i%P; rep(i,0,n) rep(j,C[i][0]=1,i) C[i][j]=C[i-1][j]+C[i-1][j-1],Mod1(C[i][j]),W[i][j]=1ll*C[i-1][i-j]*J[i]%P*I[j]%P; rep(i,2,n)&#123; int u=rd(),v=rd(),w=rd(); if(w&amp;1) return puts(&quot;0&quot;); AddEdge(u,v,w/=2),AddEdge(v,u,w); &#125; dfs(w[1]=1,0); dp[1][1]=1ll*dp[1][1]*n%P; printf(&quot;%d\\n&quot;,dp[1][1]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"各省OI","slug":"各省OI","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E7%9C%81OI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「ROI 2017 Day 1」虎   (计算几何)","slug":"「ROI 2017 Day 1」虎   (计算几何)","date":"2021-02-01T12:58:18.000Z","updated":"2021-05-22T03:54:11.233Z","comments":true,"path":"articles/2021/02/01/b9561fd9.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/02/01/b9561fd9.html","excerpt":"","text":"「ROI 2017 Day 1」虎 (计算几何)题意：（交互题） 已知$n$个点，$m$次询问，每次询问交互器随机生成一个位置的关键点，要求在$k$次查询中给出一个合法解 查询：一个凸包，返回关键点是否在凸包中 解：一个凸包，包含关键点，且不包含其它点，保证有界 对关键点的包含是包括了边界线的，其它点的包含不包括边界线，凸包均要按照顺时针给出 Solution 1 （未完全实现）先将给定点分层转化为若干凸包，容易通过二分得到关键点所在的层 如果关键点以内不再有凸包，显然得到一个解 否则，一个合法的解一定是在两层凸包中某一层选取两个点，另一层选取一个点得到的三角形 先考虑内层选两个点的情况，令二分边界为内层凸包上点的编号，$l,r$ 考虑实现一个操作，对于$l,r$，找到其连接的直线在顺时针方向上在外层凸包上切到的段 由此得到一个凸包进行查询，即可进行二分，最终$l+1=r$时，再进行一次上述操作得到一组解（不一定合法） 如果不合法，同理再在外层上二分一次 最终写道第一种情况弃掉了。。。 \\\\Solution2 随机分裂良好的随机分裂可以跑到max query times&lt;=33的好成绩 考虑一个非常简单的剖开$n$个点的方法： 1.找到这些点的凸包，从点集中删掉 2.从剩余点中选择一个作为中心，分别与凸包上的点连边，将平面分开 3.确定每个三角形中包含的点，加上三个顶点，继续进行剖分 最终当凸包以外不再有点时，结束 \\查询也是比较显然的： 对于当前凸包及其中心，二分找到关键点对应的位置，然后继续进行，直到不存在中心 二分方法： 凸包构成一圈，取一个点为$l$，顺时针180以内的范围最大角度的点为$r$，每次将中心和$l,mid$这连续一段查询判断是否包含 这样存在的问题是：可能不在$l$的180范围内，需要在开始二分前判断一下 十分朴素的实现也可以获得90分的好成绩 优化： 每次选取中心时，多随机几次，估价找到一个最优剖分即可 Loj Submission -包含大量调试语句和内嵌的交互部分 Loj Submission 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T&amp; a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T&amp; a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;bool Mbe;const int N=5010;int n,q;// 计算几何部分namespace Geometry&#123;struct Node&#123; ll x,y; Node()&#123; &#125; Node(ll x,ll y):x(x),y(y)&#123; &#125; Node operator - (const Node __) const &#123; return Node(x-__.x,y-__.y); &#125; Node operator + (const Node __) const &#123; return Node(x+__.x,y+__.y); &#125; ll operator ^ (const Node __) const &#123; return 1ll*x*__.y-1ll*y*__.x; &#125; bool operator == (const Node __) const &#123; return x==__.x &amp;&amp; y==__.y; &#125; void Read()&#123; x=rd(),y=rd(); &#125;&#125; A[N],QuePoint;typedef vector &lt;int&gt; V;// check close wiseint chk(int i,int j,int k,int bound=0)&#123; return ((A[k]-A[i])^(A[j]-A[i]))&gt;=bound; &#125;int chk(Node i,int j,int k,int bound=0)&#123; return ((A[k]-i)^(A[j]-i))&gt;=bound; &#125;// this is clockwiseint CheckConvex(const V &amp;P)&#123; int n=P.size(); rep(i,0,n-1) &#123; int j=(i+1)%n,k=(j+1)%n; if(!chk(P[j],P[k],P[i])) return 0; &#125; return 1;&#125;// this is clock-wiseint CheckIn(const V&amp;P,Node X,int bound=0)&#123; rep(i,0,P.size()-1) &#123; int j=(i+1)%P.size(); if(chk(X,P[i],P[j],bound)) continue; return 0; &#125; return 1;&#125;int Check(V P)&#123; if(P.size()&lt;=2) return 0; printf(&quot;? %llu &quot;,P.size()); for(int i:P) printf(&quot;%d &quot;,i); puts(&quot;&quot;); fflush(stdout); static char s[5]; scanf(&quot;%s&quot;,s); return *s==&#x27;Y&#x27;;&#125;void Output(V P)&#123; printf(&quot;! %llu &quot;,P.size()); for(int i:P) printf(&quot;%d &quot;,i); puts(&quot;&quot;); fflush(stdout);&#125;V Convex(V P)&#123; if(P.size()&lt;=2) return P; V Ans; int n=P.size(); static int I[N],mk[N],S[N],T; rep(i,0,n-1) mk[I[P[i]]=i]=0; sort(P.begin(),P.end(),[&amp;](int x,int y)&#123; return A[x].x&lt;A[y].x || (A[x].x==A[y].x &amp;&amp; A[x].y&gt;A[y].y); &#125;); T=0; rep(i,0,n-1) &#123; while(T&gt;1 &amp;&amp; ((A[P[i]]-A[S[T]])^(A[S[T-1]]-A[S[T]]))&gt;0 ) T--; S[++T]=P[i]; &#125; rep(i,1,T) Ans.pb(S[i]),mk[I[S[i]]]=1; sort(P.begin(),P.end(),[&amp;](int x,int y)&#123; return A[x].x&lt;A[y].x || (A[x].x==A[y].x &amp;&amp; A[x].y&lt;A[y].y); &#125;); T=0; rep(i,0,n-1) &#123; while(T&gt;1 &amp;&amp; ((A[P[i]]-A[S[T]])^(A[S[T-1]]-A[S[T]]))&lt;0 ) T--; S[++T]=P[i]; &#125; drep(i,T,1) if(!mk[I[S[i]]]) Ans.pb(S[i]); return Ans;&#125;&#125;using namespace Geometry;const int M=2e5+10;V C[M],S[M];int K[M],D[M],E[M],rt,m,mk[M];// 剖分// C凸包，S子节点// K中心，D凸包上0号点对应的180范围内的最大点，E凸包上D号点对应180范围内的最大点// m个数void Build(int &amp;u,V P) &#123; sort(P.begin(),P.end()); int n=P.size(); C[u=++m]=Convex(P); rep(i,0,n-1) mk[i]=0; if(C[u].size()==P.size()) return; for(int i:C[u]) mk[lower_bound(P.begin(),P.end(),i)-P.begin()]=1; V T; rep(i,0,n-1) if(!mk[i]) T.pb(P[i]); n=C[u].size(); // 获取剖分结果 auto Get=[&amp;]() &#123; if(rand()&amp;1) K[u]=T[(T.size()/(rand()%3+2)+rand()%8)%T.size()]; else K[u]=T[rand()%T.size()]; V P=T; P.erase(lower_bound(P.begin(),P.end(),K[u])); D[u]=E[u]=0; while(D[u]&lt;n-1 &amp;&amp; chk(K[u],C[u][0],C[u][D[u]+1])) D[u]++; E[u]=D[u]; while(E[u]&lt;n-1 &amp;&amp; chk(K[u],C[u][D[u]],C[u][E[u]+1])) E[u]++; vector &lt;V&gt; ST(n); for(int x:P) &#123; rep(i,0,n-1) &#123; if(chk(K[u],C[u][i],x) &amp;&amp; chk(K[u],x,C[u][(i+1)%n])) &#123; ST[i].pb(x); break; &#125; &#125; &#125; rep(i,0,n-1) ST[i].pb(K[u]),ST[i].pb(C[u][i]),ST[i].pb(C[u][(i+1)%n]); return ST; &#125;; vector &lt;V&gt; st; int mi=1e9; rep(kase,1,5) &#123; int d=D[u],e=E[u],k=K[u]; auto ST=Get(); int now=0; for(V j:ST) cmax(now,(int)j.size()); if(now&gt;mi)&#123; D[u]=d,E[u]=e,K[u]=k; continue; &#125; st=ST,mi=now; &#125; rep(i,0,n-1) &#123; int x; Build(x,st[i]); S[u].pb(x); &#125;&#125;void Init() &#123; V T(n); rep(i,0,n-1) T[i]=i+1; Build(rt,T);&#125;void Find(int u=rt)&#123; if(!S[u].size()) return Output(C[u]); int n=C[u].size(); int l,r; auto Get=[&amp;](int l,int r) &#123; V T; T.pb(K[u]); l%=n,r%=n; for(int i=l;;i=(i+1)%n) &#123; T.pb(C[u][i]); if(i==r) break; &#125; return Check(T); &#125;; if(Get(0,D[u])) l=0,r=D[u]; else if(Get(D[u],E[u])) l=D[u],r=E[u]; else l=E[u],r=n; while(l+1&lt;r) &#123; int mid=(l+r)&gt;&gt;1; if(Get(l,mid)) r=mid; else l=mid; &#125; Find(S[u][l]);&#125;int main()&#123; n=rd(); rep(i,1,n) A[i].Read(); Init(); q=rd(); rep(_,1,q) Find();&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"ROI","slug":"ROI","permalink":"http://chasingdeath.github.io/tags/ROI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[BJ United Round  3] 押韵","slug":"[BJ United Round  3] 押韵","date":"2021-01-30T08:20:57.000Z","updated":"2021-05-22T03:54:11.017Z","comments":true,"path":"articles/2021/01/30/d68e278e.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/01/30/d68e278e.html","excerpt":"","text":"[BJ United Round #3] 押韵先%%%%%%%%%%%%%%%%% EI \\\\下文默认模数为$P$ 简要题意：求：用$k$种元素，每种元素使用$d$的倍数次，排成一个长度为$nd$的序列 的方案数 这个题目的设定就让人想到两个离不开的元素 ： (模数暗示了？) 指数型生成函数 + 单位根反演 显然可以得到每一种元素的指数型生成函数为 $\\begin{aligned} \\text{EGF(Element)}=F(x)=\\sum_{d|i} \\frac{x^i} {i!}\\end{aligned}$ 带入单位根反演$\\begin{aligned}\\ [d|n]=\\frac{\\sum_0^{d-1} \\omega_d^{in} } {d}\\end{aligned}$ 即$F(x)=\\begin{aligned}\\frac{1} {d}\\cdot \\sum_{i=0}^{d-1}e^{\\omega_d^ix}\\end{aligned}$ 而总的生成函数就是 $G(x)=F^k(x)$ 即$\\begin{aligned} G(x)=\\frac{1} {d^k}\\cdot (\\sum_{i=0}^{d-1}e^{\\omega_d^ix})^k\\end{aligned}$ 其中的和式幂次展开会得到一个$k^d$项的多项式，我们要求$[x^n]G(x)$，就需要展开得到每一项的幂系数 所以显然我们需要先合并同类项一下。。。 而幂系数是一个单位根之和的形式，这就需要我们寻找单位根之间的关系 这里得到一个思路：用$d$次单位根中的$\\varphi(d)$个作为基底，以简单的 有理数/整系数 表示出所有的$\\omega_d^i$ \\对于$d=4$的情况比较简单，$\\varphi(d)=2$，可以得到四个单位根分别为$1,\\omega,-1,-\\omega$ 可以枚举得到的和为$x+y\\omega$，然后求系数 优先考虑组合意义，可以发现就是在平面上每次可以走四个方向，$k$步之后最终到达$(x,y)$的方案数 两个维度分立的情况，还需要枚举每个维度走了几步，所以用一种巧妙的转化两个维度联系在一起 将平面旋转$\\frac{\\pi} {8}$，并且扩大$\\sqrt 2$倍，得到新的坐标为$(x-y,x+y)$，新的行走方向是$(+1,+1),(-1,-1),(-1,+1),(+1,-1)$ 这样以来，每次每个维度都有行走，可以确定每个维度$+1$和$-1$的次数，直接组合数排列即可得到答案 \\\\对于$d=6$，甚至是更一般的情况的情况 只在代数层面来看单位根似乎十分抽象，不如从复平面单位根上找一找灵感 下面是$d=6$的情形 $\\varphi(6)=2$，假设以$\\overrightarrow{OA},\\overrightarrow{OB}$作为基底，可以直观地得到基底表达 $\\overrightarrow{OA}=1$ $\\overrightarrow{OB}=\\omega$ $\\overrightarrow{OA}=\\omega_6^0$ 1 0 $\\overrightarrow{OB}=\\omega_6^1$ 0 1 $\\overrightarrow{OC}=\\omega_6^2$ -1 1 $\\overrightarrow{OD}=\\omega_6^3$ -1 0 $\\overrightarrow{OE}=\\omega_6^4$ 0 -1 $\\overrightarrow{OF}=\\omega_6^5$ 1 -1 由此我们得到了一个$\\varphi(d)$维数的表达方法 把每一维看做不同元，也就是说，得到了一个$\\varphi(d)$维，$O(1)$次的多项式，需要我们求高维多项式幂次 令$N=k^{\\varphi(d)}$ 直接压位暴力多项式复杂度为$O(N\\log N-N\\log^2N)$，而且面临着模数难以处理，常数大的问题 所以$\\text{EI}$又用出了一个巧妙的暴力方法解决这个问题，以$d=6$为例，先做一下处理，得到要求的多项式 似乎每次$k$次幂总是求导+递推？ $f(x,y)=x^2y+xy^2+y^2+y+x+x^2,g(x,y)=f^k(x,y)$ $g(x,y)$对于$x$求偏导，得到$g’(x,y)=kf^{k-1}(x,y)f’(x,y)$ 即$g’(x,y)f(x,y)=kg(x,y)f’(x,y)$ $f’(x,y)=2xy+2x+y^2+1$ 然后我们要解这个方程，考虑乘积为$[x^ny^m]$一项两边的系数 左边$=[x^{n-2}y^{m-1}]+[x^{n-1}y^{m-2}]+[x^{n}y^{m-2}]+[x^{n}y^{m-1}]+[x^{n-1}y^{m}]+[x^{n-2}y^{m}]$ 换成$g(x,y)$的系数应该是 左边$=(n-1)[x^{n-1}y^{m-1}]+n[x^{n}y^{m-2}]+(n+1)[x^{n+1}y^{m-2}]+(n+1)[x^{n+1}y^{m-1}]+n[x^{n}y^{m}]+(n-1)[x^{n-1}y^{m}]$ 右边$=2k[x^{n-1}y^{m-1}]+2k[x^{n-1}y^m]+k[x^ny^{m-2}]+k[x^ny^m]$ 其中$[x^{n+1}y^{m-1}]$只出现了一次，按照先$n$递增再$m$递增的顺序进行递推，即 $\\begin{aligned}\\ [x^ny^m]=\\frac{2k[x^{n-2}y^{m}]+2k[x^{n-2}y^{m+1}]+k[x^{n-1}y^{m-1}]+k[x^{n-1}y^{m+1}]} {n}\\end{aligned}$ $\\begin{aligned}-\\frac{(n-2)[x^{n-2}y^{m}]+(n-1)[x^{n-1}y^{m-1}]+n[x^{n}y^{m-1}]+(n-1)[x^{n-1}y^{m+1}]+(n-2)[x^{n-2}y^{m+1}]} {n}\\end{aligned}$ 边界条件是 $\\begin{aligned}\\ [x^i]=[y^i](i\\ge k)=\\binom{k} {i-k}\\end{aligned}$ (由系数$x,x^2$或$y,y^2$得到) 由此带入递推即可 综上，得到的每项的系数的复杂度为$O(d\\cdot k^{\\varphi(d)})$ ，其中$d$为递推每项需要的时间 由系数得到答案仍然需要一次快速幂，因此依然带一个$\\log P$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; a=min(a,b); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; a=max(a,b); &#125;char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=2e3+10,P=1049874433,G=7;int n,k,d;ll qpow(ll x,ll k=P-2) &#123; k%=P-1; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int w[100],C[N][N],I[N*2];int main() &#123; n=rd(),k=rd(),d=rd(); w[0]=1,w[1]=qpow(G,(P-1)/d); rep(i,2,90) w[i]=1ll*w[i-1]*w[1]%P; rep(i,0,k) rep(j,C[i][0]=1,i) C[i][j]=C[i-1][j]+C[i-1][j-1],Mod1(C[i][j]); I[0]=I[1]=1; rep(i,2,k*2) I[i]=1ll*(P-P/i)*I[P%i]%P; if(d==1)&#123; int ans=qpow(k,1ll*d*n); printf(&quot;%d\\n&quot;,ans); &#125; else if(d==2) &#123; int ans=0; rep(i,0,k) ans=(ans+qpow((1ll*w[0]*i+1ll*w[1]*(k-i))%P,1ll*d*n)*C[k][i])%P; ans=ans*qpow(qpow(d,k))%P; printf(&quot;%d\\n&quot;,ans); &#125; else if(d==3) &#123; int ans=0; rep(i,0,k) rep(j,0,k-i) ans=(ans+qpow((1ll*w[0]*i+1ll*w[1]*j+1ll*w[2]*(k-i-j))%P,1ll*d*n)*C[i+j][i]%P*C[k][i+j])%P; ans=ans*qpow(qpow(d,k))%P; printf(&quot;%d\\n&quot;,ans); &#125; else if(d==4) &#123; int ans=0; rep(i,-k,k) rep(j,-k,k) if(abs(i)+abs(j)&lt;=k &amp;&amp; (k-i-j)%2==0) &#123; ll x=qpow((1ll*w[0]*i+1ll*w[1]*j)%P,1ll*d*n); ll y=1ll*C[k][(abs(i-j)+k)/2]*C[k][(k+abs(i+j))/2]%P; ans=(ans+x*y)%P; &#125; ans=(ans+P)*qpow(qpow(d,k))%P; printf(&quot;%d\\n&quot;,ans); &#125; else &#123; static int F[N*2][N*2]; int ans=0; rep(i,0,k*2) rep(j,max(k-i,0),min(2*k,3*k-i)) &#123; if(i==0) F[i][j]=C[k][j-k]; else if(j==0) F[i][j]=C[k][i-k]; else &#123; int s=(2ll*k*(i&gt;1?F[i-2][j]+F[i-2][j+1]:0)+1ll*k*(F[i-1][j-1]+F[i-1][j+1]))%P; int t=((i&gt;1?1ll*(i-2)*(F[i-2][j]+F[i-2][j+1]):0)+ 1ll*(i-1)*F[i-1][j-1]+1ll*i*F[i][j-1]+1ll*(i-1)*F[i-1][j+1])%P; F[i][j]=1ll*(s-t+P)*I[i]%P; &#125; ans=(ans+qpow((1ll*w[0]*(i-k)+1ll*w[1]*(j-k))%P,1ll*d*n)*F[i][j])%P; &#125; ans=(ans+P)*qpow(qpow(d,k))%P; printf(&quot;%d\\n&quot;,ans); &#125;&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「CEOI2020」象棋世界  ","slug":"「CEOI2020」象棋世界  ","date":"2021-01-30T03:09:53.000Z","updated":"2021-05-22T03:54:11.170Z","comments":true,"path":"articles/2021/01/30/26929ebf.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/01/30/26929ebf.html","excerpt":"","text":"「CEOI2020」象棋世界下文默认$n=R,m=C,x=c_1,y=c_R$ Pawn略 Rook略 Queen先判掉一次到达的情况，然后就可以从起点和终点分别画出5条可行线 由此得到若干交点，手动数一下有几个交点在内部的整点上 123456789101112131415161718void QQQ()&#123; int d=abs(x-y); if(d==n-1 || d==0) puts(&quot;1 1&quot;); // 一次到达 else &#123; d=(n-1-d)/2; int res=4; if(n==m) &#123; // 一条斜着，一条平着 if(x==1 || x==n) res++; if(y==1 || y==n) res++; &#125; if(((x+1)&amp;1)==((y+n)&amp;1)) &#123; // 先判断整点，然后判断两条斜线相交是否在内部 if(min(x,y)-d&gt;=1) res++; if(max(x,y)+d&lt;=m) res++; &#125; printf(&quot;%d %d\\n&quot;,2,res); &#125;&#125; \\\\Bishop看起来是很复杂的问题，但是实际上可以从一个简单的贪心入手 判定条件可以发现，任意一次行走的直线上，坐标$(x,y)$的$(x+y)\\mod 2$不变 所以只要$x+1\\equiv y+n\\pmod 2$即可 贪心策略首先一定是每次向前走 第一步选择向左/右，然后每次转向，每次走都顶到边界线 但是这样显然会无法到达最终位置 纠正方法考虑贪心到达的最后位置为$to$，那么得到的差值$|to-y|$是我们要矫正的距离 而矫正方法：在中途出现的每次转向位置，向里面”凹”进去一点，每凹进去一格，实际上相当于少走了两格 注意矫正的方向是根据最后一步走的方向而变化的，因此如果矫正方向不对，需要额外增加一步 此时，相当于需要多矫正到沿边界线对称的位置，需要多走$2(to-1)$或者$2(m-to)$的距离 假设走了$c$步，那么我们有$c-1$个转折点，最后将这若干的矫正距离分配到$c-1$个转折点上，可以用一个组合数解决 由于矫正距离是$O(m)$的，所以组合数显然可以在$O(m)$时间内求出 \\最后将向左向右合并即可 12345678910111213141516171819202122232425262728293031323334ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int C(int n,int m) &#123; if(m&gt;n-m) m=n-m; int a=1,b=1; rep(i,1,m) a=1ll*a*(n-i+1)%P,b=1ll*b*i%P; return a*qpow(b)%P;&#125;int Divide(int n,int m)&#123; // Divide n elements in to m groups , each can be empty if(m&lt;=0 &amp;&amp; n&gt;0) return 0; return C(n+m-1,m-1);&#125;void BBB()&#123; if(((x+1)&amp;1)!=((y+n)&amp;1)) return puts(&quot;0 0&quot;),void(); auto Subsolver=[&amp;](int x,int y)&#123; // assume that we go left first int c=0,to=x,dis=n-1; // count , towardsposition c=1,dis-=x-1,to=1; // go left by x-1 c+=dis/(m-1),to=((dis/(m-1))&amp;1)?m:1,dis%=m-1; // then each step m-1 opposite if(dis) c++,to=to==1?to+dis:to-dis; // reach destination (NO!) if(to==y) return mp(c,1); int d=abs(to-y)/2; if((c&amp;1) &amp;&amp; y&gt;to) d+=to-1,c++; if((~c&amp;1) &amp;&amp; y&lt;to) d+=m-to,c++; return mp(c,Divide(d,c-1)); &#125;; Pii l=Subsolver(x,y),r=Subsolver(m-x+1,m-y+1); if(l.first&gt;r.first) swap(l,r); if(r.first==l.first) (l.second+=r.second)%=P; printf(&quot;%d %d\\n&quot;,l.first,l.second);&#125; \\\\King可以发现，每次一定是向前的三个方向走，由此可以得到一个简单的$O(nm)\\ $ $dp$ 用矩阵优化可以做到$O(m^3\\log n)$求出所有的答案 难点在于如果快速求出这个矩阵$A$的$A^{n-1}$，即要加速矩阵求幂 容易想到用 特征多项式 解决该问题，参考 问题分为两步 得到$p_m(\\lambda)$列出我们的转移矩阵$A=$ $\\begin{matrix}1\\ 1\\ 0\\ 0\\ 0\\ 0\\ \\cdots \\ 0\\\\ 1\\ 1\\ 1\\ 0\\ 0\\ 0\\ \\cdots \\ 0\\\\ 0\\ 1\\ 1\\ 1\\ 0\\ 0\\ \\cdots \\ 0\\\\ \\cdots\\cdots\\cdots\\cdots \\\\ 0\\ \\cdots\\ 0\\ 0\\ 1\\ 1\\ 1\\ 0\\\\0\\ \\cdots\\ 0\\ 0\\ 0\\ 1\\ 1\\ 1\\\\ 0\\ \\cdots\\ 0\\ 0\\ 0\\ 0\\ 1 \\ 1\\end{matrix}$ $\\lambda I-A=$ $\\lambda -1$ $-1$ $0$ $0$ $0$ $0$ $\\cdots$ $0$ $-1$ $\\lambda -1$ $-1$ $0$ $0$ $0$ $\\cdots$ $0$ $0$ $-1$ $\\lambda -1$ $-1$ $0$ $0$ $\\cdots$ $0$ $\\cdots$ $\\cdots$ $\\cdots$ $\\cdots$ $\\cdots$ $\\cdots$ $\\cdots$ $\\cdots$ $0$ $0$ $\\cdots$ $0$ $-1$ $\\lambda -1$ $-1$ $0$ $0$ $0$ $\\cdots$ $0$ $0$ $-1$ $\\lambda -1$ $-1$ $0$ $0$ $\\cdots$ $0$ $0$ $0$ $-1$ $\\lambda -1$ 每一行有$2/3$个元素，看起来并不是很好得到行列式 但是容易得到一个递推式，设$m$阶转移矩阵的特征多项式为$p_m(\\lambda)$ 如果最后一行取第$m$个元素，值为$(\\lambda-1)p_{m-1}(\\lambda)$ 如果最后一行取第$m-1$个元素，值为$-p_{m-2}(\\lambda)$ 因而得到 $p_m(\\lambda)=\\left\\{\\begin{aligned}1&& m=0\\\\ \\lambda-1 && m=1\\\\ (\\lambda-1)p_{m-1}(\\lambda)-p_{m-2}(\\lambda) && m>1\\end{aligned}\\right.$ 可以在$O(m^2)$的时间内暴力求出，也可以得到通项公式(太憨了) 那么得到关系用$\\lambda^n\\mod p_m(\\lambda)$的系数优化计算，可以用暴力实现的多项式取模+快速幂得到$O(m^2\\log n)$ 当然也可以优化 \\求出$A^0,A^1,A^2\\cdots A^m$直接求显然是$O(m^3)$的，卡一卡说不定能过？ 由于走的是一个$m\\times m$的棋盘，可以用一个简单容斥得到答案 设$f_{x,y}$为从$x$走到$y$，中途允许超出边界的方案数 由于棋盘只有$m\\times m$，中途最多只会可能经过一条边界线 而一旦在某一个时刻超出边界线到达$0/m+1$，那么接下来达到这条边界线两侧对称点的方案数是一样的 即：跨过了某一条边界线$0/m+1$的不合法方案数，可以用到达$y$关于这条边界线的 对称点的 不一定合法方案数得到 而不一定合法的$f_{x,y}$实际上只和$|x-y|$有关 由此，可以用$f_{0,i}$表示出$A^i_{x,y}$，那么接下来只需要先计算出$f_{0,i}$对于系数的求和，最终进行一次容斥，减去两侧不合法方案数即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061typedef vector &lt;int&gt; Poly;Poly operator * (const Poly &amp;a,const Poly &amp;b)&#123; int n=a.size()-1,m=b.size()-1; Poly c(n+m+1); rep(i,0,n) rep(j,0,m) c[i+j]=(c[i+j]+1ll*a[i]*b[j])%P; return c;&#125;Poly operator * (Poly a,const int &amp;b)&#123; for(int &amp;i:a) i=1ll*i*b%P; return a;&#125;Poly operator + (Poly a,const Poly &amp;b)&#123; if(a.size()&lt;b.size()) a.resize(b.size()); rep(i,0,b.size()-1) a[i]+=b[i],Mod1(a[i]); return a;&#125;Poly operator - (Poly a,const Poly &amp;b)&#123; if(a.size()&lt;b.size()) a.resize(b.size()); rep(i,0,b.size()-1) a[i]-=b[i],Mod2(a[i]); return a;&#125;Poly operator % (Poly a,const Poly &amp;b)&#123; int n=a.size()-1,m=b.size()-1; if(n&lt;m) return a; assert(b[m]==1); drep(i,n-m,0) rep(j,0,m) a[i+j]=(a[i+j]+1ll*(P-a[i+m])*b[j])%P; a.resize(m); return a;&#125;Poly Pow(Poly x,int k,Poly Mod)&#123; Poly res=x; k--; for(;k;k&gt;&gt;=1,x=x*x%Mod) if(k&amp;1) res=res*x%Mod; return res;&#125;Poly F,G,T=Poly&#123;P-1,1&#125;;int f[N*2],g[N*2],H[N*2];void KKKInit()&#123; G=Poly&#123;1&#125;,F=T; rep(i,2,m) swap(F,G),F=G*T-F; // 递推特征多项式 F=Pow(Poly&#123;0,1&#125;,n-1,F); // 求出x^&#123;n-1&#125; mod p(x) f[0]=1,H[0]=F[0]; rep(t,1,F.size()-1) &#123; // 求出f_&#123;0,i&#125;，只需要求一半 rep(i,0,t) g[i]=f[i]; rep(i,0,t) &#123; f[i]=(0ll+(i?g[i-1]:g[1])+g[i]+g[i+1])%P; H[i]=(H[i]+1ll*f[i]*F[t])%P; // 乘上系数累和 &#125; &#125;&#125;void KKK()&#123; int res=H[abs(x-y)]; // 两侧对称点 // y -&gt; 0-(y-0)=-y // y -&gt; m+1+(m+1-y)=2(m+1)-y res-=H[abs(-y-x)]; res-=H[abs(2*(m+1)-y-x)]; // 容斥 res=(res%P+P)%P; printf(&quot;%d %d\\n&quot;,n-1,res);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"CEOI","slug":"CEOI","permalink":"http://chasingdeath.github.io/tags/CEOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[补]NOIP2020T4微信步数","slug":"[补]NOIP2020T4微信步数","date":"2021-01-07T13:57:28.000Z","updated":"2021-05-22T03:54:11.107Z","comments":true,"path":"articles/2021/01/07/3aa5cefa.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/01/07/3aa5cefa.html","excerpt":"","text":"[补]NOIP2020T4微信步数题意：一个人在$k$维平面上，每一维范围是$[1,W_i]$上的任意一个位置，初始可以在任何一个位置 这个人在空间上游走，每$n$步为一轮不断重复，每一步是一个方向上走-1或者1，求所有情况下 最后他离开空间范围的时间 之和 分析： 行走是循环的，每一维可以先看做独立，然后离开范围的时间就是每一维取$\\min$ 一个简单的思路：求出每一维每一个位置离开的时间，然后$k$路归并得到答案，复杂度为$O((\\sum W_i)k+nk)$ 容易想到根据循环来优化计算，但是如果以每一个位置为元素进行考虑，难以处理不同长度循环之间的合并 \\更换思路：简单的计数方法的转换： 从初始位置离开的时间之和 = 前$i(i\\ge 0)$步还未离开空间的初始位置个数之和 令$F_{i,j}$为$i$这一维$j$步还未离开的初始位置个数，则答案就是 $\\begin{aligned} \\sum_{i\\ge 0}\\prod F_{i,j}\\end{aligned}$ 此时观察发现除了第一轮需要特殊考虑以外，其它的$F_{i,j}$可以表示为$\\max\\lbrace0,F_{i,j-n}-D_i\\rbrace$(其中$D_i$为每一轮$i$这一维偏移的量) 对于前面$n$(好像是$2n$)个特殊考虑，后面对于每一个不同的$i\\mod n$可以放在一起考虑，用一个统一的式子表示 然后计算就是类似$\\begin{aligned} \\sum_{i\\ge 0}\\prod (G_j-i D_j)\\end{aligned}$，以$i$为元，所求的就是是一个$k$次多项式前缀和，也就是一个$k+1$次多项式的点值 暴力的方法就是 求出前面$k+2$项的值，然后用 拉格朗日插值/高斯消元 得到答案，复杂度为$O(nk^2-nk^3)$(如果插值写好一点，复杂度主要受限于求值) 然后甚至可以无脑吸多项式做到$O(nk\\log ^2k)$ 求值时可以发现 对于$i$所求的$j$处点值的积式里面 最多只有一项和$i-1$不同，因而可以特殊考虑以优化求值复杂度 下面是$nk^2$，由于求值已经是$k^2$了，所以插值也没优化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=5e5+10,P=1e9+7;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int n,m,W[12],F[12][N*2];int A[N],B[N],D[N];int ans;ll X[20],Y[20],I[20];int Lag(int n,int x)&#123; ll res=0; rep(i,0,n) &#123; ll a=1,b=1; rep(j,0,n) if(i!=j) a=a*(P+x-X[j])%P,b=b*(X[i]&lt;X[j]?-I[X[j]-X[i]]:I[X[i]-X[j]])%P; res=(res+a*b%P*Y[i])%P; &#125; return res;&#125;int main() &#123; I[0]=I[1]=1; rep(i,2,19) I[i]=P-P/i*I[P%i]%P; n=rd(),m=rd(); rep(i,1,m) W[i]=rd(); rep(i,1,n) A[i]=rd(),B[i]=rd(); int f=0; rep(i,1,m) &#123; int c=F[i][0]=W[i],now=0,l=0,r=0; rep(j,1,n*2) &#123; if(A[j&lt;=n?j:j-n]==i) now+=B[j&lt;=n?j:j-n]; if(now&lt;l) l=now,c--; if(now&gt;r) r=now,c--; c=max(c,0),F[i][j]=c; &#125; D[i]=abs(now)/2; if(now || c==0) f=1; &#125; if(!f) return puts(&quot;-1&quot;),0; rep(i,0,n)&#123; ll t=1; rep(j,1,m) t=t*F[j][i]%P; ans=(ans+t)%P; &#125; rep(i,n+1,n*2) &#123; int n=1e9,f=1; rep(j,1,m) &#123; if(D[j]) n=min(n,F[j][i]/D[j]); f&amp;=F[j][i]&gt;0; &#125; if(!f) continue; int t=1; rep(j,1,m) t=1ll*t*max(0,F[j][i]-D[j]*(n+1))%P; ans=(ans+t)%P; int s=0; rep(k,0,m+1) &#123; int t=1; rep(j,1,m) t=1ll*t*(F[j][i]-D[j]*k)%P; X[k]=k,Y[k]=s=(s+t)%P; &#125; ans=(ans+Lag(m+1,n))%P; &#125; ans=(ans%P+P)%P,printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://chasingdeath.github.io/tags/NOIP/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"NOIP2020游记","slug":"NOIP2020游记","date":"2021-01-07T07:19:40.000Z","updated":"2021-05-22T03:54:10.982Z","comments":true,"path":"articles/2021/01/07/5dd4d224.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/01/07/5dd4d224.html","excerpt":"","text":"NOIP2020游记(没想到一直到学考考完才来写这个。。) Day -1最后一张模拟赛，结果 T4放了这个 「清华集训 2017」小 Y 和地铁 哇谁没事搞一个爆搜题在这里 结果被我模拟退火搞过去了 现在感觉乱搞能力++!! \\Day0抵达杭州，为什么会有一个叫做橘子酒店的东西 听说会很冷，但是实际上也并没有 这次似乎有好好休息一下？ \\Day1假装慌得不行 一大早考试，结果第一次在XJ解决了排泄问题 T1: -5min小模拟gogogo！诶是不是要高精 不管了直接莽unsigned long long 怎么可能在考场上打高精的 \\T2Reading….. 1e6 , 5组数据， CCF什么时候这么大方了… 那一定是$O(n)$！kmp! kmp! Wondering….. 这怎么可能$O(n)$写… 果然还是写$n\\cdot (26+\\ln n)$吧 测试… 完了常年开O2差点都不会用register了 2s，感觉i7可以拯救我 T3这是一个假的传统题…. CCF居然用Spj了 题目描述还是错的… 过过过 T4诶这里怎么有一个愚蠢的80分，我要这个100有何用 pts80 ——- 分类讨论中 ….. T3*2看起来像是一个排序问题，而且几乎是没有辅助空间的排序 先写一个暴力，强行交换任意两个位置的数字.. 分类讨论中… \\常见的排序不就是 归并/快排 嘛 ， 那没有辅助空间不就是快排了 似乎已经确定了数字的个数，那么根本就不需要随机，直接自顶向下分治，向两边分开所有的数字即可 copy … paste… copy … paste … 硬生生写了200行? 啊? $O(nm\\log )$还是很稳的 果然是乱搞能力++吗? \\稳健稳健，还有将近一个小时时间检查，不打分了，不会打了 T1 果然还是怕，果然还是不想打高精，优化了一下运算顺序 T2 没毛病 T3 完全没毛病 T4 这个怎么会去写100的。。 写一个基排优化一下常数？果然没用。。。 I’m out!果然全机房几乎没有人动高精…..妙啊 听说所有人都写了hash！我去好像很简单！听说大部分都T掉了？ 听说有很多人T3写了$n^2m,nm^2$ 听说外校的人都A了T4?( ⊙ o ⊙ ) 出成绩果然出题人不会卡高精太多分( ^_^ ) 浙江居然这么少300+？","categories":[{"name":"游记","slug":"travel","permalink":"http://chasingdeath.github.io/categories/travel/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"游记","slug":"travel","permalink":"http://chasingdeath.github.io/categories/travel/"}]},{"title":"CSP-S 2020 游记","slug":"CSP-S 2020 游记","date":"2021-01-07T06:48:10.000Z","updated":"2021-05-22T03:54:10.896Z","comments":true,"path":"articles/2021/01/07/48ee5331.html","link":"","permalink":"http://chasingdeath.github.io/articles/2021/01/07/48ee5331.html","excerpt":"","text":"CSP-S 2020 游记没想到一直到学考考完才来写这个。。 Day-?,Day0机房环境极其平和，模拟赛各种花式错误 依然十分坚定，完全没复习，考前还在猛吸多项式~~。。。。 哎这太香了嘛 \\-3h中午试图午睡，果然没睡着，起来的时候眼睛都睁不开 料想每次模拟赛都是这么考的，应该问题不大 -10min哇是去年省选一样配置 今年报了Linux，机房四个人1，3，5，7座位，md结果我坐在考场第一个位置疯狂爆零 这次Linux考场文件没出问题 预想到Linux机房必然大佬无数，结果旁边的大佬一顿乱敲发现键盘是坏的！ 半天，监考人员换了一个，还是坏的！ 然后直接换了一个新的键盘。。。 -3min又是惊心动魄的输密码，果然~~ 熟悉的监考人员，一样(更)神经病的密码！！ 监考人员4次写错密码大小写，终于改完 然后另一个监考人员告诉它外面的括号也是密码。。。(结果还是错了大小写) 0-10min状态极佳，板子敲了10分钟，结果发现原来我的右括号卡键。。。 现在补换键盘还来得及不。。。 10~?min旁边换了键盘的大佬开始猛敲 啊不，是用手指猛砸键盘，场面一度十分恐怖 这就是健壮嘛 \\看T1，我啊啊大模拟，开始硬刚 刚了20分钟刚完第一份代码，然后发现题目只看了一半。。。重构.jpg 怎么两边闰年不一样的 怎么一个月少了10天 怎么还要特判那一年 啊啊啊啊啊啊啊啊啊啊啊啊啊 曾经妄想$O(1)$写，惨遭毒打 最后写了一大堆封装函数，测一下诶似乎还ko以，溜了溜了 \\看T2，$k=64$ 出题人是不是爱上unsigned long long了。。诶离散一下$q_i$，for三次判一下 哇$q_i$不相同！删掉！ 2^64-x肯定可以溢出回来，我相信unsigned long long ~~哇真实，竟然还有答案为$2^{64}$的情况~ \\看T3，有人奶今年题会很难，这个题看起来这么有b格，那这个我题必做不出来 诶开始爽暴力分.jpg $n\\leq 20000$，啊怎么没有$n^2$这一档分的。。。。 dis出题人 只凑了50pts \\T4。。。每次操作是固定的，诶这怎么是个模拟题。。。 每次取最值操作，最后决策要支持回撤 怕T手莽可删堆，结果本地还是5e4很慢。。。 最后十分钟：T4是不是可以两个队列维护最值！ 一直刚到最后一分钟，结果还是没调完。。。差点代码没交上去。。。 240min+出考场：完了所有人都A了T3。。。。。 T4两个队列果然是错的。。。","categories":[{"name":"游记","slug":"travel","permalink":"http://chasingdeath.github.io/categories/travel/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"游记","slug":"travel","permalink":"http://chasingdeath.github.io/categories/travel/"}]},{"title":"Stirling数小记","slug":"Stirling数小记","date":"2020-12-03T13:07:21.000Z","updated":"2021-05-22T03:54:10.994Z","comments":true,"path":"articles/2020/12/03/450a91ae.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/12/03/450a91ae.html","excerpt":"","text":"Stirling数小记 定义/组合意义第一类斯特林数：$\\begin{bmatrix}n\\\\ m\\end{bmatrix}$表示$n$个不同元素分为$m$个圆排列的方案数 有标号的第一类斯特林数$s(n,m)=(-1)^{n-m}\\begin{bmatrix}n\\\\ m\\end{bmatrix}$ 第二类斯特林数：$\\begin{Bmatrix}n\\\\ m\\end{Bmatrix}$表示$n$个不同元素分为$m$个集合的方案数 注意圆排列和集合都是相互之间无序的 \\ 递推方法第一类斯特林数 $\\begin{bmatrix}n\\\\ m\\end{bmatrix}=\\begin{bmatrix}n-1\\\\ m-1\\end{bmatrix}+(n-1)\\begin{bmatrix}n-1\\\\ m\\end{bmatrix}$ 即新建一个圆排列，或者插入前面$n-1$个元素中任意一个的后面 显然的，有标号的第一类斯特林数递推式就是 $\\begin{bmatrix}n\\\\ m\\end{bmatrix}=\\begin{bmatrix}n-1\\\\ m-1\\end{bmatrix}-(n-1)\\begin{bmatrix}n-1\\\\ m\\end{bmatrix}$ \\第二类斯特林数 $\\begin{Bmatrix}n\\\\ m\\end{Bmatrix}=\\begin{Bmatrix}n-1\\\\ m-1\\end{Bmatrix}+m\\begin{Bmatrix}n-1\\\\ m\\end{Bmatrix}$ 即新建一个集合，或者加入前面的$m$个集合 \\ 第二类斯特林数的通项公式$\\begin{aligned} \\begin{Bmatrix} n \\\\ m \\end{Bmatrix}=\\frac{1} {m!}\\sum_{i=0}^{\\infty} (-1)^{m-i}\\binom{m} {i} i^n \\end{aligned}$ 其组合意义是枚举生成了多少个有序的集合，然后容斥，最后除去集合的顺序 \\ 生成函数表示与行/列求解固定$n$，以$m$为形式幂指数，则第一类斯特林数的普通生成函数 $\\begin{aligned}\\text{OGF}=\\prod_{i=0}^{n-1}(x+i)=x^{\\overline{n} }\\end{aligned}$ (其意义就是上面的递推公式) 倍增+卷积二项展开求出$F(x+i)$即可做到$O(n\\log n)$求出一行 \\固定$m$，以$n$为形式幂指数，则第一类斯特林数的指数型生成函数 $\\begin{aligned}\\text{EGF}= & \\frac{1} {m!}\\cdot (\\sum_{i=1}^{\\infty}\\frac{(i-1)!} {i!}x^i)^m\\\\= & \\frac{1} {m!}\\cdot (\\sum_{i=1}^{\\infty}\\frac{x^i} {i})^m\\end{aligned}$ 设$F(x)=\\sum_{i=1}^{\\infty}\\frac{x^i} {i}$ $\\begin{aligned} \\because F'(x)=&\\sum_{i=1}^{\\infty}x^{i-1}=\\frac{1} {1-x}\\end{aligned}$ $\\begin{aligned} \\therefore F(x)=\\int \\frac{1} {1-x}=-\\ln(1-x)\\end{aligned}$ $\\begin{aligned}\\therefore \\text{EGF} = & \\frac{1} {m!}\\cdot (-\\ln(1-x))^m\\\\= & \\frac{1} {m!}\\cdot (-1)^m\\cdot \\ln^m(1-x)\\end{aligned}$ (就是百度百科上的那个，它什么都没讲清楚) 多项式快速幂即可做到$O(n\\log n-n\\log ^2n)$求一列 \\而在上式的推导过程中额外加入$(-1)^m$的常数，并且把$x^i$换成$(-x)^i$可以得到有标号第一类斯特林数的指数型生成函数 $\\begin{aligned} \\text{EGF} = & \\frac{1} {m!}\\cdot (\\sum_{i=1}^{\\infty}\\frac{(-x)^i} {i})^m\\\\=& \\frac{1} {m!}\\cdot \\ln^m(1+x)\\end{aligned}$ \\\\第二类斯特林数的一行可以直接由通项公式做卷积得到 \\固定$m$，以$n$为形式幂指数，则第二类斯特林数的指数型生成函数表示为 $\\begin{aligned} \\text{EGF} &=\\frac{1} {m!}({\\sum_{i=1}^{\\infty} \\frac{x^i} {i!} })^m\\\\ &=\\frac{1} {m!}(e^x-1)^m \\\\ &=\\frac{1} {m!}\\sum_{i=0}^m (-1)^{m-1} \\binom{m} {i}e^{ix}\\end{aligned}$ 实际上由这个二项展开的形式也可以发现，它就是上面通项公式的生成函数推导 可以求一列，复杂度为$O(n\\log n-n\\log ^2n)$常数很大 \\虽然没什么意义，但是还是写一下二元形式 第一类斯特林数: $\\begin{aligned} \\text{EGF}=e^{-\\ln (1-x)y}\\end{aligned}$ 第二类斯特林数: $\\begin{aligned}\\text{EGF}=e^{\\begin{aligned}(e^x-1)y\\end{aligned} }\\end{aligned}$ 注意元$x$为指数型，$y$是普通型 \\ 斯特林数与幂指数/上升幂/下降幂第一类斯特林数： 上面已经说过$\\begin{aligned}x^{\\overline{n} }=\\sum_{i=0}^{n}\\begin{bmatrix}n\\\\i\\end{bmatrix}x^i\\end{aligned}$ 同理，用有标号的第一类斯特林数将$x^{\\underline{n} }$展开的式子是 $\\begin{aligned}x^{\\underline{n} }=\\sum_{i=0}^{n}(-1)^{n- i}\\begin{bmatrix}n\\\\i\\end{bmatrix}x^i\\end{aligned}$ \\第二类斯特林数： 类似通项公式的求解，组合意义将幂指数展开，视$x^n$为将$n$个元素随意放在$x$个位置，则枚举$x$个位置中那些被选择 $\\begin{aligned} x^n=\\sum_{i=0}^n \\binom{x} {i}i!\\begin{Bmatrix}n\\\\i\\end{Bmatrix} \\end{aligned}$ 把$\\binom{x} {i}i!$写成下降幂的形式，得到优美的式子 $\\begin{aligned} x^n=\\sum_{i=0}^n \\begin{Bmatrix}n\\\\i\\end{Bmatrix}x^{\\underline{i} }\\end{aligned}$ \\而实际上由上式二项反演也可以得到通项公式 $\\begin{aligned} \\begin{Bmatrix} n \\\\ m \\end{Bmatrix}=\\frac{1} {m!}\\sum_{i=0}^{\\infty} (-1)^{m-i}\\binom{m} {i} i^n \\end{aligned}$ 关于下降幂多项式的快速转化，可以再借鉴这个 \\ 斯特林变换/斯特林反演对于斯特林变换 $\\begin{aligned} a_n=\\sum_{i=0}^n\\begin{Bmatrix}n\\\\i\\end{Bmatrix}b_i \\end{aligned}$ 设$A(x),B(x)$为数列$a,b$的指数型生成函数，带入前文推导的式子，则得到上式的生成函数表达就是 $A(x)=B(e^x-1)$ 显然得到$B(x)=A(\\ln(x+1))$，而$\\ln(x+1)$显然转化为有标号的第一类斯特林数 因此得到斯特林反演的表达形式是 $\\begin{aligned}b_n=\\sum_{i=0}^{n}(-1)^{n-i}\\begin{bmatrix}n\\\\i\\end{bmatrix}a_i\\end{aligned}$ (不大可能搞类似多项式复合的方法处理这个反演吧，最多可能也就是求一个位置)","categories":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}]},{"title":"TopCoder - 12584 SRM 582 Div 1 SemiPerfectPower (莫比乌斯反演)","slug":"TopCoder - 12584 SRM 582 Div 1 SemiPerfectPower (莫比乌斯反演)","date":"2020-12-03T12:43:20.000Z","updated":"2021-05-22T03:54:11.000Z","comments":true,"path":"articles/2020/12/03/e82b2347.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/12/03/e82b2347.html","excerpt":"","text":"TopCoder - 12584 SRM 582 Div 1 SemiPerfectPower (莫比乌斯反演)题目大意：给定$L,R$，求$[L,R]$中能够表示为$a\\cdot b^c(1\\leq a1)$的数(SemiPerfect数)的个数 $R\\leq 8\\cdot 10^{16}$ 解题思路首先显然可以通过作差转化为求$[1,n]$内的个数 接下来考虑简化$c$的情形 推论：任何一个SemiPerfect数可以表示为$c\\leq 3$的形式 证明：若$c&gt;3$，对于$n=a\\cdot b^c(c&gt;3)$ 当$2|c$时，显然存在形如$n=a\\cdot (b^{\\frac{c} {2} })^{2}$的表示 当$2\\not |c$时，可以表示为$n=(a\\cdot c)\\cdot (b^{\\frac{c-1} {2} })^2$同样合法 接下来考虑对于两种情况分类讨论 为了便于叙述，令$F(n)=\\max \\lbrace k\\in \\N^+|\\ k^2|n\\rbrace$ $G(n)=[\\nexists k&gt;1,k^3|n]$ Part1 $c=2$为了避免重复，强制每一个数$n$的唯一表示为 $n=a\\cdot b^2(F(a)=1,a&lt;b)$ 由于$aa^3$，即$a&lt;n^{\\frac{1} {3} }$ 暴力枚举$a$，预处理$n^{\\frac{1} {3} }$中所有的$G(i)$即可 \\Part $c=3$同样的，限制条件为$n=a\\cdot b^3,(G(a)=1,a&lt;b)$，得到$a&lt;n^{\\frac{1} {4} }$ 但是由于$c=2,3$两部分有重复，还需额外考虑强制$n$不存在形如$n=a’\\cdot b’^2$的表示 假设已知$n=a\\cdot b^3$，不存在$n=a’\\cdot b’^2$的判定条件是 $a’=\\frac{n} {F^2(n)}\\ge F(n)$，即$F(n)\\leq n^{\\frac{1} {3} }$ 同时由于$F(n)=F(a\\cdot b)b$ 得到$F(a,b)\\leq a^{\\frac{1} {3} }$ 由于等号右边包含$a$，考虑枚举$a$，易求出$L=F(a),d=\\frac{a} {L^2}$，得到$F(a\\cdot b)$的另一种表达形式 $F(a\\cdot b)=L \\cdot \\gcd (d,b)\\cdot F(\\frac{b} {\\gcd(d,b)})\\leq a^{\\frac{1} {3} }$ 上面的转化意为：$L$为$a$中已经成对的部分自然取出，然后优先考虑为$D$匹配$b$中的因数成对，对于剩下的部分再重新计算答案 \\化简该式，得到$L\\cdot \\gcd(d,b)F(\\frac{b} {\\gcd(d,b)})\\leq a^{\\frac{1} {3} }$ 式子包含$\\gcd $，似乎具有莫比乌斯反演的性质 考虑计算$b\\in [a+1,(\\frac{n} {a})^{\\frac{1} {3} }]$的数量 观察到$a^{\\frac{1} {3} }\\leq n^{\\frac{1} {12} }$，上限只有$25$左右，可以考虑直接枚举$F(\\frac{b} {\\gcd(b,d)})$ 令枚举的$g=\\gcd(b,d),F(\\frac{b} {g})=f$，计算$\\gcd(\\frac{b} {g},\\frac{d} {g})=1,g\\cdot f\\cdot L\\leq a^{\\frac{1} {3} }$的$b$的数量 考虑直接从$\\frac{b} {g}$中把$f^2$的因数提取出来，令$\\begin{aligned} L'=\\lceil \\frac{a+1} {gf^2}\\rceil,R'=\\lfloor \\frac{(\\frac{n} {a})^{\\frac{1} {3} }} {gf^2}\\rfloor \\end{aligned}$，令$i=\\frac{b} {gf^2},x=\\frac{d} {g}$，得到新的限制条件式子为 $\\gcd(x,f)=1,\\gcd(i,x)=1,F(i)=1,i\\in[L’,R’]$ 在确定了$g,f$之后，需要考虑的限制就是$\\gcd(i,x)=1,F(i)=1,i\\in[L’,R’]$ 由于包含$\\gcd$，不妨用莫比乌斯反演计算该式，得到表达式为 $Sum=\\sum_{k|x}\\mu(k)\\sum_{i\\in [L’,R’]} [k|i\\ \\text{and}\\ F(i)=1]$ 对于$k$，计算$\\sum_{i\\in[L’,R’]}[k|i\\ \\text{and}\\ F(i)=1]$可以归纳为计算 $\\sum_{i=\\frac{n} {k} } [F(ik)=1]$，一共有$n^{\\frac{1} {3} }\\ln n$种不同的权值，可以暴力预处理得到 枚举$d$的因数对于所有的上面的式子计算，可能的$g,f$并不多，可以直接枚举 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)class SemiPerfectPower &#123;public: static const int N=450000,M=20000; int w[N],notpri[N],pri[N],pc,F[N],G[N]; vector &lt;int&gt; S[N],Fac[N]; ll gcd(ll a,ll b)&#123; return b==0?a:gcd(b,a%b); &#125; SemiPerfectPower()&#123; // 预处理F,G ,w[i]=\\mu(i) S[k][i]=\\sum_&#123;j \\in [1,i]&#125; F(i,k)=1 rep(i,1,sqrt(N)) rep(j,1,(N-1)/i/i) F[i*i*j]=i; rep(i,2,pow(N,1/3.0)) rep(j,1,(N-1)/i/i/i) G[i*i*i*j]=1; rep(i,1,M-1) for(int j=i;j&lt;M;j+=i) Fac[j].pb(i); w[1]=1; rep(i,2,N-1) &#123; if(!notpri[i]) pri[++pc]=i,w[i]=-1; for(int j=1;i*pri[j]&lt;N &amp;&amp; j&lt;=pc;++j) &#123; notpri[i*pri[j]]=1; if(i%pri[j]==0) &#123; w[i*pri[j]]=0; break; &#125; w[i*pri[j]]=-w[i]; &#125; &#125; rep(i,1,N-1) if(w[i]) &#123; S[i].resize(N/i+1); rep(j,1,(N-1)/i) S[i][j]=S[i][j-1]+(F[i*j]==1); &#125; &#125; ll Solve2(ll n)&#123; ll ans=0,UX=pow(n,1/3.0); // 防止浮点误差 if((UX+1)*(UX+1)*(UX+1)&lt;=n) UX++; if(UX*UX*UX&gt;n) UX--; rep(i,1,UX) if(F[i]==1) &#123; ll UY=sqrt(n/i); // 防止浮点误差 if(i*(UY+1)*(UY+1)&lt;=n) UY++; if(i*UY*UY&gt;n) UY--; ans+=max(0ll,UY-i); &#125; return ans; &#125; ll Solve3(ll n)&#123; ll UX=pow(n,0.25); // 枚举c的上界 ll ans=0; if((UX+1)*(UX+1)*(UX+1)*(UX+1)&lt;=n) UX++; rep(x,1,UX) if(!G[x]) &#123; ll UY=pow(n/x,1.0/3.0),U=pow(x,1/3.0); // 防止浮点误差 if((U+1)*(U+1)*(U+1)&lt;=x) U++; if(U*U*U&gt;x) U--; if(x*(UY+1)*(UY+1)*(UY+1)&lt;=n) UY++; if(x*UY*UY*UY&gt;n) UY--; int L=F[x],D=x/L/L; for(int G:Fac[D]) &#123; for(int g:Fac[G]) &#123; if(g*L&gt;U) break; rep(f,1,U/g/L) if(gcd(f,D/g)==1) &#123; int L=x/G/f/f,R=UY/G/f/f; ans+=w[G/g]*(S[G/g][R]-S[G/g][L]); &#125; &#125; &#125; &#125; return ans; &#125; ll Solve(ll n) &#123; return Solve2(n)+Solve3(n); &#125; ll count(ll L,ll R) &#123; return Solve(R)-Solve(L-1); &#125;&#125;;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"Montgomery Reduction 算法流程与实际实现","slug":"Montgomery Reduction 算法流程与实际实现","date":"2020-12-01T14:16:21.000Z","updated":"2021-05-22T03:54:10.980Z","comments":true,"path":"articles/2020/12/01/b1996e9.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/12/01/b1996e9.html","excerpt":"","text":"Montgomery Reduction 算法流程与实际实现下面默认对于模数$m$取模，由于这篇文章的重点是实现(其实就是我自己存一下板子)，因此没有证明 使用注意：Montgomery Reduction 相较于 Barret Reduction来说，不需要使用__int128 但是有着更高的封装程度，因为涉及到普通数与Montgomery Reduction运算中间量的转化 另外，常见的Montgomery Reduction 在编程竞赛中的应用 要求模数为奇数 但是在Min25博客上来看，Montgomery似乎有着更高的效率 Montgomery Reduction算法思想简介在计算取模运算的过程中，将每一个元素$T$都乘上一个特定的值$R(R&gt;m,\\gcd(R,m)=1)$ 用特殊的方法处理相乘时除掉一个$R$的过程，从而避免取模运算 在使用的模数为常量时，编译器通常会自动加入Barrett reduction的优化，因此实际上这个算法对于动态模数的情形更为适用 (你自己真不一定写得过STL，但是确实可以比STL块) \\编程上的应用简介对于$m$为奇数的情况，取$R=2^{32}$，用 自然溢出来代替取模/位运算位移代替除法 来加速运算 我们还需要令$m’ = -m^{-1} \\mod R$，有结论 对于某一个数$T,0 \\leq T &lt; mR$，若令$U = Tm’ \\mod R$，则 $\\frac{T+Um} {R}$为整数，且 $\\frac{T+Um} {R}=TR^{-1} \\mod m$ 那么我们在计算$\\frac{T} {R}$时，实际上只需要计算$\\frac{T+Um} {R}$，可以预处理$m’$，溢出计算$Tm’$，位运算左移计算$\\frac{T+Um} {R}$ 实际使用时的实现，可以用一个类实现以下方法 在实现时需要尤其注意不要出现溢出 1.预处理$m’$$(R-\\lfloor \\frac{R} {m}\\rfloor )\\cdot (R\\mod m)$ 12345678910using u32=unsigned;using i32=int;using u64=unsigned long long;using i64=long long;// inv=m&#x27;u32 m;u32 getinv()&#123; u32 inv=m; for(int i=0;i&lt;4;++i) inv*=2-inv*m;&#125; 2.reduce方法12345u32 reduce(u64 x) &#123; u32 y = u32(x &gt;&gt; 32) - u32((u64(u32(x)*inv)*m) &gt;&gt; 32); // 先取u32(x)得到x mod R ，然后再转成u64进行乘法 return i32(y) &lt; 0 ? y + m : y;&#125; 3.普通数转Montgomery Reduction我们要计算$x\\rightarrow xR=x\\cdot 2^{32}$，但是如果直接用取模就失去了意义。。。 方法是快速计算$x\\cdot R^2$，然后reduce一次 1234u32 R2=-u64(m)%m;u32 intToMont(i32 x)&#123; return reduce(u64(x)*R2);&#125; \\4.Montomery运算1234567891011u32 Add(u32 x,u32 y) &#123; x+=y-m; return i32(x&lt;0)?x+m:x;&#125;u32 Dec(u32 x,u32 y)&#123; x-=y; return i32(x&lt;0)?x+m:x;&#125;u32 Mul(u32 x,u32 y)&#123; return reduce(u64(x)*y);&#125; \\5.Montomery Reduction转普通数123i32 get(u32 x)&#123; return reduce(x);&#125; 封装之后，得到板子一号，这个是动态模数的。。。 实现上可能的误区： 为什么不用-inv?避免加法，原因是加法取模要和m比较 同样的，下面的i32(y)=m(负数溢出)，看似减少一次类型转换，但是实际上0作为常量比较快得多 加法运算时也是类似的原因，x&gt;=m的比较实在太慢，因此强制减去一个m，然后和0比 12345678910111213141516171819202122232425262728293031323334using u32=uint32_t;using i32=int32_t;using u64=uint64_t;using i64=int64_t;static u32 m,inv,r2,P;u32 getinv()&#123; u32 inv=m; for(int i=0;i&lt;4;++i) inv*=2-inv*m; return inv;&#125;struct Mont&#123;private : u32 x;public : static u32 reduce(u64 x)&#123; u32 y=u32(x&gt;&gt;32)-u32((u64(u32(x)*inv)*m)&gt;&gt;32); return i32(y)&lt;0?y+m:y; &#125; Mont()&#123; ; &#125; Mont(i32 x):x(reduce(u64(x)*r2)) &#123; &#125; Mont&amp; operator += (const Mont &amp;rhs) &#123; return x+=rhs.x-m,is32(x)&lt;0&amp;&amp;(x+=m),*this; &#125; Mont&amp; operator -= (const Mont &amp;rhs) &#123; return x-=rhs.x,i32(x)&lt;0&amp;&amp;(x+=m),*this; &#125; Mont&amp; operator *= (const Mont &amp;rhs) &#123; return x=reduce(u64(x)*rhs.x),*this; &#125; friend Mont operator + (Mont x,const Mont &amp;y) &#123; return x+=y; &#125; friend Mont operator - (Mont x,const Mont &amp;y) &#123; return x-=y; &#125; friend Mont operator * (Mont x,const Mont &amp;y) &#123; return x*=y; &#125; i32 get()&#123; return reduce(x); &#125;&#125;;void Init(int m) &#123; ::m=m; inv=-getinv(); r2=-u64(m)%m;&#125; 动态模数的方法，计算$5\\cdot 10^7!\\mod 998244353$在duck.ac上评测结果，时间单位是微秒$\\mu s$ 12Naive Mod : 213689172 Time: 518352My Montgomery : 213689172 Time: 192195 \\\\这个是我自己写的静态模数的，因为模数是静态的，所以不需要一定和0比较大小 1234567891011121314151617181920212223242526272829template &lt;uint32_t m&gt; struct Mont&#123;private : using u32=uint32_t; using i32=int32_t; using u64=uint64_t; using i64=int64_t; static constexpr u32 getinv()&#123; u32 inv=m; for(int i=0;i&lt;4;++i) inv*=2-inv*m; return inv; &#125; static constexpr u32 inv=-getinv(),r2=-u64(m)%m; u32 x;public : static constexpr u32 reduce(u64 x)&#123; u32 y=(x+u64(u32(x)*inv)*m)&gt;&gt;32; return y&gt;=m?y-m:y; &#125; Mont()&#123; ; &#125; constexpr Mont(i32 x):x(reduce(u64(x)*r2)) &#123; &#125; constexpr Mont&amp; operator += (const Mont &amp;rhs) &#123; return x+=rhs.x-m,x&gt;=m&amp;&amp;(x+=m),*this; &#125; constexpr Mont&amp; operator -= (const Mont &amp;rhs) &#123; return x-=rhs.x,x&gt;=m&amp;&amp;(x+=m),*this; &#125; constexpr Mont&amp; operator *= (const Mont &amp;rhs) &#123; return x=reduce(u64(x)*rhs.x),*this; &#125; constexpr friend Mont operator + (Mont x,const Mont &amp;y) &#123; return x+=y; &#125; constexpr friend Mont operator - (Mont x,const Mont &amp;y) &#123; return x-=y; &#125; constexpr friend Mont operator * (Mont x,const Mont &amp;y) &#123; return x*=y; &#125; constexpr i32 get()&#123; return reduce(x); &#125;&#125; ; 这个是摘自LOJ多项式乘法 hly1204的提交记录 个人解读：实际上每次存储的是$x \\mod 2m$的值，避免了reduce时的加减取模 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// from https://min-25.hatenablog.com/entry/2017/08/20/171214template &lt;std::uint32_t P&gt; struct MontgomeryModInt32 &#123;public: using i32 = std::int32_t; using u32 = std::uint32_t; using i64 = std::int64_t; using u64 = std::uint64_t;private: u32 v; static constexpr u32 get_r() &#123; u32 iv = P; for (u32 i = 0; i != 4; ++i) iv *= 2 - P * iv; return iv; &#125; static constexpr u32 r = -get_r(), r2 = -u64(P) % P; static_assert((P &amp; 1) == 1); static_assert(r * P == -1); static_assert(P &lt; (1 &lt;&lt; 30));public: static constexpr u32 pow_mod(u32 x, u64 y) &#123; if ((y %= P - 1) &lt; 0) y += P - 1; u32 res = 1; for (; y != 0; y &gt;&gt;= 1, x = u64(x) * x % P) if (y &amp; 1) res = u64(res) * x % P; return res; &#125; static constexpr u32 get_pr() &#123; u32 tmp[32] = &#123; &#125;, cnt = 0; const u64 phi = P - 1; u64 m = phi; for (u64 i = 2; i * i &lt;= m; ++i) &#123; if (m % i == 0) &#123; tmp[cnt++] = i; while (m % i == 0) m /= i; &#125; &#125; if (m &gt; 1) tmp[cnt++] = m; for (u64 res = 2; res &lt;= phi; ++res) &#123; bool flag = true; for (u32 i = 0; i != cnt &amp;&amp; flag; ++i) flag &amp;= pow_mod(res, phi / tmp[i]) != 1; if (flag) return res; &#125; return 0; &#125; MontgomeryModInt32() = default; ~MontgomeryModInt32() = default; constexpr MontgomeryModInt32(u32 v) : v(reduce(u64(v) * r2)) &#123; &#125; constexpr MontgomeryModInt32(const MontgomeryModInt32 &amp;rhs) : v(rhs.v) &#123; &#125; static constexpr u32 reduce(u64 x) &#123; return x + (u64(u32(x) * r) * P) &gt;&gt; 32; &#125; constexpr u32 get() const &#123; u32 res = reduce(v); return res - (P &amp; -(res &gt;= P)); &#125; explicit constexpr operator u32() const &#123; return get(); &#125; explicit constexpr operator i32() const &#123; return i32(get()); &#125; constexpr MontgomeryModInt32 &amp;operator=(const MontgomeryModInt32 &amp;rhs) &#123; return v = rhs.v, *this; &#125; constexpr MontgomeryModInt32 operator-() const &#123; MontgomeryModInt32 res; return res.v = (P &lt;&lt; 1 &amp; -(v != 0)) - v, res; &#125; constexpr MontgomeryModInt32 inv() const &#123; return pow(-1); &#125; constexpr MontgomeryModInt32 &amp;operator+=(const MontgomeryModInt32 &amp;rhs) &#123; return v += rhs.v - (P &lt;&lt; 1), v += P &lt;&lt; 1 &amp; -(i32(v) &lt; 0), *this; &#125; constexpr MontgomeryModInt32 &amp;operator-=(const MontgomeryModInt32 &amp;rhs) &#123; return v -= rhs.v, v += P &lt;&lt; 1 &amp; -(i32(v) &lt; 0), *this; &#125; constexpr MontgomeryModInt32 &amp;operator*=(const MontgomeryModInt32 &amp;rhs) &#123; return v = reduce(u64(v) * rhs.v), *this; &#125; constexpr MontgomeryModInt32 &amp;operator/=(const MontgomeryModInt32 &amp;rhs) &#123; return this-&gt;operator*=(rhs.inv()); &#125; friend MontgomeryModInt32 operator+(const MontgomeryModInt32 &amp;lhs, const MontgomeryModInt32 &amp;rhs) &#123; return MontgomeryModInt32(lhs) += rhs; &#125; friend MontgomeryModInt32 operator-(const MontgomeryModInt32 &amp;lhs, const MontgomeryModInt32 &amp;rhs) &#123; return MontgomeryModInt32(lhs) -= rhs; &#125; friend MontgomeryModInt32 operator*(const MontgomeryModInt32 &amp;lhs, const MontgomeryModInt32 &amp;rhs) &#123; return MontgomeryModInt32(lhs) *= rhs; &#125; friend MontgomeryModInt32 operator/(const MontgomeryModInt32 &amp;lhs, const MontgomeryModInt32 &amp;rhs) &#123; return MontgomeryModInt32(lhs) /= rhs; &#125; friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, MontgomeryModInt32 &amp;rhs) &#123; return is &gt;&gt; rhs.v, rhs.v = reduce(u64(rhs.v) * r2), is; &#125; friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const MontgomeryModInt32 &amp;rhs) &#123; return os &lt;&lt; rhs.get(); &#125; constexpr MontgomeryModInt32 pow(i64 y) const &#123; if ((y %= P - 1) &lt; 0) y += P - 1; // phi(P) = P - 1, assume P is a prime number MontgomeryModInt32 res(1), x(*this); for (; y != 0; y &gt;&gt;= 1, x *= x) if (y &amp; 1) res *= x; return res; &#125;&#125;; 这个是计算$5\\cdot 10^7!\\mod 998244353$在duck.ac上的测试结果 123Naive Mod : 213689172 Time: 180649My Montgomery : 213689172 Time: 178217His Montgomery : 213689172 Time: 152847 这个是计算$7\\cdot 10^7!\\mod 998244353$在duck.ac上的测试结果 123Naive Mod : 939830261 Time: 252908My Montgomery : 939830261 Time: 249476His Montgomery : 939830261 Time: 213986 还可以看Min25博客里下面的ModInt64板本 传送门 下面自己实现的$\\mod 2m$版本，差不多也是最终版本了，跑起来和hly1204差不多 静态版本 12345678910111213141516171819202122232425262728293031template &lt;uint32_t m&gt; struct Mont2&#123;private : using u32=uint32_t; using i32=int32_t; using u64=uint64_t; using i64=int64_t; static constexpr u32 m2=m&lt;&lt;1; static constexpr u32 getinv()&#123; u32 inv=m; for(int i=0;i&lt;4;++i) inv*=2-inv*m; return inv; &#125; static constexpr u32 inv=-getinv(),r2=-u64(m)%m; u32 x;public : static constexpr u32 reduce(u64 x)&#123; return (x+u64(u32(x)*inv)*m)&gt;&gt;32; &#125; Mont2()&#123; ; &#125; constexpr Mont2(i32 x):x(reduce(u64(x)*r2)) &#123; &#125; constexpr Mont2&amp; operator += (const Mont2 &amp;rhs) &#123; return x+=rhs.x-m2,x&gt;=m2&amp;&amp;(x+=m2),*this; &#125; constexpr Mont2&amp; operator -= (const Mont2 &amp;rhs) &#123; return x-=rhs.x,x&gt;=m2&amp;&amp;(x+=m2),*this; &#125; constexpr Mont2&amp; operator *= (const Mont2 &amp;rhs) &#123; return x=reduce(u64(x)*rhs.x),*this; &#125; constexpr friend Mont2 operator + (Mont2 x,const Mont2 &amp;y) &#123; return x+=y; &#125; constexpr friend Mont2 operator - (Mont2 x,const Mont2 &amp;y) &#123; return x-=y; &#125; constexpr friend Mont2 operator * (Mont2 x,const Mont2 &amp;y) &#123; return x*=y; &#125; constexpr i32 get()&#123; u32 res=reduce(x); return res&gt;=m?res-m:res; &#125;&#125; ; 板子各有优劣.jpg 另外这是Int_To_Montgomery加法的速度,$7\\cdot 10^7$次加法与类型转换 1234Naive : : 305907824 80074My Montgomery : 305907824 109479My Montgomery2 : 305907824 99896His Montgomery : 305907824 117449 动态版本 12345678910111213141516171819202122232425262728293031323334353637using u32=uint32_t;using i32=int32_t;using u64=uint64_t;using i64=int64_t;static u32 m,m2,inv,r2,P;u32 getinv()&#123; u32 inv=m; for(int i=0;i&lt;4;++i) inv*=2-inv*m; return inv;&#125;struct Mont&#123;private : u32 x;public : static u32 reduce(u64 x)&#123; u32 y=(x+u64(u32(x)*inv)*m)&gt;&gt;32; return i32(y)&lt;0?y+m:y; &#125; Mont()&#123; ; &#125; Mont(i32 x):x(reduce(u64(x)*r2)) &#123; &#125; Mont&amp; operator += (const Mont &amp;rhs) &#123; return x+=rhs.x-m2,i32(x)&lt;0&amp;&amp;(x+=m2),*this; &#125; Mont&amp; operator -= (const Mont &amp;rhs) &#123; return x-=rhs.x,i32(x)&lt;0&amp;&amp;(x+=m2),*this; &#125; Mont&amp; operator *= (const Mont &amp;rhs) &#123; return x=reduce(u64(x)*rhs.x),*this; &#125; friend Mont operator + (Mont x,const Mont &amp;y) &#123; return x+=y; &#125; friend Mont operator - (Mont x,const Mont &amp;y) &#123; return x-=y; &#125; friend Mont operator * (Mont x,const Mont &amp;y) &#123; return x*=y; &#125; i32 get()&#123; u32 res=reduce(x); return res&gt;=m?res-m:res; &#125;&#125;;void Init(int m) &#123; ::m=m,m2=m*2; inv=-getinv(); r2=-u64(m)%m;&#125; 这个动态模板计算$5\\cdot 10^7!\\mod 998244353$ 12Naive Mod : 213689172 494061 (稍微修改了一下暴力的细节。。)My Montgomery2 : 213689172 152849 不得不说duck.ac真的很nb","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「2020联考北附1」命运歧途              ","slug":"「2020联考北附1」命运歧途              ","date":"2020-11-30T12:58:13.000Z","updated":"2021-05-22T03:54:11.129Z","comments":true,"path":"articles/2020/11/30/d57162be.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/30/d57162be.html","excerpt":"","text":"「2020联考北附1」命运歧途排列$dp$问题通常想到容斥，因为很难在$dp$的同时保证排列元素不多次出现 对于这个问题，我们只需要考虑相邻关系 我们需要计算包含0个非法位置的排列个数，因此容斥容易定义为计算 包含至少$i$个非法位置的排列个数，容斥系数可以简单设置为$(-1)^i$ 考虑一个序列的合法与非法情况，容易发现是类似下面的情况 序列会被分成若干段，每一段是形如$x,x+k,x+2k,\\cdots$或者$x,x-k,x-2k$ 显然$x,y$会产生非法关系的必要条件是$x\\equiv t \\pmod k$，因此按照$x\\mod k$分组 组内实际上是类似$k=1$的子问题，不妨设一组包含$m$个元素 显然不同组之间一定构成不同的段，而对于一组内的元素，我们可以强制某一些位置分段 最终会得到一个若干段的序列，段之间由于不确定相互关系，设最终分成$i$段，则可以有$i!$种段之间排列 (分成$i$段的贡献在我们计算时实际上是至少包含了$n-i$个非法位置) 现在问题就是落到了$dp$序列分成$i$段的方案数，显然对于每一组，是一个分组背包的问题 对于每一个大小为$m$的组，考虑$dp$其分段方案 令$dp_{i,j}$表示当前已经确定的总大小为$i$且已经分成了$j$段 转移可以枚举下一段的大小$k$，由于实际排列中的段是有递增和递减两种情况，因此对于任意$k&gt;1$，有两种段分配方法 转移式子是 $dp_{i,j}\\rightarrow dp_{i+k,j+1} (k=1)$ $2dp_{i,j}\\rightarrow dp_{i+k,j+1} (k&gt;1)$ 这个式子容易用前缀和优化，特殊的转移位置只有一个，处理一下即可 于是可以在$O(n^2)$复杂度内计算任何一个大小的组的分段方案 暴力合并组之间的背包，对于每个查询，复杂度为$O(n^2)$ 因此总复杂度受限于查询，为$O(qn^2)$ 接下来考虑如何削减查询复杂度 由于$q$的上限实际是$n$，下文认为$q=n$ 优化1上面的问题中，我们并没有具体地分析分组的情况 实际上对于$n,k$，可能的组大小只有两种，即$\\lfloor \\frac{n} {k}\\rfloor ,\\lceil \\frac{n} {k}\\rceil$ 不同的$\\lfloor \\frac{n} {k}\\rfloor $只有$O(\\sqrt n)$种，不妨对于每种$\\lfloor \\frac{n} {k}\\rfloor $从小到大计算每一个$k$的答案 简单观察即可发现： 在每个块内，按照$k$递增，两种组的个数一个递增一个递减 如果在每个$\\lfloor \\frac{n} {k}\\rfloor $中，为最小的$k$暴力$O(n^2)$预处理出答案，然后不断增大 不妨维护两个单调的个数指针 如果能够支持背包回撤一个分组，增加一个分组，那么容易做到每个块内$O(n^2)$递推答案 增加一个分组不必说，而对于去掉一个分组，不好求出模逆元 但是由于上面的$dp_{i,j}$满足$dp_{i,i}=1$，因此考虑从高到低递推每一位 模拟一个长除法即可 合理的常数优化也可以通过此题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const int N=2010;int n,m,P;int C[N][N],J[N];int dp[N][N],S[N],F[N],G[N];int len;int pl=-1,nc1,nc2;void clear() &#123; rep(i,0,len) F[i]=0; F[len=0]=1,nc1=nc2=0; &#125;int cnt=0;void Mul(int m,int *A)&#123; drep(i,len+=m,0) &#123; ull t=0; rep(j,1,min(i,m)) &#123; t+=1ll*F[i-j]*A[j]; ((j&amp;15)==0) &amp;&amp; (t%=P); &#125; F[i]=t%P; &#125;&#125;void Div(int m,int *A)&#123; static int G[N]; rep(i,0,len) G[i]=F[i],F[i]=0; drep(i,len-=m,0) &#123; ull t=G[i+m]; rep(j,1,m) &#123; t+=1ll*F[i+j]*(P-A[m-j]); ((j&amp;15)==0) &amp;&amp; (t%=P); &#125; F[i]=t%P; &#125;&#125;int Ans[N],Pow1[N],Pow2[N];int clr;void Solve(int m) &#123; int l=(n-1)/m+1,c1=0,c2=0; rep(i,1,m) if((n-i)/m+1==l) c1++; else c2++; if(l==2) &#123; rep(i,0,c1+c2) F[i]=0; rep(i,0,n-c1-c2) F[i+c1+c2]=1ll*C[c1][i]*Pow1[c1-i]%P*Pow2[i]%P; int x=1; rep(i,1,c2) x=1ll*x*dp[1][1]%P; rep(i,c1+c2,n) F[i]=1ll*F[i]*x%P; &#125; else &#123; if(l!=pl) &#123; clr++; clear(); pl=l; &#125; cnt++; while(c1&lt;nc1) Div(l,dp[l]),nc1--; while(c2&lt;nc2) Div(l-1,dp[l-1]),nc2--; while(c1&gt;nc1) Mul(l,dp[l]),nc1++; while(c2&gt;nc2) Mul(l-1,dp[l-1]),nc2++; &#125; rep(i,0,n) G[n-i]=1ll*F[i]*J[i]%P; int ans=0; rep(i,0,n) ans=(ans+1ll*((i&amp;1)?-1:1)*G[i])%P; ans=(ans%P+P)%P; Ans[m]=ans;&#125;int main() &#123; freopen(&quot;fate.in&quot;,&quot;r&quot;,stdin),freopen(&quot;fate.out&quot;,&quot;w&quot;,stdout); n=rd(),m=rd(),P=rd(); rep(i,0,n) rep(j,C[i][0]=1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P; rep(i,J[0]=1,n) J[i]=1ll*J[i-1]*i%P; dp[0][0]=S[0]=1; rep(i,1,n) &#123; drep(j,i,1) &#123; dp[i][j]=(2ll*S[j-1]+P-dp[i-1][j-1])%P; S[j]+=dp[i][j],Mod1(S[j]); &#125; &#125; rep(i,Pow1[0]=1,n) Pow1[i]=1ll*Pow1[i-1]*dp[2][1]%P; rep(i,Pow2[0]=1,n) Pow2[i]=1ll*Pow2[i-1]*dp[2][2]%P; rep(i,1,n-1) Solve(i); Ans[n]=J[n]; fprintf(stderr,&quot;%d %d\\n&quot;,cnt,clr); rep(i,1,m) printf(&quot;%d\\n&quot;,Ans[rd()]);&#125; \\优化2从生成函数的角度，我们容易把所求的值归纳为 $H(x)=F^a(x)G^b(x)$ 我们知道多项式快速幂的复杂度为$\\exp$的$n\\log n$ 当然那是对于长度为$n$的情况 而现在是长度之和为$n$ 由于EI在无数道题中介绍了这个东西，看到马上想到可以求导 $H’(x)=aF^{a-1}(x)F’(x)G(x)+bG^{b-1}(x)G’(x)F(x)$ $H’=H(a\\cdot \\frac{F’} {F}+b\\cdot \\frac{G’} {G})$ 理想的情况是：对于这个式子，两边从低到高解方程确定每一项的值 然而首先遇到的多项式除法操作就难以解决 要除掉的$F,G$没有常数项，而第一项系数为1或2，因此除法操作只需要计算$2$的逆元 因此可以考虑对于模数中的$2^t$提取出来，然后最后暴力exCRT合并 接下来就是分成两部分 计算$\\mod 2^t$由上面知道，背包的每一个位置实际对于最后答案的贡献是$i!(-1)^{n-i}$ 因此对于$i!\\mod 2^t=0$的位置都不用考虑，只需要求出背包前$O(\\log P)$位，暴力即可 \\计算$\\mod P(2\\not |P)$接下来就是上面的递推过程 然而还有一个问题就是从$[x^n]H’$得到$[x^{n+1}]H$，显然这里需要一个逆元 EI为我们提供一个很好的思路，或许有助于解决任意模数的逆元问题： 因为答案计算的是$k![x^k]H$，因此可以直接在计算过程中加入 这样求导的系数在阶乘中被省略，变成了单纯的平移 而乘法只需要额外添加一个权值$\\binom{i+j} {i}\\cdot x^i\\cdot x^j\\rightarrow x^{i+j}$ 接下来具体的方法是： 先将$F(x),G(x)$平移一位去掉空余的项，处理过后$H(x)$被平移了$a+b$的位置，首项为$x^0$ 从低到高递推$H(x)$的每一位，同步维护$ \\frac{H} {F},\\frac{H} {G}$ 对于$H’(x)$的第$i$项累和得到，然后平移一位得到$H(x)$的$i+1$项 最后需要加上平移部分的贡献，$i!\\rightarrow (i+a+b)!$，可以用一个组合数解决 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146const int N=2010;int n,m,P;int J[N];int dp[N][N],S[N],F[N],G[N];struct Solve2t&#123; int F[N],P,U; void Init(int x) &#123; P=x; int t=1; rep(i,1,n) &#123; t=1ll*t*i%P; if(t==0) break; U=i; &#125; &#125; int Solve(int m) &#123; rep(i,0,U) F[i]=0; F[0]=1; rep(x,1,m) &#123; int c=(n-x)/m+1; rep(i,0,U) G[i]=F[i],F[i]=0; rep(i,0,U) if(G[i]) rep(j,1,min(c,U)) F[i+j]=(F[i+j]+1ll*G[i]*dp[c][j])%P; &#125; int ans=0; rep(i,1,U) &#123; F[i]=1ll*F[i]*J[i]%P; ans=(ans+(((n-i)&amp;1)?-1:1)*F[i])%P; &#125; ans=(ans%P+P)%P; return ans; &#125;&#125; Sol1;void Exgcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; if(b==0) &#123; x=1,y=0; return; &#125; Exgcd(b,a%b,y,x),y-=a/b*x;&#125;ll Inv(int a,int P) &#123; ll x,y; Exgcd(a,P,x,y); return (x%P+P)%P;&#125;struct SolveP&#123; int C[N][N]; int F[N],G[N]; int A[N],B[N]; int X[N],Y[N]; int P,I2; void Init(int x) &#123; P=x; rep(i,0,n) rep(j,C[i][0]=1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P; I2=(P+1)/2; &#125; int Solve(int m) &#123; if(P==1) return 0; int l1=(n-1)/m+1,l2=l1-1; int c1=0,c2=0; rep(i,1,m) if((n-i)/m+1==l1) c1++; else c2++; int Inv=dp[l1][1]==1?1:I2; rep(i,1,l1) A[i-1]=1ll*J[i-1]*dp[l1][i]%P*Inv%P; Inv=dp[l2][1]==1?1:I2; rep(i,1,l2) B[i-1]=1ll*J[i-1]*dp[l2][i]%P*Inv%P; // 将A,B偏移补充常数项 // 同时除掉常数项，为下面做除法铺路 int d=c1+c2; // A,B存储偏移之后的值，d为偏移量 // X,Y存储除法之后的值 F[0]=X[0]=Y[0]=1; rep(i,1,n-d) &#123; ull x=0,y=0; // 注意这里计算的是两边次数为x^&#123;i-1&#125;一项的值 rep(j,1,min(l1-1,i)) &#123; // 将除法的结果乘上求导以后的值，注意求导以后第一位消失了 x+=1ll*X[i-j]*A[j]%P*C[i-1][j-1]; (j&amp;15)==0 &amp;&amp; (x%=P); // 求导以后是j-1位，因此实际应该是x^&#123;i-j&#125;*x^&#123;j-1&#125; &#125; rep(j,1,min(l2-1,i)) &#123; y+=1ll*Y[i-j]*B[j]%P*C[i-1][j-1]; (j&amp;15)==0 &amp;&amp; (y%=P); &#125; // 由[x^&#123;i-1&#125;]H&#x27;(x)一项得到[x^i]H(x) F[i]=X[i]=Y[i]=(x%P*c1+y%P*c2)%P; // 接下来做二项除法(雾) x=0,y=0; rep(j,1,min(i,l1-1)) &#123; x+=1ll*(P-A[j])*X[i-j]%P*C[i][j]; (j&amp;15)==0 &amp;&amp; (x%=P); &#125; rep(j,1,min(i,l2-1)) &#123; y+=1ll*(P-B[j])*Y[i-j]%P*C[i][j]; (j&amp;15)==0 &amp;&amp; (y%=P); &#125; X[i]=(X[i]+x)%P,Y[i]=(Y[i]+y)%P; &#125; int ans=0; rep(i,0,n-d) &#123; F[i]=1ll*F[i]*C[i+d][d]%P*J[d]%P; ans=(ans+(((n-i-d)&amp;1)?-1:1)*F[i])%P; &#125; // 将除掉的系数乘回来 rep(i,1,c1) ans=1ll*ans*dp[l1][1]%P; rep(i,1,c2) ans=1ll*ans*dp[l2][1]%P; ans=(ans%P+P)%P; return ans; &#125;&#125; Sol2;int t;void Init() &#123; t=1; for(t=1;P%2==0;) t*=2,P/=2; Sol1.Init(t),Sol2.Init(P);&#125;void Solve(int m) &#123; int x=Sol1.Solve(m),y=Sol2.Solve(m); // CRT ll res=1ll*((y-x)%P+P)*Inv(t,P)%P; ll mod=t*P; res=((res*t+x)%mod+mod)%mod; printf(&quot;%lld\\n&quot;,res);&#125;int main() &#123; freopen(&quot;fate.in&quot;,&quot;r&quot;,stdin),freopen(&quot;fate.out&quot;,&quot;w&quot;,stdout); n=rd(),m=rd(),P=rd(); rep(i,J[0]=1,n) J[i]=1ll*J[i-1]*i%P; dp[0][0]=S[0]=1; rep(i,1,n) &#123; drep(j,i,1) &#123; dp[i][j]=(S[j-1]*2ll+P-dp[i-1][j-1])%P; S[j]+=dp[i][j],Mod1(S[j]); &#125; &#125; Init(); rep(i,1,m) Solve(rd());&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「CodePlus 2017 11 月赛」Yazid 的新生舞会              ","slug":"「CodePlus 2017 11 月赛」Yazid 的新生舞会              ","date":"2020-11-29T11:52:12.000Z","updated":"2021-05-22T03:54:11.176Z","comments":true,"path":"articles/2020/11/29/172f5601.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/29/172f5601.html","excerpt":"","text":"「CodePlus 2017 11 月赛」Yazid 的新生舞会最基本的分析这里只保留：$cnt&gt;\\frac{len} {2}\\Rightarrow 2cnt&gt;len$ 对于每一个合法的区间，合法的众数显然只有一个 考虑对于每一个众数计算答案，把$x$出现的位置拿出来成一个序列$A_i$ 如果选择的区间恰好包含$A_i,A_{i+1},\\cdots ,A_j$，那么合法的情况就是$2(j-i+1)&gt;R-L+1,L\\in[A_{i-1}+1,A_i],R\\in[A_{j},A_{j},A_{j+1}-1]$ 参数分离得到$2j-R&gt;2i-L$ 如果对于每一个$L$更新答案，那么更新的是一段区间，不妨设其为$UL,UR$ 对于每个$R$查询则是一段前缀 和 的区间 我们知道树状数组维护区间修改区间查询需要做一次差分，而这次是区间前缀和 也就是说是再高一维。。 不妨在$UL$上加,$UR$上减，那么在$p$处的更新对于在$k$处的查询的贡献是 $\\cfrac{(k-p+1)(k-p+2)} {2}=\\cfrac{k^2+p^2-2pk+3k-3p+2} {2}$ 那么直接处理这个式子即可，需要维护$updval,p\\cdot updval,p^2\\cdot updval$ 查询时加入$k$的贡献 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;using ll=long long;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)int rd()&#123; int s=0; char c; while(c=getchar(),c&lt;48); do s=s*10+c-&#x27;0&#x27;; while(c=getchar(),c&gt;47); return s;&#125;enum&#123;N=1000010&#125;;int n;vector &lt;int&gt; A[N];ll ans,s1[N],s2[N],s3[N];void Add(int p,ll x) &#123; p--; ll a=x,b=x*p,c=x*p*p; for(p+=n+1;p&lt;=n*2;p+=p&amp;-p) s1[p]+=a,s2[p]+=b,s3[p]+=c;&#125;void Add(int l,int r,int x) &#123; Add(l,x),Add(r+1,-x); &#125;ll Que(int p) &#123; ll r1=0,r2=0,r3=0,tp=p; for(p+=n;p;p-=p&amp;-p) r1+=s1[p],r2+=s2[p],r3+=s3[p]; return ((tp*tp+tp)*r1-(2*tp+1)*r2+r3)/2;&#125;ll Que(int l,int r) &#123; return Que(r)-Que(l-1); &#125;int main()&#123; freopen(&quot;party.in&quot;,&quot;r&quot;,stdin),n=rd(),rd(); rep(i,1,n) A[rd()].push_back(i); rep(k,0,n-1) if(A[k].size()) &#123; rep(i,0,A[k].size()-1) &#123; int p=A[k][i],l=i?A[k][i-1]:0,r=i&lt;(int)A[k].size()-1?A[k][i+1]:n+1; Add(2*i-p+1,2*i-l,1); ans+=Que(2*(i+1)-r,2*(i+1)-p-1); &#125; rep(i,0,A[k].size()-1) &#123; int p=A[k][i],l=i?A[k][i-1]:0; Add(2*i-p+1,2*i-l,-1); &#125; &#125; fprintf(fopen(&quot;party.out&quot;,&quot;w&quot;),&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"TopCoder - 12349 SRM579 Round1 Div1 RockPaperScissors (概率Dp)","slug":"TopCoder - 12349 SRM579 Round1 Div1 RockPaperScissors (概率dp)","date":"2020-11-29T08:44:07.000Z","updated":"2021-05-22T03:54:10.997Z","comments":true,"path":"articles/2020/11/29/4eb1c588.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/29/4eb1c588.html","excerpt":"","text":"TopCoder - 12349 SRM579 Round1 Div1 RockPaperScissors (概率dp)题目大意：有$n$个骰子，每个骰子有300个面，其中有$a_i,b_i,c_i$分别为石头/布/剪刀 每轮你选择出石头/剪刀/布，然后会从剩下的骰子中随机取一个再随机结果，但是你不知道取的是什么骰子 赢一局的权值为3，平局为1 求最优情况下最大的权值期望 \\题目分析：显然当前的局面只和已经抽出的石头/布/剪刀的数量有关（因为这是你唯一的决策依据，也是唯一影响局面的） 乍一看非常抽象的决策过程，实在无法通过分析得到每一种局面下应该作出的决策 于是考虑能否直接把每一种局面出现的概率求出，决策后将期望线性相加 不妨把随机取出的骰子放在一个序列上，一个局面是由已经出现的骰子和当前第$i$次决策的骰子组成的 令$dp_{i,j,k,typ}$表示已经出现的骰子中出现$i,j,k$个石头/布/剪刀，当前决策时骰子结果为$typ$的概率 实际在$dp$时，$typ$一维需要额外加入一个值表示未确定下一个是什么 考虑对于每个骰子，枚举它是已经出现/正在决策/在第$i$次决策之后出现，将其概率累和 $dp$状态为$O(n^3)$，转移次数为$O(n)$,复杂度为$O(n^4)$ 最后对于每种局面计算最优的决策即可 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;class RockPaperScissors &#123;private: static const int N=53; static const int eps=1e-9; double F[N][N][N][4],G[N][N][N][4],w[3]; double C[N][N];public: double bestScore(vector &lt;int&gt; w1, vector &lt;int&gt; w2, vector &lt;int&gt; w3) &#123; int n=w1.size(); rep(i,0,n) rep(j,C[i][0]=1,i) C[i][j]=C[i-1][j-1]+C[i-1][j]; memset(F,0,sizeof F),F[0][0][0][3]=1; rep(i,1,n) &#123; w[0]=w1[i-1]/300.0; w[1]=w2[i-1]/300.0; w[2]=w3[i-1]/300.0; rep(a,0,i) rep(b,0,i-a) rep(c,0,i-a-b) rep(d,0,3) G[a][b][c][d]=F[a][b][c][d]; rep(a,0,i) rep(b,0,i-a) rep(c,0,i-a-b) rep(d,0,3) if(G[a][b][c][d]&gt;eps) &#123; // 枚举这个骰子在之前出现过了 F[a+1][b][c][d]+=G[a][b][c][d]*w[0]; F[a][b+1][c][d]+=G[a][b][c][d]*w[1]; F[a][b][c+1][d]+=G[a][b][c][d]*w[2]; // 枚举这个骰子为下一个出现的 if(d==3) rep(e,0,2) F[a][b][c][e]+=G[a][b][c][d]*w[e]; &#125; &#125; double ans=0; rep(a,0,n-1) rep(b,0,n-1-a) rep(c,0,n-1-a-b) &#123; // 决策这一轮出什么 double ma=0; rep(d,0,2) cmax(ma,F[a][b][c][d]+F[a][b][c][(d+2)%3]*3); ans+=ma/C[n][a+b+c]/(n-a-b-c); &#125; return ans; &#125;&#125;;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「JOI 2018 Final」毒蛇越狱                    ","slug":"「JOI 2018 Final」毒蛇越狱                    ","date":"2020-11-28T06:54:00.000Z","updated":"2021-05-22T03:54:11.195Z","comments":true,"path":"articles/2020/11/28/6179e8c.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/28/6179e8c.html","excerpt":"","text":"「JOI 2018 Final」毒蛇越狱Algorithm 1: 暴力计算对于所有$0,1,?$组成的$3^n$种串处理出答案 具体的，对于当前串包含的最后一个$?$位置，枚举它变成0/1的答案，按照一定的顺序累和即可 (代码可以在Algo2里面看到) Algorithm 2 : Meet in the Middle$3^{20}$太大，优化上面的暴力，容易想到把复杂度从预处理分一部分给查询 取出$n$中前$k$个位置，这些位置不处理$3^k$，而是让每个询问暴力地去枚举这些位置上的$?$变成$0/1$ 显然每个询问有最多$2^k$次枚举，即复杂度为$O(Q\\cdot 2^k)$ 对于剩下的$n-k$个位置，采取上面的暴力方法预处理，三进制枚举，预处理复杂度为$O(2^k3^{n-k})$ 因此复杂度为$O(Q\\cdot 2^k +2^k3^{n-k})$，计算在$k=6,7$时复杂度约为$3.5\\cdot 10^8$ (这是一个非常稳的复杂度) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;ll rd()&#123; ll s=0,f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=20,M=1&lt;&lt;20,M3=1600000;const int DM=7;int n,m,k;int Pow[N],S[M3],Low[M3],trans[M3];int QX[M],QY[M],QZ[M],Ans[M],rev[M];char val[M],q[N];int main() &#123; rep(i,Pow[0]=1,N-1) Pow[i]=Pow[i-1]*3; n=rd(),m=rd(),k=min(DM,n),scanf(&quot;%s&quot;,val); rep(i,1,(1&lt;&lt;n)-1) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(n-1)); if(i&lt;rev[i]) swap(val[i],val[rev[i]]); &#125; Low[0]=1e9; rep(i,1,Pow[n-k]-1) &#123; Low[i]=(i%3==2)?0:Low[i/3]+1; if(Low[i]&gt;n) trans[i]=(trans[i/3]&lt;&lt;1)|(i%3); &#125; rep(i,1,m) &#123; scanf(&quot;%s&quot;,q); rep(j,0,n-1) &#123; if(q[j]==&#x27;?&#x27;) QY[i]|=1&lt;&lt;j,q[j]=&#x27;2&#x27;; else QX[i]|=(q[j]-&#x27;0&#x27;)&lt;&lt;j; &#125; rep(j,k,n-1) QZ[i]+=Pow[j-k]*(q[j]-&#x27;0&#x27;); &#125; int A=(1&lt;&lt;k)-1; rep(i,0,A) &#123; rep(j,0,Pow[n-k]-1) &#123; if(Low[j]&gt;n) S[j]=val[(trans[j]&lt;&lt;k)|i]-&#x27;0&#x27;; else S[j]=S[j-Pow[Low[j]]]+S[j-2*Pow[Low[j]]]; &#125; // 暴力预处理前缀和 rep(j,1,m) if((QX[j]&amp;A)==(i&amp;~QY[j])) Ans[j]+=S[QZ[j]]; &#125; rep(i,1,m) printf(&quot;%d\\n&quot;,Ans[i]);&#125; Algorithm 3 : 高位前缀和+容斥起始学过高位前缀和/FMT的看到这个题第一反应可能都是这个。。 -&gt; 对于$?$的位置，直接赋值成1，然后对于这个数从高位前缀和里查询 然后你发现不知道怎么对于1的把0的去掉 显然这个可以通过一个暴力的容斥来完成，枚举一些1的位置变成0，然后就是容斥的奇数减偶数加 复杂度为$O(Q\\cdot 2^{1的个数}\\ \\ \\ \\ \\ )$ 同理，处理高位后缀和，复杂度为$\\begin{aligned}O(Q\\cdot 2^{0的个数}\\ \\ \\ \\ )\\end{aligned}$ 而直接暴力枚举$?$变成0/1，复杂度为$\\begin{aligned}O(Q\\cdot 2^{?的个数}\\ \\ \\ \\ \\ )\\end{aligned}$ 综合这三种算法，选一个更优的做，就得到一个复杂度为 $\\begin{aligned}O(Q \\ \\cdot 2^{ \\begin{aligned}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\min\\lbrace 1的个数,0的个数,?的个数\\rbrace\\end{aligned} })\\ \\ \\ \\ \\ \\ \\end{aligned}$ 显然查询复杂度就是$O(Q\\cdot 2^{\\lfloor \\frac{n} {3}\\rfloor }=Q\\cdot 2^6)$ 算上预处理，复杂度为$O(2^nn+Q\\cdot 2^6)$ 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;enum&#123;N=1&lt;&lt;20&#125;;int n,k,m,A[N],B[N],C[N],P[N];// A 高位前缀和// B 高位后缀和// C 点值(打扰了)// P __builtin_paritychar val[N],q[21];int main() &#123; scanf(&quot;%d%d%s&quot;,&amp;n,&amp;m,val),k=1&lt;&lt;n; for(int i=0;i&lt;k;++i) A[i]=B[i]=C[i]=val[i]-&#x27;0&#x27;,P[i]=P[i&gt;&gt;1]^(i&amp;1); for(int i=1;i&lt;k;i&lt;&lt;=1) for(int l=0;l&lt;k;l+=i*2) for(int j=l;j&lt;l+i;++j) A[j+i]+=A[j],B[j]+=B[j+i]; //预处理高位前缀和，高位后缀和 while(m--) &#123; int x=0,y=0,a=0,b=0,ans=0; for(int i=scanf(&quot;%s&quot;,q+1);i&lt;=n;++i) &#123; if(q[i]==&#x27;?&#x27;) x|=1&lt;&lt;(n-i),a++; if(q[i]==&#x27;1&#x27;) y|=1&lt;&lt;(n-i),b++; &#125; if(a&lt;=n/3) for(int S=x;~S;S=S?(S-1)&amp;x:-1) ans+=C[y|S]; // 枚举?变成0/1 else if(b&lt;=n/3) for(int S=y;~S;S=S?(S-1)&amp;y:-1) ans+=P[S^y]?-A[S|x]:A[S|x]; // 对于高位前缀和容斥 else for(int S=x=(k-1)^x^y;~S;S=S?(S-1)&amp;x:-1) ans+=P[S]?-B[S|y]:B[S|y]; // 对于高位后缀和容斥 printf(&quot;%d\\n&quot;,ans); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"JOI","slug":"JOI","permalink":"http://chasingdeath.github.io/tags/JOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"伯努利数","slug":"伯努利数","date":"2020-11-27T14:19:36.000Z","updated":"2021-05-22T03:54:11.330Z","comments":true,"path":"articles/2020/11/27/f141d45a.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/27/f141d45a.html","excerpt":"","text":"伯努利数","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"矩阵行列式","slug":"矩阵行列式","date":"2020-11-27T14:02:32.000Z","updated":"2021-05-22T03:54:11.397Z","comments":true,"path":"articles/2020/11/27/6ce15294.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/27/6ce15294.html","excerpt":"","text":"矩阵行列式对于一个$n$行$n$列的矩阵$A$，有矩阵的行列式(常用$\\det(A),|A|$)表示 行列式的意义如果将矩阵的每一行视为一个$n$维向量，则$n$阶行列式的意义可以看做是: 有向长度/面积/体积在$n$为空间下的扩展 具体的例子 $n=1$时，$|A|=A_{1,1}$，即有向长度 $n=2$时，$|A|=A_{1,1}A_{2,2}-A_{1,2}A_{2,1}=\\vec{A_1}\\times \\vec{A_2}$ 因此也可以得到常用的一个3维向量外积的表达式 $\\vec{a}\\times \\vec{b}=\\begin{vmatrix} \\vec{x}\\ \\ \\vec{y}\\ \\ \\vec{z} \\\\ a_1\\ a_2\\ a_3\\\\ b_1\\ b_2\\ b_3\\end{vmatrix}$ 其中$\\vec{x},\\vec{y},\\vec{z}$是三维平面的三个维度的单位向量 上式即将有向体积中的一个向量改为单位向量后压缩到一个平面上 \\最基本的求法：枚举$1,2,\\cdots,n$的一个排列$p_i$，设排列$p$的逆序对为$f(p)$ 则$\\begin{aligned} |A|=\\sum (-1)^{f(p)} \\Pi A_{i,p_i}\\end{aligned}$ \\矩阵行列式的性质：1.交换任意两行(列)得到矩阵$A’$，则$|A’|=-|A|$ (交换后每个排列$f(p)$的奇偶性改变) 2.对于某一行(列)乘上一个值$k$得到矩阵$A’$，则$|A’|=k|A|$ 3.某一行减去另一行的$k$倍得到矩阵$A’$，则$|A’|=|A|$ 根据性质得到的快速求法根据性质1,2,3可以对于矩阵进行高斯消元 而对于一个上三角/下三角矩阵，带入上面的基本求法，显然能够得到非0值的排列只有对角线$p_i=i$ 因此得到上/下三角矩阵之后就可以快速求解,复杂度为高斯消元的$O(n^3)$","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"数论知识小结 [微提高篇]","slug":"数论知识小结 [微提高篇]","date":"2020-11-27T12:38:06.000Z","updated":"2021-05-22T03:54:11.372Z","comments":true,"path":"articles/2020/11/27/453ae0f1.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/27/453ae0f1.html","excerpt":"","text":"数论知识小结 [微提高篇](lastest updated on 2020.08.12) 二次剩余和高次剩余$y^c\\equiv x\\pmod P$则$y$为$x$模$P$的$c$次剩余 关于二次剩余 \\$\\text{Miller_Rabin}$素数检测$x$是质数的必要条件是 $\\forall a,a^{x-1}\\equiv 1\\pmod x$ 同于对于一个质数$x$，必然有 $a^2\\equiv 1\\pmod x$的解只有$1,x-1$ 证明是 $\\because a^2\\equiv 1 \\pmod x$ $\\therefore (a-1)(a+1)\\equiv 0 \\pmod x$ 因为$x$是质数，所以$a-1\\mod x=0$ 或 $a+1\\mod x=0$，即$a\\in\\{1,x-1\\}$ \\$\\text{Miller_Rabin}$算法的步骤将$x-1$分解为$x-1=2^s\\cdot t$ 找一个$&lt;x$的质数$a$，求出$b\\equiv a^t \\pmod x$ 将$b$进行$s$次平方，设这一次平方的结果$b^2\\equiv c \\pmod x$ 当出现$c=1$时，$b$只能为$1$,$x-1$否则$x$就不是质数 $s$次平方后，$b\\equiv a^{x-1}\\pmod x$，若$b\\ne 1$，则$x$不是质数 不知道为什么，模板题跑5次就能过了。。。 注意$x\\leq 2\\or 2|x$要特判 注意取模需要快速乘 123456789101112131415161718int Miller_Rabin(ll x)&#123; if(x==2) return 1; if(x&lt;=1 || ~x&amp;1) return 0; ll s=0,t=x-1; while(~t&amp;1) s++,t&gt;&gt;=1; rep(i,1,20) &#123; ll a=prime[rand()%primecnt+1],b=qpow(a,t,x),c; rep(j,1,s) &#123; c=qmul(b,b,x); if(c==1 &amp;&amp; b!=1 &amp;&amp; b!=x-1) return 0; b=c; &#125; if(b!=1) return 0; &#125; return 1;&#125; \\可以结合$\\text{Miller_Rabin}$的$n^{\\frac{1} {3} }$特殊情况质因数分解实际上，这种方法常用于求$n$的因子个数 方法非常简单，先对于所有$pri_i\\le n^{\\frac{1} {3} }$的因子对于$n$筛去，剩下的部分中，所有质因子$&gt;n^{\\frac{1} {3} }$ 因此最多包含两个质因数(可能相同) 用$\\text{Miller_Rabin}$判断是否只包含一个质数，然后简单判别两个质因数是否相同即可 复杂度为$O(\\log n+\\pi (n^{\\frac{1} {3} }))$ 小范围内比下面的$\\text{Pollard’s_Rho}$更快，更简单 \\$\\text{Pollard’s_Rho}$质因数分解核心就是名字里的Rho($\\rho$)，是伪循环的一个形象的表示 伪循环：从某一个时刻开始，进入一个真循环，之前的时间就是$\\rho$的脚 构造伪随机函数$G_n(x)=(x^2+c)\\mod n$ 构造数列$a_i=G_n(a_{i-1})$ 由于函数的值域只有$[0,n-1]$，必然出现伪循环，即在从个位置开始，进入一个未知长度的循环，也就是长成了一个$\\rho$的形状 由于这个函数是伪随机函数，所以这个循环大小在期望情况下是$O(\\sqrt n)$的 \\$\\text{Pollard’s_Rho}$算法要找到一个$p\\in[2,n-2],p|n$ 考虑用$\\text{Floyd}$算法找环，即定义两个变量，一个每次走一步，一个每次走两步，设他们为$x,y$ 当$x=y$时，显然出现循环 由于$p|n$，所以当$x \\equiv y \\pmod p$时，实际上是$G_p(x)$这个函数出现了循环 所以在找$G_n(x)$的循环时，可以通过求出$\\gcd(x-y,n)$判断是否出现$G_p(x)$的循环 注意如果出现$x=y$情况已经找到$n$的循环，说明这个我们这次构造的这个函数找不到$p$的循环 由于$\\forall n\\notin prime,\\exist p\\in[1,\\sqrt n],p|n$ 所以期望情况下每$\\sqrt p\\leq \\sqrt {\\sqrt n}=n^{\\frac{1} {4} }$的长度会出现循环 算法复杂度是期望$O(n^{\\frac{1} {4} }\\log n)$的 那么写出$\\text{Pollard’s_Rho}$算法的代码 123456789101112ll Pollards_Rho(ll n)&#123; ll c=rand(); // 随机生成一个函数 ll x=rand(),y=x,d=1; // 随机一个初始值 while(d==1)&#123; x=(qmul(x,x)+c)%n; y=(qmul(y,y)+c)%n; y=(qmul(y,y)+c)%n; d=gcd(n,abs(x-y)); &#125; if(d==n) return Pollards_Rho(n); // 构造失败 else return d; // 找到了p&#125; 不断调用即可完成对于n的质因数分解 对于质因数分解，更高级的算法可以参考LOJ-6466 莫比乌斯函数设$n=\\prod_1^m p_i^{c_i}$，其中$c_i&gt;0,p_i$为质数 则莫比乌斯函数 $\\mu(n)=\\left\\{\\begin{aligned}1 && n=1\\\\ (-1)^m && \\nexists c_i>1 \\\\ 0 && \\exists c_i>1\\end{aligned}\\right.$ 狄利克雷卷积对于数列$F,G$，他们的狄利克雷卷积(下简称$F\\oplus G$)为 $$\\begin{aligned} (F\\oplus G)_i=\\sum_{d|i}F_d\\cdot G_{\\frac{i} {d} }\\end{aligned}$$ \\莫比乌斯反演设元函数$E_i=1$ $G=F\\oplus E$，即$G_i=\\sum_{d|i}F_d$ 由$G$反解$F$得到莫比乌斯反演$F_i=\\sum_{d|i}\\mu(d) G_{\\frac{i} {d} }$ \\积性函数积性函数的定义，对于一个定义在$\\Z$上的函数$F(n)$，若满足 $F(1)=1,\\forall (u,v)=1,F(u)\\cdot F(v)=F(u\\cdot v)$，则$F(u)$是一个积性函数 完全积性函数对于任意的$u,v$对满足上述性质 常见的积性函数有 1.元函数$e(n)=[n=1]$ 2.因数个数函数$d(n)$ 3.欧拉函数$\\varphi(n)$ 4.莫比乌斯系数$\\mu(n)$ 5.约数和函数$\\sigma(n)$ 推论：任意两个积性函数的狄利克雷函数卷积 仍然是积性函数 线性筛筛法求解积性函数把积性函数$F(n)$表示为 $F(n)=\\left\\{\\begin{aligned} 1 && n=1 \\\\ G(n) && n=p_i^t \\\\ \\prod G(p_i^{c_i}) && n=\\prod p_i^{c_i}\\end{aligned}\\right.$ 如果能在较短的时间内求得$G(p_i^t)$，则可以用线性筛法求解积性函数$F(n)$的前$n$项 一个最简单的应用: 在$O(n)$时间求解$id^z(n)=n^z$显然，$id^z(n)$是一个完全积性函数，且直接求复杂度为$O(n\\log z)$ 因为是完全积性函数，所以只需要求解$id^z(p_i)$，这一部分复杂度为$O(\\pi(n)\\cdot \\log z)=O(n)$ 线性筛法的复杂度为$O(n)$，因此总复杂度也为$O(n)$ (这就是传说中的魔法吗！！) 一个简单的应用：求解$\\mu(n)$鉴于$\\mu(n)$的特殊性，也只需要求出$\\mu(p_i)$ 写出的代码大致是这样的 123456789101112131415int pri[N],notpri[N],pc,mu[N];void Sieve_Mobius(int n)&#123; mu[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!notpri[i]) pri[++pc]=i,mu[i]=1; for(int j=1;j&lt;=pc &amp;&amp; 1ll*i*pri[j]&lt;=n;++j) &#123; notpri[i*pri[j]]=1; if(i%pri[j]==0) &#123; mu[i*pri[j]]=0; break; &#125; mu[i*pri[j]]=-mu[i]; &#125; &#125;&#125; 真-应用: 大型模板1234567891011121314151617181920212223242526272829int CalcG(int n);int prime[N],primecnt,notprime[N];int F[N],D[N];// F存储函数值// D存储质因数出现的幂次积void Sieve_Multiplicative_Function(int n)&#123; F[1]=1; for(int i=2;i&lt;=n;++i)&#123; if(!notprime[i]) &#123; prime[++primecnt]=i; for(ll j=i;j&lt;=n;j*=i) F[j]=CalcG(j),D[j]=j; // 计算F(p_i^t) &#125; for(int j=1;j&lt;=primecnt &amp;&amp; 1ll*i*prime[j]&lt;=n;++j) &#123; notprime[i*prime[j]]=1; int k=i*prime[j]; if(i%prime[j]==0) &#123; D[k]=D[i] * prime[j]; F[k]=F[i/D[i]] * F[D[k]]; break; &#125; D[k]=prime[j]; F[k]=F[i] * F[prime[j]]; &#125; &#125;&#125; \\\\杜教筛用于求解 较大范围 且 可以构造出一些性质的积性函数 前缀和 不推荐看我的，但是还是放一下链接 \\Min25筛用于求 较大范围 且 使用范围更广 的积性函数前缀和 ， 但在效率上不敌杜教筛 还是放一下链接","categories":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}]},{"title":"「JOI 2020 Final」奥运公交  (最短路)","slug":"「JOI 2020 Final」奥运公交  (最短路)","date":"2020-11-27T07:20:17.000Z","updated":"2021-05-22T03:54:11.198Z","comments":true,"path":"articles/2020/11/27/2db96091.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/27/2db96091.html","excerpt":"","text":"「JOI 2020 Final」奥运公交 (最短路)问题实际上就是要分别求$1-n$和$n-1$对于每一条边翻转之后的最短路 由于$m$的上限为$n^2$，下面所说的$\\text{Dijkstra}$都是没有堆优化的板本，即$n^2$找最小点，$m$更新 以计算$1-n$为例 不妨先考虑计算删除每一条边$(u,v,c)$之后，1为源点的的最短路情况 我们知道从源点$S$出发的最短路可以用最短路图描述，而最短路图是一张拓扑图（fix:这道题含有0边，所以并不是，但是没有关系） 如果从最短路图中提取一棵树，那么显然只有这些树边需要考虑删除之后对于最短路的影响 对于这些边重新求最短路即可，复杂度为$O(n(m+n^2))$ 如何考虑翻转一条边之后的贡献？ 不妨再求出以$n$为结束的最短路，即求反图$n$为源点的答案 然后在两个最短路上查询一下即可得到$1-n$的最短路 同理得到$n-1$的答案 复杂度为$O(n(m+n^2))$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T&amp; a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T&amp; a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0;int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;bool Mbe;const int N=210,M=5e4+10,INF=2e9+10;int n,m;int E[N][N],E2[N][N],EI[N][N],dis[N],vis[N];void Dijkstra(int S)&#123; rep(i,0,n) dis[i]=INF,vis[i]=0; dis[S]=0; while(1) &#123; int u=0; rep(i,1,n) if(!vis[i] &amp;&amp; dis[i]&lt;dis[u]) u=i; if(!u) break; vis[u]=1; rep(i,1,n) if(E[u][i]&lt;INF) cmin(dis[i],dis[u]+E[u][i]); &#125;&#125;int U[M],V[M],C[M],D[M];int mk[M];void dfs(int u) &#123; vis[u]=1; rep(i,1,n) if(!vis[i] &amp;&amp; E[u][i]&lt;INF &amp;&amp; dis[i]==dis[u]+E[u][i]) mk[EI[u][i]]=1,dfs(i);&#125;int Res1[M][N],Res2[M][N];ll Ans[M];void Solve(int S,int Res[M][N])&#123; // 计算删除每条边之后，S为源点的最短路情况，放在Res[M][N]中 rep(i,1,n) rep(j,1,n) E[i][j]=INF,E2[i][j]=INF; rep(i,1,m) &#123; int u=U[i],v=V[i],c=C[i]; if(E[u][v]&gt;c) E2[u][v]=E[u][v],E[u][v]=c,EI[u][v]=i; else if(E2[u][v]&gt;c) E2[u][v]=c; &#125; Dijkstra(S); rep(i,1,n) vis[i]=0; rep(i,1,m) mk[i]=0; dfs(S); rep(i,1,m) if(!mk[i]) rep(j,1,n) Res[i][j]=dis[j]; rep(i,1,m) if(mk[i]) &#123; swap(E[U[i]][V[i]],E2[U[i]][V[i]]); Dijkstra(S); rep(j,1,n) Res[i][j]=dis[j]; swap(E[U[i]][V[i]],E2[U[i]][V[i]]); &#125;&#125;void Solve()&#123; Solve(1,Res1); rep(i,1,m) swap(U[i],V[i]); // 反图计算 Solve(n,Res2); rep(i,1,m) swap(U[i],V[i]); rep(i,1,m) &#123; int t=min(Res1[i][n],Res2[i][1]); if(Res1[i][V[i]]&lt;INF &amp;&amp; Res2[i][U[i]]&lt;INF) cmin(t,Res1[i][V[i]]+Res2[i][U[i]]+C[i]); Ans[i]+=t; // 合并贡献 &#125;&#125;bool Med;int main()&#123; //fprintf(stderr,&quot;%.2lf\\n&quot;,(&amp;Med-&amp;Mbe)/1024.0/1024.0); n=rd(),m=rd(); rep(i,1,m) U[i]=rd(),V[i]=rd(),C[i]=rd(),D[i]=rd(); ll ans=0; rep(i,1,n) rep(j,1,n) E[i][j]=INF; rep(i,1,m) cmin(E[U[i]][V[i]],C[i]); Dijkstra(1),ans+=dis[n]; Dijkstra(n),ans+=dis[1]; // 计算1-n Solve(); // 计算n-1 rep(i,1,m) U[i]=n-U[i]+1,V[i]=n-V[i]+1; Solve(); rep(i,1,m) cmin(ans,Ans[i]+D[i]); printf(&quot;%lld\\n&quot;,ans&gt;=INF?-1:ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"JOI","slug":"JOI","permalink":"http://chasingdeath.github.io/tags/JOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「Lych_cys模拟题2018」橘子树              ","slug":"「lych_cys模拟题2018」橘子树              ","date":"2020-11-27T07:03:16.000Z","updated":"2021-05-22T03:54:11.284Z","comments":true,"path":"articles/2020/11/27/898de7a9.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/27/898de7a9.html","excerpt":"","text":"「lych_cys模拟题2018」橘子树你可能需要一点点简单知识 你可能需要一点点预先知识 设值域上限为$M=2\\cdot 10^5,T=3\\cdot 10^5$ 求$F(n)$筛去$n^{\\frac{1} {3} }$以内的质因数，此时$n$剩下的质因数$&gt;n^{\\frac{1} {3} }$ 剩下的$n$中，可能出现贡献的只有$n$是完全平方数的情况，$O(1)$判断即可 复杂度为$O(n^{\\frac{1} {3} })$ \\求出$i$结点长了$t$时间的时候被收掉的答案预处理$a_i,b_i$的答案$c_i=F(a_i),d_i=F(b_i)$，复杂度为$O(n\\pi(M^{\\frac{1} {3} }))$ 那么此时查询的权值就是$a_i\\cdot t$，如果$&gt;b_i$特判掉 否则，显然$c_i$的贡献可以先分离掉考虑进答案 对于剩下的部分，不妨设$x=\\frac{a_i} {c_i}$，显然$x$不包含平方因子 考虑$x$与$t$的合并所产生的贡献，实际上就是$\\gcd(x,t)$ (让$x$的单个因子与$t$匹配一下) 然后对于$t$剩下的部分$\\frac{t} {\\gcd(x,t)}$，由于$t\\leq 3\\cdot 10^5$，可以预处理一下答案 综合一下上面的部分，那么一个点的答案就是$c_i\\gcd(x,t)^2 F(\\frac{x} {\\gcd(t,x)})$ 因此查询一个点的复杂度就是$\\gcd$的$O(\\log T)$ \\综合利用上面的方法，勉强可以拿到$nm\\log T$的20分 剩下的部分，可以考虑把树树剖一下，然后每个查询可以化为在$\\text{dfs}$序上的若干更新区间$L_i,R_i,t_i$ 由于题目考虑的实际上是查询总和，因此可以对于每个点计算答案 不妨从$1-n$扫描$\\text{dfs}$序，对于每个区间在$L_i$插入$t_i$，在$R_i+1$删除$t_i$ 用一个set来维护$t_i$的顺序，复杂度为$O(n\\log ^2n)$ 在插入/删除set元素的同时，维护每一个$\\Delta_i=t_i-t_{i-1}$，也就是我们要查询的每个数 查询单点时，由于这样的$\\sum \\Delta_i\\leq T$，所以最多包含$O(\\sqrt T)$种不同的$\\Delta_i$ 用另一个set之类的东西维护这些不同的位置，然后暴力查询，复杂度为$O(n\\sqrt T\\log T)$ 总复杂度为$O(n\\pi(M^{\\frac{1} {3} })+n\\sqrt T\\log T)$左右 \\\\\\ 后记 由于特(智)殊(力)的(缺)原(陷)因 我考场上写了一个树剖+分块+莫比乌斯反演的做法，而且还没调出来，代码是这个，复杂度大概差不多$O(n\\sqrt n \\log_n^{\\frac{3} {2} })$ 不提了。。。","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"数论知识小结 [基础篇]","slug":"数论知识小结 [基础篇]","date":"2020-11-27T06:35:25.000Z","updated":"2021-05-22T03:54:11.368Z","comments":true,"path":"articles/2020/11/27/f71cb7e0.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/27/f71cb7e0.html","excerpt":"","text":"数论知识小结 [基础篇](latest updated on 2020.08.12) 符号$(a,b)=\\gcd(a,b)$ 乘除$a|b\\rightarrow b=ka (k\\in \\N^+)$ $\\sum$求和,$\\prod$求积 任意$\\forall$，存在$\\exists$ $\\lfloor x\\rfloor $ 向下取整，$\\lceil x\\rceil $ 向上取整 $[a,b]$区间，通常指整数即$[a,b]\\cap \\Z$ 调和级数数学上，调和级数为$H_n=\\sum_{i=1}^{n}\\frac{1} {i}$ 在OI中，我们常用调和级数分析$\\sum_{i=1}^n\\frac{n} {i}\\approx n\\ln n$ 把它近似看成是$f(x)=\\frac{n} {x}$在$[1,n]$上的积分，它的原函数$F(x)=n\\ln x$ 即$\\begin{aligned} \\sum_{i=1}^n\\frac{n} {i}\\approx \\int_1^nf(x) dx=F(n)-F(1)=n\\ln n-n\\approx n\\ln n\\end{aligned}$ 附：广义调和级数 $\\begin{aligned} H^z_n=\\sum_{i=1}^{n}\\frac{1} {i^z} \\end{aligned}$它的无穷形式为黎曼函数$\\begin{aligned}\\zeta(z)=H^{z}_{\\infty}\\end{aligned}$ \\向下取整的性质/数论分段性质:$\\lfloor \\frac{n} {ab}\\rfloor =\\lfloor \\frac{\\lfloor \\frac{n} {a}\\rfloor } {b}\\rfloor $ \\数论分段：即对于$i=[1,n]$，把$i$按照$\\lfloor \\frac{n} {i}\\rfloor$的值分成$O(\\sqrt n)$段，(通常为$2\\cdot \\sqrt n$段左右) 证明：对于$i\\leq \\sqrt n$，显然只有$\\sqrt n$个不同的值 对于$i&gt;\\sqrt n$，此时$\\frac{n} {i}&lt;\\sqrt n$，也只有$\\sqrt n$个不同的值 \\素数/质数/质数密度对于$x&gt;1$，若$\\nexists y\\in[2,n-1],y|x$，则$x$是一个质数，下文称素数集合为$prime$集合 $n$以内的素数个数用函数$\\pi(n)=|prime\\cap[1,n]|$表示，素数密度在渐进意义上是$O(\\log n)$的 即可以认为$\\pi(n)=O(\\frac{n} {\\log n})$(实际在$n$较小时完全看不出这一点) $n$的唯一分解: $n=\\prod_{p_i\\in prime} p_i^{c_i}$ 朴素的素数判别法: 一个显然方法的如果$x$不是质数，则$\\exists y\\in [2,\\sqrt n] ,y|x$ 所以可以朴素写出一个$O(\\sqrt n)$的素数判别法 利用这一点预先处理小素数，每次只判断素数，可以写出一个$O(\\pi(\\sqrt n))$的素数判别法 朴素的质因数分解法: 即求$n=\\prod p_i^{c_i},p_i\\in prime$，其中$\\sum c_i\\leq \\log _2^n$ 由于对于一个数$n$，最多存在一个$y\\in prime \\cap [\\sqrt n,n],y|n$，因此可以先分解掉$y&lt;\\sqrt n$的部分，剩下的一个就知道了 12345void Factor(int n)&#123; for(int i=2;i*i&lt;=n;++i) if(n%i==0) while(n%i==0) printf(&quot;%d &quot;,i),n/=i; // 分解掉&lt;sqrt(n)的部分 if(n&gt;1) printf(&quot;%d &quot;,n); // 如果还剩下，那么就是&gt;sqrt(n)的一个质数&#125; 复杂度是$O(\\sqrt n +\\log n)$ 更优化的只枚举质数作为因子，复杂度是$O(\\pi(\\sqrt n)+\\log n)$ \\朴素的素数筛法：埃氏筛 对于$[2,n]$每个数$i$，$x=ki(k&gt;1)$均不是质数，直接枚举复杂度为调和级数$O(n\\ln n)$ 更优化的，对于$[2,n]$中每个质数$i$，$x=ki(k&gt;1)$均不是质数，由于素数密度为$O(\\log n)$,所以可以近似认为是$O(n\\log \\log n)$(实际我不会证明。。) 线性筛(欧拉筛)筛素数知识一个基础，可以筛很多函数，尤其是适用于积性函数 直接上代码背板子好了 123456789101112int notpri[N],prime[N],primecnt;void Sieve()&#123; notpri[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!notpri[i]) prime[++primecnt]=i; for(int j=1; j&lt;=primecnt &amp;&amp; 1ll*i*prime[j]&lt;=n;++j)&#123; notpri[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125;&#125; 其中$i\\mod prime_j= 0$意味着后面的数已经被$\\frac{i} {prime_j}$筛掉了，所以可以break 复杂度是带有一定常数的$O(n)$,还可以用来筛其他的一些函数 \\\\$\\gcd,\\text{lcm}$最大公因数$\\text{gcd(greatest common divisor)}$常用$\\gcd(x,y)=(x,y)$表示 最小公倍数$\\text{lcm(least common multiple)}$ 特别的：$(a,0)=a$ 求$\\gcd(a,b)$可以用辗转相除法(也称为欧几里得算法)，即利用性质$(a,b)=(a\\mod b,b)$ 每次递归调用$\\gcd(b,a\\mod b)$即可，边界为$(a,0)=a$ 复杂度分析： 首先是取模的分析，对于$\\forall a,b,a\\ge b$，必然满足$a\\mod b \\leq \\frac{a} {2}$ 所以每次取模至少会减少一倍，复杂度为$O(\\log a)$ \\附：扩展欧几里得算法用于求解不定方程$ax+by =1$的一组解$(x,y)$ 存在解的条件是$(a,b)=1$，否则$(a,b)|ax+by$，即$ax+by&gt;1$ 用类似求$\\text{gcd}$的方法求出 $ax+by=1$ $( a\\mod b)\\cdot x+ \\lfloor \\frac{a} {b}\\rfloor\\cdot b\\cdot x + by=1$ $( a\\mod b)\\cdot x+ b\\cdot (\\lfloor \\frac{a} {b}\\rfloor\\cdot x + y)=1$ 那么如果求出$(a\\mod b)\\cdot x’+b\\cdot y’=1$的解 则$x’=x,y’=\\lfloor \\frac{a} {b}\\rfloor \\cdot x+y$ 即$x=x’,y=y’-\\lfloor \\frac{a} {b}\\rfloor x$ 每次都递归求出$(a\\mod b) \\cdot x+ by =1 $ 复杂度与$\\gcd$相同，最后的$(a,b)=a=1,b=0$是边界条件，此时$x+0\\cdot y=1$的一组解是$(1,0)$ 写成代码 12345678910// ax + by =1int Exgcd(int a,int b,int &amp;x,int &amp;y) &#123; if(b==0)&#123; if(a!=1) return 0; // (a,b)!=1 ,不存在解 x=1,y=0; // 初始解 return 1; &#125; Exgcd(b,a%b,y,x),y-=a/b*x; // 带入上面的式子，注意这里带入的是(b,a%b),所以x,y要反过来 return 1;&#125; 注意求出的$x,y$不保证为正数 \\\\\\因数个数似乎没有找到规范的函数定义，所以下称$d(n)$ 即$d(n)=|\\{i|i\\in[1,n]\\and i|n\\}|$ 对于$n=\\prod p_i^{c_i}$，列一条小学的公式$d(n)=\\prod (c_i+1)$ 因数个数一个非常松的上界是$O(\\sqrt n)$，证明这里略去 实际上，搜索得到的上界大致是 123456789101112131415161718maxn=10^ 1 max= 4maxn=10^ 2 max= 12maxn=10^ 3 max= 32maxn=10^ 4 max= 64maxn=10^ 5 max= 128maxn=10^ 6 max= 240maxn=10^ 7 max= 448maxn=10^ 8 max= 768maxn=10^ 9 max= 1344maxn=10^10 max= 2304maxn=10^11 max= 4032maxn=10^12 max= 6720maxn=10^13 max= 10752maxn=10^14 max= 17280maxn=10^15 max= 26880maxn=10^16 max= 41472maxn=10^17 max= 64512maxn=10^18 max= 103680 可以看到，因数个数是非常少的 附: 质因数个数$\\Omega(n)=|prime\\cap [1,n]|$，非常松的上界是$\\Omega(n)=O(\\log n)$ 约数和函数$\\sigma(n)=\\sum_{i|n}i$ \\费马小定理/欧拉定理/欧拉函数/阶\\费马小定理： 对于任意质数$P,x&gt;0,x^{p-1}\\equiv 1 \\pmod P$ \\欧拉函数：$\\varphi(n)$为$[1,n-1]$中与$n$互质的数个数，特别的$\\varphi(1)=1$ 设$n=\\prod p_i^{c_i}$其中$p_i$是质数,$c_i&gt;0$，则$\\varphi(n)=\\prod p_i^{c_i-1}(p_i-1)=n\\prod\\frac{p_i-1} {p_i}$ 对于可以通过类似筛素数的方法求出来$[1,n]$的$\\varphi(i)$ 对于数$n$，需要采用质因数分解求出，朴素的做法为$O(\\sqrt n)$，用$\\text{Pollard’s Rho}$算法复杂度更低 \\欧拉定理：对于任意数$P&gt;1,x&gt;0,x^{\\varphi(P)}\\equiv 1\\pmod P$ 推论：$x^c\\equiv x^{c\\mod \\varphi (P)} \\pmod P$ 很显然，费马小定理是欧拉定理的特殊情况 \\ 阶：对于$(a,n)=1$的整数，满足$a^r≡1 \\pmod n$ 的最小整数$r$,称为$a$模$n$的阶，以下简称$d(a)$ 显然$a^i \\mod n$构成了一个以$r$为最小正周期的循环 性质：根据欧拉定理$a^{\\varphi(n)}\\mod n=1$，所以有$d(a)|\\varphi(n)$ 求解阶：先对于 $\\varphi(n)$质因数分解，然后可以 1.依次枚举每个因数判断是否有$a^i\\mod n=1$，取最小的$i$，复杂度为$O(\\sqrt n\\log n)$ 2.设$\\varphi(n)=p_i^{c_i}$，令$x=\\varphi(P)$，从$x$开始，如果$a^{\\frac{x} {p_i} }\\mod n=1$，则$x\\rightarrow \\frac{x} {p_i}$ 预处理复杂度受限于质因数分解(下文有介绍) 单次查询复杂度上限是$O(\\log ^2 P)$(为快速幂复杂度乘上$\\sum c_i$) \\模逆元对于任意数$x&gt;1,P&gt;1,(x,P)=1$，存在一个数$\\frac{1} {x}\\equiv y\\pmod P$ 即$xy\\equiv 1 \\pmod P$，$y$为$x$的一个模逆元 当$P$为质数时，由于$x^{P-1}\\equiv 1 \\pmod P$，所以$y\\equiv x^{P-2}\\pmod P$为$x$的一个逆元 当$P$不为质数时，如果已知$\\varphi (P)$，可以类似得做，否则可以构造$a\\cdot x+b\\cdot P=1$，用扩展欧几里得算法求出一组合法解$(a,b)$，则$a$即为一个答案 \\原根/指标原根：一个数$P$有原根的条件是他可以表示为$P=1,2,4,p,2p,p^n(p\\in prime)$ 对于$P$，令$d(x)$为$x$模$P$的原根，若存在$d(x)=\\varphi(P)$,则$x$是$P$的一个原根 找原根： 设$\\varphi(P)=\\prod p_i^{c_i}$，其中$p_i$是质数 由于$d(x)|\\varphi(P)$，如果$d(x)&lt;\\varphi(P)$那么必然存在一个$x^{\\frac{\\varphi(P)} {p_i} }\\equiv 1\\pmod P$ 所以先求一遍质因数分解，然后快速幂判断就可以做到$O(\\log ^2 P)$判断原根 显然原根不唯一 已经被证明对于任意的$P$如果存在原根，则其最小原根最多是$O(P^{\\frac{1} {4} })$级别的 \\指标： 对于一个数$P$和它的一个原根$x$，对于$\\gcd(y,P)=1$，则$y$一定可以用$x^i$表示，那么$i$就是$y$的指标 同时，$y$模$P$的阶就是$d(y)=\\frac{\\varphi(P)} {\\gcd(\\varphi(P),i)}$，可以认为是数列$a_j=i\\cdot j\\mod \\varphi(P)$的周期问题 可以使用$\\text{BSGS}$算法在$O(\\sqrt P\\log P)$或者$O(\\sqrt P)$的时间内求出一个数的指标 (关于去掉$\\log P$：只需要处理出模逆元直接累乘，每次用$\\text{Hash Table}$访问即可) 指标在二次剩余的较劣做法中也有应用，同时也可以直接套用性质用于阶的求解 \\快速乘求$x,y\\in[0,P-1],P\\leq 10^{18},x\\cdot y \\mod P$ 直接乘法会爆long long 可以用类似快速幂的方法写，复杂度为$O(\\log P)$ 1234567typedef long long ll;typedef unsigned long long ll;void qmul(ll x,ll y,ll P)&#123; ll res=0; for(;y;y&gt;&gt;=1,x=(x+x)%P) if(y&amp;1) res=(res+x)%P; return res;&#125; 另一种方法是强行用long double 保证精度，然后计算的时候用unsigned long long 溢出回来，$O(1)$但是很奇怪，通常不会挂 1234567typedef long long ll;typedef unsigned long long ll;void qmul(ll x,ll y,ll P)&#123; ull z=(long double)x/P*y; ll res=(ull)x*y-(ull)z*P; return (res%P+P)%P;&#125; \\","categories":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}]},{"title":"FWT (快速沃尔什变换)详解 以及 K进制FWT","slug":"FWT (快速沃尔什变换)详解 以及 K进制FWT","date":"2020-11-15T11:05:50.000Z","updated":"2021-05-22T03:54:10.941Z","comments":true,"path":"articles/2020/11/15/454a92e7.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/15/454a92e7.html","excerpt":"","text":"FWT (快速沃尔什变换)详解 以及 K进制FWT约定：$F’=FWT(F)$ 卷积的问题，事实上就是要构造$F’G’=(FG)’$ 我们常见的卷积，是二进制位上的or ,and ,xor 但正式来说，是集合幂指数 上的 并 ， 交 ， 对称差 为了说人话，这里就不带入集合幂指数的概念了 一个常识：$\\sum_{T\\sube S}(-1)^{|T|}=[S=\\empty]$ or 和 and 卷积ps: 虽然这两个并不是$\\text{FWT}$，应该叫$\\text{FMT}$(快速莫比乌斯变换)，但是由于常用的是这3个，所以放到一起 这两种卷积的本质是相同的，所以只解释$or$卷积 or卷积的本质就是高位前缀和 即:$F’_S=\\sum _{T\\sube S}F_T$ 正确性：即$\\forall S,F’_S \\cdot G’_S=(F\\cup G)’_S$ 左边= $F’_S \\cdot G’_S=\\sum _{T\\sube S}\\sum _{R\\sube S}F_T\\cdot G_R$ 右边= $(F\\cup G)’_S=\\sum_{T\\sube S}(F \\cup G)_S$ $=\\sum_{T\\sube S}\\sum_{A,B,A\\cup B=S}F_A\\cdot G_B$ $=\\sum_{T \\sube S}\\sum_{R \\sube S}F_T \\cdot G_R$ \\卷积实现其实第一次层循环的意思是枚举子集中和自己不同的位最高是$i$ 让$0$向$1$转移即可 12345678910void FWT(int n,ll *a)&#123; for(int i=1;i&lt;n;i&lt;&lt;=1) rep(j,i,n-1) if(j&amp;i) s[j]+=s[j^i];&#125;void FWT(int n,ll *a)&#123; for(int i=1;i&lt;n;i&lt;&lt;1) for(int l=0;l&lt;n;l+=i*2) for(int j=0;j&lt;l+i;++j) s[j+i]+=s[j];&#125; Tips:如果要卡常，可以写成类似$\\text{FFT}$的形式，因为优化了访问顺序会快一些 \\实现逆卷积把上面的加换成减，这是一个类似容斥的东西 但是因为是反解，所以这个过程我么通常称为子集反演 那么每次$0$向$1$的转移意味着多了一个不同的位置 设$F’_S=\\sum_{T\\sube S}F_T$ 实际逆卷积就是$F_S=\\sum_{T\\sube S}(-1)^{|T\\oplus S|} F’_S$ 证明如下： $\\Leftrightarrow F_S=\\sum_{T\\sube S}(-1)^{|T\\oplus S|} \\sum _{R\\in T}F_R$ $\\Leftrightarrow F_S=\\sum_{T\\sube S}F_R\\sum _{T\\sube R,R\\sube S}(-1)^{|S\\oplus R|}$ $\\Leftrightarrow F_S=\\sum_{T\\sube S}F_R\\sum _{R\\sube (S\\oplus T)}(-1)^{|R|}$ 带入上面所提到的$\\sum_{T\\sube S}(-1)^{|T|}=[S=\\empty]$，成立 12345678910void FWT(int n,ll *a,int f)&#123; for(int i=1;i&lt;n;i&lt;&lt;=1) rep(j,i,n-1) if(j&amp;i) s[j]+=f*s[j^i];&#125;void FWT(int n,ll *a,int f)&#123; for(int i=1;i&lt;n;i&lt;&lt;1) for(int l=0;l&lt;n;l+=i*2) for(int j=0;j&lt;l+i;++j) s[j+i]+=f*s[j];&#125; \\\\应用 : 子集卷积(可以看luogu)问题描述： 给定$F_S,G_T$，求出$H_{R}=\\sum_{S\\cup T=R,S\\cap T=\\empty}F_S\\cdot G_T$，设有$2^n$个元素 我们知道直接枚举的复杂度为$O(3^n)$ 直接应用or卷积无法保证$S\\cap T=\\empty$，但是可以再记录一个占位数量，即把$F,G$按照每一位包含1的数量分开成$n+1$部分，卷积完成之后 应该满足1的个数恰好为两者之和，否则清空 需要$n$次卷积，$n^2$次转移，因此复杂度为$O(n^22^n)$，在渐进意义上更优于$O(3^n)$ Xor 卷积这里要用到一个小性质 $|A\\cap B|+|A\\cap C|\\equiv |A\\cap (B\\bigoplus C)| \\pmod 2$ 思路介绍： 我们是要构造一个$F_S\\rightarrow G_T$的变换，使得该变换满足Xor的性质，且能在较优的时间复杂度内完成，并且能够在较优的时间内完成反演 由于上面的这条式子，考虑可以构造$F’_S=\\sum_{T}(-1)^{|S\\cap T|}F_T$，这样$(-1)^k$的系数在$\\mod 2$意义下可以抵消 正确性即$\\forall S,F’_S \\cdot G’_S=(F\\bigoplus G)’_S$ $F’_S\\cdot G’_S=\\sum_{T} \\sum_{R}(-1)^{|S\\cap T|+|S\\cap R|}F_T\\cdot G_R$ $=\\sum _T\\sum _R(-1)^{|(T\\bigoplus R)\\cap S|}F_T\\cdot G_R$ 显然这个式子与右边相同 \\卷积实现考虑和前面相同的方法，枚举二进制位上最高的$1$ 之前由于转移是单向的，所以只需要一次加法，这里由于有了系数同时还是双向的转移，所以要格外注意 转移系数也是比较明显的 $0\\rightarrow 0 = 1$ $0\\rightarrow 1 = 1$ $1\\rightarrow 0 = 1$ $1\\rightarrow 1 = -1$ 1234567891011121314151617181920void FWT(int n,ll *a)&#123; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; rep(j,0,n-1) if(~j&amp;i) &#123; ll t=a[j+i]; a[j+i]=a[j]-t; a[j]=a[j]+t; &#125; &#125; &#125;void FWT(int n,ll *a)&#123; for(int i=1;i&lt;n;i&lt;&lt;=1)&#123; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j)&#123; ll t=a[j+i]; a[j+i]=a[j]-t; a[j]+=t; &#125; &#125; &#125;&#125; 实现逆卷积考虑再卷一次 $F’’_S=\\sum_T\\sum_R(-1)^{|S\\cap R|+|T\\cap R|}F_T$ $=\\sum_T \\sum_R (-1)^{|(S\\bigoplus T)\\cap R|}F_T$ $\\because \\sum_T (-1)^{|S\\cap T|}=\\sum_{T\\sube S}(-1)^{|T|}2^{|U|-|S|}=[S=\\empty]2^{|U|-|S|}$(其中$U$是全集) $\\therefore F’’_S=\\sum_S2^{|U|}F_S$ 所以逆卷积就是再卷一遍，最后除去$n$即可 12345678910111213141516171819202122void FWT(int n,ll *a,int f)&#123; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; rep(j,0,n-1) if(~j&amp;i) &#123; ll t=a[j+i]; a[j+i]=a[j]-t; a[j]=a[j]+t; &#125; &#125; if(f==-1) rep(i,0,n-1) a[i]/=n;&#125;void FWT(int n,ll *a,int f)&#123; for(int i=1;i&lt;n;i&lt;&lt;=1)&#123; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j)&#123; ll t=a[j+i]; a[j+i]=a[j]-t; a[j]+=t; &#125; &#125; &#125; if(f==-1) for(int i=0;i&lt;n;++i) a[i]/=n;&#125; 和上面一样的，可以写成类似$\\text{FFT}$的形式卡常 \\\\拓展 K - FWT实际上学习了这个拓展能让你更好地理解$\\text{FWT}$ 不妨考虑$n$个维度的情况，每个维度是一个$0,1,\\cdots k-1$中的数 由于$k$进制下不好用集合描述，因此考虑用一个向量$\\vec{V}=\\lbrace V_0,V_1,\\cdots,V_{n-1}\\rbrace,V_i\\in[0,k-1]$表示 一个多项式可以具象地用$0,1,\\cdots,k^n-1$这个$k^n$个位置上的系数表示 $\\text{and,or}$卷积在$k$进制下可以拓展为按位取$\\min,\\max$，这个直接累前缀和就可以了，不作赘述 而$k$进制下的$\\text{xor}$可以扩展为两个向量列的取模加法 $\\vec{A}+\\vec{B}=\\vec{C},C_i=(A_i+B_i)\\bmod k$ 也可以描述为不进位的$k$进制数加法 其实用$\\text{K-FWT}$称呼这个似乎不是很形象，更好的可以称之为$\\text{n-DFT}$ 也就是说$\\text{K-FWT}$实际上就是在$n$个维度上分别做大小为$k$的循环卷积，使用一种结合$\\text{FWT-DFT}$的方法(因此需要用到$k$次单位根$\\omega_k$) 卷积构造原多项式$F$向卷积多项式$F’$的转换系数为$[x^A]F\\rightarrow [x^B]F’:\\omega_k^{A\\cdot B}$ 其中$A\\cdot B$为向量内积，即$\\sum A_i\\cdot B_i$ 从中也可以很好地看到$\\text{xor}$卷积的影子 实现方法上，可以依次枚举$0,1,\\cdots,n-1$每一位，将除了这一位上都相同的数取出来 按照这一位上的值做一次$\\text{DFT}$ 需要$n$位枚举，每次枚举需要做$k^{n-1}$次$k^2$的$\\text{DFT}$，因而复杂度为$O(nk^{n+1})$ 对于$k$比较大的情况，如果$k=2^t$可以直接用$\\text{FFT/NTT}$，否则还可以参考这个 可以优化到$O(nk^n\\log k)$ 逆卷积当然是换成$\\text{IDFT}$，最后全部除掉$k^n$ 正确性上，如果你对于$\\text{IDFT}$的原理(单位根反演) 有所了解，就能发现 只有所有位置上都相同的情况才会转移出$k^n$的系数 \\123456789101112131415161718int w[20]; // 单位根的幂次void K_FWT(int *F,int n,int f)&#123; // 这个n实际上是上面叙述中的n^k static int t[20]; for(int i=1;i&lt;n;i*=k)&#123; for(int l=0;l&lt;n;l+=i*k)&#123; for(int j=l;j&lt;l+i;++j)&#123; for(int a=0;a&lt;k;++a) for(int b=t[a]=0;b&lt;k;++b) t[a]=(t[a]+1ll*F[j+b*i]%P*w[b*(k+f*a)%k])%P; for(reg int a=0;a&lt;k;++a) F[j+a*i]=t[a]; &#125; &#125; &#125; if(f==-1) &#123; ll base=qpow(n); rep(i,0,n-1) F[i]=F[i]*base%P; &#125;&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"CodeChef November Challenge2019  Winning Ways (3-FWT)","slug":"CodeChef November Challenge2019  Winning Ways (3-FWT)","date":"2020-11-15T10:16:59.000Z","updated":"2021-05-22T03:54:10.917Z","comments":true,"path":"articles/2020/11/15/669720f5.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/15/669720f5.html","excerpt":"","text":"CodeChef November Challenge2019 Winning Ways (3-FWT)显然每个把每个数换成其因子个数-1，就能转为一个扩展的$\\text{Nim}$游戏 每次操作$1,2,\\cdots,k$堆的$\\text{Nim}$游戏，其判定方法是： 将每个数二进制分解，对于每个二进制位上分别计算1的个数$\\mod (k+1)$，如果均为0则先手必败 对于这道题$k=3$，我们考虑将其转为二进制之后的形式累成3进制，然后就能进行3进制按位不进位加法，即类异或 然后问题实际上有非常多的部分需要考虑 Part1 如何求因子个数一个简单的方法是枚举$[1,\\sqrt n]$判断是否整除，复杂度过高 对于$n=\\prod p_i^{c_i}$($p_i$为质数)，其因子个数为$\\prod (c_i+1)$ 由这个式子对于$n$进行质因数分解，枚举$[1,\\sqrt n]$中的质数，复杂度为$O(\\pi(\\sqrt n))=O(\\frac{\\sqrt n} {\\log n})$，这个应该够了？ 然后是一个常规套路型的分解方法： 先对于$[1,n^{\\frac{1} {3} }]$的质数筛$n$，剩余的部分只有3种情况 1.$n$被筛成1了 2.$n$被筛到只剩一个质数，可以用$\\text{Miller_Rabin}$算法快速判断，可以参考 3.$n$仍然是若干质数的乘积，此时质因子必然$&gt;n^{\\frac{1} {3} }$，因此最多只有两个 那么只需要判断$n$是否是完全平方数即可 总复杂度为$O(w\\cdot \\log n+\\frac{n^{\\frac{1} {3} }} {\\log n})$，其中$w$为$\\text{Miller_Rabin}$筛选次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const int N=2e5+10;int notpri[N],pri[N],pc;ll qpow(ll x,ll k=P-2,int P=::P) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int Trans(int x)&#123; static int buf[20],l=0; l=0; while(x) buf[++l]=x%2,x/=2; int s=0; drep(i,l,1) s=s*3+buf[i]; cmax(ma,s); return s;&#125;int Miller_Rabin(int x) &#123; if(x&lt;N) return !notpri[x]; if(x==2) return 1; if(x&lt;=1 || ~x&amp;1) return 0; ll s=0,t=x-1; while(~t&amp;1) s++,t&gt;&gt;=1; rep(i,1,4) &#123; ll a=pri[rand()%pc+1],b=qpow(a,t,x),c; rep(j,1,s) &#123; c=1ll*b*b%x; if(c==1 &amp;&amp; b!=1 &amp;&amp; b!=x-1) return 0; b=c; &#125; if(b!=1) return 0; &#125; return 1;&#125;int CheckSqr(int n)&#123; int y=round(sqrt(n)); return y*y==n;&#125;int Count(int n)&#123; int res=1; for(int i=1;i&lt;=pc &amp;&amp; pri[i]*pri[i]*pri[i]&lt;=n;++i) if(n%pri[i]==0) &#123; int c=0; while(n%pri[i]==0) n/=pri[i],c++; res*=c+1; &#125; if(n==1) return res; if(CheckSqr(n)) return res*3; if(Miller_Rabin(n)) return res*2; return res*4;&#125;void Init()&#123; rep(i,2,N-1) if(!notpri[i]) &#123; pri[++pc]=i; for(int j=i+i;j&lt;N;j+=i) notpri[j]=1; &#125;&#125; Part2 快速计算答案$10^9$以内的数，最大因子个数为$1334$，这个数为$931170240$ 转成二进制之后最多包含$11$位，三进制下最大为$3^{11}-1=177146$，令这个上界为$M$ 一种非常暴力的方法就是直接枚举，$NM$计算每次选择一个数，复杂度为$O(NMK)$，应该可以通过$N\\leq 12$的数据 一个比较浅显的优化可以用快速幂维护乘法，复杂度为$O(M^2\\log K)$ 由于是3进制类异或，接下来考虑用$\\text{3-FWT}$优化乘法，可以参考 模数为$P=10^9+7$，不存在整数$3$阶单位根，因此要用类似拆系数$\\text{FFT}$方法做 复杂度为$O(M\\log M\\log K)$，似乎已经比较小了，但是常数非常大，应该难以通过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108int R;// R为上界struct Cp&#123; db x,y; Cp()&#123; &#125; Cp(db x,db y):x(x),y(y) &#123; &#125; Cp operator + (const Cp t)&#123; return Cp(x+t.x,y+t.y); &#125; Cp operator - (const Cp t)&#123; return Cp(x-t.x,y-t.y); &#125; Cp operator * (const Cp t)&#123; return Cp(x*t.x-y*t.y,x*t.y+y*t.x); &#125;&#125; A[N],B[N],C[N],D[N];Cp w[30];int Add(int x,int y) &#123; static int A[20],B[20]; rep(i,0,19) A[i]=x%3,x/=3; rep(i,0,19) B[i]=y%3,y/=3; int ans=0; drep(i,19,0) ans=ans*3+((A[i]+B[i])%3); return ans;&#125;void FWT(Cp *a,int f) &#123; for(int i=1;i&lt;R;i*=3) &#123; for(int l=0;l&lt;R;l+=i*3) &#123; for(int j=l;j&lt;l+i;++j) &#123; static Cp t[3]; if(f==1) &#123; t[0]=a[j]+a[j+i]+a[j+i*2]; t[1]=a[j]+w[1]*a[j+i]+w[2]*a[j+i*2]; t[2]=a[j]+w[2]*a[j+i]+w[1]*a[j+i*2]; &#125; else &#123; t[0]=a[j]+a[j+i]+a[j+i*2]; t[1]=a[j]+w[2]*a[j+i]+w[1]*a[j+i*2]; t[2]=a[j]+w[1]*a[j+i]+w[2]*a[j+i*2]; &#125; a[j]=t[0],a[j+i]=t[1],a[j+i*2]=t[2]; if(f==-1) &#123; rep(d,0,2) &#123; a[j+i*d].x/=3,a[j+i*d].y/=3; &#125; &#125; &#125; &#125; &#125;&#125;const int S=(1&lt;&lt;15)-1;#define FWTsstruct Poly&#123; int a[N]; Poly operator * (const Poly __) const &#123; Poly res; // 拆系数，任意模数3-FWT#ifdef FWTs rep(i,0,R-1) A[i]=Cp((a[i]&amp;S),(a[i]&gt;&gt;15)),B[i]=Cp((a[i]&amp;S),0); rep(i,0,R-1) C[i]=Cp((__.a[i]&amp;S),(__.a[i]&gt;&gt;15)); FWT(A,1),FWT(B,1),FWT(C,1);#define E(x) ((ll)(x+0.5))%P rep(i,0,R-1) A[i]=A[i]*C[i]; rep(i,0,R-1) B[i]=B[i]*C[i]; FWT(A,-1),FWT(B,-1); rep(i,0,R-1) &#123; ll a=E(B[i].x),b=E(A[i].y),c=E(B[i].x-A[i].x); res.a[i]=(a+1ll*b*(S+1)+1ll*c*(S+1)*(S+1))%P; &#125;#else rep(i,0,R-1) res.a[i]=0; rep(i,0,R-1) if(a[i]) rep(j,0,R-1) if(__.a[j]) &#123; int k=Add(i,j); res.a[k]=(res.a[k]+1ll*a[i]*__.a[j])%P; &#125;#endif return res; &#125;&#125; x,res;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int main()&#123; rep(i,2,N-1) if(!notpri[i]) &#123; pri[++pc]=i; for(int j=i+i;j&lt;N;j+=i) notpri[j]=1; &#125; w[0]=Cp(1,0); rep(i,1,29) w[i]=w[i-1]*Cp(cos(2*Pi/3),sin(2*Pi/3)); // 复平面3阶单位根 n=rd(),m=rd(); rep(i,1,n) x.a[Count(rd())]++; for(R=1;R&lt;=ma;R*=3); res.a[0]++; for(;m;m&gt;&gt;=1) &#123; if(m&amp;1) res=res*x; x=x*x; &#125; int ans=0; rep(i,1,R-1) ans+=res.a[i],Mod1(ans); printf(&quot;%d\\n&quot;,ans);&#125; Further对于形式幂级数多项式，我们知道$K$次幂的循环卷积可以直接 $\\text{DFT}$一次，每一位快速幂，然后$\\text{IDFT}$ 同理的，如果你学习了$\\text{K-FWT}$就知道这就是一个按$K$进制位，每一位分别进行循环卷积，因此也可以用类似的方法做 但是遇到一个非常大的问题就是无法找到模意义下的$3$阶单位根(指$3\\not |(P-1)$) 如果用复平面单位根$\\omega_n=cos(\\frac{2\\pi} {n})+sin(\\frac{2\\pi} {n})\\cdot i$($i=\\sqrt {-1})$，无法在计算时保证值域精度 这里由于$n=3$比较特殊，发现$\\omega_3=cos(\\frac{2\\pi} {3})+sin(\\frac{2\\pi} {3})\\cdot i=-\\frac{1} {2}+\\frac{\\sqrt 3} {2}\\cdot i$ 而$3$在$\\mod 10^9+7$下存在二次剩余，因此可以用一个模意义下的复数描述复平面单位根 应该是有通行的单位根求法，会根据$n$不同要用更复杂的高维复数描述，但是我并不会.jpg 总复杂度为$O(M(\\log M+\\log K))$，分别为进行$\\text{3-FWT}$以及快速幂的复杂度 Code总览: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;bool Mbe;const int N=2e5,P=1e9+7;const int Quad3=82062379; // 3在Mod P意义下的二次剩余const db Pi=acos((db)-1);const int MaxX=931170240;int n,m,ma,R;int notpri[N],pri[N],pc;ll qpow(ll x,ll k=P-2,int P=::P) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int Trans(int x)&#123; static int buf[20],l=0; l=0; while(x) buf[++l]=x%2,x/=2; int s=0; drep(i,l,1) s=s*3+buf[i]; cmax(ma,s); return s;&#125;int Miller_Rabin(int x) &#123; if(x&lt;N) return !notpri[x]; if(x==2) return 1; if(x&lt;=1 || ~x&amp;1) return 0; ll s=0,t=x-1; while(~t&amp;1) s++,t&gt;&gt;=1; rep(i,1,4) &#123; ll a=pri[rand()%pc+1],b=qpow(a,t,x),c; rep(j,1,s) &#123; c=1ll*b*b%x; if(c==1 &amp;&amp; b!=1 &amp;&amp; b!=x-1) return 0; b=c; &#125; if(b!=1) return 0; &#125; return 1;&#125;int CheckSqr(int n)&#123; int y=round(sqrt(n)); return y*y==n;&#125;int Count(int n)&#123; int res=1; for(int i=1;i&lt;=pc &amp;&amp; pri[i]*pri[i]*pri[i]&lt;=n;++i) if(n%pri[i]==0) &#123; int c=0; while(n%pri[i]==0) n/=pri[i],c++; res*=c+1; &#125; if(n==1) return res; if(CheckSqr(n)) return res*3; if(Miller_Rabin(n)) return res*2; return res*4;&#125;struct Cp&#123; int x,y; Cp()&#123; &#125; Cp(int x,int y):x(x),y(y) &#123; &#125; Cp operator + (const Cp t)&#123; Cp res(x+t.x,y+t.y); Mod1(res.x),Mod1(res.y); return res; &#125; Cp operator * (const Cp t)&#123; return Cp((1ll*x*t.x+1ll*(P-y)*t.y)%P,(1ll*x*t.y+1ll*y*t.x)%P); &#125;&#125; A[N]; // 模意义下 模拟复平面单位根Cp w1,w2; // 3阶单位根及其平方Cp qpow(Cp x,ll k=P-2) &#123; Cp res(1,0); for(;k;k&gt;&gt;=1,x=x*x) if(k&amp;1) res=res*x; return res;&#125;// 下面是展开的FWT式子void FWT() &#123; for(int i=1;i&lt;R;i*=3) &#123; for(int l=0;l&lt;R;l+=i*3) &#123; for(int j=l;j&lt;l+i;++j) &#123; Cp a=A[j]+A[j+i]+A[j+i*2]; Cp b=A[j]+w1*A[j+i]+w2*A[j+i*2]; Cp c=A[j]+w2*A[j+i]+w1*A[j+i*2]; A[j]=a,A[j+i]=b,A[j+i*2]=c; &#125; &#125; &#125;&#125;void IFWT() &#123; for(int i=1;i&lt;R;i*=3) &#123; for(int l=0;l&lt;R;l+=i*3) &#123; for(int j=l;j&lt;l+i;++j) &#123; Cp a=A[j]+A[j+i]+A[j+i*2]; Cp b=A[j]+w2*A[j+i]+w1*A[j+i*2]; Cp c=A[j]+w1*A[j+i]+w2*A[j+i*2]; A[j]=a,A[j+i]=b,A[j+i*2]=c; &#125; &#125; &#125; ll base=qpow(R); rep(i,0,R-1) A[i].x=A[i].x*base%P;&#125;int main()&#123; rep(i,2,N-1) if(!notpri[i]) &#123; pri[++pc]=i; for(int j=i+i;j&lt;N;j+=i) notpri[j]=1; &#125; w1=Cp(P-(P+1)/2,1ll*Quad3*(P+1)/2%P); w2=w1*w1; rep(kase,1,rd()) &#123; n=rd(),m=rd(); rep(i,1,n) A[Trans(Count(rd())-1)].x++; for(R=1;R&lt;=ma;R*=3); FWT(); rep(i,0,R-1) A[i]=qpow(A[i],m); IFWT(); int ans=0; rep(i,1,R-1) ans+=A[i].x,Mod1(ans); rep(i,0,R-1) A[i].x=A[i].y=0; printf(&quot;%d\\n&quot;,ans); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codechef","slug":"Codechef","permalink":"http://chasingdeath.github.io/tags/Codechef/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「2019五校联考-雅礼」大凯的疑惑              ","slug":"「2019五校联考-雅礼」大凯的疑惑              ","date":"2020-11-14T00:48:28.000Z","updated":"2021-05-22T03:54:11.122Z","comments":true,"path":"articles/2020/11/14/b2bb6508.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/14/b2bb6508.html","excerpt":"","text":"「2019五校联考-雅礼」大凯的疑惑首先判断是否有无穷解，即判断$\\gcd(a,b)&gt;1$时有无穷解 接下来我们由小凯的疑惑知道最大的无法表示的数是$ab-a-b$，这能确定一个上界 考虑计算$1,R$中能用$a,b$表示出来的数 因为$\\gcd(a,b)=1,R&lt;ab$，所以每个数最多只有一种构成法，可以枚举其包含了几个$b$，剩下的部分直接任意放$a$ 即得到计算能够被构成的个数的方法为$\\begin{aligned}\\sum_{i=0}^{\\lfloor \\frac{R} {a}\\rfloor} \\lfloor \\frac{R-ib} {a}\\rfloor+1 \\end{aligned}$ 其中+1是计算了包含0个$a$的情况 如果二分答案，复杂度为$O(a\\log (ab))$，恐怕难以通过 优化： 我的思路是是先确定了$\\lfloor \\frac{R} {a}\\rfloor$，那么此时确定了所有$b$的个数的贡献 那么考虑枚举，找到答案所属的$\\lfloor \\frac{R} {a}\\rfloor$的区间，在这段区间里，判断一个数$x$是否可以被构成即: $x\\equiv ib\\pmod a(i\\leq \\lfloor \\frac{R} {a}\\rfloor)$，即考虑了不同$b$的个数的贡献 用一个数组存下$ib\\bmod a$，那么可以$O(1)$判断一个数是否合法，如果直接for过去是$O(b)$的 显然这在一段中，构成情况每$a$个一循环，那么先快速跳循环即可 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)const int N=2e7+10;ll a,b,k;ll gcd(ll a,ll b)&#123; return b==0?a:gcd(b,a%b); &#125;bool mk[N];int main() &#123; freopen(&quot;math.in&quot;,&quot;r&quot;,stdin),freopen(&quot;math.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;k); if(gcd(a,b)!=1 || a==1) return puts(&quot;-1&quot;),0; if(a&gt;b) swap(a,b); if(k==1) return printf(&quot;%lld\\n&quot;,a*b-a-b),0; ll s=(a-1)*(b-1)/2,c=0; // s为总的个数 if(s&lt;k) return puts(&quot;-1&quot;),0; k=s-k+1; // 改为求第k小 int p=mk[0]=1; // p为所属区间 rep(i,1,a-1) &#123; c+=i*b/a; ll t=i*(b-1)-c; // t为这段区间内无法被表示的个数 if(t&gt;=k)&#123; p=i; break; &#125; mk[i*b%a]=1; // 把区间内的ib mod a 放进去 &#125; k-=(p-1)*(b-1)-(c-p*b/a); //还需要做的个数 ll l=(p-1)*b+1,d=l%a; //l为区间开始位置 ll i=l+(k-1)/(a-p)*a; // 每个长度为a的循环中已经有p个位置被标记，可以被表示，因此还有a-p个位置无法表示 k-=(k-1)/(a-p)*(a-p); // 跳过循环 for(;;++i,d++,d==a&amp;&amp;(d=0)) if(!mk[d] &amp;&amp; --k==0) return printf(&quot;%lld\\n&quot;,i),0; // 暴力for最后a个&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"CodeChef 2020 November Challenge - Scalar Product Tree (莫队)","slug":"CodeChef 2020 November Challenge - Scalar Product Tree (莫队)","date":"2020-11-13T06:26:18.000Z","updated":"2021-05-22T03:54:10.912Z","comments":true,"path":"articles/2020/11/13/4e259898.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/13/4e259898.html","excerpt":"","text":"CodeChef 2020 November Challenge - Scalar Product Tree (莫队)题目大意：给定一棵根为1的树，每个点有权值$A_i$，每个点按照其从根开始的路径记录下来一串数$(A_1,\\cdots,A_u)$构成一个向量$v_u$ 每次查询两个点$(x,y)$，查询$v_x\\cdot v_y$ \\由于向量点积是对位相乘的，不好用数据结构维护 考虑用一个序列描述$\\text{dfs}$遍历树时每个点入栈出栈的过程，扫描一段前缀即可得到遍历到每个点时$\\text{dfs}$栈的情况，也就得到了题目指定的向量 每次查询两个点$x,y$，那么就是查询了两段前缀，用莫队维护两个前缀指针的移动，同时维护每个深度上两个前缀对应的值以及这些值的乘积即可 复杂度为$O(n\\sqrt n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair &lt;int,int&gt; Pii;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=6e5+10,P=1e9+7;int n,m;struct Edge&#123; int to,nxt;&#125;e[N];int head[N],ecnt;void AddEdge(int u,int v) &#123; e[++ecnt]=(Edge)&#123;v,head[u]&#125;; head[u]=ecnt;&#125;int id[N],dfn;typedef unsigned U;U A[N];int L[N],K[N]; // L,K维护括号序列，L为编号,K为左括号还是右括号U Sum,Ans[N];int dep[N];void dfs(int u,int f) &#123; L[id[u]=++dfn]=u,K[dfn]=1; dep[u]=dep[f]+1; for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(v==f) continue; dfs(v,u); &#125; L[++dfn]=u,K[dfn]=-1;&#125;int len;struct Que&#123; int l,r,id; bool operator &lt; (const Que __) const &#123; if(l/len!=__.l/len) return l/len&lt;__.l/len; return ((l/len)&amp;1)?r&lt;__.r:r&gt;__.r; &#125;&#125; Q[N];U S[2][N];void Add(int d,int x,int k) &#123; int p=dep[x]; Sum-=S[d][p]*S[!d][p]; S[d][p]=k==1?A[x]:0; Sum+=S[d][p]*S[!d][p];&#125;int main() &#123; n=rd(),m=rd(); rep(i,1,n) A[i]=rd(); rep(i,2,n) &#123; int u=rd(),v=rd(); AddEdge(u,v),AddEdge(v,u); &#125; dfs(1,0),len=sqrt(dfn); rep(i,1,m) &#123; int l=rd(),r=rd(); l=id[l],r=id[r]; if(l&gt;r) swap(l,r); Q[i]=(Que)&#123;l,r,i&#125;; &#125; sort(Q+1,Q+m+1); int l=1,r=1; Add(0,1,1),Add(1,1,1); rep(i,1,m) &#123; while(l&lt;Q[i].l) ++l,Add(0,L[l],K[l]); while(l&gt;Q[i].l) Add(0,L[l],-K[l]),l--; while(r&lt;Q[i].r) ++r,Add(1,L[r],K[r]); while(r&gt;Q[i].r) Add(1,L[r],-K[r]),r--; Ans[Q[i].id]=Sum; &#125; rep(i,1,m) printf(&quot;%u\\n&quot;,Ans[i]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codechef","slug":"Codechef","permalink":"http://chasingdeath.github.io/tags/Codechef/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CodeChef 2020 November Challenge - Red-Black Boolean Expression","slug":"CodeChef 2020 November Challenge - Red-Black Boolean Expression","date":"2020-11-13T06:10:40.000Z","updated":"2021-05-22T03:54:10.904Z","comments":true,"path":"articles/2020/11/13/390cee77.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/13/390cee77.html","excerpt":"","text":"CodeChef 2020 November Challenge - Red-Black Boolean Expression吐槽：这题很蠢，很套路 题目大意： 给定$n$个布尔变量$x_i$，每个变量有其反变量$ \\overline {x_i}$ 有$n$组关系$a_i,b_i$，要求$a_i\\lor b_i$为真 并且保证所有$a_i,b_i$关系构成一张二分图，其中$x_i$与$\\overline{x_i}$有一条边相连 给定每个变量的初始值$s_i$，以及翻转其所需的代价$C_i$，求最小满足条件的代价 \\$a_i\\lor b_i$为真即不存在$a_i,b_i$均为假的情况 如果是2-sat上的理解，即可以由$a_i$假推$b_i$真，$b_i$假推$a_i$真，但是$2-sat$没法带权 由于题目保证了关系的二分图性质，不妨把所有变量分成两个集合$A,B$ 这个问题令人联想到网络流最小割模型，我们用一条边$(u,v)$限制$(u,v)$不同时为假的情况 对于$A$中的点，我们令源点$S$向$u$连的边$(S,u,w)$表示$u$变成$0$所需代价，令$(u,T,w)$表示$u$变成1的代价 对于$B$中的点，采取相反的连接方式 任意一个关系的两点不在同一集合，不妨对于$u\\in A$的情况考虑，实际上可以分为两类考虑 1.$(u,v)$不同时为0，那么连接一条边$(v,u,\\infty)$，表示如果合法必然有一条让$u$或$v$变成1的边被割掉 2.$(u,v)$不同时为1，连接一条边$(v,u,\\infty)$，原理类似 然后就可以跑网络流最小割了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef unsigned long long ull;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1e5+10,INF=1e9+10;int n,m,S,T;char s[N];struct Edge&#123; int to,nxt,w;&#125;e[N&lt;&lt;1];int head[N],ecnt=1;void AddEdge(int u,int v,int w) &#123; e[++ecnt]=(Edge)&#123;v,head[u],w&#125;; head[u]=ecnt;&#125;void Link(int u,int v,int w)&#123; AddEdge(u,v,w),AddEdge(v,u,0);&#125;int F[N],X[N],Y[N],col[N],A[N];// 这里我用带权并查集实现了二分图int Find(int x)&#123; if(F[x]==x) return x; int f=F[x]; F[x]=Find(F[x]); col[x]^=col[f]; return F[x];&#125;int dis[N];int Bfs() &#123; rep(i,1,T) dis[i]=INF; static queue &lt;int&gt; que; dis[S]=0; que.push(S); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to,w=e[i].w; if(!w || dis[v]&lt;=dis[u]+1) continue; dis[v]=dis[u]+1,que.push(v); &#125; &#125; return dis[T]&lt;INF;&#125;int Dfs(int u,int in) &#123; if(u==T) return in; int out=0; for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to,w=e[i].w; if(!w || dis[v]!=dis[u]+1) continue; int t=Dfs(v,min(in-out,w)); e[i].w-=t,e[i^1].w+=t,out+=t; if(in==out) break; &#125; if(!out) dis[u]=0; return out;&#125;int Dinic() &#123; int ans=0; while(Bfs()) ans+=Dfs(S,INF); return ans;&#125;int main() &#123; rep(kase,1,rd()) &#123; n=rd(),m=rd(); rep(i,1,n) F[i]=i,col[i]=0; scanf(&quot;%s&quot;,s+1); S=n+1,T=n+2; rep(i,1,n) A[i]=rd(); rep(i,1,m) &#123; X[i]=rd(),Y[i]=rd(); int x=abs(X[i]),y=abs(Y[i]); int u=Find(x),v=Find(y); if(u==v) continue; F[u]=v,col[u]=col[x]^col[y]^(X[i]&lt;0)^(Y[i]&lt;0)^1; &#125; rep(i,1,n) Find(i); rep(i,1,n) &#123; if(col[i]^s[i]^&#x27;0&#x27;) Link(S,i,A[i]); else Link(i,T,A[i]); &#125; rep(i,1,m) &#123; int t=col[abs(X[i])]^(X[i]&lt;0); assert(col[abs(X[i])]^col[abs(Y[i])]^(X[i]&lt;0)^(Y[i]&lt;0)); if(t) Link(abs(X[i]),abs(Y[i]),INF); else Link(abs(Y[i]),abs(X[i]),INF); &#125; printf(&quot;%d\\n&quot;,Dinic()); rep(i,1,T) head[i]=0; ecnt=1; &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codechef","slug":"Codechef","permalink":"http://chasingdeath.github.io/tags/Codechef/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"Codechef November Chanllenge 2019 Div1 PrettyBox (贪心，线段树)","slug":"Codechef November Chanllenge 2019 Div1 PrettyBox (贪心，线段树)","date":"2020-11-11T07:56:34.000Z","updated":"2021-05-22T03:54:10.926Z","comments":true,"path":"articles/2020/11/11/c756e26.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/11/c756e26.html","excerpt":"","text":"Codechef November Chanllenge 2019 Div1 PrettyBox (贪心，线段树)原题链接 前言：这篇文章主要讲如何用线段树优化贪心，关于贪心的证明建议看官方题解 贪心思路： 首先肯定要按照$(S_i,P_i)$递增的顺序排序 每次选取两个点，一个标记为左括号，权值为$-P_i$，一个标记为右括号，权值为$P_i$，显然只要是一个合法的括号序列即可 题解证明了在不断增加括号时，不会出现一个位置的括号情况改变 现在我们的贪心问题就在于怎样找到一对最优的括号，注意每次选出的 两个括号之间并不一定匹配 为了便于描述，把左括号看做1，右括号看做-1，一个合法括号序列满足任何一个前缀和$\\ge 0$ 考虑什么样的情况可以放置左右括号，设分别放在$x,y$ 1.$x&lt;y$显然合法 2.$x&gt;y$时，如果存在一个括号对，将$(x,y)$包含在一起，即$(y,x)$这一段区间不跨过一个前缀和为$0$的位置 如果把序列 看做 由一段段 前缀和为0的位置 分割开来的 一个个联通块，似乎比较好理解 也就是块内随意选，之间只能由小到大匹配 接下来考虑用线段树维护这样的块的信息，下面只讨论$x&gt;y$的情况 由于线段树每个结点统计区间$[l,r]$的信息，所以实际上块之间的间隔并不为0 设$[l,r]$中最小的前缀和为$Min$(是指从$l$开始的前缀和) 不妨统计$[l,r]$中不跨过一个前缀和为$Min$的位置的答案$Ans$，以及跨过的答案$Ans2$ 合并两个区间时，需要找到 左区间中 右边连续的一段不跨过最小值 的最大权值 $R$ 右区间中 左边连续的一段不跨过最小值 的最小权值 $L$ 以及任意的最小值最大值$mi,ma$ 然后按照$Min$的权值大小关系 ，判断这4种权值的合并应该被分配到$Ans$还是$Ans2$ 合并$L,R$时注意$L$优先看左儿子，$R$优先看右儿子，具体实现看代码中的$Up$函数 每次存下答案找到最优配对后，在序列上对应放置-1,1单点修改即可，复杂度为$O(n\\log n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; a=min(a,b); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; a=max(a,b); &#125;char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=2e5+10,M=N&lt;&lt;2;int n;Pii T[N];int A[N];int S[M]; // 区间和int Min[M]; // 前缀最小值struct Node&#123; int x; Node()&#123; &#125; Node(int x):x(x)&#123; &#125; int operator &lt; (const Node __) const &#123; return A[x]&lt;A[__.x]; &#125;&#125; L[M],R[M]; // 左最小，右最大 , 记录的是不跨过最小值的权值Node mi[M],ma[M]; // 区间最大最小，没有限制struct Pair&#123; int x,y; Pair()&#123; &#125; Pair(int x,int y):x(x),y(y)&#123; &#125; Pair(Node x,Node y):x(x.x),y(y.x)&#123; &#125; int Val() const &#123; return A[y]-A[x]; &#125; int operator &lt; (const Pair __) const &#123; return Val()&lt;__.Val(); &#125;&#125; Ans[M],Ans2[M]; // 不跨过最小值的答案以及x&lt;y的答案，包含最小值的答案// 区间答案void Up(int p)&#123; S[p]=S[p&lt;&lt;1]+S[p&lt;&lt;1|1]; Min[p]=min(Min[p&lt;&lt;1],S[p&lt;&lt;1]+Min[p&lt;&lt;1|1]); mi[p]=min(mi[p&lt;&lt;1],mi[p&lt;&lt;1|1]),ma[p]=max(ma[p&lt;&lt;1],ma[p&lt;&lt;1|1]); Ans[p]=max(Ans[p&lt;&lt;1],Ans[p&lt;&lt;1|1]); Ans2[p]=Pair(mi[p&lt;&lt;1|1],ma[p&lt;&lt;1]); cmax(Ans2[p],Ans2[p&lt;&lt;1]); cmax(Ans2[p],Ans2[p&lt;&lt;1|1]); cmax(Ans[p],Pair(mi[p&lt;&lt;1],ma[p&lt;&lt;1|1])); Ans[p]=max(Ans[p],Pair(L[p&lt;&lt;1|1],R[p&lt;&lt;1])); if(Min[p&lt;&lt;1]!=Min[p]) &#123; cmax(Ans[p],Ans2[p&lt;&lt;1]); cmax(Ans[p],Pair(L[p&lt;&lt;1|1],ma[p&lt;&lt;1])); L[p]=min(mi[p&lt;&lt;1],L[p&lt;&lt;1|1]); &#125; else &#123; L[p]=L[p&lt;&lt;1]; &#125; if(S[p&lt;&lt;1]+Min[p&lt;&lt;1|1]!=Min[p]) &#123; cmax(Ans[p],Ans2[p&lt;&lt;1|1]); cmax(Ans[p],Pair(mi[p&lt;&lt;1|1],R[p&lt;&lt;1])); R[p]=max(R[p&lt;&lt;1],ma[p&lt;&lt;1|1]); &#125; else &#123; R[p]=R[p&lt;&lt;1|1]; &#125;&#125;void Build(int p,int l,int r)&#123; if(l==r) &#123; S[p]=Min[p]=0; L[p]=n+1,R[p]=n+2; mi[p]=ma[p]=l; Ans[p]=Ans2[p]=Pair(n+1,n+2); return; &#125; int mid=(l+r)&gt;&gt;1; Build(p&lt;&lt;1,l,mid),Build(p&lt;&lt;1|1,mid+1,r); Up(p);&#125;void Upd(int p,int l,int r,int x,int k) &#123; if(l==r) &#123; S[p]=Min[p]=k; L[p]=n+1,R[p]=n+2; mi[p]=n+1,ma[p]=n+2; Ans[p]=Ans2[p]=Pair(n+1,n+2); return; &#125; int mid=(l+r)&gt;&gt;1; x&lt;=mid?Upd(p&lt;&lt;1,l,mid,x,k):Upd(p&lt;&lt;1|1,mid+1,r,x,k); Up(p);&#125;int main()&#123; rep(i,1,n=rd()) T[i].first=rd(),T[i].second=rd(); sort(T+1,T+n+1); rep(i,1,n) A[i]=T[i].second; A[n+1]=1e9+10,A[n+2]=-1e9-10; ll ans=0; int i=1; Build(1,1,n); while(i&lt;=n/2) &#123; Pair res=Ans[1]; if(res.Val()&lt;=0) break; printf(&quot;%lld\\n&quot;,ans+=res.Val()); Upd(1,1,n,res.x,1),Upd(1,1,n,res.y,-1); i++; &#125; while(i&lt;=n/2) printf(&quot;%lld\\n&quot;,ans),i++;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Codechef","slug":"Codechef","permalink":"http://chasingdeath.github.io/tags/Codechef/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「2019 集训队互测 Day 1」最短路径  (点分治+NTT/FFT+线段树)","slug":"「2019 集训队互测 Day 1」最短路径  (点分治+NTT FFT+线段树)","date":"2020-11-10T08:23:37.000Z","updated":"2021-05-22T03:54:11.119Z","comments":true,"path":"articles/2020/11/10/ee49be2f.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/10/ee49be2f.html","excerpt":"","text":"「2019 集训队互测 Day 1」最短路径 (点分治+NTT/FFT+线段树)题意：给定了一棵基环树，求所有的$d(u,v)^k$的期望 当$k$较小时，可以想到用斯特林数/二项式定理展开 维护+1操作，对于树的可以从儿子合并上来，对于环上可以枚举每个块求得答案 复杂度为$O(nk)$ 当图为一棵树时，由于不好处理$x^k$，考虑直接求出$d(u,v)=i$的数量 比较容易想到用用点分治+$\\text{NTT}$求解，复杂度为$O(n\\log ^2n)$ 环上的情况比较麻烦，不妨为每个块标号$1,2,\\cdots m$，每个块包含$sz_i$个结点 显然$(i,j)$的距离为$\\min\\lbrace|i-j|,m-|i-j|\\rbrace$ 考虑计算所有块$(i,j)(i&lt;j)$之间的贡献，令$d=\\lfloor \\frac{m} {2}\\rfloor $，则对于$j\\in[i+1,i+d]$在环上的距离为$j-i$，否则距离为$m-(j-i)$ 对于两种情况分类讨论，这里以计算$j\\in[i+1,i+d]$为例 因为是一段区间，考虑直接在线段树的$[i+1,i+d]$加入$i$，然后对于线段树上每个结点计算 推论1：能够被添加到线段树结点$[l,r]$上的$i$构成一段连续的区间 推论2：从区间$[l,r]$的一端出发，$\\text{dfs}$区间内的块得到的$\\max dis_u\\leq \\sum_{i=l}^r sz_i$ 因此同样考虑用$\\text{NTT}$维护该答案，每次更新答案可以看做是区间$[l1,r1],l2,r2$之间的贡献 分别从$r1,l2$开始$\\text{dfs}$得到$dis_u$，然后$\\text{NTT}$合并，不把$[r1+1,l2-1]$这一部分在环上的加入$\\text{NTT}$大小 这样就能保证卷积大小$\\leq \\sum_{i=l1}^{r1} sz_i+\\sum_{i=l2}^{r2} sz_i$ 同理可以类似处理$j&gt;i+d$的情况 分析复杂度：每个$i$会出现在线段树上$\\log n$个位置，每个$j$会在线段树上$\\log n$层被计算 因此每个点被加入卷积大小的次数为$O(\\log n)$，复杂度为$O(n\\log ^2 n)$与前面的点分治同阶 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;bool Mbe;const int N=1&lt;&lt;18|10,P=998244353;int n,m,k;int A[N];ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int Pow[N];struct Edge&#123; int to,nxt;&#125;e[N];int head[N],ecnt,deg[N];void AddEdge(int u,int v) &#123; e[++ecnt]=(Edge)&#123;v,head[u]&#125;; head[u]=ecnt,deg[v]++;&#125;#define erep(u,i) for(int i=head[u];i;i=e[i].nxt)int w[N];void Init() &#123; int R=1&lt;&lt;18; int t=qpow(3,(P-1)/R); w[R/2]=1; rep(i,R/2+1,R-1) w[i]=1ll*w[i-1]*t%P; drep(i,R/2-1,1) w[i]=w[i&lt;&lt;1];&#125;int rev[N];void NTT(int n,int *a,int f) &#123; static int e[N&gt;&gt;1]; rep(i,0,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int i=e[0]=1,t;i&lt;n;i&lt;&lt;=1) &#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,Mod2(a[j+i]); a[j]+=t,Mod1(a[j]); &#125; &#125; &#125; if(f==-1) &#123; reverse(a+1,a+n); ll base=qpow(n); rep(i,0,n-1) a[i]=a[i]*base%P; &#125;&#125;int Init(int n) &#123; int R=1,c=-1; while(R&lt;=n) R&lt;&lt;=1,c++; rep(i,0,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;c); return R;&#125;int Q[N],L,R,vis[N];namespace pt1&#123; const int N=1010; int dis[N]; void Bfs(int u) &#123; rep(i,1,n) dis[i]=-1; dis[Q[L=R=1]=u]=0; while(L&lt;=R) &#123; u=Q[L++]; erep(u,i)&#123; int v=e[i].to; if(~dis[v]) continue; dis[v]=dis[u]+1,Q[++R]=v; &#125; &#125; &#125; void Solve() &#123; int ans=0; rep(i,2,n) &#123; Bfs(i); rep(j,1,i-1) ans=(ans+Pow[dis[j]])%P; &#125; ans=ans*qpow(n*(n-1)/2)%P; printf(&quot;%d\\n&quot;,ans); &#125;&#125;int Ans[N],sz[N];namespace pt2&#123; int mi=1e9,rt; void FindRt(int n,int u,int f) &#123; int ma=0; sz[u]=1; erep(u,i) &#123; int v=e[i].to; if(v==u || v==f || vis[v]) continue; FindRt(n,v,u),sz[u]+=sz[v],cmax(ma,sz[v]); &#125; cmax(ma,n-sz[u]); if(mi&gt;ma) mi=ma,rt=u; &#125; int F[N],A[N],B[N]; void Solve(int n,int k) &#123; // 容斥型 点分治 int R=Init(n*2+1); rep(i,0,R) F[i]=0; rep(i,0,n) F[i]=A[i]; NTT(R,F,1); rep(i,0,R-1) F[i]=1ll*F[i]*F[i]%P; NTT(R,F,-1); if(k==1) rep(i,0,n*2) Ans[i]+=F[i],Mod1(Ans[i]); else rep(i,0,n*2) Ans[i]-=F[i],Mod2(Ans[i]); &#125; int maxd; void dfs(int u,int f,int d=0) &#123; A[d]++,sz[u]=1,cmax(maxd,d); erep(u,i) &#123; int v=e[i].to; if(v==u || v==f || vis[v]) continue; dfs(v,u,d+1),sz[u]+=sz[v]; &#125; &#125; void Divide(int n,int u) &#123; mi=1e9,FindRt(n,u,0),u=rt; vis[u]=1; int D=0;B[0]=1; erep(u,i) &#123; int v=e[i].to; if(vis[v]) continue; maxd=0,dfs(v,u,1); Solve(maxd,-1); rep(j,0,maxd) B[j]+=A[j],A[j]=0; cmax(D,maxd); &#125; rep(i,0,D) A[i]=B[i],B[i]=0; Solve(D,1); rep(i,0,D) A[i]=0; erep(u,i) &#123; int v=e[i].to; if(vis[v]) continue; Divide(sz[v],v); &#125; &#125; void Solve() &#123; rep(i,1,n) vis[i]=0; Divide(n,1); int ans=0; rep(i,1,n) ans=(ans+1ll*Ans[i]*Pow[i])%P; ans=ans*qpow(1ll*n*(n-1)%P)%P; printf(&quot;%d\\n&quot;,ans); &#125;&#125;int QL[N&lt;&lt;2],QR[N&lt;&lt;2];void Add(int p,int l,int r,int ql,int qr,int x) &#123; // 在线段树上加入结点 if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; if(!QL[p]) QL[p]=x; QR[p]=x; return; &#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) Add(p&lt;&lt;1,l,mid,ql,qr,x); if(qr&gt;mid) Add(p&lt;&lt;1|1,mid+1,r,ql,qr,x);&#125;int typ;int X[N],Y[N],D;void dfs(int *C,int u,int f,int d) &#123; cmax(D,d),C[d]++; for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(v==f || vis[v]) continue; dfs(C,v,u,d+1); &#125;&#125;void Mark(int i,int k) &#123; int l=A[i==1?m:i-1],r=A[i==m?1:i+1]; vis[l]=vis[r]=k;&#125;void Get(int p,int l,int r) &#123; if(QL[p]) &#123; // 计算区间QL,QR到l,r的贡献 if(typ==0) &#123; int qr=QR[p]; rep(x,QL[p],QR[p]) Mark(x,1),dfs(X,A[x],0,qr-x),Mark(x,0); int T=D; D=0; rep(x,l,r) Mark(x,1),dfs(Y,A[x],0,x-l),Mark(x,0); int R=Init(T+D+1); NTT(R,X,1),NTT(R,Y,1); rep(i,0,R-1) X[i]=1ll*X[i]*Y[i]%P; NTT(R,X,-1); rep(i,0,T+D) Ans[i+l-qr]+=X[i],Mod1(Ans[i+l-qr]); rep(i,0,R) X[i]=Y[i]=0; &#125; else &#123; int ql=QL[p]; rep(x,QL[p],QR[p]) Mark(x,1),dfs(X,A[x],0,x-ql),Mark(x,0); int T=D; D=0; rep(x,l,r) Mark(x,1),dfs(Y,A[x],0,r-x),Mark(x,0); int R=Init(T+D+1); NTT(R,X,1),NTT(R,Y,1); rep(i,0,R-1) X[i]=1ll*X[i]*Y[i]%P; NTT(R,X,-1); int d=ql+m-r; rep(i,0,T+D) Ans[i+d]+=X[i],Mod1(Ans[i+d]); rep(i,0,R) X[i]=Y[i]=0; &#125; QL[p]=QR[p]=0; &#125; if(l==r) return; int mid=(l+r)&gt;&gt;1; Get(p&lt;&lt;1,l,mid),Get(p&lt;&lt;1|1,mid+1,r);&#125;int main() &#123; freopen(&quot;path.in&quot;,&quot;r&quot;,stdin),freopen(&quot;path.out&quot;,&quot;w&quot;,stdout); n=rd(),k=rd(); rep(i,1,n) Pow[i]=qpow(i,k); rep(i,1,n) &#123; int u=rd(),v=rd(); AddEdge(u,v),AddEdge(v,u); &#125; if(n&lt;=1000) return pt1::Solve(),0; Init(),L=1; // 拓扑求环 rep(i,1,n) if(deg[i]==1) sz[Q[++R]=i]=1; while(L&lt;=R) &#123; int u=Q[L++]; vis[u]=1; for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(deg[v]&lt;=1) sz[u]+=sz[v]; if(--deg[v]==1) Q[++R]=v; &#125; &#125; for(int u=1;u&lt;=n;++u) if(!vis[u]) &#123; while(1) &#123; vis[u]=1,A[++m]=u; int nxt=-1; for(int i=head[u];i;i=e[i].nxt) &#123; int v=e[i].to; if(!vis[v]) nxt=v; &#125; if(nxt==-1) break; u=nxt; &#125; break; &#125; if(m==1) return pt2::Solve(),0; fprintf(stderr,&quot;Circle Length =%d\\n&quot;,m); rep(i,1,n) vis[i]=0; k=m/2; rep(i,1,m) &#123; Mark(i,1); pt2::Divide(sz[A[i]],A[i]); Mark(i,0); &#125; rep(i,1,n) Ans[i]=1ll*Ans[i]*(P+1)/2%P; rep(i,1,n) vis[i]=0; rep(i,1,m-1) Add(1,1,m,i+1,min(i+k,m),i); typ=0,Get(1,1,m); rep(i,1,m-k-1) Add(1,1,m,i+k+1,m,i); typ=1,Get(1,1,m); int ans=0; rep(i,1,n) ans=(ans+1ll*Ans[i]*Pow[i])%P; ans=ans*qpow(1ll*n*(n-1)/2%P)%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「清华集训 2017」小 Y 和二叉树              ","slug":"「清华集训 2017」小 Y 和二叉树              ","date":"2020-11-09T09:01:59.000Z","updated":"2021-05-22T03:54:11.299Z","comments":true,"path":"articles/2020/11/09/c6a7899.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/09/c6a7899.html","excerpt":"","text":"「清华集训 2017」小 Y 和二叉树原题数据好像没有卡这个情况 12345651 22 1 33 2 4 51 31 3 输出是 11 2 3 4 5 首先考虑一个$O(n^2)$的暴力： 枚举一个点为根，向下展开树，此时只需要决策左儿子和右儿子的顺序 当两个子树都存在时，由于两个子树包含的元素不同，所以可以直接把 两个子树序列首较小 (显然不会出现相同的情况) 的一个放在前面即可 实际上我们可以发现，这样得到的序列第一个元素必然是 编号最小的 、不同时包含左右儿子 的结点 不妨称固定根之后，这样的结点为叶子 \\显然的性质：任何一个度数$\\leq 2$的点可以作为答案序列的第一个点 设原树上最小的$\\leq 2$的点为$root$，接下来对于$root$的不同情况讨论，要在强制$root$为序列首的情况下，求得最小的序列 不妨先预处理出结点$u$子树里最小的叶子$mi_u$ 1.没有相邻结点，结束 2.有两个相邻结点，此时要使自己为序列首，必然有一个结点是自己的父亲，有一个结点是自己的右儿子 右儿子会被先遍历到，所以可以直接考虑比较两个相邻结点 作为 右儿子时谁的序列首 较小 即比较两个子树中最小的叶子即可 3.只有一个相邻结点，设其为$v$ 此时要使得自己为序列第一个，只有两种可能，此时同样可以考虑比较序列首元素 3-1.让相邻结点作为自己的父亲，此时下一个元素一定是$v$ 3-2.让相邻结点作为自己的右儿子，此时下一个元素一定是$mi_v$ 如果$v\\ne mi_v$，显然好决策 当$v=mi_v$时，必然满足$v$是一个叶子，此时如果将$v$放在父亲上，$v$的另一个相邻结点(如果存在) 可以放在$v$的父亲或者是$v$的右子树，如果放在$v$的右子树，那么这种情况与$v$被放在$u$的子树等价 也就是说，把$v$放在父亲可以决策出的序列情况，包含了把$v$放在右儿子的情况 所以这种情况也应当把$v$放在父亲上 实现上，不妨用两个$dfs$处理最后的决策，一个强制当前结点$u$为序列首，一个求出$u$子树的最优方案 在代码里就是$Solve,dfs_get$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1e6+10;int n;int c[N],s[N][3];int mi[N];int rt=1e9;void dfs(int u,int f) &#123; mi[u]=1e9; int cnt=0; rep(i,0,c[u]-1) if(s[u][i]!=f) &#123; int v=s[u][i]; cnt++; dfs(v,u),cmin(mi[u],mi[v]); &#125; if(cnt&lt;=1) cmin(mi[u],u);&#125;int vis[N];void dfs_get(int u) &#123; vis[u]=1; int a=-1,b=-1; rep(i,0,c[u]-1) if(!vis[s[u][i]]) &#123; int v=s[u][i]; if(~a) b=v; else a=v; &#125; if(a==-1) printf(&quot;%d &quot;,u); else if(b==-1) &#123; if(mi[a]&lt;u) dfs_get(a),printf(&quot;%d &quot;,u); else printf(&quot;%d &quot;,u),dfs_get(a); &#125; else &#123; if(mi[a]&gt;mi[b]) swap(a,b); dfs_get(a),printf(&quot;%d &quot;,u),dfs_get(b); &#125;&#125;void Solve(int u) &#123; int cnt=0; rep(i,0,c[u]-1) if(!vis[s[u][i]]) cnt++; vis[u]=1,printf(&quot;%d &quot;,u); if(cnt==1) &#123; rep(i,0,c[u]-1) if(!vis[s[u][i]]) &#123; int v=s[u][i]; if(v&gt;mi[v]) dfs_get(s[u][i]); else Solve(v); &#125; &#125; else if(cnt==2) &#123; int a=-1,b=-1; rep(i,0,c[u]-1) if(!vis[s[u][i]]) &#123; int v=s[u][i]; if(~a) b=v; else a=v; &#125; if(mi[a]&gt;mi[b]) swap(a,b); dfs_get(a),Solve(b); &#125;&#125;int main()&#123; //freopen(&quot;binary.in&quot;,&quot;r&quot;,stdin),freopen(&quot;binary.out&quot;,&quot;w&quot;,stdout); n=rd(); if(n==1) return puts(&quot;1&quot;),0; rep(i,1,n) &#123; c[i]=rd(); if(c[i]&lt;=2) cmin(rt,i); rep(j,0,c[i]-1) s[i][j]=rd(); &#125; dfs(rt,0); Solve(rt);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"[CSP-S 2020 T3] 动物园 (拓扑排序)","slug":"[CSP-S 2020 T3] 动物园 (拓扑排序)","date":"2020-11-08T08:46:05.000Z","updated":"2021-05-22T03:54:11.033Z","comments":true,"path":"articles/2020/11/08/1e683601.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/08/1e683601.html","excerpt":"","text":"[CSP-S 2020 T3] 动物园 (拓扑排序)很难考虑每个操作的顺序，但由于操作比较简单，可以直接考虑每个操作贡献的权值 一个操作的权值可以定义为：每次这个操作执行之后后，后面所有的乘法操作的积 如果没有递归，只需要倒序枚举一次调用情况，就能知道所有的权值 对于递归的情况，显然函数之间的递归关系构成一张拓扑图，可以考虑预处理出每个操作的乘法操作之积 对于所有的函数，同样能得到一个权值，接下来的操作只需要把每个存在递归的函数不断将权值向下传给子函数 如果把最终的调用序列看做一个主函数，那么对于这个操作实际也是一样的做法 即：倒序枚举一次累积，然后乘上自己的权值下传即可 Tips: 最后加入贡献时，注意先将所有数的权值乘上全局乘法倍数，然后再依次处理每个加法操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1e5+10,P=998244353;int n,m;int A[N],T[N],H[N]; // A为原数组，T为乘法积，H为函数调用权值int O[N],X[N],Y[N];int B[N*11],C,L[N],R[N],ind[N];int Q[N],QL,QR;int main() &#123; //freopen(&quot;call.in&quot;,&quot;r&quot;,stdin),freopen(&quot;call.out&quot;,&quot;w&quot;,stdout); rep(i,1,n=rd()) A[i]=rd(); m=rd()+1; // 令m+1号为主函数 rep(i,1,m) &#123; O[i]=i&lt;m?rd():3,T[i]=1; if(O[i]==1) X[i]=rd(),Y[i]=rd(); else if(O[i]==2) T[i]=rd(); else &#123; L[i]=C+1,R[i]=C+=rd(); rep(j,L[i],R[i]) ind[B[j]=rd()]++; &#125; &#125; rep(i,QL=1,m) if(!ind[i]) Q[++QR]=i; while(QL&lt;=QR) &#123; int u=Q[QL++]; if(O[u]==3) rep(j,L[u],R[u]) if(--ind[B[j]]==0) Q[++QR]=B[j]; &#125; drep(k,m,1)&#123; int u=Q[k]; if(O[u]==3) rep(j,L[u],R[u]) T[u]=1ll*T[u]*T[B[j]]%P; &#125; rep(i,H[m]=1,n) A[i]=1ll*A[i]*T[m]%P; rep(k,1,m) &#123; int u=Q[k],x=1; drep(j,R[u],L[u])&#123; int v=B[j]; H[v]=(H[v]+1ll*x*H[u])%P; x=1ll*x*T[v]%P; &#125; if(O[u]==1) A[X[u]]=(A[X[u]]+1ll*H[u]*Y[u])%P; &#125; rep(i,1,n) printf(&quot;%d &quot;,A[i]); puts(&quot;&quot;);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"CSP","slug":"CSP","permalink":"http://chasingdeath.github.io/tags/CSP/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"CTSC2016 香山的树 (KMP+dp)","slug":"CTSC2016 香山的树 (KMP+dp)","date":"2020-11-08T06:25:26.000Z","updated":"2021-05-22T03:54:10.899Z","comments":true,"path":"articles/2020/11/08/4b6d98b6.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/08/4b6d98b6.html","excerpt":"","text":"CTSC2016 香山的树 (KMP+dp)我的做法比较奇怪 约定$\\Sigma$为字符集 显然是要枚举答案，不断增大答案$S$的字典序，求出字典序$&gt;S$的个数，考虑$dp$求解 比较大小可以想到要不断进行前缀匹配，因此考虑 $\\text{kmp}$ 因为要 $dp$ 的是一个循环同构串，不妨直接扩展为无限循环的串，$dp$一个 最小 的循环节 不妨先考虑没有字典序限制的简单情形，也就是抛开$\\text{kmp}$判断字典序，计算长度为$i$的方案数 显然此时一个合法的长度为$i$的串只需要满足$i$中不会出现循环 设$f_i$为最小循环节为$i$的答案，一种Naive的思路是直接拿$|\\Sigma|^i$计算，但是显然长度为$i$的会包含长度为$\\forall d,d|i$的 即$g_i=|\\Sigma|^i=\\sum_{d|i}f(d)$，然后直接$O(n\\ln n)$减去重复部分即可 由于题目要求是最小的循环，因此实际上每个循环有$i$中不同开始位置，所以答案应是$\\frac{f_i} {i}$ 接下来考虑字典序的问题：不妨枚举一个无限循环串$S$的最优匹配位置为$st$，然后$dp$一个长度为$i$的循环节 显然要满足的条件是： 1.$dp$了$i$个字符之后匹配状态为$st$ 2.在$dp$过程中如果$\\text{kmp}$出现失配，必须满足当前字符更大 注意这里有一个问题，当匹配位置恰好等于$|S|$时，可能会将恰好为$S$的情况算入，因此要特判 3.中途不能匹配到比$st$更大的位置 同样的会出现两种重复计算： 1.串内出现了循环 可以考虑同样的容斥方法 2.多个不同的开始位置都合法 这个我的处理方法非常暴力，考虑直接记录匹配过程中恰好为$st$的次数，这些位置都是可能的开始位置 不妨令$dp_{i,j,d}$表示当前$dp$了$i$位，匹配状态为$j$，中途出现了$d$个恰好为$st$的匹配位置 可以得到一个$O(n^3|\\Sigma|)$的暴力dp，算上枚举起始位置，复杂度为$O(n^4|\\Sigma|)$ 由于还需要按位二分答案，所以复杂度为$O(n^5|\\Sigma|\\log |\\Sigma|)$，实际可以通过 一个小优化：每次二分时，只有$st=|S|$或者$st=|S|-1$的部分需要重新$dp$ 因此实际复杂度为$O(n^4|\\Sigma|\\log |\\Sigma|)$ 感觉这个$dp$明显太麻烦了，显然可以删掉一些东西 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;typedef __int128 ll;//本地测试可以改成long long ，并且把下面的U=1e36改为U=1e18#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) f|=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=52,S=26;const ll U=1e36;void chk(ll &amp;a)&#123; a&gt;U &amp;&amp; (a=U); &#125;int n,m;ll k;char s[N];int nxt[N],trans[N][S];void Init_KMP()&#123; rep(i,2,m) &#123; int j=nxt[i-1]; while(j &amp;&amp; s[i]!=s[j+1]) j=nxt[j]; if(s[i]==s[j+1]) j++; nxt[i]=j; &#125; rep(i,0,m) &#123; rep(j,0,S-1) &#123; int k=i,f=1; while(s[k+1]!=j+&#x27;a&#x27;) &#123; f&amp;=j+&#x27;a&#x27;&gt;s[k+1]; if(!k) break; k=nxt[k]; &#125; if(s[k+1]==j+&#x27;a&#x27;) k++; trans[i][j]=f?k:-1; &#125; &#125;&#125;ll dp[N][N][N];ll Ans[N];ll Calc(int k=0)&#123; m=strlen(s+1),Init_KMP(); ll ans=0; rep(st,(k?0:m-1),m) &#123; Ans[st]=0; rep(i,0,n) rep(j,0,st) rep(d,0,n) dp[i][j][d]=0; dp[0][st][0]=1; rep(i,1,n) &#123; rep(j,0,st) rep(d,0,i) if(dp[i-1][j][d])&#123; rep(c,j==m?0:s[j+1]-&#x27;a&#x27;,S-1) if(~trans[j][c]) &#123; chk(dp[i][trans[j][c]][d+(trans[j][c]==st)]+=dp[i-1][j][d]); &#125; &#125; &#125; rep(i,1,n) rep(d,0,n) if(dp[i][st][d]) &#123; if(dp[i][st][d]==U) return U; rep(j,2,min(n/i,n/d)) dp[i*j][st][d*j]-=dp[i][st][d]; if(i&gt;m || st!=m) chk(Ans[st]+=dp[i][st][d]/d); // 特判了恰好为S的情况 &#125; &#125; rep(i,0,m) chk(ans+=Ans[i]); return ans;&#125;int main()&#123; //freopen(&quot;treelabel.in&quot;,&quot;r&quot;,stdin),freopen(&quot;treelabel.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%lld%s&quot;,&amp;n,&amp;k,s+1); k=Calc(1)-k+1; if(k&lt;0) return puts(&quot;-1&quot;),0; rep(i,1,n) &#123; int l=&#x27;a&#x27;,r=&#x27;a&#x27;+S-1,res=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; s[i]=mid,s[i+1]=0; if(Calc()&gt;=k) res=mid,l=mid+1; else r=mid-1; &#125; s[i]=res,s[i+1]=0; if(!res || Calc()==k) break; &#125; puts(s+1);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"CTSC","slug":"CTSC","permalink":"http://chasingdeath.github.io/tags/CTSC/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[学军20201104CSP模拟赛] 二维码              ","slug":"[学军20201104CSP模拟赛] 二维码              ","date":"2020-11-05T04:19:40.000Z","updated":"2021-05-22T03:54:11.101Z","comments":true,"path":"articles/2020/11/05/6fc3de75.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/05/6fc3de75.html","excerpt":"","text":"[学军20201104CSP模拟赛] 二维码简要题意： 对于$n\\times m$的网格图，初始时全部为白色，现在 通过下面的方法染色 每次选择一个行或者列，把它全部染成黑色或者全部染成白色 求任意操作的情况下，可以得到的不同网格图的数量$\\mod 998244353$ \\判定一个染色方案是否有解的条件是： 染色完成的矩阵不包含一个子矩阵满足四个角分别为 01 10 或者 10 01 但是这样看这个条件似乎比较抽象，如果具体对于一个行上考虑，就是满足 每一行所包含的1的位置的集合之间 互为子集 显然一个方案可以任意交换行/列，不妨把按照每一行1的个数将每一行排序，设每一行有$a_i$个1，边界条件为$a_0=0$ 那么对于行上的1考虑排列，方案数为$\\begin{aligned} \\prod \\binom{m-a_{i-1} } {a_i-a_{i-1} }\\end{aligned}$，即从空的$m-a_{i-1}$个位置里选出多出的$a_i-a_{i-1}$个位置 而对于列之间的排列需要考虑$a_i$与$a_{i+1}$的关系，因为如果$a_i=a_{i+1}$时，必然满足这两行相同 设所有的$a_i$构成若干个相同的组，每一组包含$b_i(i\\in[1,k])$个元素，则方案数显然为$\\begin{aligned} \\frac{n!} {\\prod b_i!}\\end{aligned}$ 而组内的$a_i$之间显然是没有$\\begin{aligned} \\sum \\binom{m-a_{i-1} } {a_i-a_{i-1} }\\end{aligned}$的贡献的，可以跳过 由此，不妨令$dp_{i,j}$表示$dp$了前$i$行，最后一行$a_i=j$，每次枚举每个组$b_i$转移 复杂度为$O(n^4)$ 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)const int N=2010,P=998244353;int n,m,C[N][N],dp[N][N],I[N],J[N];ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int main()&#123; rep(i,J[0]=1,N-1) J[i]=1ll*J[i-1]*i%P; I[N-1]=qpow(J[N-1]); drep(i,N-2,0) I[i]=1ll*I[i+1]*(i+1)%P; rep(i,0,N-1) rep(j,C[i][0]=1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%P; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,0,n) dp[i][0]=I[i]; // 第一个块 rep(i,1,n) rep(j,1,m) &#123; rep(a,0,i-1) rep(b,0,j-1) &#123; dp[i][j]=(dp[i][j]+1ll*dp[a][b]*I[i-a]%P*C[m-b][j-b])%P; &#125; &#125; int ans=0; rep(i,0,m) ans=(ans+dp[n][i])%P; ans=1ll*ans*J[n]%P; printf(&quot;%d\\n&quot;,ans);&#125; 优化： 发现两维$dp$之间是相互独立的，分别是把$n,m$分组 令$F_{i,j}$表示把$n$分成了$i$个组，当前总和为$j$的方案数，$G_{i,j}$表示把$m$分成$i$组，当前总和为$j$ 按照上面的系数转移，最后$O(n)$合并，复杂度为$O(n^3)$ \\进一步优化： 为了方便下面的叙述，不妨先整理一下$a_i$之间转移的系数，不妨设边界$a_{n+1}=m$ $\\begin{aligned} \\prod \\binom{m-a_{i-1} } {a_i-a_{i-1} }=\\prod_{i=1}^n \\frac{(m-a_{i-1})!} {(a_i-a_{i-1})!(m-a_{i})!}= \\frac{m!} {\\prod_{i=1}^{n+1} (a_{i}-a_{i-1})!}\\end{aligned}$ 发现实际上和列之间的系数是类似的，每次枚举$a_i-a_{i-1}$即可 而实际上只有$k$个$b_i$直接相交的位置$a_{i}-a_{i-1}$有效，因此行和列实际上分别是将$n,m$分成了$k$组 观察上面的转移系数，行构成的块，首个块大小可以为$0$，而列构成的块最后一个块大小可以为$0$，所以这个并不是严格分成$k$组，下面会讨论这个问题 我们计算答案的复杂度消耗在计算分成若干块的方案，而实际上，把$n$分成$k$块的方案数就是$\\begin{Bmatrix} n\\\\ k\\end{Bmatrix}\\cdot k!$ 用$n^2$递推第二类斯特林数的方法即可计算 对于并不是严格分成$k$组的问题，可以考虑把开头/结尾那一个大小为$0$的块删掉，即同时还要考虑$\\begin{Bmatrix}n \\\\ k-1\\end{Bmatrix}(k-1)!$ 最后再枚举$k$，复杂度为$O(n^2)$ 更优化的就是$\\text{NTT}$计算斯特林数，带入通项公式 $\\begin{aligned} \\begin{Bmatrix}n\\\\ m\\end{Bmatrix}m!=\\sum_{i=0}^m i^n(-1)^{m-i}\\binom{m} {i} \\end{aligned}$ 显然把组合数拆开$\\text{NTT}$即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)const int N=1&lt;&lt;18|10,P=998244353;int n,m,ans;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int I[N],J[N];int rev[N];int Init(int n)&#123; int R=2,c=0; while(R&lt;=n) R&lt;&lt;=1,c++; rep(i,0,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;c); return R;&#125;void NTT(int n,int *a,int f)&#123; static int e[N&gt;&gt;1]; rep(i,1,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int i=e[0]=1;i&lt;n;i&lt;&lt;=1) &#123; ll t=qpow(f==1?3:(P+1)/3,(P-1)/i/2); for(int j=i-2;j&gt;=0;j-=2) e[j+1]=(e[j]=e[j&gt;&gt;1])*t%P; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,Mod2(a[j+i]); a[j]+=t,Mod1(a[j]); &#125; &#125; &#125; if(f==-1) &#123; ll base=qpow(n); rep(i,0,n-1) a[i]=a[i]*base%P; &#125;&#125;int A[N],B[N],C[N];int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(n&lt;m) swap(n,m); rep(i,J[0]=1,N-1) J[i]=1ll*J[i-1]*i%P; I[N-1]=qpow(J[N-1]); drep(i,N-2,0) I[i]=1ll*I[i+1]*(i+1)%P; int R=Init(n+n+2); rep(i,0,n) A[i]=qpow(i,n)*I[i]%P; rep(i,0,n) B[i]=(i&amp;1)?P-I[i]:I[i]; NTT(R,A,1),NTT(R,B,1); rep(i,0,R-1) A[i]=1ll*A[i]*B[i]%P; NTT(R,A,-1); rep(i,n+1,R) A[i]=0; rep(i,0,m) C[i]=qpow(i,m)*I[i]%P; NTT(R,C,1); rep(i,0,R-1) C[i]=1ll*C[i]*B[i]%P; NTT(R,C,-1); rep(i,m+1,R) C[i]=0; int ans=0; rep(i,0,min(n,m)) ans=(ans+1ll*(1ll*A[i]*J[i]%P+1ll*A[i+1]*J[i+1]%P)*(1ll*C[i]%P*J[i]%P+1ll*C[i+1]*J[i+1]%P))%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"CSP","slug":"CSP","permalink":"http://chasingdeath.github.io/tags/CSP/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"零化多项式/特征多项式/最小多项式/常系数线性齐次递推","slug":"零化多项式 特征多项式 最小多项式 常系数线性齐次递推","date":"2020-11-03T07:33:31.000Z","updated":"2021-05-22T03:54:11.419Z","comments":true,"path":"articles/2020/11/03/f8425ab9.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/03/f8425ab9.html","excerpt":"","text":"零化多项式/特征多项式/最小多项式/常系数线性齐次递推约定:$I_n$是$n$阶单位矩阵，即主对角线是$1$的$n$阶矩阵 一个矩阵$A$的$|A|$是$A$的行列式 默认$A$是一个$n\\times n$的矩阵 定义零化多项式:对于一个矩阵$A$，它的一个零化多项式$f(\\lambda)$是满足$f(A)=0$的多项式，定义域包含矩阵 \\最小多项式:次数最低的零化多项式特征多项式对于一个$n$阶的矩阵$A$，它的特征多项式 $p(\\lambda)=|\\lambda I_n-A|$ $\\lambda$定义域不止是$\\R$，还可以是矩阵 $p(\\lambda)$是关于$\\lambda$的一个不超过$n+1$次的多项式 即$p(\\lambda )=\\sum_0^{n}a_ix^i$ Cayley-Hamilton定理:矩阵的特征多项式也是它的零化多项式 求解特征多项式带入$n$个数，求出得$|x I_n-A|$,得到$n$个矩阵，通过高斯消元可以$O(n^3)$地求出行列式 然后可$O(n^2)$拉格朗日插值求出原来的多项式，总复杂度受限于高斯消元，为$O(n^4)$ 求解最小多项式构造矩阵序列$a_i=A^i$ 求出它的一个线性递推$r_i$，即 $\\begin{aligned} \\sum_{j=0}^{m} r_j a_{i-j}=\\sum_{j=0}^{m} r_j A^{i-j}=(\\sum_{j=0}^m r_{m-j}A^j)\\cdot A^{i-m}=0\\end{aligned}$ $\\begin{aligned} \\therefore \\sum_{j=0}^m r_{m-j}A^j=0\\end{aligned}$ 所以可以由$r_i$翻转得到$f(\\lambda)$ 求解$a_i$前$n$项的复杂度受限于矩阵乘法为$O(n^4)$，求解递推式的复杂度为$O(n^3)$ 考虑到实际求解递推式时，随机生成了两个向量$u,v$ 实际是计算标量序列$\\{uA^iv\\}$的递推式，所以实际每次求出$uA^i$复杂度应为$O(n^2)$ 求这个递推式需要用到$a_i$前$2n$项，求解复杂度为$O(n^3)$ 因此总复杂度为$O(n^3)$ (但是如果只是求出来并没有什么用，因为求解方法是随机的，甚至连检查一次保证正确都需要$O(n^2(n+e))$的时间($e$为矩阵非0位置个数)) \\求解稀疏方程组设方程系数用矩阵$A$表示，右侧每个方程的常数用向量$b$表示，答案用向量$x$表示，则满足关系式 $Ax=b$，即$x=A^{-1}b$ 求出$\\{A^ib\\}$线性递推式，反推出$A^{-1}b$即可 反推方法: 带入线性递推的$m$项，则$\\sum_{i=0}^{m} A^{m-i}b\\cdot r_i=0$ 两边同乘$A^{-1}$，得到$A^{-1}b\\cdot r_m +\\sum_{i=0}^{m-1}A^{m-i}br_i=0$ \\ 求解矩阵$k$次幂我们要求解$A^k$，常规做法是直接用快速幂 设矩阵$A$的一个零化多项式是$f(\\lambda)$ 显然，$A^k$可以用一个多项式表示$A^k=\\sum_0^k w_i A^i$ $\\{w_i\\}$构成了一个$k+1$次多项式$F_k(x)$ 存在一种合法的表示是$F_k(x)=x^k$ $\\because f(A)=0 \\therefore \\forall i, f(A)A^i=0$ 也就是相当于我们要求出$x^k$对于$f(x)$这个$n+1$多项式取模 显然可以通过类似快速幂的方式倍增求解这个多项式，每次对$f(x)$取模复杂度是$O(n\\log n)$ 就能在$O(n\\log m\\log n)$时间得求出$F(x)$ 最后得到的$F(x)$是一个$n$次多项式 那么带入就可以快速求出$A_k$ 可以认为这个复杂度是受限于求解$A^0,A^1,\\cdots,A^{n-1}$的$O(n^4)$ 对于元矩阵$A$为稀疏矩阵的情况，设其包含$e$个非零位置 那么求解$B\\cdot A$的过程是$O(n\\cdot e)$的，求解$A_0,A^1,\\cdots,A^{n-1}$的过程，是$O(n^2e)$的 求解零化多项式的复杂度也是$O(n^2(n+e))$的，因此总复杂度为$O(n^2(n+e))$ 而一般的矩阵快速幂是$O(n^3\\log k)$的，这种方法适用情况非常特殊 另外，对于并不需要知道整个矩阵的答案，并且$A^0,A^1,\\cdots,A^{n-1}$特殊的具体问题，这个方法也十分有效 \\ 求解常系数线性齐次递推问题是要求数列$f_i=\\sum _{j=1}^{n}a_j\\cdot f_{i-j}$ 给出$f_0,f_1,\\cdots,f_{n-1}$，求第$k$项的值 线性递推显然可以用 初始向量列 与 转移矩阵的幂次 的乘积表示，即$f_i=(S \\cdot A^i)_n$，其中$A$为转移矩阵，$S$为初始向量列，我们求的是第$n$项 对于$n=4$的情况，我们的转移矩阵$A$是 1 2 3 4 1 $a_4$ 2 1 $a_3$ 3 1 $a_2$ 4 1 $a_1$ 鉴于它的特殊性，我们可以直接求出它的特征多项式表达式 由$\\lambda I_n-A=$ 1 2 3 4 1 $\\lambda$ $-a_4$ 2 $-1 $ $\\lambda$ $-a_3$ 3 $-1$ $\\lambda$ $-a_2$ 4 $-1$ $\\lambda -a_1$ 带入行列式最暴力的求法 枚举一个排列$p_i$，设排列$p$的逆序对为$f(p)$，$|A|=\\sum (-1)^{f(p)} \\Pi A_{i,p_i}$ 实际上合法的排列只有$n$个，就是 枚举$p_i=n$ 那么$p_j=\\left\\{\\begin{aligned} j && j i\\end{aligned}\\right.$ 当$i=n$时，$(-1)^{f(p)} \\Pi A_{i,p_i}=\\lambda ^n-a_1\\lambda ^{n-1}$ 当$i&gt;1$时， $f(p)=n-i$ $\\Pi A_{i,p_i}=(-1)^{n-i+1}\\lambda^i\\cdot a_{n-i+1}$ $(-1)^{f(p)} \\Pi A_{i,p_i}=-\\lambda^i a_{n-i+1}$ 综上,转移矩阵$A$的特征多项式有简单的表达 $p(\\lambda) = |\\lambda I_n-A|=\\lambda^n-a_1\\lambda^{n-1} -a_2\\lambda^{n-2} -\\cdots -a^n$ 假设有$f_0$这一项(不需要知道是多少)，那么认为初始向量列为$S=(f_{-(n-1)},f_{-(n-2)},\\cdots ,f_{0})$ 这个问题，我们要求的是$S\\cdot A^k$的第$n$项，不需要知道整个矩阵 类似求出$A^k$的过程，求出$F_k(x)\\mod p(\\lambda)$ 我们要求解$(S\\cdot A^k)_n=\\sum_1^{n}[x^i]{F(x)}(S\\cdot A^i)_n$ 而$(S\\cdot A^i)_n=f_i$已知，求出$F(x)$后直接带入即可 需要用到多项式取模，求解这个表达式是$O(n\\log n\\log k)$的，求完直接带入即可 用最朴素的$\\text{NTT}$，完全不卡常，甚至过不掉模板题","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"[TopCoder - 12244 SRM 559 Round1 Div1] CircusTents","slug":"[TopCoder - 12244 SRM 559 Round1 Div1] CircusTents","date":"2020-11-02T08:37:22.000Z","updated":"2021-05-22T03:54:11.082Z","comments":true,"path":"articles/2020/11/02/b7e7ec66.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/02/b7e7ec66.html","excerpt":"","text":"[TopCoder - 12244 SRM 559 Round1 Div1] CircusTents小而精的计算几何题 题目大意：有$n$个实心圆（不能从内部经过） 在第一个圆上选出一个点，使得从其他任意圆上到达它的最小距离 最大 分析：要最小值最大，显然可以想到二分答案 不能穿过其他圆这一条件让计算答案变得十分困难，但是可以发现，如果路径经过了一号圆以外的圆 那么从路径与该圆的交点直接过去的距离一定更近 也就是说，可以把 距离 看做 可以穿过一号圆以外的圆 的距离 考虑从一个圆$O$到达一号圆上的某一点$X$的最小距离，大致可以成两种情况 1.$OX$连线不穿过一号圆，那么可以直接走$OX$连线 最优路径就是绿色线 2.先走一条切线，然后绕着圆周走一段 其中$Y$是$O$点对于一号圆的切线的切点，绿色线+圆弧是最优路径 那么二分答案$mid$之后，可以发现满足距离$\\ge mid$的选点位置是一段圆弧，可以从角度取交集判断是否有解 实现上，可以先把一号圆平移到远点 然后对于其他的圆，按照角度范围是否在切线内部可以分类讨论 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,const T &amp;b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,const T &amp;b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;const int N=110;const db eps=1e-10,Pi=acos(-1),D=2*Pi;int n;struct Cir&#123; int x,y,r;&#125;A[N];db X[N],Y[N],H[N];int C,S[N];db Norm(db x)&#123; return x&lt;0?x+D:x; &#125;int I(db x)&#123; return lower_bound(H+1,H+C+1,x)-H; &#125;int Check(db L)&#123; memset(S,0,sizeof S); H[1]=0,H[C=2]=D; rep(i,1,n) &#123; db dis=A[i].x*A[i].x+A[i].y*A[i].y; db t=sqrt(dis-A[0].r*A[0].r)-A[i].r; //t为走过切线的距离 dis=sqrt(dis); if(dis-A[0].r-A[i].r&gt;=L)&#123; X[i]=0,Y[i]=D; continue; &#125; db l,r; if(t&gt;=L) &#123; // 说明范围在切线位置以内 // 此时，满足d=dis((x0,y0),A[i].O)-A[i].r&gt;=L db a=dis,b=A[0].r,c=L+A[i].r; db co=(a*a+b*b-c*c)/(2*a*b); //余弦定理 db x=acos(co),y=atan2(A[i].y,A[i].x); l=y+x,r=y-x+D; &#125; else &#123; db d=acos(A[0].r/dis); db x=atan2(A[i].y,A[i].x); db y=(L-t)/A[0].r+d; // 圆弧长度/半径得到圆弧弧度 if(y&gt;Pi) return 0; // 特判一下全部覆盖的情况 l=x+y,r=x-y+D; &#125; // 求 [l,r] 的交 if(r&gt;D) l-=D,r-=D; if(r&lt;=0) l+=D,r+=D; H[++C]=Norm(X[i]=l),H[++C]=Y[i]=r; &#125; sort(H+1,H+C+1); rep(i,1,n) &#123; if(X[i]&gt;=0) S[I(X[i])]++,S[I(Y[i])]--; else S[I(0)]++,S[I(Y[i])]--,S[I(X[i]+D)]++,S[I(D)]--; &#125; // 暴力求交 rep(i,1,C) if((S[i]+=S[i-1])==n) return 1; return 0;&#125;class CircusTents &#123; public: double findMaximumDistance(vector &lt;int&gt; _x, vector &lt;int&gt; _y, vector &lt;int&gt; _r) &#123; n=_x.size()-1; rep(i,0,n) A[i]=(Cir)&#123;_x[i]-_x[0],_y[i]-_y[0],_r[i]&#125;; db l=0,r=1e5; while(r-l&gt;eps) &#123; db mid=(l+r)/2; if(Check(mid)) l=mid; else r=mid; &#125; return l; &#125;&#125;;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"LOJ 2882. 「JOISC 2014 Day4」两个人的星座 ","slug":"LOJ 2882. 「JOISC 2014 Day4」两个人的星座 ","date":"2020-11-02T08:15:10.000Z","updated":"2021-05-22T03:54:10.959Z","comments":true,"path":"articles/2020/11/02/dbed4db0.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/11/02/dbed4db0.html","excerpt":"","text":"LOJ 2882. 「JOISC 2014 Day4」两个人的星座对于任意两个凸多边形相离，一定可以找到一条直线将它们分在平面的两个区域 而对于三角形的情况更为特殊 分析可以发现，很难直接枚举三角形外直线计算，而对于任意的两个合法的三角形，在其6点中较近的4个点中 一定可以从两个三角形中各选一个点，连出两条交错的合法的分界线，例如下图 那么可以考虑枚举这样的一条直线，即确定了两个分界线上的端点，然后从两个半平面内选出不同颜色的点 直接枚举，然后$O(n)$数出这样的点，复杂度为$O(n^3)$ 显然可以想到枚举一个顶点，然后对于其他极角排序，旋转另一个点，同步统计半平面内的点个数，复杂度为$O(n^2\\log n)$ 实现上，可以枚举一个点，尺取一个半平面内的点 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;using ll=int64_t;enum&#123;N=3010&#125;;int n,X[N],Y[N],I[N],C[N],c,s[2][3],i;double T[N];ll ans;ll E(int j,int k)&#123; return 1ll*(X[j]-X[i])*(Y[k]-Y[i])-1ll*(Y[j]-Y[i])*(X[k]-X[i]); &#125;int main()&#123; for(int i=scanf(&quot;%d&quot;,&amp;n);i&lt;=n;++i) scanf(&quot;%d%d%d&quot;,X+i,Y+i,C+i); for(i=1;i&lt;=n;++i) &#123; c=0; memset(s,0,sizeof s); for(int j=1;j&lt;=n;++j) if(i!=j) I[++c]=j,T[j]=atan2(Y[j]-Y[i],X[j]-X[i]),s[0][C[j]]++; sort(I+1,I+n,[&amp;](int x,int y)&#123; return T[x]&lt;T[y]; &#125;); int p=1; for(int j=1;j&lt;n;++j) &#123; while(E(I[j],I[p])&gt;=0) &#123; s[0][C[I[p]]]--,s[1][C[I[p]]]++; p=p%c+1; if(p==j) break; &#125; ans+=1ll*s[0][(C[i]+1)%3]*s[0][(C[i]+2)%3]*s[1][(C[I[j]]+1)%3]*s[1][(C[I[j]]+2)%3]; s[1][C[I[j]]]--,s[0][C[I[j]]]++; &#125; &#125; cout&lt;&lt;ans/2;&#125; 一个更好的写法是把在$y$轴以下的点中心对称上来，统计时每跨过一个点改变一次 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;enum&#123;N=3010&#125;;int n,X[N],Y[N],C[N],c,s[2][3],i,j,d,a,b,x,y;int64_t ans;struct Node&#123; int x,y,d,c; Node()&#123; &#125; Node(int p,int q,int r) &#123; x=p,y=q,c=r,d=0; if(y&lt;0||(x&lt;0&amp;&amp;y==0)) d=1,x=-x,y=-y; s[d][c]++; &#125;&#125; A[N];struct cmp&#123; int operator () (const Node &amp;a,const Node &amp;b)&#123; return 1ll*a.x*b.y&lt;1ll*a.y*b.x; &#125; &#125;;int main()&#123; for(i=scanf(&quot;%d&quot;,&amp;n);i&lt;=n;++i) scanf(&quot;%d%d%d&quot;,X+i,Y+i,C+i); for(i=1;i&lt;=n;++i) &#123; memset(s,c=0,sizeof s),a=(C[i]+1)%3,b=(a+1)%3; for(j=1;j&lt;=n;++j) if(i!=j) A[++c]=Node(X[j]-X[i],Y[j]-Y[i],C[j]); for(sort(A+1,A+n,cmp()),j=1;j&lt;n;++j) &#123; s[A[j].d][c=A[j].c]--,x=(c+1)%3,y=(x+1)%3; for(d=0;d&lt;2;++d) ans+=1ll*s[d][a]*s[d][b]*s[!d][x]*s[!d][y]; s[!A[j].d][c]++; &#125; &#125; cout&lt;&lt;ans/4;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"},{"name":"JOI","slug":"JOI","permalink":"http://chasingdeath.github.io/tags/JOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「300iq Contest 2」[LOJ 6719] 数仙人掌 Counting Cactus ","slug":"「300iq Contest 2」[LOJ 6719] 数仙人掌 Counting Cactus ","date":"2020-10-28T08:10:16.000Z","updated":"2021-05-22T03:54:11.133Z","comments":true,"path":"articles/2020/10/28/713a6cc8.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/10/28/713a6cc8.html","excerpt":"","text":"「300iq Contest 2」[LOJ 6719] 数仙人掌 Counting CactusLOJ上的 $n\\leq 18$ 如果把仙人掌上的树边看做二元环，那么可以认为仙人掌就是由很多环嵌套在一起的结构 $n\\leq 13$状压$dp$，300iq的题解里给出了状态，但是也只告诉了你状态。。。 令$f(i,S)$为$i$号节点为根，子树集合为$S$的方案数 令$g(i,S)$为$i$号节点为根，子树集合为$S$的方案数，并且强制根上只接了一个环 令$dp(u,v,S)$为钦定一个当前环的开头为$u$，环尾扩展到了$v$，当前包含$S$的方案数 由此得到转移为 1.$f(i,S)\\cdot g(j,T)(S\\cap T=\\empty)\\rightarrow f(i,S\\cup T)$ 2.$dp(u,v,S)\\cdot f(d,T)(S\\cap T=\\empty,(u,v)\\in E) \\rightarrow dp(u,d,S\\cup T)$ 3.$dp(u,v,S) ((u,v)\\in E)\\rightarrow g(u,S)$ 实际上涉及到很多计算重复，因此需要在转移过程中加入一些调整: 1.在转移环时，钦定的环开头节点下方不应该接有任何其他节点 2.转移1中$S,T$合并上来时，可以保证$S&lt;T$来避免集合加入顺序的重复 3.当环长&gt;2时，同一个环，同一个开始位置会由于环遍历顺序的不同被转移两次 对于这个问题我的解决方法是: 让$\\frac{dp(u,v,S)} {2}\\rightarrow g(u,S)$，然后把环长为2的部分加上去 转移过程中涉及到集合运算都是枚举子集，因此复杂度一个很松的上限为$O(n^33^n)$ 转移顺序不难解决，代码比较丑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;#define reg registertypedef long long ll;#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)char IO;int rd()&#123; int s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=13,M=1&lt;&lt;N|3,P=998244353;int n,m;int G[N];int f[M][N],g[M][N];int dp[M][N][N];int main()&#123; n=rd(),m=rd(); if(n==1) return puts(&quot;1&quot;),0; rep(i,1,m) &#123; int u=rd()-1,v=rd()-1; G[u]|=1&lt;&lt;v,G[v]|=1&lt;&lt;u; &#125; int A=(1&lt;&lt;n)-1; rep(i,0,n-1) g[1&lt;&lt;i][i]=1,dp[1&lt;&lt;i][i][i]=1; rep(S,1,A) &#123; // dp[S][u][v]转移 rep(u,0,n-1) rep(v,0,n-1) if(S&amp;(1&lt;&lt;u) &amp;&amp; S&amp;(1&lt;&lt;v)) &#123; int R=S^(1&lt;&lt;u); if(u!=v) R^=(1&lt;&lt;v); for(int T=R&amp;(R-1);;T=(T-1)&amp;R)&#123; int X=T|(1&lt;&lt;u)|(1&lt;&lt;v),Y=S^X; if(dp[X][u][v]) rep(d,0,n-1) if(f[Y][d] &amp;&amp; G[v]&amp;(1&lt;&lt;d)) dp[S][u][d]=(dp[S][u][d]+1ll*dp[X][u][v]*f[Y][d])%P; if(!T) break; &#125; &#125; // dp反馈给g rep(u,0,n-1) rep(v,0,n-1) if(dp[S][u][v] &amp;&amp; G[u]&amp;(1&lt;&lt;v)) g[S][u]=(g[S][u]+1ll*(P+1)/2*dp[S][u][v])%P; // 特判环长为2的情况 rep(i,0,n-1) rep(j,0,n-1) if(i!=j &amp;&amp; S&amp;(1&lt;&lt;i) &amp;&amp; S&amp;(1&lt;&lt;j) &amp;&amp; G[i]&amp;(1&lt;&lt;j)) g[S][i]=(g[S][i]+1ll*(P+1)/2*f[S^(1&lt;&lt;i)][j])%P; // f[S][i]合并 rep(i,0,n-1) f[S][i]+=g[S][i],Mod1(f[S][i]); rep(i,0,n-1) if(S&amp;(1&lt;&lt;i)) &#123; int R=S^(1&lt;&lt;i); for(int T=R&amp;(R-1);T;T=(T-1)&amp;R) &#123; int X=T,Y=T^R; if(X&gt;Y) continue; // 防止转移顺序重复 f[S][i]=(f[S][i]+1ll*f[X|(1&lt;&lt;i)][i]*g[Y|(1&lt;&lt;i)][i])%P; &#125; &#125; &#125; printf(&quot;%d\\n&quot;,f[A][0]);&#125; $n\\leq 18$前置知识：集合幂级数的$\\ln ,\\exp$ 同样上面的，一颗仙人掌可以看做若干$\\ge 2$环，两两之间在某一个节点上相接构成 不妨先求出环的集合幂级数，枚举环上编号最小的点，然后走环，复杂度为$O(n^32^n)$，常数较小 接下来当然想到枚举环的交点$i$，将当前所有包含$i$的项取出，去掉$i$后求出$\\exp$，然后放回去，就能计算相交在$i$上的方案 两部分复杂度均为$O(n^32^n)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a;i&lt;=b;++i)enum&#123;N=20,M=1&lt;&lt;18|10,P=998244353&#125;;struct U&#123; int x; U()&#123; &#125; U(int x):x(x)&#123; &#125; inline void operator += (const U &amp;t)&#123; x+=t.x,x&gt;=P&amp;&amp;(x-=P); &#125; inline void operator -= (const U &amp;t)&#123; x-=t.x,x&lt;0&amp;&amp;(x+=P); &#125; inline U operator * (const U &amp;t)&#123; return U(static_cast&lt;unsigned long long&gt;(x)*t.x%P); &#125;&#125;I[N],F[M][N],H[M][N];int n,m,G[N],C[M],B[M];void FWT(int f) &#123; for(int i=1;i&lt;m;i&lt;&lt;=1) &#123; for(int l=0;l&lt;m;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; if(f==1) rep(d,1,n) F[j+i][d]+=F[j][d]; else rep(d,1,n) F[j+i][d]-=F[j][d]; &#125; &#125; &#125;&#125;void Exp(U *a)&#123; static U b[N]; rep(i,0,n-1) b[i]=a[i+1]*(i+1); rep(i,0,n-1) &#123; U t=b[i]; rep(j,1,i) t+=a[j]*b[i-j]; a[i+1]=t*I[i+1]; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(n==1) return puts(&quot;1&quot;),0; for(int x,y;m--;) scanf(&quot;%d%d&quot;,&amp;x,&amp;y),x--,y--,G[x]|=1&lt;&lt;y,G[y]|=1&lt;&lt;x; I[0]=I[1]=1,m=1&lt;&lt;n; rep(i,0,n-1) B[1&lt;&lt;i]=i; rep(i,2,n) I[i]=U(P-P/i)*I[P%i]; rep(i,1,m-1) C[i]=C[i&amp;(i-1)]+1; rep(st,0,n-1) &#123; H[1&lt;&lt;st][st]=1; rep(S,0,m-1) rep(i,st,n-1) if(H[S][i].x) &#123; for(int T=G[i]&amp;~S;T;T&amp;=T-1) H[S|(T&amp;-T)][B[T&amp;-T]]+=H[S][i]; if(G[i]&amp;(1&lt;&lt;st)) F[S][C[S]]+=H[S][i]*I[1+(C[S]&gt;2)]; H[S][i]=0; &#125; &#125; FWT(1); for(int i=1;i&lt;m;i&lt;&lt;=1)&#123; for(int l=0;l&lt;m;l+=i*2) for(int j=l;j&lt;l+i;++j) &#123; rep(k,1,n) F[j+i][k]-=F[j][k]; Exp(F[j+i]+1); rep(k,1,n) F[j+i][k]+=F[j][k]; &#125; &#125; FWT(-1),printf(&quot;%d\\n&quot;,F[m-1][n].x);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"LOJ 6719. 「300iq Contest 2」数仙人掌 加强版 (集合幂级数)","slug":"LOJ 6719. 「300iq Contest 2」数仙人掌 加强版 (集合幂级数)","date":"2020-10-28T08:03:40.000Z","updated":"2021-05-22T03:54:10.963Z","comments":true,"path":"articles/2020/10/28/671aee9f.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/10/28/671aee9f.html","excerpt":"","text":"LOJ 6719. 「300iq Contest 2」数仙人掌 加强版 (集合幂级数)前置知识：集合幂级数的$\\ln ,\\exp$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a;i&lt;=b;++i)enum&#123;N=20,M=1&lt;&lt;18|10,P=998244353&#125;;struct U&#123; int x; U()&#123; &#125; U(int x):x(x)&#123; &#125; inline void operator += (const U &amp;t)&#123; x+=t.x,x&gt;=P&amp;&amp;(x-=P); &#125; inline void operator -= (const U &amp;t)&#123; x-=t.x,x&lt;0&amp;&amp;(x+=P); &#125; inline U operator * (const U &amp;t)&#123; return U(static_cast&lt;unsigned long long&gt;(x)*t.x%P); &#125;&#125;I[N],F[M][N],H[M][N];int n,m,G[N],C[M],B[M];void FWT(int f) &#123; for(int i=1;i&lt;m;i&lt;&lt;=1) &#123; for(int l=0;l&lt;m;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; if(f==1) rep(d,1,n) F[j+i][d]+=F[j][d]; else rep(d,1,n) F[j+i][d]-=F[j][d]; &#125; &#125; &#125;&#125;void Exp(U *a)&#123; static U b[N]; rep(i,0,n-1) b[i]=a[i+1]*(i+1); rep(i,0,n-1) &#123; U t=b[i]; rep(j,1,i) t+=a[j]*b[i-j]; a[i+1]=t*I[i+1]; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(n==1) return puts(&quot;1&quot;),0; for(int x,y;m--;) scanf(&quot;%d%d&quot;,&amp;x,&amp;y),x--,y--,G[x]|=1&lt;&lt;y,G[y]|=1&lt;&lt;x; I[0]=I[1]=1,m=1&lt;&lt;n; rep(i,0,n-1) B[1&lt;&lt;i]=i; rep(i,2,n) I[i]=U(P-P/i)*I[P%i]; rep(i,1,m-1) C[i]=C[i&amp;(i-1)]+1; rep(st,0,n-1) &#123; H[1&lt;&lt;st][st]=1; rep(S,0,m-1) rep(i,st,n-1) if(H[S][i].x) &#123; for(int T=G[i]&amp;~S;T;T&amp;=T-1) H[S|(T&amp;-T)][B[T&amp;-T]]+=H[S][i]; if(G[i]&amp;(1&lt;&lt;st)) F[S][C[S]]+=H[S][i]*I[1+(C[S]&gt;2)]; H[S][i]=0; &#125; &#125; FWT(1); for(int i=1;i&lt;m;i&lt;&lt;=1)&#123; for(int l=0;l&lt;m;l+=i*2) for(int j=l;j&lt;l+i;++j) &#123; rep(k,1,n) F[j+i][k]-=F[j][k]; Exp(F[j+i]+1); rep(k,1,n) F[j+i][k]+=F[j][k]; &#125; &#125; FWT(-1),printf(&quot;%d\\n&quot;,F[m-1][n].x);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"集合幂级数的  Ln, Exp ","slug":"集合幂级数的  ln, exp ","date":"2020-10-28T07:59:07.000Z","updated":"2021-05-22T03:54:11.413Z","comments":true,"path":"articles/2020/10/28/edc2a775.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/10/28/edc2a775.html","excerpt":"","text":"集合幂级数的$\\ln,\\exp$起始：求联通子图个数 令$F(x)$为联通的生成子图个数的形式幂级数，可以简单求出$G(x)$为生成子图个数的形式幂级数 下可能略写$F(x)$为$F$ 不连通的子图可以通过联通子图做集合并运算得到，即构造卷积 $\\begin{aligned} F\\times G=\\sum_{S\\ne \\empty}\\sum_{T\\ne \\empty,S\\cap T=\\empty} [x^S]F\\cdot [x^T]G\\cdot x^{S\\cup T} \\end{aligned}$ 显然满足关系式$\\begin{aligned} G=\\sum_{i\\ge 1} \\frac{F^i} {i!}=e^{F}-1\\end{aligned}$ $F=\\ln (G+1)$ 计算集合幂级数$\\ln$的方法似乎非常抽象 方法是： 1.类似子集卷积，把所有项按照占位数(集合包含元素个数)分开，记录在第二维 2.求出$\\text{FMT}$ 3.对于集合幂级数每一位(现在是一个形式幂级数)求出其$\\ln$的前$n$项 4.求出$\\text{IFMT}$ 求出形式幂级数$\\ln$的$n^2$方法是 $F=\\ln (G+1)$ $F’=\\frac{G’} {G+1}$ $F’(G+1)=G’$ $\\begin{aligned}F'_i=G'_i-\\sum_{j=1}G_jF'_{i-j}\\end{aligned}$ 类似的，可以计算集合幂级数的$\\exp$，即由上面的$F$求$G$ $\\begin{aligned}G'_i=F'_i+\\sum_{j=1}G_jF'_{i-j}\\end{aligned}$ 可能在子图计数题中出现 LOJ6729 LOJ6719 LOJ6730 下面是代码实现上的参考 12345678910111213141516171819202122232425262728293031323334353637383940414243#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a;i&lt;=b;++i)int I[N];// 模逆元void FMT(int F[M][N],int f)&#123; for(int i=1;i&lt;m;i&lt;&lt;=1) for(int l=0;l&lt;m;l+=i*2) for(int j=l;j&lt;l+i;++j) if(f==1) rep(d,1,n) F[j+i][d]+=F[j][d],Mod1(F[j+i][d]); else rep(d,1,n) F[j+i][d]-=F[j][d],Mod2(F[j+i][d]);&#125;void Ln(int *a)&#123; static int b[N]; rep(i,0,n-1) &#123; int t=0; rep(j,0,i-1) t=(t+1ll*b[j]*a[i-j])%P; b[i]=(1ll*a[i+1]*(i+1)-t+P)%P; &#125; rep(i,1,n) a[i]=1ll*b[i-1]*I[i]%P;&#125;void Exp(int *a)&#123; static int b[N]; rep(i,0,n-1) b[i]=1ll*a[i+1]*(i+1)%P; rep(i,0,n-1) &#123; int t=b[i]; rep(j,1,i) t=(t+1ll*a[j]*b[i-j])%P; a[i+1]=1ll*t*I[i+1]%P; &#125;&#125;void Ln(int F[M][N]) &#123; FMT(F,1); rep(i,1,m-1) Ln(F[i]); FMT(F,-1);&#125;void Exp(int F[M][N]) &#123; FMT(F,1); rep(i,1,m-1) Exp(F[i]); FMT(F,-1);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"LOJ6729. 点双连通生成子图计数 (集合幂级数)","slug":"LOJ6729. 点双连通生成子图计数 (集合幂级数)","date":"2020-10-28T07:47:04.000Z","updated":"2021-05-22T03:54:10.969Z","comments":true,"path":"articles/2020/10/28/1e2a4812.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/10/28/1e2a4812.html","excerpt":"","text":"LOJ6729. 点双连通生成子图计数 (集合幂级数)基础： 由子图的集合幂级数取$\\ln$可以得到连通子图的集合幂级数，可以参考? 根据点双连通的定义，我们先求得连通子图的集合幂级数 然后考虑枚举每个节点$i$，把所有删去$i$之后不连通的方案去掉 具体实现上，可以把所有包含$i$的项提出，删除$i$之后取$\\ln$得到连通的方案数，然后替换回去 每次取$\\ln$的复杂度为$O(n^22^n)$，因此总复杂度为$O(n^32^n)$ 常数优化：每次实际上只会修改包含$i$的项，不需要每次都把多项式莫比乌斯反演回去 刚开始进行一次莫比乌斯变换之后 每次可以直接从前缀和的作差得到这一项 除了$i$以外的位置 累和之后的结果，然后直接对于形式幂级数取$\\ln$，具体实现见代码 注意去掉$i$后，占位数量$-1$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a;i&lt;=b;++i)const int N=20,M=1&lt;&lt;18|3,P=998244353;struct U&#123; int x; U()&#123; &#125; U(int x):x(x)&#123; &#125; inline void operator += (const U &amp;t)&#123; x+=t.x,x&gt;=P&amp;&amp;(x-=P); &#125; inline void operator -= (const U &amp;t)&#123; x-=t.x,x&lt;0&amp;&amp;(x+=P); &#125; inline U operator * (const U &amp;t)&#123; return U(static_cast&lt;unsigned long long&gt;(x)*t.x%P); &#125;&#125; I[N],F[M][N],b[N];int n,m,G[N],C[M],Pow[N*N];void FWT(int f)&#123; for(int i=1;i&lt;m;i&lt;&lt;=1) for(int l=0;l&lt;m;l+=i*2) for(int j=l;j&lt;l+i;++j) if(f==1) rep(d,1,n) F[j+i][d]+=F[j][d]; else rep(d,1,n) F[j+i][d]-=F[j][d];&#125;void Ln(U *a)&#123; rep(i,0,n-1) &#123; U t=0; rep(j,0,i-1) t+=b[j]*a[i-j]; b[i]=a[i+1]*(i+1),b[i]-=t; &#125; rep(i,1,n) a[i]=b[i-1]*I[i];&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int u,v;m--;) scanf(&quot;%d%d&quot;,&amp;u,&amp;v),u--,v--,G[u]|=1&lt;&lt;v,G[v]|=1&lt;&lt;u; m=1&lt;&lt;n,I[0]=I[1]=1; rep(i,1,m-1) C[i]=C[i&amp;(i-1)]+1; rep(i,2,n) I[i]=U(P-P/i)*I[P%i]; rep(i,Pow[0]=1,N*N-1) Pow[i]=Pow[i-1]*2%P; rep(i,1,m-1) &#123; int c=0; rep(j,0,n-1) if(i&amp;(1&lt;&lt;j)) c+=C[G[j]&amp;i]; F[i][C[i]]=Pow[c/2]; &#125; FWT(1); rep(i,1,m-1) Ln(F[i]); // 先取一次ln得到连通子图的集合幂级数 for(int i=1;i&lt;m;i&lt;&lt;=1)&#123; for(int l=0;l&lt;m;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; rep(k,1,n) F[j+i][k]-=F[j][k]; // 前缀和作差得到 Ln(F[j+i]+1); // 取出自己后大小-1 rep(k,1,n) F[j+i][k]+=F[j][k]; &#125; &#125; &#125; FWT(-1); printf(&quot;%d\\n&quot;,F[m-1][n].x);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「517模拟赛1」ABC难题","slug":"「517模拟赛1」ABC难题","date":"2020-10-28T04:22:52.000Z","updated":"2021-05-22T03:54:11.135Z","comments":true,"path":"articles/2020/10/28/4d08478.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/10/28/4d08478.html","excerpt":"","text":"「517模拟赛1」ABC难题Tips: 模数是$10^8+7$ 不妨令序列总长为$n$，包含$m$种不同的数字 发现存在$ABC$的子序列只需要满足最左边的$A$和最右边的$C$之间有一个$B$ 由于可能出现多个$ABC$，考虑计算不存在$ABC$的情况 那么可以枚举最左边的$A$和最右边的$C$分别为$X,Y$，那么需要不存在$ABC$，并且枚举的$X,Y$合法 的充要条件是 $[1,X-1]$中不存在$A$，$[X+1,Y-1]$中不存在$B$，$[Y+1,n]$中不存在$C$ 这三个限制，每一个限制会让一种颜色能够选择的字母数量-1 那么枚举$X$，扫描每一个$Y$(注意不一定满足$X&lt; Y$)，同时记录每个数字是否出现在$[1,X-1],[X+1,Y-1],[Y+1,n]$中 在每次扫描时改变限制，同步统计出受到$0,1,2,3$个限制的数字的个数，然后答案就是$(3-i)^k$之积 然而这样还不够，因为可能根本不存在$A,C$，不存在$A$或者$C$的答案为$2^m$，同时不存在$A,C$的答案为$1^m$，容斥一下即可","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"Codechef Oct Chanllenge Queries on Matrix-JIIT ","slug":"Codechef Oct chanllenge Queries on Matrix-JIIT ","date":"2020-10-26T09:43:37.000Z","updated":"2021-05-22T03:54:10.928Z","comments":true,"path":"articles/2020/10/26/c77625a4.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/10/26/c77625a4.html","excerpt":"","text":"Codechef Oct chanllenge Queries on Matrix-JIIT首先发现矩阵的两个维度显然是互不相干的，假设最后操作后有$x$列被操作奇数次，$y$行操作奇数次 那么最后为奇数的格子个数就是$x(m-y)+(n-x)y$ 考虑求出$q$操作后有$x$个位置被操作奇数次的方案数 考虑一个Naive的$dp$，令$dp_{i,j}$为操作$i$次后有$j$位置操作奇数的方案数，显然得到转移为 $dp_{i,j}\\cdot j\\rightarrow dp_{i+1,j-1}$ $dp_{i,j}\\cdot (n-j)\\rightarrow dp_{i+1,j+1}$ 直接$dp$复杂度为$O(nq)$，用矩阵优化复杂度为$O(n^3\\log q)$ 没有考虑过求向量列的现行递推式？说不定暴力求递推然后。。。 $O(n^3)$由于笔者不会数学，所以考虑一个非常暴力非常直观的理解，可以完全抛开组合意义 每次是挑选一个位置异或上1，用形式幂级数可能比较蛋疼，不如直接搞成集合幂级数 即令集合$S$包含所有被操作奇数次的位置，用一个多项式$F=\\sum_S a_S x^S$表示答案 那么转移多项式即为$F=\\sum_{i=1}^{n} x^{\\lbrace i \\rbrace}$，转移运算为集合对称差运算(哎就是异或) 那么实际就是要求出$F^q$，可以直接用$\\text{FWT}$优化，先$\\text{FWT}$，然后求出每一项的$q$次幂，然后$\\text{FWT}$回来 (这样不是$n2^n$的吗) 显然的可以发现，$F^i$的任意位置系数$[x^S]F^i$只与$|S|$有关，所以实际上只需要存下含有$0,1,2\\cdots,n$个元素的项的系数即可 考虑在这样的多项式上模拟原先的$\\text{FWT}$过程 按照快速沃尔什变换的式子，令$G=\\text{FWT(F)}=\\sum_{S}x^S \\sum_{T}(-1)^{|S\\cap T|}\\cdot [x^T]F $ 考虑枚举$|S|,|T|,|S\\cap T|$，然后组合数计算系数，令$F_i$表示$[x^S]F(|S|=i)$ 则有$\\begin{aligned} G_i=\\sum_{j}F_j\\sum_k C_i^k\\cdot C_{n-i}^{j-k}(-1)^{k}\\end{aligned}$，其中$C_{n-i}^{j-k}$表示从不相交的部分里选出$j$中剩下的元素 按照该式即可完成$O(n^3)$模拟$\\text{FWT}$，注意$\\text{IFWT}$时需要除掉$2^n$ 算上快速幂复杂度应为$O(n^3+n\\log q)$ $O(n^2\\log n)$用$\\text{NTT}$优化上式 $O(n^2)$依然考虑上面$\\text{FWT}$的转移式，发现$i$项得到$j$项的贡献为一个常数，考虑直接计算这个常数$W_{i,j}=\\sum_k C_i^k\\cdot C_{n-i}^{j-k}(-1)^{k}$ 我们知道组合数就是二项展开的结果，所以发现实际就是$W_{i,j}=[x^j] (-x+1)^i\\cdot (x+1)^{n-i}$ 该式可以$O(n^2)$按照$i$递推求出，每次乘上一个$\\frac{1-x} {1+x}$即可 实际复杂度为$O(n^2+n\\log q)$ 实际上应该还可以处理一些稍微复杂点的问题，比如每次可以操作若干个位置 不知道能否优化到$n^2$以下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166// NTT Version#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef long double ldb;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)bool Mbe;const int N=2050,P=998244353;int n,m,Z; ll k;int A[N],B[N];ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int C[N][N];int rev[N],T[N],IT[N];void NTT(int n,int *a,int f)&#123; rep(i,0,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); static int e[N&gt;&gt;1]; for(reg int i=e[0]=1;i&lt;n;i&lt;&lt;=1) &#123; ll t=f==1?T[i]:IT[i]; //qpow(f==1?3:(P+1)/3,(P-1)/i/2); for(reg int j=i-2;j&gt;=0;j-=2) e[j+1]=t*(e[j]=e[j&gt;&gt;1])%P; for(reg int l=0;l&lt;n;l+=i*2) &#123; for(reg int j=l;j&lt;l+i;++j) &#123; reg int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,Mod2(a[j+i]); a[j]+=t,Mod1(a[j]); &#125; &#125; &#125; if(f==-1) &#123; ll base=qpow(n); rep(i,0,n-1) a[i]=a[i]*base%P; &#125;&#125;int Init(int n)&#123; int R=1,cc=-1; while(R&lt;=n) R&lt;&lt;=1,cc++; rep(i,1,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;cc); return R;&#125;int mk1[N],mk2[N];void FWT(int n,int *A,int *B,int f,int *mk)&#123; static int X[N],Y[N]; rep(i,0,n) &#123; memset(X,0,sizeof X),memset(Y,0,sizeof Y); rep(k,0,i) X[i-k]=(k&amp;1)?P-C[i][k]:C[i][k]; rep(j,0,n) Y[j]=A[j]; int R=Init(n+i+1); NTT(R,X,1),NTT(R,Y,1); rep(j,0,R-1) X[j]=1ll*X[j]*Y[j]%P; NTT(R,X,-1); rep(j,0,n-i) B[i]=(B[i]+1ll*C[n-i][j]*X[i+j])%P; &#125;&#125;void Solve(int n,int *A,int *mk) &#123; static int X[N],Y[N]; memset(X,0,sizeof X),memset(Y,0,sizeof Y); X[1]=1,FWT(n,X,Y,1,mk); rep(i,0,n) Y[i]=qpow(Y[i],k); memset(X,0,sizeof X); FWT(n,Y,X,2,mk); ll base=qpow(qpow(2,n),P-2); rep(i,0,n) A[i]=X[i]*base%P*C[n][i]%P;&#125;bool Med;int main()&#123; //fprintf(stderr,&quot;%.2lf\\n&quot;,(&amp;Med-&amp;Mbe)/1024.0/1024.0); freopen(&quot;clone.in&quot;,&quot;r&quot;,stdin),freopen(&quot;clone.out&quot;,&quot;w&quot;,stdout); rep(i,0,N-1) rep(j,C[i][0]=1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P; for(int i=1;i&lt;N;i&lt;&lt;=1) &#123; T[i]=qpow(3,(P-1)/i/2); IT[i]=qpow((P+1)/3,(P-1)/i/2); &#125; scanf(&quot;%d%d%lld%d&quot;,&amp;n,&amp;m,&amp;k,&amp;Z); rep(i,0,n) rep(j,0,m) &#123; if(i*(m-j)+j*(n-i)!=Z) continue; mk1[i]=1,mk2[j]=1; &#125; Solve(n,A,mk1),Solve(m,B,mk2); int ans=0; rep(i,0,n) rep(j,0,m) &#123; if(i*(m-j)+j*(n-i)!=Z) continue; ans=(ans+1ll*A[i]*B[j])%P; &#125; printf(&quot;%d\\n&quot;,ans);&#125;// n^2#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)const int N=2050,P=998244353;int n,m,Z; ll k;int A[N],B[N];ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int C[N][N],W[N][N],mk1[N],mk2[N];void Solve(int n,int *A,int *mk) &#123; static int X[N],Y[N]; rep(i,0,n) W[0][i]=C[n][i]; rep(i,1,n) &#123; rep(j,0,n) W[i][j]=W[i-1][j]-(j?W[i][j-1]:0),Mod2(W[i][j]); drep(j,n,0) W[i][j]=(j?-W[i][j-1]:0)+W[i][j],Mod2(W[i][j]); &#125; memset(Y,0,sizeof Y); rep(i,0,n) X[i]=qpow(W[i][1],k); rep(i,0,n) if(mk[i]) rep(j,0,n) Y[i]=(Y[i]+1ll*W[i][j]*X[j])%P; ll base=qpow(qpow(2,n),P-2); rep(i,0,n) A[i]=Y[i]*base%P*C[n][i]%P;&#125;int main()&#123; freopen(&quot;clone.in&quot;,&quot;r&quot;,stdin),freopen(&quot;clone.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%lld%d&quot;,&amp;n,&amp;m,&amp;k,&amp;Z); rep(i,0,max(n,m)) rep(j,C[i][0]=1,i) C[i][j]=C[i-1][j-1]+C[i-1][j],Mod1(C[i][j]); rep(i,0,n) rep(j,0,m) &#123; if(i*(m-j)+j*(n-i)!=Z) continue; mk1[i]=mk2[j]=1; &#125; Solve(n,A,mk1),Solve(m,B,mk2); int ans=0; rep(i,0,n) rep(j,0,m) &#123; if(i*(m-j)+j*(n-i)!=Z) continue; ans=(ans+1ll*A[i]*B[j])%P; &#125; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"},{"name":"Codechef","slug":"Codechef","permalink":"http://chasingdeath.github.io/tags/Codechef/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「PA 2019」Szprotki I Szczupaki","slug":"「PA 2019」Szprotki i szczupaki","date":"2020-10-02T12:27:23.000Z","updated":"2021-05-22T03:54:11.222Z","comments":true,"path":"articles/2020/10/02/733edfb3.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/10/02/733edfb3.html","excerpt":"","text":"「PA 2019」Szprotki i szczupaki根据题意模拟，得到一种浅显的贪心方法是: 每次选择能吃的最大的一个吃掉 如果用set维护，就能得到一个$O(n^2\\log n)$的算法! 考虑用加速这个贪心: 设当前重量为$now$，目标是$des$ 每次找到存在$\\ge now$的最小的一条鱼$nxt$ 那么这一次决策的目标就是吃最少的鱼让自己能够吃掉$nxt$或者直接达到$des$ 在达到这一次的决策目标之前，能够吃的鱼的集合都是一样的 那么就可以找到最短的一段以$now-1$为右端点的区间使得区间的和达到目标 发现每做一次决策之后，下一次吃一条鱼就会翻倍，所以只有$\\log 10^{18}$次决策 那么考虑如何用数据结构维护这个目标 注意一个比较难维护的问题，每次决策之后，被吃掉的鱼应当暂时消失 暂时消失的问题，常见的思路可能是:可持久化 或者 删除之后存下来回撤 平衡树涉及到插入，删除，二分区间，删除区间和复原区间 可以用$\\text{Splay}$或者非旋$\\text{Treap}$维护这个问题 复原区间的过程可以写成一个伪平衡树合并的样子 非常慢 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair &lt;int,int&gt; Pii;#define mp make_pairtypedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,const T &amp;b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,const T &amp;b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125; char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125; const int N=4e5+10;const ll U=1e12; int n,m;int rt,c[N],ls[N],rs[N],key[N],ma[N],mi[N];ll s[N],val[N]; int cmp(int x,int y)&#123; return val[x]!=val[y]?val[x]&lt;val[y]:x&gt;y; &#125;void Up(int p) &#123; s[p]=s[ls[p]]+s[rs[p]]+val[p]; c[p]=c[ls[p]]+c[rs[p]]+1; ma[p]=mi[p]=p; if(ma[ls[p]] &amp;&amp; cmp(ma[p],ma[ls[p]])) ma[p]=ma[ls[p]]; if(ma[rs[p]] &amp;&amp; cmp(ma[p],ma[rs[p]])) ma[p]=ma[rs[p]]; if(mi[ls[p]] &amp;&amp; cmp(mi[ls[p]],mi[p])) mi[p]=mi[ls[p]]; if(mi[ls[p]] &amp;&amp; cmp(mi[ls[p]],mi[p])) mi[p]=mi[rs[p]];&#125;void Show(int x) &#123; if(ls[x]) Show(ls[x]); printf(&quot;(%d,%lld,%lld) &quot;,x,val[x],s[x]); if(rs[x]) Show(rs[x]);&#125; int Union(int x,int y) &#123; if(!x || !y) return x|y; if(key[x]&lt;key[y]) return rs[x]=Union(rs[x],y),Up(x),x; return ls[y]=Union(x,ls[y]),Up(y),y;&#125; Pii Split(int x,int k) &#123; if(c[x]&lt;=k) return mp(x,0); if(!x || !k) return mp(0,x); if(c[ls[x]]+1&lt;=k) &#123; Pii y=Split(rs[x],k-c[ls[x]]-1); return rs[x]=y.first,Up(x),mp(x,y.second); &#125; else &#123; Pii y=Split(ls[x],k); return ls[x]=y.second,Up(x),mp(y.first,x); &#125;&#125;Pii Split2(int x,int k) &#123; if(!x) return mp(0,0); if(cmp(ma[x],k)) return mp(x,0); if(cmp(k,mi[x])) return mp(0,x); if(cmp(x,k)) &#123; Pii y=Split2(rs[x],k); return rs[x]=y.first,Up(x),mp(x,y.second); &#125; else &#123; Pii y=Split2(ls[x],k); return ls[x]=y.second,Up(x),mp(y.first,x); &#125;&#125;Pii Split3(int x,ll k) &#123; if(!x) return mp(0,0); if(s[x]&lt;=k) return mp(0,x); if(s[rs[x]]&gt;=k) &#123; Pii y=Split3(rs[x],k); return rs[x]=y.first,Up(x),mp(x,y.second); &#125; else &#123; Pii y=Split3(ls[x],k-s[rs[x]]-val[x]); return ls[x]=y.second,Up(x),mp(y.first,x); &#125;&#125; void Insert()&#123; val[++n]=rd&lt;ll&gt;(),s[n]=val[n],ma[n]=mi[n]=n,c[n]=1,key[n]=rand(); Pii t=Split2(rt,n); rt=Union(Union(t.first,n),t.second);&#125;void Erase() &#123; Pii x=Split2(rt,0); Pii y=Split(x.second,1); rt=Union(x.first,y.second);&#125; int T[N],cnt;int main()&#123; rep(i,1,rd()) Insert(); rep(kase,1,rd()) &#123; int opt=rd(); if(opt==2) Insert(); else if(opt==3) val[0]=rd&lt;ll&gt;()-1,Erase(); else &#123; ll now=rd&lt;ll&gt;(),des=rd&lt;ll&gt;(),ans=cnt=0; while(now&lt;des) &#123; val[n+1]=now; Pii x=Split2(rt,n+1); ll nxt=x.second?val[mi[x.second]]+1:1e18; cmin(nxt,des); ll d=nxt-now; Pii y=Split3(x.first,d); now+=s[y.second],ans+=c[y.second]; rt=Union(y.first,x.second); T[++cnt]=y.second; if(now&lt;nxt) break; &#125; drep(i,cnt,1) &#123; Pii x=Split2(rt,T[i]); rt=Union(Union(x.first,T[i]),x.second); &#125; if(now&gt;=des) printf(&quot;%lld\\n&quot;,ans); else puts(&quot;-1&quot;); &#125; &#125;&#125; 线段树离线之后写，让每个位置只包含一个数会更好写 关于用线段树维护暂时删除的问题，有很多写法 1.强行标记，把被标记的节点全部存下来然后复原 2.","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「USACO 2020 US Open Platinum」Exercise","slug":"「USACO 2020 US Open Platinum」Exercise","date":"2020-09-30T02:08:35.000Z","updated":"2021-05-22T03:54:11.251Z","comments":true,"path":"articles/2020/09/30/c1ba6452.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/30/c1ba6452.html","excerpt":"","text":"「USACO 2020 US Open Platinum」Exercise做法与模数是否是质数无关 问题可能比较复杂，需要多步分析 1.对于一个已知的排列 显然这样的置换会构成若干个环，设每个环长度为$a_i,i\\in [1,m]$，显然答案就是$lcm(a_i)$ 2.对于已知的$a_i$序列(注意这里说的是有序的)，计算其方案数 考虑已经排列的个数为$i$，加入一个环大小为$j$ 为了避免重复，应当固定这个环的初始位置为1号点，其余位置按照原先顺序插入 则方案数可以分为两部分考虑: 2-1.环内排列，固定的环首不可排列，即$(j-1)!$ 2-2.剩下的$j-1$一个点位置未知，从未固定的$i+j-1$个点中选择 即$C(i+j-1,j-1)$ 所以就是$C(i+j-1,j-1)(j-1)!=\\frac{(i+j-1)!} {i!}$ 归纳一下，发现更形象的描述就是$\\begin{aligned}\\frac{n!} {\\prod_{i=1}^{m} (\\sum_{j=1}^i a_j)}\\end{aligned}$ 也就是每次除掉转移时的大小，将$n!$分成若干段，这似乎有利于理解下面的dp优化 3.计算$lcm$之积 考虑对于每个质因数计算其出现的幂次，注意这个幂次是对于$\\varphi$取模的 原先是求恰好包含$x^k$的方案数，得到的$dp$不好优化，考虑转换为: 求质因数$x$出现在答案里的幂次$\\ge k$的方案数$F_k$，答案就是$x^{\\sum F_k}$ Solution 1那么反向求解，令$dp_i$表示当前已经确定了$i$个点，没有出现$x^k$倍数大小的联通块 暴力转移，枚举$i$从所有$x^k\\not|j$转移过来即可，单次求解复杂度为$O(n^2)$，不可行 优化1: 考虑分解系数$\\frac{(i+j-1)!} {i!}$，累前缀和，对于$j$为$x^k$倍数的情况枚举减掉 这样单次求解复杂度为$O(\\frac{n^2} {x^k})$，总复杂度为$O(n^2\\ln n)$，且不好处理阶乘逆元 优化2: 不枚举$x^i$的倍数，直接再用一个前缀和数组$s_i$记录下来，让$s_i$从$s_{i-x^k}$转移过来即可 如何将系数$\\frac{(i+j-1)!} {i!}$分解？ 每次$i+j$增大1，就多乘上一个$i+j$即可 当$s_{i}$从$s_{i-x^k}$转移过来时，需要补上$\\begin{aligned}\\prod_{j=i-x^k+1}^{i-1}j\\end{aligned}$ 也就是模拟了上面提到的把$n!$分段的过程 这样就去掉了阶乘逆元的求解 Tips:发现需要预处理$T_{i,j}=\\prod_{k=i}^j k$，可以滚动一下会快一点，内存为$O(n)$ \\不同的$x^i$上限为$O(n)$种，实际大概可能是$O(\\pi(n)\\log \\log n=\\frac{n\\log \\log n} {\\log n})$? 因此复杂度为$O(n^2)$ 可以看到代码还是很简单的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P2))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i) const int N=7510; int n,P,P2;int mk[N];int s[N],T[N],dp[N]; ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125; int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;P),P2=P-1; int ans=1; rep(i,2,n) if(!mk[i]) &#123; for(int j=i+i;j&lt;=n;j+=i) mk[j]=1; for(int x=i;x&lt;=n;x*=i) mk[x]=i; &#125; rep(i,1,n) T[i]=1; int r=1; rep(i,1,n) r=1ll*r*i%P2; rep(x,2,n) &#123; rep(j,1,n-x+1) T[j]=1ll*T[j]*(j+x-2)%P2; // 滚动求解区间乘积 if(mk[x]&lt;=1) continue; dp[0]=1,s[0]=1; int sum=1; rep(i,1,n) &#123; s[i]=0; if(i&gt;=x) s[i]=1ll*s[i-x]*T[i-x+1]%P2; dp[i]=sum-s[i]; Mod2(dp[i]); s[i]=(1ll*s[i]*i+dp[i])%P2; sum=(1ll*sum*i+dp[i])%P2; &#125; ans=1ll*ans*qpow(mk[x],P2+r-dp[n])%P; &#125; printf(&quot;%d\\n&quot;,ans);&#125; Solution 2为了便于表达，设满足条件为至少出现一个$x$的倍数 实际用min-max容斥确实比较好理解，设对于集合$S$，求其最大值 $\\begin{aligned} \\max \\lbrace S\\rbrace =\\sum_{T\\sube S} (-1)^{|T|+1}\\min\\lbrace T \\rbrace\\end{aligned}$ 简要证明的话: 把$S$中的元素倒序排成一排分别为$S_i$ 对于$S_1$即最大值，显然被计算一次 对于剩下的值$S_i(i&gt;1)$，则它作为最小值产生贡献意味着选的数都在$1-i$内，显然有$2^{i-1}$次为奇数集合大小，$2^{i-1}$为偶数集合大小，两部分抵消 \\要计算最大值为1的方案数，那么就要计算最小值为1的子集方案数 考虑强制一个子集中每一个环大小均为$x$的倍数，设选出了$i$个这样的环，总大小为$j$的方案数为$dp_{i,j}$ 则实际对答案的贡献还要考虑这样的子集出现的次数 考虑选择子集的位置，以及剩下的$n-j$个点任意排布，方案数应该为$C(n,j)\\cdot (n-j)!=\\frac{n!} {j!}$ 如果真的用$dp_{i,j}$，复杂度显然太高，考虑$i$这一维的影响只在于系数$(-1)^{|T|+1}$，可以直接在转移过程中解决 因此可以直接记录大小$i$，从前面转移过来 (可以看到依然需要访问上面提到的$T_{i,j}$，要滚动的话还会更难处理) 这样的$dp$状态有$\\frac{n} {x}$种，转移为$(\\frac{n} {x})^2$，最后统计复杂度为$O(\\frac{n} {x})$ 实际上这样的复杂度已经足够了，是$O(\\sum \\frac{n^2} {i^2}\\approx n^2)$ 以下是$O(n^2)$内存的代码 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a;i&lt;=b;++i)#define drep(i,a,b) for(int i=a;i&gt;=b;--i)typedef long long ll;const int N=7510;int n,P,P2,T[N][N],mk[N],dp[N];ll qpow(ll x,ll k) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int Calc(int x)&#123; int m=n/x,s=P2-1; rep(i,1,m) &#123; s=1ll*s*T[(i-1)*x+1][i*x-1]%P2; dp[i]=P2-s; s=(1ll*s*i*x+dp[i])%P2; &#125; int ans=0; rep(i,1,m) ans=(ans+1ll*dp[i]*T[i*x+1][n])%P2; return ans;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;P),P2=P-1; rep(i,2,n) if(!mk[i]) &#123; for(int j=i;j&lt;=n;j+=i) mk[j]=1; for(int j=i;j&lt;=n;j*=i) mk[j]=i; &#125; rep(i,1,n+1)&#123; T[i][i-1]=1; rep(j,i,n) T[i][j]=1ll*T[i][j-1]*j%P2; &#125; int ans=1; rep(i,2,n) if(mk[i]&gt;1) ans=ans*qpow(mk[i],Calc(i))%P; printf(&quot;%d\\n&quot;,ans);&#125; \\最终优化可以看到，这个做法和Sol1的转移有十分的相同之处，因此考虑用同样的方法优化掉 但是预处理系数的部分依然是$O(n^2)$的，如何解决呢? 1.线段树大法 预处理复杂度为$O(n)$，查询复杂度为$O(\\log n)$，总复杂度$O(n\\log^2 n)$ 空间复杂度为$O(n)$ Oh这个代码是ZKW线段树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a;i&lt;=b;++i)typedef long long ll;const int N=7510;int n,P,P2;struct Tree &#123; int s[N&lt;&lt;2],bit; void Build() &#123; for(bit=1;bit&lt;=n;bit&lt;&lt;=1); rep(i,1,n) s[i+bit]=i; for(int i=bit;i&gt;=1;--i) s[i]=1ll*s[i&lt;&lt;1]*s[i&lt;&lt;1|1]%P2; &#125; int Que(int l,int r)&#123; if(l&gt;r) return 1; if(l==r) return l; int res=1; for(l+=bit-1,r+=bit+1;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1)&#123; if(~l&amp;1) res=1ll*res*s[l^1]%P2; if(r&amp;1) res=1ll*res*s[r^1]%P2; &#125; return res; &#125;&#125; T;int mk[N];ll qpow(ll x,ll k) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int dp[N];int Calc(int x)&#123; int m=n/x,s=P2-1; rep(i,1,m) &#123; s=1ll*s*T.Que((i-1)*x+1,i*x-1)%P2; dp[i]=P2-s; s=(1ll*s*i*x+dp[i])%P2; &#125; int ans=0; rep(i,1,m) ans=(ans+1ll*dp[i]*T.Que(i*x+1,n))%P2; return ans;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;P),P2=P-1; T.Build(); rep(i,2,n) if(!mk[i]) &#123; for(int j=i;j&lt;=n;j+=i) mk[j]=1; for(int j=i;j&lt;=n;j*=i) mk[j]=i; &#125; int ans=1; rep(i,2,n) if(mk[i]&gt;1) ans=ans*qpow(mk[i],Calc(i))%P; printf(&quot;%d\\n&quot;,ans);&#125; 2.模数分解+CRT(Chinese Remainder Theory) 分解后，可以用模逆元处理，然后就直接做，最后CRT合并一下，其实我并不会实现。。。 3.猫树(嘿嘿) 这是一个$O(n\\log n)$预处理，$O(1)$查询的数据结构，空间复杂度为$O(n\\log n)$ 因此复杂度为$O(n\\log n)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a;i&lt;=b;++i)#define drep(i,a,b) for(int i=a;i&gt;=b;--i)typedef long long ll;const int N=7510;int n,P,P2;struct SuckCat&#123; int s[14][8200],Log[8200],bit; void Build() &#123; for(bit=1;bit&lt;=n;bit&lt;&lt;=1); rep(i,2,bit) Log[i]=Log[i&gt;&gt;1]+1; for(int l=1,d=0;l*2&lt;=bit;l&lt;&lt;=1,d++)&#123; for(int i=l;i&lt;=bit;i+=l*2)&#123; s[d][i-1]=i-1,s[d][i]=i; drep(j,i-2,i-l) s[d][j]=1ll*s[d][j+1]*j%P2; rep(j,i+1,i+l-1) s[d][j]=1ll*s[d][j-1]*j%P2; &#125; &#125; &#125; int Que(int l,int r)&#123; if(l&gt;r) return 1; if(l==r) return l; int d=Log[l^r]; return 1ll*s[d][l]*s[d][r]%P2; &#125;&#125; T;int mk[N];ll qpow(ll x,ll k) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int dp[N];int Calc(int x)&#123; int m=n/x,s=P2-1; rep(i,1,m) &#123; s=1ll*s*T.Que((i-1)*x+1,i*x-1)%P2; dp[i]=P2-s; s=(1ll*s*i*x+dp[i])%P2; &#125; int ans=0; rep(i,1,m) ans=(ans+1ll*dp[i]*T.Que(i*x+1,n))%P2; return ans;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;P),P2=P-1; T.Build(); rep(i,2,n) if(!mk[i]) &#123; for(int j=i;j&lt;=n;j+=i) mk[j]=1; for(int j=i;j&lt;=n;j*=i) mk[j]=i; &#125; int ans=1; rep(i,2,n) if(mk[i]&gt;1) ans=ans*qpow(mk[i],Calc(i))%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"USACO","slug":"USACO","permalink":"http://chasingdeath.github.io/tags/USACO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"Sprinklers 2  Return of the Alfalfa P","slug":"Sprinklers 2  Return of the Alfalfa P","date":"2020-09-27T08:43:18.000Z","updated":"2021-05-22T03:54:10.992Z","comments":true,"path":"articles/2020/09/27/b6c8a0c4.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/27/b6c8a0c4.html","excerpt":"","text":"Sprinklers 2: Return of the Alfalfa P条件是: 每个点都要被覆盖，且不能被两种覆盖，那么最后覆盖的情况一定是形如下图的 其中红色和黄色的点表示关键的覆盖点，其他点按照其所属的颜色可以选择放或者不放 那么考虑从上到下，依次对于每一层$dp$竖线的位置，那么有两种转移方法 1.保留上层竖线，两边空白位置的可行点用2的幂次乘进答案即可 2.将当前层的竖线右移，必须选择两个位置，其他位置依然按照2的幂次加入答案 直接转移是$O(n^3)$的，对于第2中转移应用前缀和优化即可做到$O(n^2)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)typedef double db;typedef long double ldb;typedef long long ll;typedef unsigned long long ull;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,const T &amp;b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,const T &amp;b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125; char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125; const int N=2e3+10,P=1e9+7; int n;char A[N][N]; int dp[N][N];int c[N][N],rc[N][N]; int Pow[N]; int main()&#123; n=rd(); rep(i,1,n) scanf(&quot;%s&quot;,A[i]+1); rep(i,1,n) rep(j,1,n) c[i][j]=c[i][j-1]+(A[i][j]==&#x27;.&#x27;); rep(i,1,n) drep(j,n,1) rc[i][j]=rc[i][j+1]+(A[i][j]==&#x27;.&#x27;); rep(i,Pow[0]=1,n) Pow[i]=Pow[i-1]*2%P; dp[0][0]=1; rep(i,1,n) &#123; int s=0; rep(j,0,n) &#123; dp[i][j]=(dp[i][j]+1ll*dp[i-1][j]*Pow[c[i][j]+rc[i-1][j+1]])%P; // 空白位置的可行点按照2的幂次加入答案 if(A[i][j]!=&#x27;W&#x27;) dp[i][j]=(dp[i][j]+1ll*s*(j?Pow[c[i][j]-1]:1))%P; //把两个强制选择的关键点分开，在累入前缀和 和 从前缀和中拿出时考虑即可 if(A[i-1][j+1]!=&#x27;W&#x27;) s=(s+1ll*dp[i-1][j]*(i&gt;1&amp;&amp;j&lt;n?Pow[rc[i-1][j+1]-1]:1))%P; &#125; &#125; int ans=0; rep(i,0,n) if(A[n][i+1]!=&#x27;W&#x27;) ans=(ans+1ll*(i&lt;n?Pow[rc[n][i+1]-1]:1)*dp[n][i])%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"Equilateral Triangles","slug":"Equilateral Triangles","date":"2020-09-25T12:51:48.000Z","updated":"2021-05-22T03:54:10.937Z","comments":true,"path":"articles/2020/09/25/4e5cd8bd.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/25/4e5cd8bd.html","excerpt":"","text":"Equilateral Triangles题意: 求所有三个点哈密顿距离相等的无序三元点对个数 推论1: 到平面中一点$(x,y)$哈密顿距离为$d$的点，构成一个以$(x,y)$为中心，$d$为半对角线长的菱形 菱形不好搞，转一下，令旋转后的点$x’=x+y,y’=x-y$，(也就是曼哈顿距离转切比雪夫距离) 这样得到的就是一个正方形了 推论2: 选出的三点中，一定存在两个点$x$或者$y$坐标相同 如果选出点$A,B$不满足，由下图可以看到，可行的部分(就是相交部分$C1,C2$)也必然满足 接下来以$x$相同为例，枚举点$A,B$，设其距离为$d$ 可以看到比较显然就是两条红色的相交线段，$O(n^3)$枚举$A,B$两点后，直接用前缀和维护即可 对于$x$相同，对于$y$相同分别做一次即可，注意考虑的时候不要把$x,y$都有相同的算两次 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)const int N=610;int n;char A[N][N],B[N][N];int S[N][N];int D[N],C;int main() &#123; scanf(&quot;%d&quot;,&amp;n); rep(i,1,n) &#123; scanf(&quot;%s&quot;,A[i]+1); rep(j,1,n) if(A[i][j]==&#x27;*&#x27;) B[i+j][i-j+n]=1; &#125; int ans=0; rep(i,1,n*2) rep(j,1,n*2) S[i][j]=S[i][j-1]+B[i][j]; rep(i,1,n*2) &#123; C=0; rep(x,1,n*2) if(B[i][x]) D[++C]=x; rep(a,1,C) rep(b,a+1,C) &#123; int d=D[b]-D[a]; i-d&gt;=1 &amp;&amp; (ans+=S[i-d][D[b]]-S[i-d][D[a]-1]); i+d&lt;=n*2 &amp;&amp; (ans+=S[i+d][D[b]]-S[i+d][D[a]-1]); &#125; &#125; rep(i,1,n*2) rep(j,1,n*2) S[i][j]=S[i][j-1]+B[j][i]; rep(i,1,n*2) &#123; C=0; rep(x,1,n*2) if(B[x][i]) D[++C]=x; rep(a,1,C) rep(b,a+1,C) &#123; int d=D[b]-D[a]; i-d&gt;=1 &amp;&amp; (ans+=S[i-d][D[b]-1]-S[i-d][D[a]]); i+d&lt;=n*2 &amp;&amp; (ans+=S[i+d][D[b]-1]-S[i+d][D[a]]); &#125; &#125; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[USACO 2020 February Platinum]Help Yourself","slug":"[USACO 2020 February Platinum]Help Yourself","date":"2020-09-25T04:16:05.000Z","updated":"2021-05-22T03:54:11.086Z","comments":true,"path":"articles/2020/09/25/11c9902.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/25/11c9902.html","excerpt":"","text":"[USACO 2020 February Platinum]Help Yourself真的很套路。。。 考虑将区间$(L_i,R_i)$按照左端点排序，依次考虑每个区间的贡献 令$dp_i$表示当前所有选择的右端点中最大的为$i$时的方案数 加入区间$(L,R)$时 1.所有$i&lt;L$的部分一定会断开成两个区间，转移时个数+1 2.当$i\\ge L$时，$dp_i$向$dp_{\\max\\lbrace R,i\\rbrace}$转移，分两类讨论即可 不考虑个数的问题，直接转移是$O(n^2)$的，但是可以用线段树优化到$n\\log n$ (比较麻烦，需要实现区间查询，单点修改，区间乘法) 考虑个数$k$次幂，一种暴力的办法是存下$dp_{i,j}$，但是转移会变成$O(n^2\\log n)$ 对于当前个数为$c$的情况，如果新增一个联通块，即变为$c+1$，答案由$c^k$ 变为$(c+1)^k$ 考虑直接用二项式定理展开这个式子，需要记录$c^i(i\\in [0,k])$的所有答案，再$O(k^2)$完成+1操作 结合线段树，维护$nk$个值，复杂度为$O(n(k\\log n +k^2))$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair &lt;int,int&gt; Pii;#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=2e5+10,P=1e9+7;int n,k;Pii A[N];int C[11][11];int s[N&lt;&lt;2][11],res[11];int t[N&lt;&lt;2];void Up(int p) &#123; rep(i,0,k) s[p][i]=s[p&lt;&lt;1][i]+s[p&lt;&lt;1|1][i],Mod1(s[p][i]);&#125;void Down(int p) &#123; if(t[p]==1) return; t[p&lt;&lt;1]=1ll*t[p&lt;&lt;1]*t[p]%P; t[p&lt;&lt;1|1]=1ll*t[p&lt;&lt;1|1]*t[p]%P; rep(i,0,k) &#123; s[p&lt;&lt;1][i]=1ll*s[p&lt;&lt;1][i]*t[p]%P; s[p&lt;&lt;1|1][i]=1ll*s[p&lt;&lt;1|1][i]*t[p]%P; &#125; t[p]=1;&#125;void Que(int p,int l,int r,int ql,int qr) &#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; rep(i,0,k) res[i]+=s[p][i],Mod1(res[i]); return; &#125; Down(p); int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) Que(p&lt;&lt;1,l,mid,ql,qr); if(qr&gt;mid) Que(p&lt;&lt;1|1,mid+1,r,ql,qr);&#125;void Upd(int p,int l,int r,int ql,int qr) &#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; rep(i,0,k) s[p][i]*=2,Mod1(s[p][i]); t[p]*=2,Mod1(t[p]); return; &#125; Down(p); int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) Upd(p&lt;&lt;1,l,mid,ql,qr); if(qr&gt;mid) Upd(p&lt;&lt;1|1,mid+1,r,ql,qr); Up(p);&#125;void Upd(int p,int l,int r,int x)&#123; if(l==r)&#123; rep(i,0,k) s[p][i]+=res[i],Mod1(s[p][i]); return; &#125; Down(p); int mid=(l+r)&gt;&gt;1; x&lt;=mid?Upd(p&lt;&lt;1,l,mid,x):Upd(p&lt;&lt;1|1,mid+1,r,x); Up(p);&#125;int main()&#123; n=rd(),k=rd(); rep(i,1,n) A[i].first=rd(),A[i].second=rd(); sort(A+1,A+n+1); rep(i,1,N*4-1) t[i]=1; rep(i,0,k) rep(j,C[i][0]=1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P; res[0]=1; Upd(1,0,n*2,0); rep(t,1,n) &#123; int l=A[t].first,r=A[t].second; Upd(1,0,n*2,r,n*2); memset(res,0,sizeof res); Que(1,0,n*2,0,l-1); drep(i,k,0) rep(j,0,i-1) res[i]=(res[i]+1ll*C[i][j]*res[j])%P; Upd(1,0,n*2,r); memset(res,0,sizeof res); Que(1,0,n*2,l,r-1); Upd(1,0,n*2,r); &#125; printf(&quot;%d\\n&quot;,s[1][k]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"USACO","slug":"USACO","permalink":"http://chasingdeath.github.io/tags/USACO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"美丽的桥梁","slug":"美丽的桥梁","date":"2020-09-11T10:34:02.000Z","updated":"2021-05-22T03:54:11.410Z","comments":true,"path":"articles/2020/09/11/ec4a25b7.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/11/ec4a25b7.html","excerpt":"","text":"美丽的桥梁可以得到一个Naive的暴力方法来判断在$(L,R)$上修桥是否合法: 显然的性质: 如果有相交，则一定存在一个关键点相交 设得到的圆半径为$r=\\frac{x_R-x_L} {2}$，圆心为$(x,y)=(\\frac{x_L+x_R} {2},h-r)$ 枚举每个$i\\in [L,R]$判断是否点$x_i,y_i$是否相交，如果相交，只需要满足 $y_i&gt;y$，且 其与圆心距离$&gt;r$ \\考虑优化判断，将生成的拱形分为左右两部分，分别考虑即可 推论: 对于每个$L$，其左半边不相交的半径为描述为一个范围$[0,A_L]$ 同理的，对于每个$R$也是如此，能求得一个范围$[0,B_R]$ 考虑对于每个$L$，枚举每个$i&gt;L$ 来求出$A_L$ 设半径为$r$，列出圆心与点$x_i,y_i$距离的表达式，必须满足距离$\\leq r$，就能得到一个二次方程 二次方程的解集为$x_1,x_2$，但是实际上$[0,x_1]$这一段不满足$y_i&gt;y$，因此也是合法的 即将每次求得的$[0,x_2]$区间取交集即可 复杂度为$O(n^2)$ 同理求得每个$B_R$ 考虑朴素的dp，令$dp_i$表示解决了$[1,i]$前缀的最小代价 枚举$j$，$O(1)$判断$(i,j)$是否合法，然后进行转移 tips: 题目的代价计算方法可能没讲清楚。。。 复杂度为$O(n^2)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)typedef double db;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,const T &amp;b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,const T &amp;b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1e4+10;const db eps=1e-9;const ll INF=4e18;int n,h,a,b;int X[N],Y[N];db L[N],R[N];db Sqr(db x)&#123; return x*x; &#125;ll dp[N];int main()&#123; n=rd(),h=rd(),a=rd(),b=rd(); rep(i,1,n) X[i]=rd(),Y[i]=rd(); rep(i,1,n) &#123; L[i]=min((db)(X[n]-X[i])/2,(db)(h-Y[i])); rep(j,i+1,n) &#123; if(X[j]-X[i]&gt;L[i]+eps) break; db a=1,b=2*(X[i]-X[j]+Y[j]-h),c=Sqr(X[i]-X[j])+Sqr(Y[j]-h); db d=sqrt(b*b-4*a*c); db r=(-b+d)/(2*a); cmin(L[i],r); &#125; L[i]*=2; &#125; rep(i,1,n) &#123; R[i]=min((db)(X[i]-X[1])/2,(db)(h-Y[i])); drep(j,i-1,1) &#123; if(X[i]-X[j]&gt;R[i]+eps) break; db a=1,b=2*(X[j]-X[i]+Y[j]-h),c=Sqr(X[j]-X[i])+Sqr(Y[j]-h); db d=sqrt(b*b-4*a*c); db r=(-b+d)/(2*a); cmin(R[i],r); &#125; R[i]*=2; &#125; dp[1]=1ll*a*(h-Y[1]); rep(i,2,n) &#123; dp[i]=INF; drep(j,i-1,1) &#123; if(X[i]-X[j]&gt;R[i]+eps) break; if(X[i]-X[j]&gt;L[j]+eps) continue; cmin(dp[i],dp[j]+1ll*a*(h-Y[i])+1ll*(X[i]-X[j])*(X[i]-X[j])*b); &#125; &#125; if(dp[n]&lt;INF) printf(&quot;%lld\\n&quot;,dp[n]); else puts(&quot;impossible&quot;);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"何以伊名始","slug":"何以伊名始","date":"2020-09-11T10:21:48.000Z","updated":"2021-05-22T03:54:11.333Z","comments":true,"path":"articles/2020/09/11/c91f3f73.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/11/c91f3f73.html","excerpt":"","text":"何以伊名始本题现已知四种做法，如果不会后缀系列结构可以直接看Solution4 设初始树大小和查询总长均为$O(n)$ Solution1由于查询只有1e6，因此出现的不同查询串长度最多$\\sqrt {10^6}=1000$种 考虑对于每一种做一次dfs，在$\\text{Hash Table}$中查询，复杂度为$O(n\\sqrt n)$ Solution2将树上节点后缀排序，然后每次插入需要询问的字符就二分后缀区间 预处理复杂度为$O(n\\log n)$，查询涉及二分和倍增，复杂度为$O(n\\log ^2 n)$ Solution3给定的树看做trie树，可以对于trie树建广义后缀自动机，然后倒着让询问串去匹配，一旦失配答案为0， 需要预处理$link$树的子树和，时间复杂度为$O(n)$，空间复杂度为$O(n|\\Sigma|)$ Solution4将询问的串倒着插入，构建AC自动机 由于AC自动机预处理，时间空间复杂度为$O(n|\\Sigma|)$ 然后考虑对于树上每一个前缀在AC自动机上匹配，每次从父亲转移过来，复杂度为$O(n)$ 然后是常见的AC自动机操作，$fail$树上的子树累和即可 需要询问离线，因此有一定局限性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=1e6+10;int n,m,len,F[N],A[N];char s[N],t[N];int nxt[N][26],fail[N],cnt,pos[N];int Q[N],L=1,R;void Build()&#123; rep(i,0,25) if(nxt[0][i]) Q[++R]=nxt[0][i]; while(L&lt;=R) &#123; int u=Q[L++]; rep(i,0,25) &#123; int &amp;v=nxt[u][i]; if(v) fail[v]=nxt[fail[u]][i],Q[++R]=v; else v=nxt[fail[u]][i]; &#125; &#125;&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,n) scanf(&quot;%c&quot;,s+i),F[i]=rd(); rep(i,1,m) &#123; scanf(&quot;%s&quot;,t+1); int now=0; drep(j,strlen(t+1),1) &#123; int c=t[j]-&#x27;A&#x27;; if(!nxt[now][c]) nxt[now][c]=++cnt; now=nxt[now][c]; &#125; pos[i]=now; &#125; Build(); rep(i,1,n) A[F[i]=nxt[F[F[i]]][s[i]-&#x27;A&#x27;]]++; drep(i,R,1) A[fail[Q[i]]]+=A[Q[i]]; rep(i,1,m) printf(&quot;%d\\n&quot;,A[pos[i]]);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"COCI20162017 Contest 7 F","slug":"COCI20162017 Contest 7 F","date":"2020-09-10T12:44:52.000Z","updated":"2021-05-22T03:54:10.891Z","comments":true,"path":"articles/2020/09/10/fa32eb3c.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/10/fa32eb3c.html","excerpt":"","text":"COCI20162017 Contest#7 F前置知识沿用上面的定义，设字符串$S$的$\\text{border}$集合为$B(S)$ 考虑对于单串$S$求答案，设答案为$Ans$ 将所有可能出现的字符串分为两个集合$A,B$ 其中$A$为所有恰好出现$S$的字符串集合，$B$为所有还未出现匹配的字符串集合 我们知道每个字符串出现有一定的概率，即为$\\frac{1} {n^{|T|} }$ 设$A$集合中所有长度为$i$的串出现的概率总和为$A_i$，同理得到$B_i$ $A$中的概率是不重复的，因为每个匹配过程只有一次会恰好匹配，因此可以得到 $\\sum A_i=1$ (而$B$中每个不匹配的串概率会被算多次) 最后的答案期望可以表示为 1.每个匹配的串概率*匹配时串的长度之和，即$Ans=\\sum_i i\\cdot A_i$ 2.将匹配成功的长度，转化为匹配失败的次数之和(包含空串)，可以表示为$Ans=\\sum B_i$ 直接计算似乎比较麻烦 \\考虑如果在$B$中所有字符串的后面接上一个原串$S$（同时概率乘上$\\frac{1} {n^{|S|} }$），那么得到的新字符串一定完成匹配 但是实际上，这样的串并不一定完全合法，因为可能在更早的位置出现匹配 由上面的定义，假设原先在$B$中的串为$T$，原先已经在$S$中匹配了$T’$作为前缀 那么直接强行加上$S$后，如果$T’$会影响第一个出现匹配位置，设出现匹配时加入的字符串为$R$ 则显然满足: $R$即是$S$的一段前缀，又是$S$的一段后缀，也就是$R\\in B(S)$ 而剩下部分($|S|-|R|$)，实际上是无效的，因此概率会被算小了 \\不妨设$B$集合接上一个$S$串得到的集合为$C$ 可以把$C$中的字符串，按照多余的部分$|S|-|R|$为多个部分$D_{R}$其中$R\\in B(S)$ 发现，实际上去掉多余的部分后，每个$D_R$集合就与$A$集合对应，但是多余部分的要乘回去 即 $A_i=D_{|R|,i+|S|-|R|}\\cdot n^{|S|-|R|}$ (偏移多出的部分) 由$B,C$的关系，有$\\sum_R D_{R,i}=C_i=B_i\\cdot \\frac{1} {n^{|S|} }$ 也就是$B_i\\frac{1} {n^{|S|} }=\\sum _R D_{R,i+|S|-|R|}=\\sum _R \\frac{A_{i+|S|-|R|} } {n^{|S|-|R|} }$ 即 $B_i=\\sum _R A_{i+|S|-|R|}n^{|R|}$ 将上式求和对于$i$求和，得到$\\sum B_i=\\sum_i\\sum_R A_{i+|S|-|R|}n^{|R|}$ 由于$\\sum A_i=1$ ($\\sum A_i$和$\\sum A_{i+|S|-|R|}$等价)， 即 $Ans=\\sum B_i=\\sum_{R\\in B(S)} n^{|R|}$","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"COCI","slug":"COCI","permalink":"http://chasingdeath.github.io/tags/COCI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"COCI20162017 Contest 6 F ","slug":"COCI20162017 Contest 6 F ","date":"2020-09-10T11:49:00.000Z","updated":"2021-05-22T03:54:10.888Z","comments":true,"path":"articles/2020/09/10/7e45e64c.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/10/7e45e64c.html","excerpt":"","text":"COCI20162017 Contest#6 F其实这个题不是很难的。。。 设值域为$M$ 考虑如果没有幸运数的限制，那么从$A$变成$B$，实际上只与$\\frac{A} {B}$有关 不妨令$dp_{i,j}$为从$i$走了$j$步变成1，显然这个$j$的最大值为$\\log M=19$，即$2^{19}$最多操作19次 从$i$枚举倍数进行转移，同时也暴力处理每个数的因数个数，复杂度为$O(M\\ln M\\log M)$ \\接下来考虑幸运数的限制 推论: 最多只会在一个幸运数上停留 如果经过多个，显然在代价最小的那个上面停留 因此考虑枚举停留的幸运数$x$ 那么转移可以分为两步$\\frac{A} {x}$和$\\frac{x} {B}$，可以暴力合并两个$dp$数组，单次查询复杂度为$O(T\\cdot \\log^2 M)$ 合并得到的结果，可以描述为: 可以在$x$上用$C(x)$的代价停留，并且其他部分的转移花了$j$的时间，$y$的代价 如果考虑停留的时间，那么得到的答案显然是一条直线，斜率就是停留的代价 关于一群直线，一群查询，不难想到可以斜率优化求解，这一部分复杂度为$O(T\\log M\\log (T\\log M)+m)$（排序复杂度） 总复杂度可以认为就是$O(M\\log^2 M+Q(T\\log ^2 M+m))$ 斜率优化的实现可以参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)typedef long long ll;#define reg register#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,const T &amp;b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,const T &amp;b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1e6+10,INF=1e9;int n,m;int F[N],A[N],B[N];int L[N];// A: 因子个数// B: 将B变成1需要的最大步数int C[N],D[N];int dp[N][20];// 用了j步，将i变为1的最小代价struct Node&#123; // 描述一条直线 ll x,y; // 答案为 x*i+y ll operator [](const ll i)const &#123; return i*x+y; &#125; //求直线点值 bool operator &lt; (const Node __) const &#123; if(x!=__.x) return x&lt;__.x; return y&lt;__.y; //按照斜率排序 &#125;&#125; U[N];int Uc,T[21],R[21];int main()&#123; rep(i,1,N-1) &#123; A[i]++; for(reg int j=i+i;j&lt;N;j+=i) A[j]++,cmax(B[j],B[i]+1); &#125; rep(i,1,rd()) F[i]=rd(); rep(i,1,m=rd()) L[i]=rd(); sort(L+1,L+m+1); rep(i,1,N-1) rep(j,0,B[i]) dp[i][j]=INF; dp[1][0]=0; rep(i,1,N-1) rep(j,0,B[i]) if(dp[i][j]&lt;INF) for(reg int k=i+i;k&lt;N;k+=i) cmin(dp[k][j+1],dp[i][j]+F[A[k/i]]); rep(i,1,n=rd()) C[i]=rd(),D[i]=rd(); rep(kase,1,rd()) &#123; int x=rd(),y=rd(),d=x/y; if(x%y!=0)&#123; printf(&quot;%d\\n&quot;,-m); continue; &#125; memset(R,63,sizeof R); Uc=0; rep(i,1,n) if(x%C[i]==0 &amp;&amp; C[i]%y==0)&#123; int dx=x/C[i],dy=C[i]/y; memset(T,63,sizeof T); rep(a,0,B[dx]) if(dp[dx][a]&lt;INF) rep(b,0,B[dy]) cmin(T[a+b],dp[dx][a]+dp[dy][b]); rep(j,0,B[dx]+B[dy]) if(T[j]&lt;INF) &#123; ll a=D[i],b=T[j]-a*j; U[++Uc]=(Node)&#123;a,b&#125;; rep(k,j,B[d]) cmin(R[k],(int)U[Uc][k]); &#125; &#125; rep(i,0,B[d]) cmin(R[i],dp[d][i]); ll ans=0; ll mi=1e18; sort(U+1,U+Uc+1); int R=0; rep(i,1,Uc) &#123; if(mi&lt;U[i].y) continue; mi=U[i].y; while(R&gt;1 &amp;&amp; (U[i].y-U[R].y)*(U[R].x-U[R-1].x)&lt;=(U[R].y-U[R-1].y)*(U[i].x-U[R].x)) R--; U[++R]=U[i]; // 单调栈处理凸包，注意加入时满足x递增，y递减 &#125; rep(i,1,m) if(L[i]&lt;=B[d]) ans+=::R[L[i]]&lt;INF?::R[L[i]]:-1; else &#123; while(R&gt;1 &amp;&amp; U[R-1][L[i]]&lt;=U[R][L[i]]) R--; if(!R) ans--; else ans+=U[R][L[i]]; &#125; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"COCI","slug":"COCI","permalink":"http://chasingdeath.github.io/tags/COCI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"COCI2016/2017 Contest 3 F Meksikanac","slug":"COCI2016 2017 Contest 3 F Meksikanac","date":"2020-09-09T13:52:27.000Z","updated":"2021-05-22T03:54:10.883Z","comments":true,"path":"articles/2020/09/09/547a0d94.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/09/547a0d94.html","excerpt":"","text":"COCI2016/2017 Contest#3 F Meksikanac设$M=\\max\\lbrace X_p,Y_p\\rbrace$ 分析:给定的多边形很难直接处理 如果直接枚举平移位置，然后判断每个点是否在多边形内部 由于不是凸包，判断点的位置可以用1.射线法,2.转角判断是否是360 一次判断复杂度为$O(K)$，因此复杂度为$O(M^2\\cdot N\\cdot K)$，显然不可取 但是观察题目的条件，不管怎么移动，多边形都只包含一些整点 由于多边形内的整点只有 $O(M^2)$ 个，如果能全部求出，直接匹配判断会方便很多，且复杂度降为$O(M^4)$ 那么如何求出多边形内部的整点? 做法1考虑枚举每个点，暴力判断，复杂度为$O(M^2K)$ 做法2考虑枚举$x$一维，像写扫描线一样，把所有合法的$y$扫描出来(跨过奇数次在内部) 复杂度为$O(MK\\log K)$或者可能$O(MK)$ \\优化发现转化后，问题变为了 : 给定点集$A,B$，判断将$A$点集平移$(dx,dy)$后，是否存在点与$B$中重合 考虑这个问题的一维情形: 在给定的数轴上的$[0,M]$内部有$A,B$两个数集 那么出现重合的平移量即$B_i-A_j$，这个问题可以用一次卷积解决，复杂度为$O(M\\log M)$ \\类似的，将$x,y$两维压在一起，做类似的卷积就可以判断$(dx,dy)$是否合法了 复杂度为$O(M^2\\log M^2)=O(M^2\\log M)$ 实现上的话，把$(x,y)$变为$x\\cdot (y_p+2)+y$即可 注意这里的减法向下溢出没有关系，因为溢出的部分恰好不会被调用到 \\综上，总复杂度为$O(KM+M^2\\log M)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define reg register#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125; const int N=510,M=10010,P=998244353;const double eps=1e-9; int X,Y,D,n,m;struct Point&#123; int x,y; void Read()&#123; x=rd(), y=rd(); &#125;&#125; A[M]; const int K=N*N*4.2;int F[K],G[K];double U[M];int cnt,rev[K];ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;void NTT(int n,int *a,int f)&#123; static int e[K&gt;&gt;1]; rep(i,1,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); e[0]=1; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int w=qpow(f==1?3:(P+1)/3,(P-1)/i/2); for(int j=i-2;j&gt;=0;j-=2) e[j+1]=1ll*(e[j]=e[j&gt;&gt;1])*w%P; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,Mod2(a[j+i]); a[j]+=t,Mod1(a[j]); &#125; &#125; &#125; if(f==-1) &#123; ll base=qpow(n); rep(i,0,n-1) a[i]=a[i]*base%P; &#125;&#125; void Cover(int x,int y)&#123; F[(X+1-x)*D+Y-y]=1;&#125; int main()&#123; X=rd(),Y=rd(),D=Y+2; rep(i,1,n=rd()) &#123; int x=rd(),y=rd(); G[x*D+y]=1; &#125; int mix=1e9,miy=1e9,max=-1e9,may=-1e9; rep(i,1,m=rd()) &#123; A[i].Read(); cmin(mix,A[i].x),cmax(max,A[i].x); cmin(miy,A[i].y),cmax(may,A[i].y); &#125; max-=mix,may-=miy; if(max&gt;X || may&gt;Y) return puts(&quot;0&quot;),0; rep(i,1,m) A[i].x-=mix,A[i].y-=miy; A[m+1]=A[1]; rep(i,0,X) &#123; cnt=0; rep(j,1,m) &#123; Point L=A[j],R=A[j+1]; if(L.x&gt;R.x) swap(L,R); if(i&lt;L.x || i&gt;R.x) continue; if(L.x==R.x) &#123; rep(y,min(L.y,R.y),::max(L.y,R.y)) Cover(i,y); continue; &#125; double y=1.0*(R.y-L.y)/(R.x-L.x)*(i-L.x)+L.y; if(i&lt;R.x) U[++cnt]=y; if(abs(y-int(y))&lt;eps) Cover(i,y); &#125; sort(U+1,U+cnt+1); for(int j=1;j&lt;=cnt;j+=2) for(int y=ceil(U[j]);y&lt;=U[j+1]+eps;++y) Cover(i,y); &#125; int R=1,cc=-1; while(R&lt;=(X+1)*2*D) R&lt;&lt;=1,cc++; rep(i,1,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;cc); NTT(R,F,1),NTT(R,G,1); rep(i,0,R-1) F[i]=1ll*F[i]*G[i]%P; NTT(R,F,-1); int ans=0; rep(i,0,X-max) rep(j,0,Y-may) if(!F[(X+1+i)*D+Y+j]) ans++; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"COCI","slug":"COCI","permalink":"http://chasingdeath.github.io/tags/COCI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"COCI2016-2017 Contest 2 F ","slug":"COCI2016-2017 Contest 2 F ","date":"2020-09-08T06:54:59.000Z","updated":"2021-05-22T03:54:10.885Z","comments":true,"path":"articles/2020/09/08/73ef4e1c.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/08/73ef4e1c.html","excerpt":"","text":"COCI2016-2017 Contest#2 F首先分析题意: 任意走都能在$k$步内结束，也就是说，一定可以在$k$步内封锁所有出路 注意游戏停止的条件是后手不能走，因此即使在$k$步封住了出路，下一轮依然要标记一个点 因此必须是$&lt;k$的 设树根1的$dep=0$，第$i$层表示所有$dep=i$的节点 发现第$i$次操作，一定是从$i-1$层走到了$i$ 假设最后的封路决策在$i$层封掉了2个点，那么这个决策一定是不优的 因为在$i$层花2的时间一定不如在$i-1$层和$i$层各花1的时间 因此，问题可以转化为: 在$1-k$层每层选择一个点，判断是否存在一种方案使得选择完成后完全封死出路 显然在最优情况下，选择的点之间不会有祖先关系，并且我们可以删掉所有$dep&gt;k$的点 因此可以写出一个$n\\cdot 2^k$的$dp$ 由于最后要阻塞其实是阻塞所有的叶子($dep=k$的点) 因此考虑令选择每个节点是覆盖了一段叶子，将叶子按照$\\text{dfs}$序从小到大依次标号，设选择$i$子树能覆盖叶子范围$L_i,R_i$ 因此按照$L_i$从小到大依次考虑每个节点，加入的转移就是 $\\begin{aligned} dep_i\\notin S,dp_{L_i,S}\\rightarrow dp_{R_i+1,S\\cup \\lbrace dep_i\\rbrace }\\end{aligned} $ 如果用bitset实现，时间/空间复杂度均为$O(n \\cdot 2^{k-5})$ 如果直接$dp$显然。。。考虑缩小$k$的范围 推论1: 当$n&lt; \\frac{(k-1)\\cdot (k+2)} {2}$时，一定有解 考虑一个浅显的贪心： 在第$i$层用$\\leq i$的代价标记这层所有点 这个方法不可用的条件就是第$i$层的点个数$&gt;i$，那么就有$n\\ge 2+3+\\cdots+k=\\frac{(k-1)(k+2)} {2}$ 可以看到此时$k$的上界已经缩小到$O(\\sqrt n)$级别，但由于实际常数，还是太大了 \\推论2: 当$n\\leq k\\cdot k$时，一定有解 假设删除原树的1节点，则我们决策的对象变为一片森林 考虑依次决策每一层，每次推进一层，都会把选择一棵树删除，并且当前森林所有顶端的节点删除 要求$k$次决策后森林为空 设森林第一层包含$d$个节点 此时一定存在一个子树大小$\\ge \\frac{n} {d}$ 删除这个子树后，规模变为$n-d-\\frac{n} {d}+1$ 我们知道$d+\\frac{n} {d}\\ge 2\\sqrt n$ $n-d-\\frac{n} {d}+1\\leq n-2\\sqrt n+1=(\\sqrt n-1)^2$ 因此得证 此时$k$的上界已经缩小到19，完全可以通过 带入优化的复杂度为$O(n\\cdot 2^{15})$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)typedef long long ll;#define reg register#define pb push_back#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=410;int n,m;vector &lt;int&gt; G[N],Q[N];int dep[N],L[N],R[N],cnt;void pre_dfs(int u,int f) &#123; dep[u]=dep[f]+1; if(dep[u]==m-1) &#123; L[u]=cnt++,R[u]=cnt; return; &#125; L[u]=cnt; for(int v:G[u]) if(v!=f) pre_dfs(v,u); R[u]=cnt;&#125;bitset &lt;1&lt;&lt;19&gt; dp[401],rev[20];int F[N]; int main()&#123; n=rd(),m=rd(); if(m*m&gt;=n) return puts(&quot;DA&quot;),0; rep(i,2,n) &#123; int u=rd(),v=rd(); G[u].pb(v),G[v].pb(u); &#125; memset(dep,-1,sizeof dep),dep[0]=-2,pre_dfs(1,0); rep(i,1,n) if(~dep[i]) Q[L[i]].pb(i); dp[0][0]=1; rep(i,0,m-1) rep(j,0,(1&lt;&lt;m)-1) if(~j&amp;(1&lt;&lt;i)) rev[i][j]=1; rep(i,0,cnt-1) for(int v:Q[i]) &#123; dp[R[v]]|=(dp[i]&amp;rev[dep[v]])&lt;&lt;(1&lt;&lt;dep[v]); &#125; puts(dp[cnt].count()?&quot;DA&quot;:&quot;NE&quot;);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"COCI","slug":"COCI","permalink":"http://chasingdeath.github.io/tags/COCI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"TopCoder SRM 570 Div1 CurvyonRails ","slug":"TopCoder SRM 570 Div1 CurvyonRails ","date":"2020-09-07T03:54:13.000Z","updated":"2021-05-22T03:54:11.009Z","comments":true,"path":"articles/2020/09/07/c8a42437.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/07/c8a42437.html","excerpt":"","text":"TopCoder SRM 570 Div1 CurvyonRails题意: 一个$n\\times m$的网格图，其中有一些点需要建铁路，有一些点为关键点，在关键点上修直铁路会产生1的代价，求最小的代价 由于$n,m\\leq 25$显然不可以插头$\\text{dp}$。。。 考虑轨道联通实际上类似网络流的形式 考虑一个常见的思路: 网格图可以简化为二分图 然后 跑网络流 先不考虑代价的问题，判断是否存在合法方案 每个格子要有两条出边，因此可以让$S$向左侧点连边权为2的边，右侧点向$T$连边权为2的边 然后可以让每个左侧点向相邻的右侧点连边，即考虑了联通关系 下面考虑代价的计算，加入边的代价，即为费用流 连同向边会产生代价，因此考虑为每个节点新增两个节点，表示向上下/左右连边 对于让原节点对于新增的上下和左右节点 分别连两条代价为0和1的边 这样如果流了同向边，就会产生代价 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair &lt;int,int&gt; Pii;#define pb push_back#define mp make_pair#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=25*30*3,M=N&lt;&lt;3,INF=1e9+10;int n,m,k;int a[30][30];// Max Flow Min Costint id[30][30][2];struct Edge&#123; int to,nxt,w,c;&#125;e[M];int head[N],ecnt,S,T,V;void Clear()&#123; rep(i,1,V) head[i]=0; ecnt=1,V=0;&#125;void AddEdge(int u,int v,int w,int c) &#123; e[++ecnt]=(Edge)&#123;v,head[u],w,c&#125;; head[u]=ecnt;&#125;void Link(int u,int v,int w,int c=0)&#123; AddEdge(u,v,w,c),AddEdge(v,u,0,-c); &#125;#define erep(u,i) for(int i=head[u],v=e[i].to,w=e[i].w,c=e[i].c;i;i=e[i].nxt,v=e[i].to,w=e[i].w,c=e[i].c)int dis[N];int SPFA()&#123; static int inq[N]; static queue &lt;int&gt; que; rep(i,1,V) dis[i]=INF; que.push(S),dis[S]=0; while(!que.empty()) &#123; int u=que.front(); que.pop(); inq[u]=0; erep(u,i) if(w &amp;&amp; dis[v]&gt;dis[u]+c) &#123; dis[v]=dis[u]+c; if(!inq[v]) inq[v]=1,que.push(v); &#125; &#125; return dis[T]&lt;INF;&#125;int Dfs(int u,int in) &#123; if(u==T) return in; int out=0,t=dis[u]; dis[u]=INF; erep(u,i) if(w &amp;&amp; dis[v]==t+c) &#123; int t=Dfs(v,min(in-out,w)); e[i].w-=t,e[i^1].w+=t,out+=t; if(in==out) break; &#125; if(out) dis[u]=t; return out;&#125;Pii Dinic()&#123; int flow=0,cost=0; while(SPFA()) for(int t;(t=Dfs(S,INF));) flow+=t,cost+=dis[T]*t; return mp(flow,cost);&#125;class CurvyonRails &#123; public: int getmin(vector &lt;string&gt; field) &#123; n=field.size(),m=field[0].size(); rep(i,0,n-1) rep(j,0,m-1) a[i+1][j+1]=field[i][j]; k=0,Clear(); rep(i,1,n) rep(j,1,m) if(a[i][j]!=&#x27;w&#x27;) &#123; k++; rep(d,0,1) id[i][j][d]=++V; &#125; S=++V,T=++V; rep(i,1,n) rep(j,1,m) if(a[i][j]!=&#x27;w&#x27;) &#123; if((i+j)&amp;1)&#123; Link(S,++V,2,0); rep(d,0,1) &#123; Link(V,id[i][j][d],1,0); Link(V,id[i][j][d],1,a[i][j]==&#x27;C&#x27;); // 如果两条走了同向，就会产生1的代价 &#125; if(i&lt;n &amp;&amp; a[i+1][j]!=&#x27;w&#x27;) Link(id[i][j][0],id[i+1][j][0],1,0); if(j&lt;m &amp;&amp; a[i][j+1]!=&#x27;w&#x27;) Link(id[i][j][1],id[i][j+1][1],1,0); &#125; else &#123; Link(++V,T,2,0); rep(d,0,1) &#123; Link(id[i][j][d],V,1,0); Link(id[i][j][d],V,1,a[i][j]==&#x27;C&#x27;); // 如果两条走了同向，就会产生1的代价 &#125; if(i&lt;n &amp;&amp; a[i+1][j]!=&#x27;w&#x27;) Link(id[i+1][j][0],id[i][j][0],1,0); if(j&lt;m &amp;&amp; a[i][j+1]!=&#x27;w&#x27;) Link(id[i][j+1][1],id[i][j][1],1,0); &#125; &#125; Pii ans=Dinic(); if(ans.first!=k) return -1; return ans.second; &#125;&#125;;//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"[BZOJ4331] [JSOI2012]越狱老虎桥","slug":"[BZOJ4331] [JSOI2012]越狱老虎桥","date":"2020-09-05T12:34:29.000Z","updated":"2021-05-22T03:54:11.026Z","comments":true,"path":"articles/2020/09/05/59479430.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/05/59479430.html","excerpt":"","text":"[BZOJ4331] [JSOI2012]越狱老虎桥题意: 在任意加入一条边的情况下，求 割一条边使图不从1联通的最小割边的 最大值 首先根据题目的意思，可以下对这个无向图中 进行边双联通分量 缩点 建出一棵边双生成树，树边即为原图的割边，树边带权 割掉双联通分量内部的边显然没有意义，所以忽略掉他们，下文所提的均是树上节点和边 在不额外加边的情况下，而割掉树边会使子树内部的点断开 在加入边的情况下，若加入一条$1-u$的边，则形成了一个$1-u$的环，环是无法通过割开一条边断开的 而连接树上两个节点$(u,v)$的情况，把图展开后，就会发现，就是把$u,v$路径上所有的点都缩进了同一个环 此时断掉环上的边显然不合法，而不在环上的边，只需要随便断掉一条，就能让一个点不连通 也就是说，答案是 (去掉某个点对$(u,v)$路径上的所有边，剩下的边中最小值) 的最大值 设答案为$ans$ 这个问题实际上等价于所有的$e\\in E,w(e)\\leq ans$的边无法被一条路径完全覆盖 做法1: 考虑二分答案，把每条$e\\in E,w(e)\\leq ans$的边的权值设为1，求出直径长度判断是否可以用一条路径完全覆盖即可 复杂度为$O(n\\log n)$ 做法2: 实际上这个问题就是 (选择了合法的3条边中边权的最大值) 的最小值 对于当前节点$u$，实际合法情况有 1.选择了一条祖先的边，和2条儿子岔开的边 2.选择了3条垂下的岔开的边，这个合并时比较诡异可以看代码 $\\text{dp}$维护即可，复杂度为$O(n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,const T &amp;b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=5e5+10,INF=1e9+10;int n,m;struct Edge&#123; int to,nxt,w;&#125; e[N*6];int head[N],ecnt;void AddEdge(int u,int v,int w) &#123; e[++ecnt]=(Edge)&#123;v,head[u],w&#125;; head[u]=ecnt;&#125;#define erep(u,i) for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to)int low[N],t[N],id[N],scc,dfn;int stk[N],top;void dfs(int u,int f) &#123; low[u]=t[u]=++dfn; stk[++top]=u; erep(u,i) if(v!=f) &#123; if(!t[v]) dfs(v,u),cmin(low[u],low[v]); else cmin(low[u],t[v]); &#125; if(low[u]==t[u])&#123; int v; ++scc; do v=stk[top--],id[v]=scc; while(v!=u); &#125;&#125;int head2[N];void AddEdge2(int u,int v,int w) &#123; e[++ecnt]=(Edge)&#123;v,head2[u],w&#125;; head2[u]=ecnt;&#125;#define erep2(u,i) for(int i=head2[u],v=e[i].to,w=e[i].w;i;i=e[i].nxt,v=e[i].to,w=e[i].w)int ans=INF;int dp[N][4],tmp[4],g[N];void dfs1(int u,int f) &#123; dp[u][0]=0,dp[u][1]=dp[u][2]=dp[u][3]=INF; erep2(u,i) if(v!=f) &#123; g[v]=min(g[u],w),dfs1(v,u); memset(tmp,63,sizeof tmp); rep(j,0,3) &#123; cmin(tmp[j],dp[u][j]); if(j&lt;3) cmin(tmp[j+1],max(dp[u][j],w)); rep(k,0,3-j) cmin(tmp[j+k],max(dp[u][j],dp[v][k])); &#125; rep(j,0,3) dp[u][j]=tmp[j]; &#125; cmin(ans,dp[u][3]); cmin(ans,max(g[u],dp[u][2]));&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,m) &#123; int u=rd(),v=rd(),w=rd(); AddEdge(u,v,w),AddEdge(v,u,w); &#125; dfs(1,0); rep(u,1,n) erep(u,i) if(id[u]!=id[v]) AddEdge2(id[u],id[v],e[i].w); g[id[1]]=INF,dfs1(id[1],0); printf(&quot;%d\\n&quot;,ans==INF?-1:ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各省OI","slug":"各省OI","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E7%9C%81OI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[BZOJ2688]Green Hackenbush","slug":"[BZOJ2688]Green Hackenbush","date":"2020-09-05T12:28:34.000Z","updated":"2021-05-22T03:54:11.024Z","comments":true,"path":"articles/2020/09/05/bd3920fe.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/05/bd3920fe.html","excerpt":"","text":"[BZOJ2688]Green Hackenbush题意: 有$n$棵随机的二叉树，每棵只知道大小为$a_i$ 博弈:每次选取一个子树删掉，只剩根不能操作，求先手获胜概率 考虑这个博弈，求出一棵树的$\\text{SG}$值 显然有: 1.只有一个点的树的$\\text{SG}$值为0 2.多个树组合的问题为$\\text{SG}$值异或 暴力$dp$，对于树$T$求答案，设$T$所有可行的后继状态集合为$N(T)$，则得到$\\text{SG}$值的表达式为 $\\text{SG}(T)=\\text{mex}_{R\\in N(T)}\\lbrace\\text{SG(R)}\\rbrace $ 直接求解复杂度过高，考虑归纳性质 性质: 1.一棵根节点只有一个儿子的树，其$\\text{SG}$值为儿子的$\\text{SG}$值+1 考虑归纳证明: 设子树为$T$，令$T+u$表示$T$子树上面接上自己作为根，问题变为求证$\\text{SG}(T+u)=\\text{SG}(T)+1$ 设已经归纳证明所有$T$的子联通块成立 我们要求$\\text{SG}(T+u)$ $\\text{SG}(T+u)=\\text{mex} \\{\\text{SG}(u),\\forall _{R\\in N(T)}\\text{SG}(R+u)\\}$ 由归纳的性质有 $\\forall _{R\\subsetneq T}\\text{SG}(R+T)=\\text{SG}(R)+1$ 又因为$\\text{SG}(u)=0$，看做把所有儿子的情况平移了1，0的位置由自己占据，因而上式成立 2.多叉树的问题可以归纳为 根分别接上每个儿子得到的树 的问题的组合 因为儿子之间实际互不干扰，比较容易理解 由此得到，一棵树的$\\text{SG}$值为其所有儿子的$\\text{SG}$值+1的异或和 令$dp_{n,i}$为一棵$n$个节点的二叉树$\\text{SG}$值为$i$的概率，为了便于转移，设空树的$\\text{SG}$值为-1 考虑直接枚举两棵子树的大小和$\\text{SG}$值 考虑对于$n$个节点的二叉树，设其左儿子为$i$时的总概率为$F_i$ 得到的$\\text{dp}$转移是 $dp_{n,(a+1)\\oplus (b+1)}\\leftarrow {dp_{i,a}\\cdot dp_{n-i-1,b}\\cdot F_i}$ 我们知道$n$个节点的二叉树方案数为$Catalan(n)=\\frac{(2n)!} {n!(n+1)!}$ 由此得到$\\begin{aligned} F_i=\\frac{Catalan(i)Catalan(n-i-1)} {Catalan(n)}\\end{aligned} $ 此题范围可以直接带入$Catalan(i)$求解，但是依然要提一下递推的做法（似乎精度更有保障?） $\\begin{aligned} F_i=\\frac{\\frac{(2i)!} {i!(i+1)!}\\cdot \\frac{(2n-i-2)!} {(n-i-1)!(n-i)!} } {\\frac{(2n)} {n!(n+1)!} }\\end{aligned} $ 递推求解$F_i$，每次$i$改变一阶乘只会改变1或者2，因此由$F_{i-1}$得到$F_i$的递推式为 $F_i=\\left\\{ \\begin{aligned}\\frac{n(n+1)} {2n(2n-1)}&& i=0\\\\ F_{i-1}\\cdot \\frac{2i(2i-1)} {(i+1)i}\\frac{(n-i+1)(n-i)} {2(n-i)(2n-2i-1)} && i\\in[1,n-1]\\end{aligned}\\right.$ 化简之后应该是 $F_i=\\left\\{ \\begin{aligned}\\frac{(n+1)} {2(2n-1)}&& i=0\\\\ F_{i-1}\\cdot \\frac{(2i-1)} {(i+1)}\\frac{(n-i+1)} {(2n-2i-1)} && i\\in[1,n-1]\\end{aligned}\\right.$ 至此得到一个朴素的$O(n^4)$预处理，由于是异或，可以用$\\text{FWT}_{\\oplus}$求解，复杂度为$O(n^3)$ 对于输入的每棵树，类似背包地叠加概率即可，复杂度为$O(n^3)$ 以下是朴素dp代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;#define rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=128;int n;db dp[N][N];void FWT(db *a,int f)&#123; for(int i=1;i&lt;N;i&lt;&lt;=1)&#123; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;j++)&#123; db t=a[j+i]; a[j+i]=a[j]-t; a[j]+=t; &#125; &#125; &#125; if(f==-1) rep(i,0,N-1) a[i]/=N;&#125;db F[N],G[N];int main()&#123; dp[0][0]=1,dp[1][0]=1; rep(i,2,100) &#123; F[0]=1.0/(2*i)/(2*i-1)*(i+1)*i; rep(j,1,i-1) &#123; F[j]=F[j-1] * (2*j)*(2*j-1)/(j+1)/j * 1.0/(2*(i-j))/(2*(i-j)-1)*(i-j+1)*(i-j); &#125; rep(a,0,i-1) rep(h1,0,N-1) if(dp[a][h1]&gt;0) &#123; rep(h2,0,N-1) if(dp[i-a-1][h2]) &#123; int nxt=0; if(a&gt;0) nxt^=h1+1; if(i-1-a&gt;0) nxt^=h2+1; dp[i][nxt]+=dp[a][h1]*dp[i-a-1][h2]*F[a]; &#125; &#125; &#125; n=rd(); rep(i,0,N-1) F[i]=0; F[0]=1; rep(i,1,n) &#123; int x=rd(); rep(j,0,N-1) G[j]=0; rep(j,0,N-1) if(F[j]) rep(k,0,N-1) G[j^k]+=F[j]*dp[x][k]; rep(j,0,N-1) F[j]=G[j]; &#125; db ans=0; rep(i,1,N-1) ans+=F[i]; printf(&quot;%.6lf\\n&quot;,ans);&#125; 以下是FWT优化代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;#define rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=128;int n;db dp[N][N],T[N][N];void FWT(db *a,int f)&#123; for(int i=1;i&lt;N;i&lt;&lt;=1)&#123; for(int l=0;l&lt;N;l+=i*2) &#123; for(int j=l;j&lt;l+i;j++)&#123; db t=a[j+i]; a[j+i]=a[j]-t; a[j]+=t; &#125; &#125; &#125; if(f==-1) rep(i,0,N-1) a[i]/=N;&#125;db F[N],G[N];int main()&#123; dp[0][0]=1,dp[1][0]=1; T[0][0]=1,T[1][1]=1; FWT(T[0],1),FWT(T[1],1); rep(i,2,100) &#123; F[0]=1.0/(2*i)/(2*i-1)*(i+1)*i; rep(j,1,i-1) &#123; F[j]=F[j-1] * (2*j)*(2*j-1)/(j+1)/j * 1.0/(2*(i-j))/(2*(i-j)-1)*(i-j+1)*(i-j); &#125; rep(j,0,i-1) rep(k,0,N-1) dp[i][k]+=T[j][k]*T[i-j-1][k]*F[j]; FWT(dp[i],-1); rep(j,0,N-2) T[i][j+1]=dp[i][j]; FWT(T[i],1); &#125; n=rd(); rep(i,0,N-1) F[i]=0; F[0]=1; rep(i,1,n) &#123; int x=rd(); rep(j,0,N-1) G[j]=0; rep(j,0,N-1) if(F[j]) rep(k,0,N-1) G[j^k]+=F[j]*dp[x][k]; rep(j,0,N-1) F[j]=G[j]; &#125; db ans=0; rep(i,1,N-1) ans+=F[i]; printf(&quot;%.6lf\\n&quot;,ans);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"Topcoder SRM 569 Div1 - MegaFactorial (矩阵)","slug":"Topcoder SRM 569 Div1 - MegaFactorial (矩阵)","date":"2020-09-05T08:05:27.000Z","updated":"2021-05-22T03:54:11.011Z","comments":true,"path":"articles/2020/09/05/8bd66f83.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/05/8bd66f83.html","excerpt":"","text":"Topcoder SRM 569 Div1 - MegaFactorial (矩阵)首先是对于末尾0个数的处理，设最后得到的数中包含$i$的指数为$F(i)$ 对于$B=2,3,5,7$的情况，可以直接计算答案$\\sum_{i=1}\\sum_{j=1}F(j\\cdot B^i)$ 对于$B$为质因子组合的情况，即$B=6(2\\times 3),10(2\\times 5)$，因为$F(i)$实际有单调性，可以直接取较大的质因子 对于$B$为质因子次方的情况，即$B=2^2,2^3,3^2$的情况，设$B=p^k$则答案可以表示为 $\\begin{aligned} \\lfloor \\frac{\\sum_{i=1}\\sum_{j=1}F(j\\cdot p^i)} {k}\\rfloor \\end{aligned} $ 由于要取模，实际上要做一点魔改，设模数为$m$，答案可以表示为$c=ak+b$的形式，这个式子求出的是$a$ 则$\\lfloor \\frac{(ak+b)\\mod km } {k}\\rfloor =a+\\lfloor \\frac{(b\\mod km)} {k}\\rfloor =a$ 由于$k\\leq 3$，扩大模数后可以用unsigned int 存 下面考虑用矩阵求解上式 $nk!$(下面用$f(n,k)$表示)这个东西可以看作从$n$向下的一个递推式 因此考虑以$k$为矩阵元素，求出每个$f(n,k)$被调用的次数 注意这样递推就是反向的了 递推的转移式子是$f(n,k)\\rightarrow f(n,k-1),f(n-1,k)$，其中$f(n,k-1)$的转移需要在层内完成 据此构造矩阵即可，注意$f(n,0)$不能向$f(n-1,0)$转移 考虑对于$\\sum_{i=1}\\sum_{j=1}F(j\\cdot B^i)$的每个$i$求解，一共有$\\frac{n} {B^i}$个$j$，每个$j$出现的递推层数为等差数列 即$n\\mod B^i,n\\mod B^i+B^i,n\\mod B^i +2 \\cdot B^i\\cdots $ 我们要求的其实是每一层的$f(i,0)$，所以考虑求出每次$B^i$层的转移矩阵 然后是依次累和，把矩阵的转移中$0\\rightarrow 0$的转移赋为1即可做到 tips:首项是$n\\mod B^i$ 一共有$\\log _Bn$种不同的$i$，因此复杂度为$O(\\log_Bn\\log_2 n\\cdot k^3)$ 当然更优的做法，咕咕咕 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;#define reg registertypedef long long ll;typedef unsigned int U;#define rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)#define pb push_backtemplate &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=20;int n,d;U P=1e9+9;struct Mat&#123; U a[N][N]; Mat()&#123; memset(a,0,sizeof a);&#125; void One()&#123; rep(i,0,d) a[i][i]=1; &#125; U* operator [] (int x)&#123; return a[x]; &#125; Mat operator * (const Mat &amp;x) const &#123; Mat res; rep(i,0,d) rep(j,0,d) rep(k,0,d) res.a[i][k]=(res.a[i][k]+1ll*a[i][j]*x.a[j][k])%P; return res; &#125; void Show()&#123; rep(i,0,d) &#123; rep(j,0,d) printf(&quot;%d &quot;,a[i][j]); puts(&quot;&quot;); &#125; &#125;&#125; A,B,C;Mat qpow(Mat x,int k)&#123; Mat res; res.One(); for(;k;k&gt;&gt;=1,x=x*x) if(k&amp;1) res=res*x; return res;&#125;int Factor(int &amp;x) &#123; int p=-1,c=0; rep(i,2,x) if(x%i==0) &#123; while(x%i==0) c++,x/=i; p=i; break; &#125; return x=p,c;&#125;class MegaFactorial &#123; public: int countTrailingZeros(int N, int K, int b) &#123; A=Mat(),n=N,d=K; if(b==10) b=5; if(b==6) b=3; int t=Factor(b); P*=t; drep(i,d,0) &#123; A[i][i]=1; rep(j,0,d) A[j][i]+=A[j][i+1]; &#125; A[0][0]=0; ll ans=0; for(ll i=b;i&lt;=n;i*=b) &#123; B=qpow(A,i); B[0][0]=1; Mat res=qpow(A,n%i)*qpow(B,n/i-1); rep(i,0,d) (ans+=res[i][0])%=P; &#125; P/=t,ans/=t; return ans; &#125;&#125;;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"COCI2013-2014 Contest 3 F 单调栈","slug":"COCI2013-2014 Contest 3 F 单调栈","date":"2020-09-03T14:14:16.000Z","updated":"2021-05-22T03:54:10.880Z","comments":true,"path":"articles/2020/09/03/b4fdaba7.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/03/b4fdaba7.html","excerpt":"","text":"COCI2013-2014 Contest#3 F 单调栈考虑每个小区间$[x_i,x_{i+1}]$中，外部光照进来只能是这样 其中两边是光源，红色表示被照到了 那么所有合法的被照到的段可以表示为$[x_i,x_{i+1}]$中的两个小段，即 1.左边照进来的$[s0_i,x_{i+1}]$ 2.右边照进来的$[x_i,s1_i]$ 考虑从左到右维护可能照到右边的较优光源 显然对于每一个光源都有一个当前能遮住它最多的城市，构成(光源，限制城市)这样的点对 对于每一个较优的这样的点对 可以维护一个单调栈，维护出来应该是这样的 有几个较为显然的性质: 1.所有点对的$h_i$递减，否则要么是上一个光源被完全遮住了，要么是这个点可以遮住上一个光源更多 2.靠右的点对能够覆盖的范围较大，即可行区间的左端点较小 否则它此时不会产生贡献，而当后面较高的点进来时，相对更矮的它也更容易被遮住 实际上，这样的形状就会构成一个类似上凸包的东西，但是凸包上只有一部分点产生贡献 \\考虑依次加入点$(x_i,h_i)$，显然可以弹掉$h_j&lt;h_i$的所有点对(为了防止下面计算左端点时出现问题) 接下来的情况，类似维护凸包，但是要考虑更新限制城市 或者 弹掉点对 \\对于向左的情况，反着求一遍即可，最后可以减去两种区间都覆盖不到的部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=3e5+10;int n,D;struct City&#123; int k,x,h; &#125; C[N];struct Lightpair&#123; //描述一个灯塔和右边遮住它最多的城市 int x,y; Lightpair(const int &amp;_x=0,const int &amp;_y=0) : x(_x),y(_y) &#123; &#125; db Left()&#123; return C[y].x+1.0*(C[y].x-C[x].x)/(C[x].h-C[y].h)*C[y].h; &#125; // z这个发光对能照到的范围为[Left(),+oo)&#125; stk[N];int top;void Cover(Lightpair &amp;x,int y)&#123; if(Lightpair(x.x,y).Left()&gt;x.Left()) x.y=y; &#125;db s[2][N];// 将所有可能的发光区间描述为 [C[i].x,s[k][i]]int main()&#123; n=rd(),D=rd(); rep(i,1,n) C[i].k=rd(),C[i].x=rd(),C[i].h=rd(); C[n+1].x=D; rep(k,0,1) &#123; rep(i,0,n) &#123; while(top &amp;&amp; C[stk[top].x].h&lt;=C[i].h) top--; // 完全被遮住的，先弹掉 if(top) &#123; Cover(stk[top],i); while(top&gt;1)&#123; Cover(stk[top-1],i); if(stk[top-1].Left()&gt;stk[top].Left()) break; top--; &#125; &#125; if(C[i].k) stk[++top]=i,s[k][i]=C[i].x; // 一定覆盖C[i].x,C[i+1].x else if(top) s[k][i]=min(stk[top].Left(),(db)C[i+1].x); // 尝试让当前最优的点对覆盖过来 else s[k][i]=C[i+1].x; // 无覆盖 &#125; if(!k) &#123; reverse(C+1,C+n+1),top=0; rep(i,1,n) C[i].x=D-C[i].x; &#125; else &#123; reverse(s[k],s[k]+n+1); rep(i,0,n) s[k][i]=D-s[k][i]; &#125; &#125; db ans=D; // 减去不合法的 rep(i,0,n) if(s[0][i]&gt;s[1][i]) ans-=s[0][i]-s[1][i]; printf(&quot;%.3lf\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"COCI","slug":"COCI","permalink":"http://chasingdeath.github.io/tags/COCI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"Topcoder SRM568 Div1 DisjointSemicircles (二分图染色)","slug":"Topcoder SRM568 Div1 DisjointSemicircles (二分图染色)","date":"2020-09-02T12:57:09.000Z","updated":"2021-05-22T03:54:11.013Z","comments":true,"path":"articles/2020/09/02/49c6f513.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/02/49c6f513.html","excerpt":"","text":"Topcoder SRM568 Div1 DisjointSemicircles (二分图染色)题意: 给定数轴上排列的$2n$个点，每个点需要找到另一个点和它匹配，并且以他们为直径两端，向上或者向下作一个半圆 有一些点已经匹配好了，要求判断是否存在一个合法的方案，满足所有的半圆不相交 思路: 枚举已经确定的匹配半圆的方向(设有$m$对已匹配)，然后$O(n)$判断自由点是否存在合法方案 判断合法方案的核心性质:定义一个点的方向为其所连接的半圆的方向(上为0，下为1) 则自由点存在合法方案的充要条件是: 整个序列上每种方向的点数为偶数，且所有已匹配的半圆所覆盖的区间下，和半圆同向的点个数为偶数 必要性: 如果某个半圆下同向点个数为奇数，则必然有一个点与其同向并且不得不连到区间外，这显然不合法 充分性: 一种合法的构造方法是: 按照$L$从左到右，遍历每个已匹配的半圆，如果包含同向子半圆优先解决同向的子半圆 剩下的点依然是偶数个，从左到右依次和上一个匹配即可 \\判断是否存在合法方案那么问题转化为判断是否存在一种合法的定向方案，使得某一些区间里0/1的个数为偶数 考虑构建二分图染色，令点集$V=\\{0,1,\\cdots,n,0’,1’,\\cdots,n’\\}$，则$(u,v)\\in E$表示$col(u)\\ne col(v)$ 其中$i$号节点表示$1-i$中所有未匹配节点方向的异或和，$i’$表示$i$的反点$(i,i’)\\in E$ (到这里可以自己想一下怎么连边) 对于已匹配圆$[L,R]$ (注意不要忘了$[1,n]$) 如果它方向为$1$，显然只需要$col(L-1)=col(R)$ 如果方向为0，设$[L,R]$未染色个数为$k$，则显然有$col(L-1)=col(R)\\oplus (k\\mod 2)$，即考虑反向的个数 同时对于已匹配点$i$，显然有$col(i)=col(i-1)$ 由此，得到一个$O(n)$点数边数的图 如果在$\\text{dfs}$枚举时同步加边和回撤，总复杂度就为$O(2^m\\cdot n)$ 由于不可能所有方案都合法，实际应该是一个比较松的上界 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)const int N=110;int n;int a[N];int cnt[N];int L[N],R[N],m,Cross[N][N];int vec[2][N],c[2];struct Edge&#123; int u,v,nxt;&#125;e[N*10];int head[N],ecnt;void AddEdge(int u,int v) &#123; e[++ecnt]=(Edge)&#123;u,v,head[u]&#125;; head[u]=ecnt;&#125;void Link(int u,int v)&#123; AddEdge(u,v),AddEdge(v,u); &#125;void Back()&#123; head[e[ecnt].u]=e[ecnt].nxt,ecnt--; head[e[ecnt].u]=e[ecnt].nxt,ecnt--;&#125;int ans,fl;int vis[N];void dfs_col(int u,int c)&#123; vis[u]=c; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].v; if(!vis[v]) dfs_col(v,3-c); else if(vis[v]==vis[u]) fl=0; &#125;&#125;void dfs(int p) &#123; if(ans) return; if(p&gt;m)&#123; rep(i,0,n*2+1) vis[i]=0; fl=1; rep(i,0,n*2+1) if(!vis[i]) dfs_col(i,1); ans|=fl; return; &#125; rep(i,0,1)&#123; int fl=1; rep(j,1,c[i]) if(R[vec[i][j]]&gt;L[p] &amp;&amp; R[vec[i][j]]&lt;R[p]) fl=0; if(!fl) continue; vec[i][++c[i]]=p; if(i || ~(cnt[R[p]]-cnt[L[p]])&amp;1) Link(L[p]+n+1,R[p]-1); else Link(L[p],R[p]-1); dfs(p+1); c[i]--,Back(); &#125;&#125;class DisjointSemicircles &#123;public: string getPossibility(vector &lt;int&gt; labels) &#123; n=labels.size(),m=0; rep(i,1,n) a[i]=labels[i-1]; rep(i,1,n) &#123; cnt[i]=cnt[i-1]+(a[i]==-1); if(~a[i]) rep(j,i+1,n) if(a[j]==a[i]) L[++m]=i,R[m]=j; &#125; if(!m) return &quot;POSSIBLE&quot;; rep(i,0,(n+1)*2) head[i]=ecnt=0; rep(i,1,n) if(~a[i]) Link(i+n+1,i-1); rep(i,0,n) Link(i,i+n+1); Link(n+1,n); ans=0,dfs(1); return ans?&quot;POSSIBLE&quot;:&quot;IMPOSSIBLE&quot;; &#125;&#125;;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"JOI","slug":"JOI","permalink":"http://chasingdeath.github.io/tags/JOI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"COCI20102011 Contest Final D (Dp)","slug":"COCI20102011 Contest Final D (dp)","date":"2020-09-02T06:55:51.000Z","updated":"2021-05-22T03:54:10.867Z","comments":true,"path":"articles/2020/09/02/517d8319.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/02/517d8319.html","excerpt":"","text":"COCI20102011 Contest#Final D (dp)我们将一个操作序列看做由左右括号，空格构成的字符串，则序列大致长这个样子 $\\text{_ ( ( ) _ ( ) ) ( _ ( ( ) ) ( }$ 很显然，一个失配的左括号只能在最外层出现，而空格可以出现在任意位置 dp一个括号序列让人想到区间dp，但是这个题目的区间实际只需要用长度就可以描述 令$dp[t][l][r][f1][f2]$表示用$t$的时间从$l$走到$r$，$f1$表示是不是最外层括号，$f2$表示当前$dp$是否受到单纯括号序列的限制 其中，引入的单纯括号序列是为了防止出现重复转移，其意思就是这个括号序列两端必须是一对匹配的左右括号，而中间随意 转移大致如下: 1.那么对于非单纯的括号序列，可以在序列插入空格或者失配的左括号(需要满足$f1$)，从$dp[t-1]$转移过来 2.对于任何的括号序列，都可以在两端找到匹配的的左右括号，从$dp[t-2]$转移过来，且完成匹配后$f1$应为$0$ 3.且一个非单纯的括号序列是可以分割的，为了不重复，强制分割的左序列是单纯的即可 实际会发现，一个单纯的括号序列可以认为一定不是最外层括号，即$f2$为真时，$f1$一定为假，所以可以压缩为三种状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define reg register#define rep(i,a,b) for(reg int i=a;i&lt;=b;++i)#define drep(i,a,b) for(reg int i=a;i&gt;=b;--i)char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=51,P=10007;int n,m,T;int E[N][N];int dp[N][N][N][2][2];int main()&#123; n=rd(),m=rd(),T=rd(); memset(E,-63,sizeof E); rep(i,1,m) &#123; int u=rd(),v=rd(),c=IO==&#x27; &#x27;?getchar():IO; if(c&gt;=&#x27;A&#x27; &amp;&amp; c&lt;=&#x27;Z&#x27;) E[u][v]=c-&#x27;A&#x27;+1; else if(c&gt;=&#x27;a&#x27; &amp;&amp; c&lt;=&#x27;z&#x27;) E[u][v]=&#x27;a&#x27;-c-1; else E[u][v]=0; &#125; rep(i,1,n) rep(j,0,1) dp[0][i][i][j][0]=1; rep(k,1,T)&#123; rep(l,1,n) rep(r,(k&lt;T?1:n),n) rep(fl,0,1) rep(fl2,0,1) &#123; ll res=0; if(!fl2) &#123; rep(i,2,k-1) rep(j,1,n) res+=dp[i][l][j][0][1]*dp[k-i][j][r][fl][0]; rep(i,1,n) if(E[l][i]&gt;=0 &amp;&amp; (!E[l][i] || fl)) res+=dp[k-1][i][r][fl][fl2]; &#125; if(k&gt;1) rep(i,1,n) if(E[l][i]&gt;0) rep(j,1,n) if(E[j][r]+E[l][i]==0) res+=dp[k-2][i][j][0][0]; dp[k][l][r][fl][fl2]=res%P; &#125; &#125; int ans=0; rep(i,1,T) ans+=dp[i][1][n][1][0]; printf(&quot;%d\\n&quot;,ans%P);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"COCI","slug":"COCI","permalink":"http://chasingdeath.github.io/tags/COCI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"COCI2013-2014 Contest 1 F  SLASTIČAR","slug":"COCI2013-2014 Contest 1 F  SLASTIČAR","date":"2020-09-01T13:31:06.000Z","updated":"2021-05-22T03:54:10.875Z","comments":true,"path":"articles/2020/09/01/c5d36d9e.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/01/c5d36d9e.html","excerpt":"","text":"COCI2013-2014 Contest#1 F SLASTIČAR其实挺妙的一个数据结构题 题意: 给定一个A串，对于查询的每个$B$串，从头开始匹配匹配$A$的每个后缀，每次匹配失败的代价是$\\text{LCP}+1$可，匹配成功的代价是$|B|$，且立即停止，求代价总和 设$A$串长为$n$，查询个数为$q$，查询总长为$m$ 我们知道求两个串的$\\text{LCP}$可以把两个串中间放一个符号分开，跑后缀数组/后缀自动机 但是首先是$m=3\\cdot 10^6$，内存就开不下 而且发现，如果$|B|$的某个前缀未出现在$A$中，后面的部分都不造成贡献，所以可以在$A$串中定位$B$的每个前缀 这样就只需要求$A$的后缀数组即可，然而，这个并不好实现 假设当前已经定位了一个长度为$i$的前缀，其对应的合法后缀排名范围为$[L_i,R_i]$ 那么接下来就是在当前前缀上接上下一个字符$c$，这个如果再外加数据结构并不好实现 考虑后缀数组的性质，$[L_i,R_i]$这些后缀前$d$个字符相同，$d+1$个字符呈单调非递减 所以字符$c$出现的范围也一定是一段区间，可以直接两次二分得到 这样查询$[L_i,R_i]$的复杂度为$\\log n$，这样就用$O(m\\log n)$的复杂度完成了串定位 如果不考虑每次完成匹配后停止，其实答案就是$\\sum R_i-L_i+1$，即$\\sum_i LCP_i=\\sum_i \\sum_j [LCP_j\\ge i]$ 设最终的匹配位置为$p$，这个位置可以用线段树在最后的一段$[L_{|B|},R_{|B|}]$中求最小值得到 考虑减掉多余的部分，即减去实际位置$&gt;p$的且在后缀数组排名在$[L_i,R_i]$中的部分 可以把所有的$[L_i,R_i]$拿出来作为，离线询问，用树状数组维护查询，复杂度为$O((n+m)\\log n)$ 因此总复杂度为$O((n+m)\\log n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,const T &amp;b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,const T &amp;b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;const int N=1e5+10,M=3e6+10;int n,m;char s[N],t[N];int rk[N&lt;&lt;1],tmp[N],cnt[N],sa[N];void Build(int n)&#123; rep(i,1,n) cnt[int(s[i])]++; rep(i,1,200) cnt[i]+=cnt[i-1]; rep(i,1,n) rk[i]=cnt[(int)s[i]],sa[i]=i; for(reg int k=1;k&lt;n;k&lt;&lt;=1) &#123; for(reg int i=0;i&lt;=n;++i) cnt[i]=0; for(reg int i=1;i&lt;=n;++i) cnt[rk[i+k]]++; for(reg int i=1;i&lt;=n;++i) cnt[i]+=cnt[i-1]; for(reg int i=n;i&gt;=1;--i) tmp[cnt[rk[i+k]]--]=i; for(reg int i=0;i&lt;=n;++i) cnt[i]=0; for(reg int i=1;i&lt;=n;++i) cnt[rk[i]]++; for(reg int i=1;i&lt;=n;++i) cnt[i]+=cnt[i-1]; for(reg int i=n;i&gt;=1;--i) sa[cnt[rk[tmp[i]]]--]=tmp[i]; for(reg int i=1;i&lt;=n;++i) tmp[sa[i]]=tmp[sa[i-1]]+(rk[sa[i]]!=rk[sa[i-1]]||rk[sa[i]+k]!=rk[sa[i-1]+k]); for(reg int i=1;i&lt;=n;++i) rk[i]=tmp[i]; &#125;&#125;void FindChar(int &amp;l,int &amp;r,int len,int c)&#123; int tl=l,tr=r; int lres=-1,rres=-1; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(s[sa[mid]+len]&lt;=c) l=mid+1,lres=mid; else r=mid-1; &#125; if(lres==-1 || s[sa[lres]+len]!=c) &#123; l=0; return; &#125; l=tl,r=tr; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(s[sa[mid]+len]&gt;=c) r=mid-1,rres=mid; else l=mid+1; &#125; l=rres,r=lres;&#125;ll ans[N];int ql[M],qr[M],qid[M],qnxt[M];int head[N],qc;int L[N],R[N];struct BIT&#123; int s[N]; void Add(int p) &#123; while(p&lt;=n) s[p]++,p+=p&amp;-p; &#125; int Que(int p) &#123; int res=0; while(p) res+=s[p],p-=p&amp;-p; return res; &#125; int Que(int l,int r)&#123; return Que(r)-Que(l-1); &#125;&#125; T;struct Tree&#123; int s[N&lt;&lt;2]; void Build(int p,int l,int r)&#123; if(l==r) &#123; s[p]=sa[l]; return ;&#125; int mid=(l+r)&gt;&gt;1; Build(p&lt;&lt;1,l,mid),Build(p&lt;&lt;1|1,mid+1,r); s[p]=min(s[p&lt;&lt;1],s[p&lt;&lt;1|1]); &#125; int Que(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) return s[p]; int mid=(l+r)&gt;&gt;1,res=1e9; if(ql&lt;=mid) cmin(res,Que(p&lt;&lt;1,l,mid,ql,qr)); if(qr&gt;mid) cmin(res,Que(p&lt;&lt;1|1,mid+1,r,ql,qr)); return res; &#125;&#125;SGT;int main()&#123; scanf(&quot;%d%s&quot;,&amp;n,s+1); Build(n),scanf(&quot;%d&quot;,&amp;m); SGT.Build(1,1,n); rep(i,1,m) &#123; scanf(&quot;%s&quot;,t+1); L[0]=1,R[0]=n; int len=0,pos=1; for(int j=1;t[j];++j) &#123; L[len=j]=L[j-1],R[j]=R[j-1]; FindChar(L[j],R[j],j-1,t[j]); if(!L[j])&#123; pos=0; break; &#125; ans[i]+=R[j]-L[j]+1; &#125; if(pos &amp;&amp; (pos=SGT.Que(1,1,n,L[len],R[len]))&lt;n) &#123; ans[i]+=pos-1,pos++; rep(j,1,len)&#123; qc++,ql[qc]=L[j],qr[qc]=R[j],qid[qc]=i,qnxt[qc]=head[pos]; head[pos]=qc; &#125; &#125; else ans[i]+=n; &#125; drep(i,n,1)&#123; T.Add(rk[i]); for(int j=head[i];j;j=qnxt[j]) ans[qid[j]]-=T.Que(ql[j],qr[j]); &#125; rep(i,1,m) printf(&quot;%lld\\n&quot;,ans[i]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"COCI","slug":"COCI","permalink":"http://chasingdeath.github.io/tags/COCI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"TopCoder SRM 561 Orienteering 树形Dp","slug":"TopCoder SRM 561 Orienteering 树形dp","date":"2020-09-01T02:49:55.000Z","updated":"2021-05-22T03:54:11.002Z","comments":true,"path":"articles/2020/09/01/7965ba9b.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/09/01/7965ba9b.html","excerpt":"","text":"TopCoder SRM 561 Orienteering 树形dp题意: 给定了一棵树，以及树上一些节点为关键点，求出随机选出$k$个关键点后遍历它们的最短路径的期望 遍历关键点相当于要遍历一棵树，考虑遍历一棵树的最优决策 假设我们确定了一个根$u$，递归考虑每棵子树的问题 发现除了最后留在的那个点对应的路径$(u,v)$以外，所有的边都要被遍历两次 即答案$\\sum _{e\\in E} 2\\cdot w(e)-dis(u,v)$ 所以改变根就会发现，答案就是总长*2-直径长度 设总点数为$n$，包含的总关键点数为$m$，要选出$k$个点 Part1 总长计算考虑对于每一条边计算产生的树跨过它的概率 设这条边两边的关键点的个数分别为$a,b(a+b=m)$ 显然，这条边被跨过的概率就是 $\\begin{aligned} 1-\\frac{C(a,k)} {C(m,k)}-\\frac{C(b,k)} {C(m,k)}\\end{aligned}$ (即减去所有选出的关键点都在两边的概率) 设$\\begin{aligned} f(i)=\\frac{C(i,k)} {C(m,k)}=\\frac{i!(m-k)!} {m!(i-k)!}\\end{aligned} $ 因为这个题目要计算double，所以求阶乘的精度会比较有问题 考虑递推求出$f(i)$，则有 $f(i)=\\left\\{\\begin{aligned}1 && i=m \\\\ \\frac{f(i+1)(i+1-k)} {i+1} && i","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"COCI20122013 Contest 5 F ","slug":"COCI20122013 Contest 5 F ","date":"2020-08-31T11:34:38.000Z","updated":"2021-05-22T03:54:10.871Z","comments":true,"path":"articles/2020/08/31/7ef411bf.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/31/7ef411bf.html","excerpt":"","text":"COCI20122013 Contest#5 F不知道题解在写什么.jpg Part1 : Naive的dp令$dp_{i,a,b,j}$表示当前时刻$i$，两队比分为$a,b$，球在$j$手上的概率 转移非常简单就不说了，单次转移为$O(n)$，复杂度为$O(n^2r^2T)$ 在优秀卡常+O2下跑进700ms 优化的话:1.float 2.分小块加速 3.循环展开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)typedef float db;#define reg register#define rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,const T &amp;b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,const T &amp;b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int INF=1e9+10;const db eps=1e-12;int n,R,T;db dp[510][11][11][210],p[410],sz[410],ans[11][11];struct Edge&#123; int to,nxt;&#125; e[80000];int head[410],ecnt;void AddEdge(int u,int v) &#123; e[++ecnt]=(Edge)&#123;v,head[u]&#125;; head[u]=ecnt;&#125;int E[410][410],G[410][410]; const int D=5;db tmp[210][1&lt;&lt;D];int main()&#123; n=rd(),R=rd(),T=rd(); int m=(n*2+D-1)/D; rep(i,1,n*2) &#123; scanf(&quot;%f&quot;,&amp;p[i]); int e=rd(),f=rd(); sz[i]=e+f+1; rep(j,1,e) &#123; int x=rd(); if(i&gt;n) x+=n; E[i][x]=1; &#125; rep(j,1,f) &#123; int x=rd(); if(i&lt;=n) x+=n; E[i][x]=1; &#125; rep(j,1,m) &#123; int f=(j-1)*D+1; rep(k,0,D-1) G[i][j]|=E[i][f+k]&lt;&lt;k; if(G[i][j]) AddEdge(i,j); &#125; &#125; dp[0][0][0][1]=1; for(reg int i=0;i&lt;=T;++i) &#123; for(reg int a=0;a&lt;=R;++a) &#123; for(reg int b=0;b&lt;=R;++b) &#123; for(reg int j=1;j&lt;=n*2;++j) if(dp[i][a][b][j]&gt;eps) &#123; if(a==R || b==R || i==T) &#123; ans[a][b]+=dp[i][a][b][j]; continue; &#125; db t=dp[i][a][b][j]/sz[j]; for(reg int k=1;k&lt;=m;k+=4) &#123; tmp[k][G[j][k]]+=t; tmp[k+1][G[j][k+1]]+=t; tmp[k+2][G[j][k+2]]+=t; tmp[k+3][G[j][k+3]]+=t; &#125; if(j&lt;=n) &#123; dp[i+1][a][b][n+1]+=t*(1-p[j]); dp[i+1][a+1][b][n+1]+=t*p[j]; &#125; else &#123; dp[i+1][a][b][1]+=t*(1-p[j]); dp[i+1][a][b+1][1]+=t*p[j]; &#125; &#125; for(reg int j=1;j&lt;=m;++j) &#123; int f=(j-1)*D+1; rep(k,1,(1&lt;&lt;D)-1) &#123; (k&amp;1) &amp;&amp; (dp[i+1][a][b][f]+=tmp[j][k]); (k&amp;2) &amp;&amp; (dp[i+1][a][b][f+1]+=tmp[j][k]); (k&amp;4) &amp;&amp; (dp[i+1][a][b][f+2]+=tmp[j][k]); (k&amp;8) &amp;&amp; (dp[i+1][a][b][f+3]+=tmp[j][k]); (k&amp;16) &amp;&amp; (dp[i+1][a][b][f+4]+=tmp[j][k]); tmp[j][k]=0; &#125; &#125; &#125; &#125; &#125; rep(i,0,R) rep(j,0,R) if(i!=R || j!=R) printf(&quot;%.10f\\n&quot;,ans[i][j]);&#125; \\Part2: 状态割裂定义每个球进的时间为关键点，我们发现关键点的状态非常单一，只有两种 一个合法的转移序列可以被分为若干关键点的段以及最后一段到达$T$之后停止转移 考虑预处理两个关键点之间的转移概率 令$g_{a,b,i}$为当球在$a$队一号队员时，$i$次后$b$队进球的概率 可以枚举$a$，类似上面的$dp$，去掉比分的一维即可 预处理复杂度为$O(Tn^2)$ 然后$dp$时直接枚举两个关键点转移，令 $h_{i,a,b,j}$时刻$i$比分为$a,b$，球在$j$队一号队员手上的概率 转移分两种 1.枚举下一个在$T$以内的关键点转移 复杂度为$O(T)$ 2.考虑在$T$以内的时间不再出现进球了 需要预处理出当球在$i$队手上时，$j$次内出现进球的概率$s_{i,j}$，这个直接由$g$数组累前缀和即可 $dp$关键点的复杂度为$O(T^2r^2)$ 大概比上面代码快4-5倍 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)typedef float db;#define reg register#define rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int INF=1e9+10;const db eps=1e-12;int n,R,T;struct Edge&#123; int to,nxt;&#125; e[80000];int head[410],ecnt;void AddEdge(int u,int v) &#123; e[++ecnt]=(Edge)&#123;v,head[u]&#125;; head[u]=ecnt;&#125;db p[410],sz[410],ans[11][11],f[510][210],g[2][2][510],s[2][510];// g[i][j][k] 在i拿球的情况下，j在第k次进球了db h[510][11][11][2];int main()&#123; n=rd(),R=rd(),T=rd(); rep(i,1,n*2) &#123; scanf(&quot;%f&quot;,&amp;p[i]); int e=rd(),f=rd(); sz[i]=e+f+1; rep(j,1,e) &#123; int x=rd(); if(i&gt;n) x+=n; AddEdge(i,x); &#125; rep(j,1,f) &#123; int x=rd(); if(i&lt;=n) x+=n; AddEdge(i,x); &#125; &#125; rep(d,0,1) &#123; f[0][d*n+1]=1; rep(i,0,T) &#123; rep(j,1,n*2) if(f[i][j]&gt;eps) &#123; db t=f[i][j]/sz[j]; for(reg int k=head[j];k;k=e[k].nxt) f[i+1][e[k].to]+=t; f[i+1][j&gt;n?1:n+1]+=t*(1-p[j]); g[d][j&gt;n][i+1]+=t*p[j]; f[i][j]=0; &#125; &#125; rep(i,0,T) &#123; s[d][i]=g[d][0][i]+g[d][1][i]; if(i) s[d][i]+=s[d][i-1]; &#125; &#125; h[0][0][0][0]=1; rep(i,0,T) &#123; rep(a,0,R) rep(b,0,R) rep(j,0,1) if(h[i][a][b][j]&gt;eps) &#123; if(a==R || b==R || i==T)&#123; ans[a][b]+=h[i][a][b][j]; continue; &#125; rep(k,1,T-i) &#123; // 能在结束前产生一次进球 h[i+k][a+1][b][1]+=h[i][a][b][j]*g[j][0][k]; h[i+k][a][b+1][0]+=h[i][a][b][j]*g[j][1][k]; &#125; ans[a][b]+=h[i][a][b][j]*(1-s[j][T-i]); &#125; &#125; rep(i,0,R) rep(j,0,R) if(i&lt;R || j&lt;R) printf(&quot;%.10f\\n&quot;,ans[i][j]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"COCI","slug":"COCI","permalink":"http://chasingdeath.github.io/tags/COCI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"2014多校6 Another Letter Tree","slug":"2014多校6 Another Letter Tree","date":"2020-08-31T00:58:06.000Z","updated":"2021-05-22T03:54:10.697Z","comments":true,"path":"articles/2020/08/31/727d6e9a.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/31/727d6e9a.html","excerpt":"","text":"2014多校6 Another Letter Tree点分治做法就裸地离个线，放到点分治上，从每个根开始，维护$dp_{u,l,r}$表示这条链匹配了序列中$[l,r]$的部分 注意dp数组要一正一反，俩家伙一个含根一个不含 查询要合并两个dp数组，但是只需要知道$dp_{1,|s_0|}$，因此合并复杂度是$O(|s_0|)$的 最终复杂度，处理为$O(n\\log n|s_0|^2+q|s_0|)$ 树剖线段树做法类似上面的dp，线段树维护即可 问题1需要存正反！ 然后你发现内存从中间裂开！！ 正反分两次，离线跑两次就可以了啊啊啊啊 问题2如果直接查询合并，合并两个dp数组复杂度为$O(|s_0|^3)$ 查询复杂度为$O(q\\log ^2n|s_0|^3)$ 妙啊!!比$n^2$还大!! 所以最后不能合并dp数组，而应该直接累加到答案数组上 问题3没错现在我们的复杂度为$O(q\\log ^2n|s_0|^2)$ 依然大得令人无法忍受 但是没想到吧，数据全部都是链，树剖是$O(1)$的 优化：查询重链时，只有最后依次是在链上查询$[l,r]$都在中间的，而对于直接跳到top的部分，可以预处理出来 算上线段树的预处理，这样总复杂度就是$O(n|s_0|^3+q\\log n |s_0|^2)$ 并查集做法把问题拆成查询两条$u$到它的祖先$v$的答案 每个节点存储一个dp矩阵，用带权并查集维护 具体方法是:将询问按照$\\text{LCA}$深度逆序排序后，每次查询一直将$u$合并到$v$为止 复杂度为$O(n\\alpha(n)|s_0|^3)$，理论上来说，这个转移矩阵应当很稀疏，乘法应该很快，但是实际常数比较大 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)#define reg register#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=5e4+10,P=10007;int n,m,len;char str[N],t[N];struct Node&#123; int a[31][31]; void clear()&#123; memset(a,0,sizeof a); &#125; void Init(int u) &#123; clear(); rep(i,1,len) if(t[i]==str[u]) a[i][i]=1; &#125; Node operator + (const Node &amp;x) const &#123; Node res; res.clear(); rep(i,1,len) for(int j=i;j&lt;len &amp;&amp; a[i][j];++j) for(int k=j+1;k&lt;=len &amp;&amp; x.a[j+1][k];++k) res.a[i][k]=(res.a[i][k]+a[i][j]*x.a[j+1][k])%P; rep(i,1,len) rep(j,i,len) &#123; res.a[i][j]+=a[i][j],Mod1(res.a[i][j]); res.a[i][j]+=x.a[i][j],Mod1(res.a[i][j]); &#125; return res; &#125;&#125; s[N];struct Edge&#123; int to,nxt;&#125;e[N&lt;&lt;1];int head[N],ecnt;void AddEdge(int u,int v) &#123; e[++ecnt]=(Edge)&#123;v,head[u]&#125;; head[u]=ecnt; &#125;#define erep(u,i) for(int i=head[u];i;i=e[i].nxt)int QX[N],QY[N],QL[N];int dep[N],id[N],fa[N][18];void pre_dfs(int u,int f) &#123; dep[u]=dep[fa[u][0]=f]+1; rep(i,1,17) fa[u][i]=fa[fa[u][i-1]][i-1]; erep(u,i) &#123; int v=e[i].to; if(v==f) continue; pre_dfs(v,u); &#125;&#125;int LCA(int x,int y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=0,del=dep[x]-dep[y];(1&lt;&lt;i)&lt;=del;++i) if(del&amp;(1&lt;&lt;i)) x=fa[x][i]; if(x==y) return x; drep(i,17,0) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;int F[N],ans[N][31],Ans[N];int Find(int x,int k=0) &#123; if(F[x]==x) return x; int f=F[x]; F[x]=Find(f,k); if(F[f]!=f)&#123; if(!k) s[x]=s[x]+s[f]; else s[x]=s[f]+s[x]; &#125; return F[x];&#125;int main()&#123; rep(kase,1,rd()) &#123; n=rd(),m=rd(); rep(i,1,n) head[i]=ecnt=0; rep(i,2,n) &#123; int u=rd(),v=rd(); AddEdge(u,v),AddEdge(v,u); &#125; scanf(&quot;%s%s&quot;,str+1,t+1),len=strlen(t+1); pre_dfs(1,0); rep(i,1,m) id[i]=i,QX[i]=rd(),QY[i]=rd(),QL[i]=LCA(QX[i],QY[i]); sort(id+1,id+m+1,[&amp;](int x,int y)&#123; return dep[QL[x]]&gt;dep[QL[y]]; &#125;); rep(i,1,n) F[i]=i,s[i].clear(); rep(k,1,m)&#123; int i=id[k],x=QX[i]; while(1)&#123; int y=Find(x); if(y==QL[i]) break; F[y]=fa[y][0],s[y].Init(y); &#125; ans[i][0]=1; rep(j,1,len) ans[i][j]=s[x].a[1][j]; drep(j,len,1) if(str[QL[i]]==t[j]) ans[i][j]+=ans[i][j-1],Mod1(ans[i][j]); &#125; rep(i,1,n) F[i]=i,s[i].clear(); rep(k,1,m)&#123; int i=id[k],x=QY[i]; Ans[i]=0; while(1)&#123; int y=Find(x,1); if(y==QL[i]) break; F[y]=fa[y][0],s[y].Init(y); &#125; rep(j,0,len-1) Ans[i]=(Ans[i]+ans[i][j]*s[x].a[j+1][len])%P; Ans[i]=(Ans[i]+ans[i][len])%P; &#125; rep(i,1,m) printf(&quot;%d\\n&quot;,Ans[i]); &#125;&#125; \\伪矩阵求逆做法同样的，把问题拆成查询两条$u$到它的祖先$v$的答案(不包含v) 以从$v$到$u$的字符串为例，设$dp_u$为$u$的祖先链的dp矩阵，我们要求的部分答案是$x$ 则$dp_v\\cdot x=dp_u, x=\\frac{dp_u} {dp_v}$ 一般来说，矩阵求逆是一个很难实现的东西 但是发现对于一种$dp$，它的矩阵一定是一个上/下对角的矩阵 我们需要求出矩阵第一维为1或者第二维为$|s_0|$的部分 如果暴力求，可以看做求解一个$|s_0|$元的线性方程组，可以用高斯消元在$O(|s_0|^3)$时间内求解 而实际上，这个线性方程组是含拓扑序关系的，任何一个含拓扑关系的线性方程组求解是不需要高斯消元的 而且这个问题列出的方程矩阵就已经是上对角矩阵了 所以写出来就是容斥吧 tips: 预处理部分一次只插入一个字符，复杂度为$O(n|s_0|^2)$ (也可以认为是稀疏矩阵乘法) 查询部分求解线性方程复杂度为$O(|s_0|^2)$，合并答案复杂度为$O(|s_0|)$ 因此复杂度为$O((n+q)|s_0|^2)$ Code: 注意两种dp共用了一个数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;#define reg register#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=5e4+10,P=10007;int n,m,len;char str[N],t[N];struct Edge&#123; int to,nxt;&#125;e[N&lt;&lt;1];int head[N],ecnt;void AddEdge(int u,int v) &#123; e[++ecnt]=(Edge)&#123;v,head[u]&#125;; head[u]=ecnt; &#125;#define erep(u,i) for(int i=head[u];i;i=e[i].nxt)int dep[N],id[N],fa[N][18];int dp[N][31][31];int f1[31],f2[31];void pre_dfs(int u,int f) &#123; dep[u]=dep[fa[u][0]=f]+1; rep(i,1,17) fa[u][i]=fa[fa[u][i-1]][i-1]; rep(i,1,len) rep(j,1,len) &#123; dp[u][i][j]=dp[f][i][j]; if(str[u]==t[j]) &#123; if(i==j) dp[u][i][j]++,Mod1(dp[u][i][j]); if(i&lt;j) dp[u][i][j]+=dp[f][i][j-1],Mod1(dp[u][i][j]); if(i&gt;j) dp[u][i][j]+=dp[f][i][j+1],Mod1(dp[u][i][j]); &#125; &#125; erep(u,i) &#123; int v=e[i].to; if(v==f) continue; pre_dfs(v,u); &#125;&#125;int LCA(int x,int y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=0,d=dep[x]-dep[y];(1&lt;&lt;i)&lt;=d;++i) if(d&amp;(1&lt;&lt;i)) x=fa[x][i]; if(x==y) return x; drep(i,17,0) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void Calcdp1(int u,int f) &#123; rep(i,f1[0]=1,len) &#123; f1[i]=dp[u][i][1]; rep(j,0,i-1) f1[i]=(f1[i]-f1[j]*dp[f][i][j+1])%P; Mod2(f1[i]); &#125;&#125;void Calcdp2(int u,int f) &#123; drep(i,len,f2[len+1]=1) &#123; f2[i]=dp[u][i][len]; rep(j,i+1,len+1) f2[i]=(f2[i]-dp[f][i][j-1]*f2[j])%P; Mod2(f2[i]); &#125;&#125;int Que(int x,int y) &#123; int lca=LCA(x,y); Calcdp1(x,fa[lca][0]),Calcdp2(y,lca); int ans=0; rep(i,0,len) ans=(ans+f1[i]*f2[i+1])%P; return ans;&#125;int main()&#123; rep(kase,1,rd()) &#123; n=rd(),m=rd(); rep(i,1,n) head[i]=ecnt=0; rep(i,2,n) &#123; int u=rd(),v=rd(); AddEdge(u,v),AddEdge(v,u); &#125; scanf(&quot;%s%s&quot;,str+1,t+1),len=strlen(t+1); pre_dfs(1,0); rep(i,1,m) &#123; int x=rd(),y=rd(); printf(&quot;%d\\n&quot;,Que(x,y)); &#125; &#125;&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"2016 多校5 ATM","slug":"2016 多校5 ATM","date":"2020-08-30T13:17:05.000Z","updated":"2021-05-22T03:54:10.700Z","comments":true,"path":"articles/2020/08/30/c8ff4ca3.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/30/c8ff4ca3.html","excerpt":"","text":"2016 多校5 ATM题意: 有个人富到不知道自己有多少钱，但是知道钱数$x\\in \\Z \\cap [0,K]$ 它最多可以有$W$次查询超过钱数，$W\\ge 1$ 要求在最优决策的情况下，最小次数取出所有钱的期望次数 \\设$K,W$上界为$O(n)$ 先考虑边界情况，如果它手里有$0$块钱，那么需要查询一次才知道自己吃土了 如果手头$W=1$，那么只能每次取$1$，否则就可能被抓走 众所周知，情况个数有限的期望问题，可以先直接计数然后除掉情况数，所以 定义$dp_{i,j}$为已知手头的票子上限$i$，且还剩$j$次会被抓去干奇怪的事情的最小代价总和 对于$j&gt;1$的情况，我们需要决策这一次选出多少钱 假设这一次我们选择取出$k$块钱 1.那么对于实际钱数为$[0,k-1]$的部分，查询会超限，并且知道上界变为$k-1$ 2.对于实际钱数$[k,i]$的部分，上界变为$i-k$ 而这次决策产生的代价要计算所有情况的代价，即为$i+1$ 因此，转移的表达式应是$\\begin{aligned} dp_{i,j}=\\min_{k=1}^i\\lbrace dp_{k-1,j-1}+dp_{i-k,j}+i+1\\rbrace\\end{aligned}$ 因为不是期望而是计数，决策应该更好理解了吧 直接转移，复杂度为$O(n^3)$ 优化1不会证明，但是$dp_{k-1,j-1}+dp_{i-k,j}$构成了关于$k$的 斜率单调非递减的函数(俗称单峰函数)，可以直接三分 复杂度为$O(n^2\\log n)$ 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long double ldb;#define reg register#define rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,const T &amp;b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;const int N=2e3+10; int n,m;int dp[N][N]; int main()&#123; rep(i,1,N-1) dp[1][i]=2; rep(i,1,N-1) dp[i][1]=i*(i+1)/2+i; rep(i,2,N-1) rep(j,2,N-1) &#123; dp[i][j]=1e9; int l=1,r=i; cmin(dp[i][j],dp[0][j-1]+dp[i-1][j]+i+1); cmin(dp[i][j],dp[i-1][j-1]+dp[0][j]+i+1); while(l&lt;r) &#123; int a=(l+r)&gt;&gt;1,b=a+1; int x=dp[a-1][j-1]+dp[i-a][j]+i+1,y=dp[b-1][j-1]+dp[i-b][j]+i+1; cmin(dp[i][j],x),cmin(dp[i][j],y); if(x&gt;=y) l=b; else r=a; &#125; &#125; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) printf(&quot;%.6Lf\\n&quot;,(ldb)dp[n][m]/(n+1));&#125; 优化2感性理解，钱的上界越大，显然我们每次最优决策要取出的也就越多 即$dp_{i,j}$的最优决策位置关于$i$ 单调非递减 由于转移的式子比较奇怪，这个题目不好使用决策单调性的分治优化方法(或许很简单吗) 但是由于转移是一个单峰函数，不存在波动的问题，所以可以直接记录决策位置$g_{i,j}$ 或者说，就是单峰函数的最值位置是递增的，每次从$g_{i-1,j}$的最优位置开始向后找到$g_{i,j}$的峰的位置即可停止 对于每个$j$，$g_{i,j}$最多从$1$移动到$K$，所以复杂度为$O(n^2)$ 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;typedef long double ldb;#define rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,const T &amp;b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125; const int N=2e3+10; int n,m;int dp[N][N],G[N][N]; int main()&#123; rep(i,1,N-1) dp[1][i]=2; rep(i,1,N-1) dp[i][1]=i*(i+1)/2+i; rep(i,2,N-1) rep(j,2,N-1) &#123; dp[i][j]=1e9; rep(k,max(G[i-1][j],1),i) &#123; // 从上一个决策位置开始for int x=dp[k-1][j-1]+dp[i-k][j]+i+1; if(x&lt;=dp[i][j]) G[i][j]=k,dp[i][j]=x; else break; &#125; &#125; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) printf(&quot;%.6Lf\\n&quot;,(ldb)dp[n][m]/(n+1));&#125; 优化3:第二维大小的优化我们知道，存在一种决策方法即每次二分上界，可以取到一个较优值 满足这个决策只需要$W\\ge \\log_2 k$，大致可以认为$W\\ge 10$ 在最优决策的情况下，一定可以在$10$次错误的范围内查出结果，即$W\\ge 10$之后$W$的值已经不会影响答案了 所以直接上优化，转移复杂度就是$O(n^2\\log n)$ 加上决策单调性的优化，就是$O(n\\log n)$ 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;#define reg register#define rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,const T &amp;b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;const int N=2e3+10;int n,m;int dp[N][11],G[N][11];int main()&#123; rep(i,1,10) dp[1][i]=2; rep(i,1,N-1) dp[i][1]=i*(i+1)/2+i; rep(i,2,N-1) rep(j,2,10) &#123; dp[i][j]=1e9; rep(k,max(G[i-1][j],1),i) &#123; int x=dp[k-1][j-1]+dp[i-k][j]+i+1; if(x&lt;=dp[i][j]) G[i][j]=k,dp[i][j]=x; else break; &#125; &#125; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) printf(&quot;%.6lf\\n&quot;,1.0*dp[n][min(m,10)]/(n+1));&#125; 以下是来自地狱的魔改代码1234567891011121314#include&lt;cstdio&gt;#define rep(i,a,b) for(i=a;i&lt;=b;++i)enum&#123;N=2000&#125;;int n,m,dp[11][N|1],i,j,k,x;main()&#123; rep(i,1,N) dp[1][i]=i*(i+1)/2+i; rep(j,2,10) rep(i,dp[j][k=1]=2,N) &#123; dp[j][i]=1e9; for(;k&lt;=i &amp;&amp; (x=dp[j-1][k-1]+dp[j][i-k]+i+1)&lt;=dp[j][i];++k) dp[j][i]=x; --k; &#125; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))printf(&quot;%.6lf\\n&quot;,1.0*dp[m&gt;10?10:m][n]/(n+1));&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"线性递推的求解","slug":"线性递推的求解","date":"2020-08-30T05:29:03.000Z","updated":"2021-05-22T03:54:11.405Z","comments":true,"path":"articles/2020/08/30/92716457.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/30/92716457.html","excerpt":"","text":"线性递推的求解参考文献：2019集训队论文，钟子谦《两类递推数列的性质和应用》 这篇文章介绍如何求解，线性递推的应用更多在这里 数列$\\{a_0,a_1,\\cdots \\}$ 向量序列$\\{v_0,v_1,\\cdots\\}$ 矩阵序列$\\{M_0,M_1,\\cdots\\}$ 的线性递推 序列$a_0,a_1,\\cdots,a_n$的线性递推的定义应当是 对于一个常数列$r_0,r_1,\\cdots,r_m(r_0=1)$ 为了便于表示，令 $\\lambda(i,r)=\\sum_{j=1}^{m}a_{i-j}r_j$ $\\Delta(i,r)=\\sum_{j=0}^m a_{i-j}$ 满足$\\forall i\\ge m,\\Delta(i,r)=0$ 这似乎与与平常的认知有一些冲突 \\求解序列的最短线性递推: Berlekamp-Massey 算法对于一个$n$个元素的数列$a_{1,\\cdots, n}$，求出它的最短线性递推式 为了便于理解约定下文求出的是最小的$m$和对应的$r_1,\\cdots r_m$使得$\\forall i\\in [m+1,n],a_i=\\sum_{j=1}^{m}a_{i-j}r_j$ 很显然使用高斯消元可以在$O(n^3)$的时间内求解 而$\\text{Berlekamp-Massey(BM)}$算法是通过依次对于前$i$项构造， 添加每一项时在$O(n)$的时间内找到一个可行的构造方法，将复杂度降低到了$O(n^2)$ \\\\算法过程为了更好描述，设$r$的阶为$d(r)$ 考虑依次加入每个数$a_i$，设当前$d(r)=m$，上一次的递推是$p$,$p$出现不匹配的位置是$f$ 特别的，初始状态的递推是$r=\\{ \\},f=0$ $1.\\Delta(i,r)=0$，那么不需要扩展 2.$\\Delta(i,r)\\ne 0$ $\\text{i}.m=0$，此时只有一种情况即插入了第一个$a_i\\ne 0$，唯一的递推序列就是$d(r’)=i,r_j=0(j&gt;0)$，此时显然成立 $\\text{ii}.m\\ne 0$ 构造思路是找到一个$r’$使得$\\forall j\\in[d(r’),i-1],\\lambda(j,r’)=0\\and \\lambda (n,r’)=\\Delta(i-1,r)$ 那么当前合法的转移就是$r+r’$ 设$t=\\frac{\\Delta(n,r)} {\\Delta(f,p)}$ 构造$r’=t \\cdot x^{i-f-1}(1-p)$ 写出来就是 $r’=\\{\\underbrace{0,\\cdots,0},t\\cdot (1-p)\\}$ $ \\ \\ \\ \\ \\ \\ \\ \\ i-f-1$个$0$ $r’=\\{\\underbrace{0,\\cdots,0},t,-t\\cdot p_{1},-t\\cdot p_{2}\\cdots,-t\\cdot p_{d(p)} \\}$ $ \\ \\ \\ \\ \\ \\ \\ \\ i-f-1$个$0$ 此时，$d(r’)=i-f+d(p)$ 当$j\\in [d(r’)+1,i-1]$时，$\\lambda(j,r’)=\\sum_{k=i-f}^{d(r’)}a_{j-k}r’_k$ $=t\\cdot( a_{j-(i-f)}-\\lambda(j-(i-f),p))$ 由于$p$对于$j\\in[d(r’)+1-(i-f),i-1-(i-f)]=[d(p)+1,f-1]$，$p$这个递推式成立 即$\\lambda(j,r’)=0$ 当$j=i$时， $\\lambda(i,r’)=t\\cdot (a_{i-(i-f)}+\\lambda(i-(i-f),p))=t\\cdot \\Delta(f,p)$ 即$\\lambda (i,r’)=\\Delta(n,r)$ 完成了我们想要的构造，所以每次记录上一次的失配位置，即可找到最小递推式 关于为什么求得的就是最小递推，可以看论文里的证明 求解向量序列的线性递推对于长度为$n$的向量序列$\\{v_0,v_1,\\cdots\\}$ 在模$P$意义下，随机一个向量$u$，构造标量序列$\\{v_0u,v_1u,\\cdots\\}$ 构造和求解这个标量序列的线性递推，复杂度均为$O(n^2)$ 求得的线性递推也为向量序列的线性递推的概率为$1-\\frac{n} {P}$，通常认为不会错 (可以认为复杂度与读入同阶?) \\求解矩阵序列的线性递推对于长度为$n$的矩阵序列$\\{M_0,M_1,\\cdots\\}$ 同样在模$P$意义下，随机两个向量$u,v$，构造标量序列$\\{uM_0v,uM_1v,\\cdots\\}$ 求解线性递推的复杂度为$O(n^2)$ 但是构造标量序列需要计算$n$次向量与矩阵的乘法，复杂度为$O(n^3)$ (可以认为复杂度与读入同阶?)","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"COCI2011/2012 Contest 1 F  状压加速Dp","slug":"COCI2011 2012 Contest 1 F  状压加速dp","date":"2020-08-27T12:12:36.000Z","updated":"2021-05-22T03:54:10.869Z","comments":true,"path":"articles/2020/08/27/2e683e2a.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/27/2e683e2a.html","excerpt":"","text":"COCI2011/2012 Contest#1 F 状压加速dp首先是一个非常Naive的dp，令$dp[i][x][y]$表示$i$时刻$x,y$是否能被跳到 枚举，然后转移，如果滚动数组，就可以做到$O(n^2)$空间，$O(Tn^2)$时间复杂度 这显然是TLE的。。。 \\注意到题目的$n\\leq 30$，可以直接用一个int存在某一行/列的答案 设时刻$i$第$j$列的答案为$dp[i][j]$ 假设不考虑答案的限制，两之间转移可以做到$O(1)$，即 1.$dp[i][j\\pm 1]$左/右移两位 2.$dp[i][j\\pm 2]$左/右移一位 两者转移即可，但是涉及到倍数的限制，设$can[i][j]$为$i$时刻$j$列的可行跳跃位置 则只需要最后的时候让$dp[i][j]$与$can[i][j]$取交集即可 如果直接枚举倍数，复杂度上限是$O(n^2 T)$ 考虑分块决策，设将$[1,D]$的因数挑出来额外记录一个数组$can2[x][j]$表示值为$x$的第$j$列有那些 不直接枚举他们，而是在每次访问时考虑他们对于$can[i][j]$的贡献 在优秀实现下，复杂度上限为$O(n^2\\frac{T} {D+1}+T (D+\\sum_{t=1}^{D} \\frac{1} {t} n))=O(n^2\\frac{T} {D+1}+T (n\\ln D+D))$ 这个实现上来说，就是枚举时间$i$后，判断是否满足$t|i $，然后再将$can2[t][j]$贡献到$can[i][j]$ 显然，$t|i$成立的次数就是$T\\sum_{t=1}^{D} \\frac{1} {t} $，也就是要循环这么多次取贡献$j$这一维 调整一下$D$的参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)#define reg register#define rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)const int N=30,D=7;int n,m,a[N][N],dp[2][N];int can[1000010][N],t[D+1][N];int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int sx,sy; scanf(&quot;%d%d&quot;,&amp;sx,&amp;sy),sx--,sy--; rep(i,0,n-1) rep(j,0,n-1) &#123; scanf(&quot;%d&quot;,&amp;a[i][j]); if(a[i][j]&lt;=D) t[a[i][j]][i]|=1&lt;&lt;j; else for(reg int T=a[i][j];T&lt;=m;T+=a[i][j]) can[T][i]|=1&lt;&lt;j; &#125; int cur=0; dp[cur][sx]=1&lt;&lt;sy; rep(i,1,m) &#123; rep(j,1,D) if(i%j==0) rep(k,0,n-1) can[i][k]|=t[j][k]; rep(j,0,n-1) &#123; dp[!cur][j]=0; if(j) &#123; dp[!cur][j]|=dp[cur][j-1]&lt;&lt;2; dp[!cur][j]|=dp[cur][j-1]&gt;&gt;2; &#125; if(j&lt;n-1) &#123; dp[!cur][j]|=dp[cur][j+1]&lt;&lt;2; dp[!cur][j]|=dp[cur][j+1]&gt;&gt;2; &#125; if(j&gt;1) &#123; dp[!cur][j]|=dp[cur][j-2]&lt;&lt;1; dp[!cur][j]|=dp[cur][j-2]&gt;&gt;1; &#125; if(j&lt;n-2) &#123; dp[!cur][j]|=dp[cur][j+2]&lt;&lt;1; dp[!cur][j]|=dp[cur][j+2]&gt;&gt;1; &#125; dp[!cur][j]&amp;=can[i][j]; &#125; cur^=1; &#125; int ans=0; rep(i,0,n-1) rep(j,0,n-1) if(dp[cur][i]&amp;(1&lt;&lt;j)) ans++; printf(&quot;%d\\n&quot;,ans); rep(i,0,n-1) rep(j,0,n-1) if(dp[cur][i]&amp;(1&lt;&lt;j)) printf(&quot;%d %d\\n&quot;,i+1,j+1);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"COCI","slug":"COCI","permalink":"http://chasingdeath.github.io/tags/COCI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[COCI2010-2011 7] UPIT","slug":"[COCI2010-2011 7] UPIT","date":"2020-08-26T06:33:51.000Z","updated":"2021-05-22T03:54:11.031Z","comments":true,"path":"articles/2020/08/26/415f869c.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/26/415f869c.html","excerpt":"","text":"[COCI2010-2011#7] UPIT约定:视$n,q$同阶 看一下题目的操作 1.区间赋值 2.区间差分加 3.插入元素 4.区间查询 我们知道1,2操作都是可以用懒标记维护的，具体过程可能有一点细节 1.记录区间差分加的过程，要记录等差数列首项和公差，两个等差数列相加直接首项和公差都相加即可 2.区间赋值的优先级要高于加法，即打上赋值标记就要清空加法标记，标记下传时注意先下传赋值标记 然后具体问题落到如何实现插入元素这个操作上 块状链表对于静态的数组，可以直接静态分块来做 而要动态插入时，找到对应块，插入即可，但是涉及到编号问题 所以需要每个块维护一个$Size$，块内每个元素维护一个标号$id_i$ 同时需要对于块的$Size$累前缀和$SumSize$，则块$i$内编号为$j$的元素在数组中的实际编号为$SumSize_{i-1}+j$ 插入时把整个块内的元素取出重新标号即可 但是这样插入后，一个块的$Size$会变大，再实现分块的操作时复杂度没有保证 因此需要加入一个操作:当$Size_i&gt;2\\sqrt n$时,$O(n)$重构整个序列，这样每$\\sqrt n$次插入操作会导致一次重构，复杂度为均摊的$O(n\\sqrt n)$ 然后可以用类似分块的方法来直接维护 \\线段树静态的操作线段树可以直接维护 在线段树上额外维护一个01，表示这个元素是否出现 将插入操作转化为在让对应位置的0变为1，但是由于不知道插入后的位置，所以不能直接操作 于是有两种解决办法 暴力值域静态情况下我们对于$[1,n]$建树，但是动态可以对于$[1,n\\cdot q]$建函数式线段树 离线离线维护，预处理出插入的位置 \\平衡树下面是安利时间 来学Treap吧 它可以 1.查询k大 2.插入元素 3.区间修改 4.区间翻转 5.可持久化!! 6.吊打Splay Treap 即树堆，意思是在满足二叉查找树的性质同时满足二叉堆的性质 给定每个节点一个额外的随机权值，让二叉查找树对于这个权值满足堆的性质即可 这样构造的二叉查找树，树高是$O(\\log n)$的 带旋Treap像普通二叉查找树一样每次插入节点到叶子位置后，可能不满足二叉堆的性质，因此需要不断向上zig/zag来调整满足 区间操作可以尝试像写线段树一样写 但是它不可持久化 非旋Treap维护两个基础操作 1.平衡树合并，操作需要满足两棵树的大小顺序确定，返回新的根 2.平衡树分裂为$[1,d],[d+1,n]$的两部分，返回两棵树的根 1.合并操作$x,y$ 按照节点的权值比较谁是平衡树的根，然后将根的左/右子树与另一棵树合并作为新的子树，递归实现 2.分裂$x,d$ 维护$Size$判断是要分裂左子树还是右子树，将子树分裂得到的部分作为$x$新的子树，递归实现即可 12345678910111213141516171819202122typedef pair &lt;int,int&gt; Pii;#define mp make_pairint Union(int x,int y) &#123; if(!x || !y) return x|y; Down(x),Down(y); if(key[x]&lt;key[y]) return rs[x]=Union(rs[x],y),Up(x),x; return ls[y]=Union(x,ls[y]),Up(y),y;&#125;Pii Split(int x,int d)&#123; if(!x) return mp(x,x); if(sz[x]&lt;=d) return mp(x,0); if(d==0) return mp(0,x); Down(x); if(sz[ls[x]]+1&lt;=d) &#123; Pii y=Split(rs[x],d-sz[ls[x]]-1); return rs[x]=y.first,Up(x),mp(x,y.second); &#125; else &#123; Pii y=Split(ls[x],d); return ls[x]=y.second,Up(x),mp(y.first,x); &#125;&#125; 插入操作可以分裂前$k$个，将新节点和得到的两棵树按次合并 区间更新可以分裂两次，将对应区间的子树操作即可 Code块状链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)typedef double db;typedef long double ldb;typedef long long ll;typedef unsigned long long ull;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125; char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125; const int N=2e5+10; int n,m,cnt;int head[N],nxt[N],sz[N];struct Node&#123; int rk,id; &#125; E[N];ll s[N],st[N],t[N],d[N],a[N]; int ssz[N]; ll Get(ll l,ll r)&#123; return (r-l+1)*(l+r)/2; &#125;void Down(int p) &#123; s[p]=0; for(int i=head[p];i;i=nxt[i]) &#123; if(~st[p]) a[E[i].id]=st[p]; a[E[i].id]+=1ll*(E[i].rk-1)*d[p]+t[p]; s[p]+=a[E[i].id]; &#125; st[p]=-1,t[p]=d[p]=0;&#125;void Up(int p) &#123; s[p]=0; for(int i=head[p];i;i=nxt[i]) s[p]+=a[E[i].id];&#125; void Build() &#123; sort(E+1,E+n+1,[&amp;](Node x,Node y)&#123; return x.rk&lt;y.rk; &#125;); rep(i,0,cnt) sz[i]=head[i]=0,st[i]=-1; rep(i,1,n) &#123; int p=i/cnt+1; nxt[i]=head[p],E[i].rk=++sz[p]; head[p]=i; &#125; rep(i,1,cnt) ssz[i]=ssz[i-1]+sz[i],Up(i);&#125; void Break()&#123; rep(i,1,cnt) &#123; sz[i]+=sz[i-1],Down(i); for(int j=head[i];j;j=nxt[j]) E[j].rk+=sz[i-1]; &#125; Build();&#125; int Get(int x)&#123; x--; int l=1; while(sz[l]&lt;=x) x-=sz[l++]; return l;&#125; void Insert(int p,int x)&#123; int l=p&lt;=n?Get(p):cnt; Down(l),p-=ssz[l-1]; for(int i=head[l];i;i=nxt[i]) if(E[i].rk&gt;=p) E[i].rk++; a[++n]=x,E[n]=(Node)&#123;p,n&#125;,nxt[n]=head[l],head[l]=n; sz[l]++,s[l]+=x; if(sz[l]&gt;cnt*2.4) Break(); rep(i,1,cnt) ssz[i]=ssz[i-1]+sz[i];&#125; void Set(int l,int r,int x) &#123; int p1=Get(l),p2=Get(r); if(p1==p2) &#123; Down(p1); for(int i=head[p1];i;i=nxt[i]) if(ssz[p1-1]+E[i].rk&gt;=l &amp;&amp; ssz[p1-1]+E[i].rk&lt;=r) a[E[i].id]=x; Up(p1); return; &#125; Down(p1),Down(p2); s[p1]=s[p2]=0; for(int i=head[p1];i;i=nxt[i]) &#123; if(ssz[p1-1]+E[i].rk&gt;=l) a[E[i].id]=x; s[p1]+=a[E[i].id]; &#125; for(int i=head[p2];i;i=nxt[i]) &#123; if(ssz[p2-1]+E[i].rk&lt;=r) a[E[i].id]=x; s[p2]+=a[E[i].id]; &#125; rep(i,p1+1,p2-1) st[i]=x,d[i]=t[i]=0,s[i]=1ll*x*sz[i];&#125; void Add(int l,int r,int x) &#123; int p1=Get(l),p2=Get(r); if(p1==p2) &#123; Down(p1); for(int i=head[p1];i;i=nxt[i]) if(ssz[p1-1]+E[i].rk&gt;=l &amp;&amp; ssz[p1-1]+E[i].rk&lt;=r) a[E[i].id]+=1ll*(ssz[p1-1]+E[i].rk-l+1)*x; Up(p1); return; &#125; Down(p1),Down(p2); s[p1]=s[p2]=0; for(int i=head[p1];i;i=nxt[i]) &#123; if(ssz[p1-1]+E[i].rk&gt;=l) a[E[i].id]+=1ll*(ssz[p1-1]+E[i].rk-l+1)*x; s[p1]+=a[E[i].id]; &#125; for(int i=head[p2];i;i=nxt[i]) &#123; if(ssz[p2-1]+E[i].rk&lt;=r) a[E[i].id]+=1ll*(ssz[p2-1]+E[i].rk-l+1)*x; s[p2]+=a[E[i].id]; &#125; rep(i,p1+1,p2-1) &#123; t[i]+=1ll*(ssz[i-1]-l+2)*x,d[i]+=x; s[i]+=Get(ssz[i-1]-l+2,ssz[i]-l+1)*x; &#125;&#125; ll Que(int l,int r) &#123; int p1=Get(l),p2=Get(r); ll ans=0; Down(p1),Down(p2); if(p1==p2) &#123; Down(p1); for(int i=head[p1];i;i=nxt[i]) if(ssz[p1-1]+E[i].rk&gt;=l &amp;&amp; ssz[p1-1]+E[i].rk&lt;=r) ans+=a[E[i].id]; return ans; &#125; Down(p1),Down(p2); for(int i=head[p1];i;i=nxt[i]) if(ssz[p1-1]+E[i].rk&gt;=l) ans+=a[E[i].id]; for(int i=head[p2];i;i=nxt[i]) if(ssz[p2-1]+E[i].rk&lt;=r) ans+=a[E[i].id]; rep(i,p1+1,p2-1) ans+=s[i]; return ans;&#125; int main()&#123; n=rd(),m=rd(); cnt=ceil(sqrt(n+m)); rep(i,1,n) a[i]=rd(),E[i]=(Node)&#123;i,i&#125;; Build(); rep(i,1,m) &#123; int opt=rd(); if(opt==1) &#123; int l=rd(),r=rd(),x=rd(); Set(l,r,x); &#125; else if(opt==2) &#123; int l=rd(),r=rd(),x=rd(); Add(l,r,x); &#125; else if(opt==3) &#123; int p=rd(),x=rd(); Insert(p,x); &#125; else if(opt==4) &#123; int l=rd(),r=rd(); printf(&quot;%lld\\n&quot;,Que(l,r)); &#125; &#125;&#125; 旋Treap: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;//#pragma GCC optimize(2)typedef double db;typedef long double ldb;typedef long long ll;typedef unsigned long long ull;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=2e5+10;int n;int rt,son[N][2],fa[N];ll s[N],t[N],d[N],st[N],val[N];ll sz[N],key[N];void Up(int p) &#123; s[p]=s[son[p][0]]+s[son[p][1]]+val[p]; sz[p]=sz[son[p][0]]+sz[son[p][1]]+1;&#125;void Set(int p,ll x)&#123; t[p]=d[p]=0,st[p]=val[p]=x,s[p]=sz[p]*x;&#125;void Add(int p,ll x,ll d) &#123; val[p]+=x+d*sz[son[p][0]]; s[p]+=sz[p]*(sz[p]-1)/2*d+x*sz[p]; t[p]+=x,::d[p]+=d;&#125;void Down(int p) &#123; if(~st[p]) Set(son[p][0],st[p]),Set(son[p][1],st[p]),st[p]=-1; if(t[p] || d[p]) Add(son[p][0],t[p],d[p]),Add(son[p][1],t[p]+(sz[son[p][0]]+1)*d[p],d[p]),t[p]=d[p]=0;&#125;void rotate(int u) &#123; int f=fa[u],ff=fa[f],d=son[f][1]==u; fa[u]=ff; if(ff) son[ff][son[ff][1]==f]=u; son[f][d]=son[u][!d]; if(son[u][!d]) fa[son[u][!d]]=f; son[u][!d]=f,fa[f]=u; Up(f),Up(u);&#125;void Insert(int p,int x)&#123; int v=++n; val[v]=s[v]=x,sz[v]=1,st[v]=-1,key[v]=rand(); if(!rt)&#123; rt=v; return; &#125; int u=rt; while(u) &#123; Down(u); if(sz[son[u][0]]&gt;=p) &#123; if(!son[u][0]) &#123; son[fa[v]=u][0]=v; break; &#125; u=son[u][0]; &#125; else &#123; p-=sz[son[u][0]]+1; if(!son[u][1]) &#123; son[fa[v]=u][1]=v; break; &#125; u=son[u][1]; &#125; &#125; while(fa[v] &amp;&amp; key[v]&lt;key[fa[v]]) rotate(v); if(!fa[v]) rt=v; while(fa[v]) Up(v=fa[v]);&#125;void Set(int p,int l,int r,int x) &#123; if(!p || r&lt;=0 || l&gt;sz[p]) return; if(l&lt;=1 &amp;&amp; r&gt;=sz[p]) return Set(p,x); int t=sz[son[p][0]]+1; Down(p),Set(son[p][0],l,r,x),Set(son[p][1],l-t,r-t,x); if(t&gt;=l &amp;&amp; t&lt;=r) val[p]=x; Up(p);&#125;void Add(int p,int l,int r,ll x,ll d) &#123; if(!p || r&lt;=0 || l&gt;sz[p]) return; if(l&lt;=1 &amp;&amp; r&gt;=sz[p]) return Add(p,x,d); int t=sz[son[p][0]]+1; Down(p),Add(son[p][0],l,r,x,d),Add(son[p][1],l-t,r-t,x+d*t,d); if(t&gt;=l &amp;&amp; t&lt;=r) val[p]+=(t-1)*d+x; Up(p);&#125;ll Que(int p,int l,int r) &#123; if(!p || r&lt;=0 || l&gt;sz[p]) return 0; if(l&lt;=1 &amp;&amp; r&gt;=sz[p]) return s[p]; ll t=sz[son[p][0]]+1,res=0; Down(p),res+=Que(son[p][0],l,r),res+=Que(son[p][1],l-t,r-t); if(t&gt;=l &amp;&amp; t&lt;=r) res+=val[p]; return res;&#125;int main()&#123; int n=rd(),m=rd(); rep(i,0,n-1) Insert(i,rd()); while(m--) &#123; int opt=rd(); if(opt==1) &#123; int l=rd(),r=rd(); Set(rt,l,r,rd()); &#125; else if(opt==2) &#123; int l=rd(),r=rd(),x=rd(); Add(rt,l,r,x-1ll*(l-1)*x,x); &#125; else if(opt==3) &#123; int x=rd(),y=rd(); Insert(x-1,y); &#125; else &#123; int l=rd(),r=rd(); printf(&quot;%lld\\n&quot;,Que(rt,l,r)); &#125; &#125;&#125; 非旋Treap: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair &lt;int,int&gt; Pii;#define mp make_pairint rd()&#123; char c;int s=0; while((c=getchar())&lt;48); do s=s*10+c-48; while((c=getchar())&gt;47); return s;&#125;enum&#123;N=200010&#125;;int n,m,rt,ls[N],rs[N],key[N];ll s[N],t[N],d[N],st[N],val[N],sz[N]; inline void Up(int p) &#123; s[p]=s[ls[p]]+s[rs[p]]+val[p]; sz[p]=sz[ls[p]]+sz[rs[p]]+1;&#125;inline void Set(int p,ll x)&#123; t[p]=d[p]=0,st[p]=val[p]=x,s[p]=sz[p]*x; &#125;inline void Add(int p,ll x,ll d) &#123; val[p]+=x+d*sz[ls[p]]; s[p]+=sz[p]*(sz[p]-1)/2*d+x*sz[p]; t[p]+=x,::d[p]+=d;&#125;inline void Down(int p) &#123; ~st[p] &amp;&amp; (Set(ls[p],st[p]),Set(rs[p],st[p]),st[p]=-1); (t[p] || d[p]) &amp;&amp; (Add(ls[p],t[p],d[p]),Add(rs[p],t[p]+(sz[ls[p]]+1)*d[p],d[p]),t[p]=d[p]=0);&#125;int Union(int x,int y) &#123; if(!x || !y) return x|y; return key[x]&lt;key[y]?(Down(x),rs[x]=Union(rs[x],y),Up(x),x):(Down(y),ls[y]=Union(x,ls[y]),Up(y),y);&#125;Pii Split(int x,int d)&#123; if(sz[x]&lt;=d) return mp(x,0); if(d==0) return mp(0,x); Down(x); if(sz[ls[x]]+1&lt;=d) &#123; Pii y=Split(rs[x],d-sz[ls[x]]-1); return rs[x]=y.first,Up(x),mp(x,y.second); &#125; else &#123; Pii y=Split(ls[x],d); return ls[x]=y.second,Up(x),mp(y.first,x); &#125;&#125; int main()&#123; n=rd(),m=rd(); for(int i=1;i&lt;=n+m;++i) key[i]=rand(),st[i]=-1,sz[i]=1; for(int i=1;i&lt;=n;++i) val[i]=s[i]=rd(),rt=Union(rt,i); while(m--)&#123; int opt=rd(); if(opt==3) &#123; Pii t=Split(rt,rd()-1); ++n,val[n]=s[n]=rd(); rt=Union(Union(t.first,n),t.second); &#125; else &#123; int l=rd(),r=rd(); Pii a=Split(rt,l-1),b=Split(a.second,r-l+1); if(opt==1) Set(b.first,rd()); else if(opt==2) &#123;int x=rd(); Add(b.first,x,x); &#125; else if(opt==4) printf(&quot;%lld\\n&quot;,s[b.first]); rt=Union(Union(a.first,b.first),b.second); &#125; &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"COCI","slug":"COCI","permalink":"http://chasingdeath.github.io/tags/COCI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"最大流/最小割树/等价流树 学习笔记","slug":"最大流 最小割树 等价流树 学习笔记","date":"2020-08-24T04:18:05.000Z","updated":"2021-05-22T03:54:11.381Z","comments":true,"path":"articles/2020/08/24/cf0087fb.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/24/cf0087fb.html","excerpt":"","text":"最大流/最小割树/等价流树 学习笔记最小割树 $\\text{Gomory-Hu Tree}$ 前置约定无向图点数为$n$，边数为$m$ 割:断开一些边，使得$s,t$两点不连通 设$\\lambda(u,v)$为$u,v$的最小割权值 在非负边权的无向图上使用网络流即可求得两点间的最小割，但是如果涉及查询所有点对的最小割，就需要进行$n^2$次网络流，复杂度很高 \\简介对于非负边权的无向图，适用于求出多点对之间的最小割/最大流的结构 1.$\\text{Gomory-Hu Tree}$的核心性质构造树，使得树边$(u,v)$满足割掉这条边后，$u,v$的最小割对应将图分为树在两边的这两个集合 而边$(u,v)$的权值$w(u,v)=\\lambda(u,v)$ 2.求解最小割的方法引理:$\\lambda(a,b)\\ge \\min\\{\\lambda(a,c),\\lambda(c,b)\\}$ 假设$\\lambda(a,b) &lt; \\min\\{\\lambda(a,c),\\lambda(c,b)\\}$ 设$a,b$最小割的两个集合后两点所属的联通块集合为$A,B$ 1.若$c\\in A$，则$a,b$最小割也是$b,c$的割 2.若$c\\in B$，则$a,b$最小割也是$a,c$的割 以上两种情况均与$\\lambda(a,b) &lt; \\min\\{\\lambda(a,c),\\lambda(c,b)\\}$矛盾 \\假设要求$u,v$两点间的最短路，则答案就是$u,v$在树上路径的最小边权值，设其为边$(s,t)$ 由上面的引理，显然有$\\lambda(u,v)\\ge\\lambda(s,t)$ 而我们由$\\text{Gomory-Hu Tree}$的性质知道，$s,t$的割也是$u,v$的一个割，即$\\lambda(u,v)\\le \\lambda(s,t)$ 所以答案就是$\\lambda(s,t)$ 构建方法构建$\\text{Gomory-Hu Tree}$最重要的一条引理，可以认为是最小割的”不交叉”性质 对于$s,t$最小割的一侧，设其点集为$W$，则对于任意的$u,v\\in W$，存在一个$s,t$最小割$X$，满足$X\\sube W$ 具体的证明比较复杂，咕，但是这个性质确实非常巧妙 利用这个性质，可以得到$\\text{Gomory-Hu Tree}$的不严谨的递归构造方法 1.对于当前点集$S$，若$|S|=1$，则结束递归 2.从$S$中选择两个点$x,y$求出最小割，设在割中$x,y$所属点集分别为$X,Y$ 3.在$\\text{Gomory-Hu Tree}$上加入边$(x,y,\\lambda(x,y))$，递归解决子问题$X\\cap S,Y\\cap S$ \\实际在递归求解$S$的问题时，应该将图中其他的点缩点(这是论文里说的，实际没有人这么写) 是不是不缩点跑出来的树形是错的? 递归求解的次数为$O(n)$，只需要求$O(n)$次网络流即可 放一下丑陋的板子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair &lt;int,int&gt; Pii;#define pb push_back#define mp make_pair#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=510,M=6200,INF=1e9+10;int n,m;int U[M],V[M],W[M];struct Edge&#123; int to,nxt,w;&#125; e[M];int head[N],ecnt;void AddEdge(int u,int v,int w) &#123; e[++ecnt]=(Edge)&#123;v,head[u],w&#125;; head[u]=ecnt;&#125;void Link(int u,int v,int w)&#123; AddEdge(u,v,w),AddEdge(v,u,w); &#125;#define erep(u,i) for(int i=head[u];i;i=e[i].nxt)int dis[N],vc,S,T;void clear()&#123; rep(i,1,vc) head[i]=0; ecnt=1,vc=0; &#125;int Bfs() &#123; rep(i,1,vc) dis[i]=INF; static queue &lt;int&gt; que; dis[S]=0,que.push(S); while(!que.empty()) &#123; int u=que.front(); que.pop(); erep(u,i) &#123; int v=e[i].to,w=e[i].w; if(!w || dis[v]&lt;=dis[u]+1) continue; dis[v]=dis[u]+1,que.push(v); &#125; &#125; return dis[T]&lt;INF;&#125;int Dfs(int u,int in) &#123; if(u==T) return in; int out=0; erep(u,i) &#123; int v=e[i].to,w=e[i].w; if(!w || dis[v]!=dis[u]+1) continue; int t=Dfs(v,min(in-out,w)); e[i].w-=t,e[i^1].w+=t,out+=t; if(in==out) break; &#125; if(!out) dis[u]=0; return out;&#125;int Dinic()&#123; int ans=0; while(Bfs()) ans+=Dfs(S,INF); return ans;&#125;int Mincut(int u,int v)&#123; clear(),vc=n,S=u,T=v; rep(i,1,m) Link(U[i],V[i],W[i]); return Dinic();&#125;vector &lt;Pii&gt; G[N];int P[N],R[N];void Build(int l,int r) &#123; if(l==r) return; int x=P[l],y=P[l+1]; int w=Mincut(x,y); int p1=l-1,p2=r+1; rep(i,l,r) if(dis[P[i]]&lt;INF) R[++p1]=P[i]; else R[--p2]=P[i]; rep(i,l,r) P[i]=R[i]; G[x].pb(mp(y,w)),G[y].pb(mp(x,w)); Build(l,p1),Build(p2,r);&#125;int fa[N][10],s[N][10],dep[N];void dfs(int u,int f) &#123; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];++i) fa[u][i]=fa[fa[u][i-1]][i-1],s[u][i]=min(s[u][i-1],s[fa[u][i-1]][i-1]); for(Pii t:G[u]) if(t.first!=f) &#123; int v=t.first,w=t.second; fa[v][0]=u,s[v][0]=w,dep[v]=dep[u]+1; dfs(v,u); &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); int mi=1e9; for(int i=0,del=dep[x]-dep[y];(1&lt;&lt;i)&lt;=del;++i) if(del&amp;(1&lt;&lt;i)) cmin(mi,s[x][i]),x=fa[x][i]; if(x==y) return mi; drep(i,9,0) if(fa[x][i]!=fa[y][i]) cmin(mi,s[x][i]),cmin(mi,s[y][i]),x=fa[x][i],y=fa[y][i]; cmin(mi,s[x][0]),cmin(mi,s[y][0]); return mi;&#125;int main() &#123; n=rd()+1,m=rd(); rep(i,1,m) U[i]=rd()+1,V[i]=rd()+1,W[i]=rd(); rep(i,1,n) P[i]=i; Build(1,n); dfs(1,0); rep(kase,1,rd()) printf(&quot;%d\\n&quot;,LCA(rd()+1,rd()+1));//printf(&quot;%d\\n&quot;,MinCut(rd()+1,rd()+1));&#125; 等价流树等价流树的树形不需要满足$\\text{Gomory-Hu Tree}$的性质，只需要能够查询两点间的答案即可 在论文中看到的等价流树的非递归构建方法(伪代码) $w_{1,..,n}=0,fa_{1}=1,fa_{2,..,n}=1$ $\\text{for u = 2 to n do}$ $v = fa_u$ 求解$u,v$最小割 ​ $w_u=\\lambda(u,v)$ ​ $\\text{for x=u+1 to n do}$ ​ $\\text{if} fa_x=v \\text{ and x在u这一侧 then }fa_x=u$ ​ $\\text{end for}$ $\\text{end for}$ 但是这个东西实际也不会跑得比$\\text{Gomory-Hu Tree}$快，了解一下即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef unsigned long long ull;typedef pair &lt;int,int&gt; Pii;#define reg register#define pb push_back#define mp make_pair#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=860,M=170010,INF=1e9+10;int n,m;int U[M],V[M],W[M];struct Edge&#123; int to,nxt,w;&#125; e[M];int head[N],ecnt;void AddEdge(int u,int v,int w) &#123; e[++ecnt]=(Edge)&#123;v,head[u],w&#125;; head[u]=ecnt;&#125;void Link(int u,int v,int w)&#123; AddEdge(u,v,w),AddEdge(v,u,w); &#125;#define erep(u,i) for(int i=head[u];i;i=e[i].nxt)int dis[N],vc,S,T;void clear()&#123; rep(i,1,vc) head[i]=0; ecnt=1,vc=0; &#125;int Bfs() &#123; rep(i,1,vc) dis[i]=INF; static queue &lt;int&gt; que; dis[S]=0,que.push(S); while(!que.empty()) &#123; int u=que.front(); que.pop(); erep(u,i) &#123; int v=e[i].to,w=e[i].w; if(!w || dis[v]&lt;=dis[u]+1) continue; dis[v]=dis[u]+1,que.push(v); &#125; &#125; return dis[T]&lt;INF;&#125;int Dfs(int u,int in) &#123; if(u==T) return in; int out=0; erep(u,i) &#123; int v=e[i].to,w=e[i].w; if(!w || dis[v]!=dis[u]+1) continue; int t=Dfs(v,min(in-out,w)); e[i].w-=t,e[i^1].w+=t,out+=t; if(in==out) break; &#125; if(!out) dis[u]=0; return out;&#125;int Dinic()&#123; int ans=0; while(Bfs()) ans+=Dfs(S,INF); return ans;&#125;int Mincut(int u,int v)&#123; clear(),vc=n,S=u,T=v; rep(i,1,m) Link(U[i],V[i],W[i]); return Dinic();&#125;int fa[N],w[N];int main() &#123; n=rd(),m=rd(); rep(i,1,m) U[i]=rd(),V[i]=rd(),W[i]=rd(); rep(i,2,n) fa[i]=1; rep(u,2,n) &#123; int v=fa[u]; w[u]=Mincut(v,u); rep(x,u+1,n) if(fa[x]==v &amp;&amp; dis[x]==INF) fa[x]=u; &#125;&#125;","categories":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}]},{"title":"[COCI2010-2011 2] CRNI(单调栈)","slug":"[COCI2010-2011 2] CRNI(单调栈)","date":"2020-08-23T10:51:24.000Z","updated":"2021-05-22T03:54:11.029Z","comments":true,"path":"articles/2020/08/23/cd2cee96.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/23/cd2cee96.html","excerpt":"","text":"[COCI2010-2011#2] CRNI(单调栈)问题分析首先考虑两个不相交的矩形可能存在的位置关系，我将其分成 1.左右 2.上下 3.左上右下 4.左下右上 发现1,2,3,4之间有相交,考虑四种情况的答案应该是1+2-3-4 统计方法核心: 统计以一个点作为顶点的矩形数量 以统计$i,j$为右下角的矩形为例，先不考虑矩形大小&gt;1的限制 显然可以在线性时间内处理得到每个$i,j$向上连续延伸的连续1长度，设其为$U_{i,j}$ 假设枚举了$i$，从左到右依次扫描$j$，则得到$i,j$位置的答案应该是 $$\\begin{aligned} \\sum_{k=1}^{j} \\min_{d=k}^j\\lbrace U_{i,d}\\rbrace\\end{aligned} $$ 这条式子中，相当于枚举了$i,(k,j)$为底，统计向上延伸的最长长度 这个式子可以用单调栈在线性时间内求解，其过程可以描述为 1.每次插入元素$U_{i,j}$，得到它的影响区间$k\\in [L,j]$ 2.将原先单调栈内$k\\in [L,j]$这段区间的答案减掉，改为$U_{i,j}\\cdot (j-L+1)$ 类似的，可以通过改变循环顺序和额外记录向下延伸的长度$D_{i,j}$来统计四种顶点的答案(详细见代码) 然后可以用前缀和帮助统计以上4种答案，枚举一个端点，另一个查询前缀和即可 tips: 注意累和顺序，前缀和要开long long 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1e3+10;int n;char a[N][N];int D[N][N],U[N][N]; //i,j向下/上延伸的最长长度int stk[N],c[N],top;int CRR[N][N]; // 以i,j为右下角的矩形个数int CLL[N][N]; // 以i,j为左上角的矩形个数int CLR[N][N]; // 以i,j为右上角的矩形个数int CRL[N][N]; // 以i,j为左下角的矩形个数ll SLL[N][N],SRL[N][N]; // 前缀和int main()&#123; n=rd(); rep(i,1,n) scanf(&quot;%s&quot;,a[i]+1); rep(i,1,n) rep(j,1,n) if(a[i][j]==&#x27;C&#x27;) U[i][j]=U[i-1][j]+1; drep(i,n,1) rep(j,1,n) if(a[i][j]==&#x27;C&#x27;) D[i][j]=D[i+1][j]+1; rep(i,1,n) &#123; // 统计四种端点的情况 top=0; int now=0; rep(j,1,n) &#123; int x=U[i][j],cnt=1; while(top &amp;&amp; stk[top]&gt;=x) cnt+=c[top],now-=c[top]*stk[top],top--; stk[++top]=x,c[top]=cnt; now+=x*cnt; CRR[i][j]=max(now-1,0); &#125; now=top=0; rep(j,1,n) &#123; int x=D[i][j],cnt=1; while(top &amp;&amp; stk[top]&gt;=x) cnt+=c[top],now-=c[top]*stk[top],top--; stk[++top]=x,c[top]=cnt; now+=x*cnt; CLR[i][j]=max(now-1,0); &#125; now=top=0; drep(j,n,1) &#123; int x=U[i][j],cnt=1; while(top &amp;&amp; stk[top]&gt;=x) cnt+=c[top],now-=c[top]*stk[top],top--; stk[++top]=x,c[top]=cnt; now+=x*cnt; CRL[i][j]=max(now-1,0); &#125; now=top=0; drep(j,n,1) &#123; int x=D[i][j],cnt=1; while(top &amp;&amp; stk[top]&gt;=x) cnt+=c[top],now-=c[top]*stk[top],top--; stk[++top]=x,c[top]=cnt; now+=x*cnt; CLL[i][j]=max(now-1,0); &#125; &#125; drep(i,n,1) drep(j,n,1) SLL[i][j]=SLL[i+1][j]+SLL[i][j+1]-SLL[i+1][j+1]+CLL[i][j]; rep(i,1,n) drep(j,n,1) SRL[i][j]=SRL[i-1][j]+SRL[i][j+1]-SRL[i-1][j+1]+CRL[i][j]; // 前缀和 ll ans=0; rep(i,1,n) rep(j,1,n) if(CRR[i][j]) ans+=CRR[i][j]*(SLL[i+1][1]+SLL[1][j+1]-SLL[i+1][j+1]); rep(i,1,n) rep(j,1,n) ans-=CLR[i][j]*SRL[i-1][j+1]; // 统计4种情况 printf(&quot;%lld\\n&quot;,ans%10007);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"COCI","slug":"COCI","permalink":"http://chasingdeath.github.io/tags/COCI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[WC2020] 选课 (枚举+Dp)","slug":"[WC2020] 选课 (枚举+dp)","date":"2020-08-21T11:18:05.000Z","updated":"2021-05-22T03:54:11.092Z","comments":true,"path":"articles/2020/08/21/f186931.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/21/f186931.html","excerpt":"","text":"[WC2020] 选课 (枚举+dp)题面数据范围锅了导致枚举炸裂，写了正解却只有50分。。。。。。。 正确题面可以查看LOJ 记限制涉及到的不同的点个数为$P$ 首先是不同的会被限制的个数$\\leq 12$，所以应该直接枚举这些点的状态，枚举部分的复杂度是$O(2^P)$ (然后我枚举了$p$，实际$p\\leq 66$啊啊啊啊啊啊) 对于没有被限制的点，可以优先预处理出每个类型的答案，注意到$L=T-\\sum s_i\\leq 40$，则可以每次只取出长度为$O(L)$ 的这一部分，类型之间合并为$O(ML^2)$的复杂度 或许比较难的点是在于每种类型内的合并，注意到$w\\in\\{1,2,3\\}$ 把每种$w$排序后，令$dp_i$为总权值为$i$的最小花费，同时记录最小花费时选取的三种$w$的个数，最优决策肯定是取最小的几个 每次转移，可以直接枚举选取的$w$，在排序好的数组上找到下一个最小花费 ps:事实证明，这个做法显然是假的，但是为什么就是没卡掉呢？正确的做法是先dp，w=1或2，再和3的暴力合并求出最大的$L$个值，这样的复杂度为$O(NL)$ ps2:后来测试，这个错误做法在值域只有200的情况下，随机情况下，整个值域中的错误率只有1/100~1/1000左右，而答案需要用到的部分又奇少，只有L个，于是乎，嘿嘿嘿嘿 如果用这种邪教写法，预处理的转移复杂度就是$O(N)$的 每次枚举之后，把被改变的几个类型答案重新计算，重新合并，这一部分复杂度就是$O(PL^2)$的 算上$2^P$次枚举，得到总复杂度是$O(N+2^PPL^2)$ Code","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"WC","slug":"WC","permalink":"http://chasingdeath.github.io/tags/WC/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"HDU-6886 Tic-Tac-Toe-Nim(2020HDU多校第十场T10)","slug":"HDU-6886 Tic-Tac-Toe-Nim(2020HDU多校第十场T10)","date":"2020-08-20T11:02:28.000Z","updated":"2021-05-22T03:54:10.956Z","comments":true,"path":"articles/2020/08/20/d0817435.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/20/d0817435.html","excerpt":"","text":"HDU-6886 Tic-Tac-Toe-Nim(2020HDU多校第十场T10)正如题目名字，这是一个nim游戏 观察题目条件，前两次操作一定会清空两个位置，那么考虑后面得到的状态是否先手必胜即可 对于这两个位置，发现只有两种情况 两个位置共线此时先手者直接选择同线的另一个即可，必胜 两个位置不共线此时还剩下一个位置与这两个空位均不共线，其他6个位置均共线 考虑可能存在的结束情况: 1.6个位置中有一个被清空，则下一个人直接清空共线的另一个位置必胜 2.不共线的位置被清空，不影响结局 考虑把这个问题转化为普通的Nim游戏 可以认为如果那6个位置均为1时游戏必败，而不共线的一个位置随意 则转化为 六个共线位置的值-1 与 不共线位置的值 形成的普通Nim游戏，根据常识，直接异或判断即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)int rd()&#123; int IO,s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;int a[4][4];int Check()&#123; // 判断是否必胜 rep(i,1,3) rep(j,1,3) if(a[i][j]) &#123; int fl=1; rep(k,1,3) if(j!=k &amp;&amp; !a[i][k]) fl=0; rep(k,1,3) if(k!=i &amp;&amp; !a[k][j]) fl=0; if(!fl) continue; int x=a[i][j],ans=0; a[i][j]=0; rep(i,1,3) rep(j,1,3) if(a[i][j]) ans^=a[i][j]-1; // 共线位置 ans^=x,a[i][j]=x; // 不共线位置 return ans; &#125; return &#x27;?&#x27;;&#125;int main()&#123; rep(kase,1,rd()) &#123; rep(i,1,3) rep(j,1,3) a[i][j]=rd(); int ans=0; rep(i,1,3) rep(j,1,3) &#123; int t=a[i][j]; a[i][j]=0; int fl=0; rep(x,1,3) rep(y,1,3) &#123; // 枚举两次初始操作，注意两次操作不共线! if(x==i || y==j) continue; int t=a[x][y]; a[x][y]=0; if(!Check()) fl=1; a[x][y]=t; &#125; if(!fl) ans++; a[i][j]=t; &#125; printf(&quot;%d\\n&quot;,ans); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[HDU-6883] Coin Game(2020HDU多校第十场T7)","slug":"[HDU-6883] Coin Game(2020HDU多校第十场T7)","date":"2020-08-20T10:54:40.000Z","updated":"2021-05-22T03:54:11.069Z","comments":true,"path":"articles/2020/08/20/18615522.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/20/18615522.html","excerpt":"","text":"[HDU-6883] Coin Game(2020HDU多校第十场T7)题目给出的模型看起来比较奇怪，但是简单推理后，发现可以转化为一个简单的01背包问题 对于题目给定的权值$a_i,b_i$，分为$a_i,a_i+b_i$两个物品，发现可以得到这个机器的所有合法贡献情况 也就是说，有两种大小分别为$1,2$的物品，要做01背包 这个刚刚在WC2020考过。。。 设两类转化后的权值分别为$a_i,b_i$，则转移过程可以简单描述为 1.将两类权值分别从大到小排序 2.将dp值转化为在两个序列中分别选取一段前缀和 3.转移时枚举下一次决策的选取是那种物品，选取最优一个，记录指针转移即可 主要复杂度可能还在于排序，Trick:有一点卡内存 但是实测桶排和直接sort好像差距不大。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)const int N=5e6+10,INF=1e9;int n,m;int a[N],b[N];ull k1,k2;int Shift()&#123; ull k3=k1,k4=k2; k1=k4; k3^=k3&lt;&lt;23; k2=k3^k4^(k3&gt;&gt;17)^(k4&gt;&gt;26); return (k2+k4)%10000000+1;&#125;int A[N*3],B[N*3]; // 记录在两个序列中的指针ll dp[3]; // dp数组滚动了一下int main()&#123; while(~scanf(&quot;%d%d%llu%llu&quot;,&amp;n,&amp;m,&amp;k1,&amp;k2)) &#123; rep(i,1,n) a[i]=Shift(),b[i]=Shift()+a[i]; sort(a+1,a+n+1,greater&lt;int&gt;()),sort(b+1,b+n+1,greater&lt;int&gt;()); A[0]=B[0]=1; rep(i,0,2) dp[i]=0; ll ans=0; int cur=0; rep(i,0,m) &#123; if(i+1&lt;=m &amp;&amp; A[i]&lt;=n) &#123; int nxt=(cur+1)%3; if(dp[cur]+a[A[i]]&gt;dp[nxt]) dp[nxt]=dp[cur]+a[A[i]],A[i+1]=A[i]+1,B[i+1]=B[i]; &#125; if(i+2&lt;=m &amp;&amp; B[i]&lt;=n) &#123; int nxt=(cur+2)%3; if(dp[cur]+b[B[i]]&gt;dp[nxt]) dp[nxt]=dp[cur]+b[B[i]],A[i+2]=A[i],B[i+2]=B[i]+1; &#125; ans^=dp[cur]; cur=(cur+1)%3; &#125; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"Default Title","slug":"default title","date":"2020-08-16T10:44:40.000Z","updated":"2021-05-22T03:54:11.113Z","comments":true,"path":"articles/2020/08/16/4adbf780.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/16/4adbf780.html","excerpt":"","text":"","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"[[HDU-6791] 2020HDU多校第三场T1](回文自动机)","slug":"[[HDU-6791] 2020HDU多校第三场T1](回文自动机)","date":"2020-08-16T04:41:47.000Z","updated":"2021-05-22T03:54:11.094Z","comments":true,"path":"articles/2020/08/16/60cd65b0.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/16/60cd65b0.html","excerpt":"","text":"[HDU-6791] 2020HDU多校第三场T1(回文自动机)前置知识：1.字符串的$\\text{Border}$ 2.回文自动机 3.回文串与$\\text{Border}$ 3.1:回文串的$\\text{Border}$也是回文串 若有回文串$S$的一个$\\text{Border} :T$，则$S_{1,|T|}=S_{|S|-|T|+1,|S|}=reverse(S_{1,|T|})$ 故$T$也是一个回文串 3.2:遍历回文自动机的$fail$链，能得到当前串的所有$\\text{Border}$(基于3.1得到) 约定:串$S$的$\\text{Border}$集合为$B(S)$，字符集为$\\Sigma$ 题意:设随机空串末尾添加$\\Sigma$中的字符，第一次出现子串$S$的期望长度为$E(S)$ 给定一个串，每次查询它的两个回文子串$A,B$，比较$E(A),E(B)$ 起源？一切的起源都是” 国家集训队论文2018 :1-浅谈生成函数在掷骰子问题上的应用 “的一个结论。。。 还有为什么会是回文子串呢？因为只有回文自动机能访问子串的所有$\\text{Border}$。。。 结论 以及 口胡证明?$\\begin{aligned}E(S)=\\sum_{T\\in B(S)}|\\Sigma|^{|T|}\\end{aligned}$~~(???)~~ 在原论文给出了生成函数性的证明，实际可以直接口胡(好吧也差不多)，大致分成两个步骤 1.$E(S)=\\sum_{i=0}^{\\infty}$长度为$i$依然不包含$S$的概率(即把长度为$i$时恰好合法转化为了$0..i-1$时不合法) 2.设所有长度下不合法的串集合为$G$(每个不合法串有概率$G(T)$)，合法的串集合为$F$(每个合法串也有概率$F(T)$) 由第一步$E(S)=\\sum G(T)$，合法串的概率不会重复，所以$\\sum F(T)=1$ 考虑$G$中所有的串，如果在后面接上$S$必然合法，但是可能在更早的时候就结束了，这是必然满足接上的前缀是$\\text{Border}$ 也就是说，在$G$集合后面接上$S$后，不仅会得到$F$集合，还会得到$F$集合后面额外接上$|S|-|R|,(R\\in B(S))$长度字符的状态 所以有$\\sum G(T)\\cdot (\\frac{1} {|\\Sigma|})^{|S|}=\\sum_{R\\in B(S)}\\sum F(T)\\cdot (\\frac{1} {|\\Sigma|})^{|S|-|R|}$ 化简且带入$\\sum F(T)=1$，得到$E(S)=\\sum G(T)=\\begin{aligned}\\sum_{R\\in B(S)}|\\Sigma|^{|R|}\\end{aligned}$ 那么比较问题就落到了比较$\\text{Border}$上面 视答案为为一个$26$进制数从高位到低位比较，转化为直接从大到小比较$\\text{Border}$序列的字典序即可 建出回文自动机后，倍增找到当前查询串对应的状态，所有的$\\text{Border}$就是$fail$链上所有非空状态长度 比较字典序可以 1.倍增+hash 2.可以根据$\\text{Border}$的性质分解为等差数列后暴力比较 3.像后缀数组一样，倍增地去为所有节点的字典序排序，这样查询是$O(1)$的 hash应该细节比较少，但是常数大 以下是hash版本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0;int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1e5+10;const ll P1=1e9+13,P2=19260817;const ll K1=123213,K2=342525;int n;char s[N];int now,len[N],fail[N],nxt[N][26],pos[N],cnt;int Pow1[N],Pow2[N];int fa[N][18],h1[N][18],h2[N][18];void Init()&#123; rep(i,0,cnt) memset(nxt[i],fail[i]=0,104); len[1]=-1; fail[now=0]=fail[1]=cnt=1;&#125;int Find(int x,int y)&#123; while(s[y]!=s[y-len[x]-1]) x=fail[x]; return x;&#125;void Extend(int i,int c)&#123; now=Find(now,i); if(!nxt[now][c])&#123; fail[++cnt]=nxt[Find(fail[now],i)][c]; len[nxt[now][c]=cnt]=len[now]+2; &#125; pos[i]=now=nxt[now][c];&#125;int Que(int l,int p)&#123; l=p-l+1,p=pos[p]; drep(i,17,0) if(len[fa[p][i]]&gt;=l) p=fa[p][i]; return p;&#125;int main()&#123; rep(i,Pow1[0]=Pow2[0]=1,N-1) Pow1[i]=1ll*Pow1[i-1]*K1%P1,Pow2[i]=Pow2[i-1]*K2%P2; rep(kase,1,rd())&#123; Init(),n=rd(),scanf(&quot;%s&quot;,s+1); rep(i,1,n) Extend(i,s[i]-&#x27;a&#x27;); rep(i,2,cnt) &#123; fa[i][0]=fail[i],h1[i][0]=h2[i][0]=len[i]; rep(j,1,17)&#123; fa[i][j]=fa[fa[i][j-1]][j-1]; if(fa[i][j]&gt;1)&#123; h1[i][j]=(1ll*h1[i][j-1]*Pow1[1&lt;&lt;(j-1)]+h1[fa[i][j-1]][j-1])%P1; h2[i][j]=(1ll*h2[i][j-1]*Pow2[1&lt;&lt;(j-1)]+h2[fa[i][j-1]][j-1])%P2; &#125; &#125; &#125; rep(q,1,rd()) &#123; int A=rd(),B=rd(),C=rd(),D=rd(); A=Que(A,B),C=Que(C,D); drep(i,17,0) if(fa[A][i]&gt;1 &amp;&amp; fa[C][i]&gt;1 &amp;&amp; h1[A][i]==h1[C][i] &amp;&amp; h2[A][i]==h2[C][i]) A=fa[A][i],C=fa[C][i]; A=max(len[A],0),C=max(len[C],0); if(A==C) puts(&quot;draw&quot;); else if(A&lt;C) puts(&quot;sjfnb&quot;); else puts(&quot;cslnb&quot;); &#125; &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"关于生成函数","slug":"关于生成函数","date":"2020-08-15T14:18:57.000Z","updated":"2021-05-22T03:54:11.335Z","comments":true,"path":"articles/2020/08/15/a5a38979.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/15/a5a38979.html","excerpt":"","text":"关于生成函数基础普通生成函数对于数列$a_i$，它的普通生成函数($\\text{OGF}$)为$A(x)=\\sum a_ix^i$ 这个$x^i$刚开始并没有实际意义，即为形式幂级数，实际这个$i$甚至可以不是一个整数，如$\\text{FWT}$中的指数为集合幂指数 普通生成函数常用于解决无序的组合计数问题，如背包问题 常见背包的生成函数我们让$x^i$项表示选择了$i$个物品，则可以构造生成函数 一个01背包，每一个物品的生成函数为$A(x)=x+1$，其中$x$项表示多选了一个，1项表示空着不选 同理，对于一个有限背包，每个物品上限$m_i$，则$A_i(x)=\\sum_{j=0}^{m_i} x^j$ 一个完全背包的生成函数为$\\begin{aligned} A(x)=\\sum_{i=0}^{\\infty} x^i=\\frac{1-x^{\\infty} } {1-x}=\\frac{1} {1-x}\\end{aligned} $(因为我们所求的答案是前若干项，无穷项没有意义) 那么多个物品的组合就可以通过这些生成函数相乘来轻松表示，因此也容易被多项式的快速运算优化 用生成函数描述递推关系一个最简单的例子，设斐波那契数列的普通生成函数为$F(x)$ 我们知道$F_i=F_{i-1}+F_{i-2},F_0=0,F_1=1$ 则可以用生成函数表示斐波那契数列的递推关系$F(x)=x F(x)+x^2 F(x)+x$ 其中$xF(x)$对应递推式的$F_{i-1}$，$x^2F(x)$对应递推式的$F_{i-2}$，$x$对应$F_1$的值 类似的问题还包括数列的线性递推，即$a_i=\\sum b_ja_{i-j}$，但是这个求解比较复杂。。。 \\基于概率期望的生成函数取自 集训队论文 2018 - 1 浅谈生成函数在掷骰子问题上的应用长沙市长郡中学杨懋龙 对于随机非负离散变量$x$，令它的概率生成函数是$F(z)=\\begin{aligned}\\sum_{i=0}^{\\infty}P(x=i)z^i\\end{aligned}$，则可以看到这里的指数代表$x$的值 $x$的值不一定能够相加，但是利用这个生成函数，可以快速表达期望，方差等，具体见下式 1.$F(1)=\\begin{aligned}\\sum_{i=0}^{\\infty}P(x=i)=1\\end{aligned}$ 2.$F'(1)=\\begin{aligned}\\sum_{i=0}^{\\infty}P(x=i)\\cdot i=E(x)\\end{aligned}$ 3.$E(x^{\\underline{k} })=F^{(k)}(1)$ ($x$的$k$阶下降幂，($k$)表示$k$阶导数) 4.$x$的方差$=\\begin{aligned}\\sum_{i=0}^{\\infty}P(x=i)\\cdot (i-E(x))^2\\end{aligned}=\\begin{aligned}\\sum_{i=0}^{\\infty}P(x=i)\\cdot i^2-2P(x=i)\\cdot i\\cdot E(x)+P(x=i)\\cdot E^2(x)\\end{aligned}$ $=E(x^2)-2E^2(x)+E^2(x)=E(x^2)-E^2(x)=E(x^{\\underline{2} })+E(x)-E^2(x)=F’’(1)+F’(1)-(F’(1))^2$ 可以作为导数在生成函数推导中应用的一个例子 \\指数生成函数对于数列$a_i$，它的指数生成函数($\\text{EGF}$)为$\\begin{aligned} A(x)=\\sum \\frac{a_ix^i} {i!}\\end{aligned} $ 指数型生成函数是处理有序排列问题的一大利器，因此，指数上的$i$通常表示个数 为什么$\\frac{1} {i!}$可以简化排列问题，可以参见这样的一个例子 用若干类物品排成一个排列，每一类有$m_i$个，则不同的排列个数为 $\\begin{aligned} \\frac{(\\sum m_i)!} {\\prod m_i!}\\end{aligned} $ 这个式子的意义就是: 假设先随便排列，由于每一类相同，因此类之内的排列都要除掉 可以看到，$\\frac{1} {i!}$描述的就是类内的排列，因此最后求得答案项还要乘上$n!$ 如果一类物品任意个数加入排列，则其指数生成函数为$\\begin{aligned} A(x)=\\sum_{i=0}^{\\infty}\\frac{x^i} {i!}=e^x\\end{aligned} $ 根据$e^{-x}=\\sum_i \\frac{(-x)^i} {i!}$,还能得到: 限制为偶数个的指数生成函数$\\begin{aligned} A(x)=\\sum_{2|i}^{\\infty}\\frac{x^i} {i!}=\\frac{e^x+e^{-x} } {2}\\end{aligned} $ 限制为奇数个的指数生成函数$\\begin{aligned} A(x)=\\sum_{2|i}^{\\infty}\\frac{x^i} {i!}=\\frac{e^x-e^{-x} } {2}\\end{aligned} $ 限制为$n$的倍数个，较为复杂，需要用到单位根反演 $e^{x}$在排列问题叠加上的应用若有一类等价排列子问题，其指数型生成函数为$F(x)$，则任意叠加其得到的排列问题指数型生成函数为 $\\begin{aligned} \\sum_{i=0}^{\\infty} \\frac{F^i(x)} {i!}=e^{F(x)}\\end{aligned} $，其中$\\frac{1} {i!}$表示除去子问题之间等价 \\更多常用技巧1.分治NTT解决多个多项式卷积问题 2.CDQ分治NTT解决有序递推问题 \\3.推导生成函数的关系 3-1.树的递归关系 问题: 计算合法树的数量，如树上染色问题等 这一类问题可以表示为 一种递归关系，即 枚举根的状态 加上根的儿子对应的生成函数 例子 [Codeforces Round #250]小朋友和二叉树 设一个点的生成函数为$G$，整棵数的生成函数为$F$，其中幂指数代表权值和，则$G$是我们已知的，且有关系 $F=G\\cdot F^2+1$，其中$F^2$表示枚举两个子树的状态，$G$表示枚举根的状态，$+1$表示空树 类似这样的问题还有 烷基计数加强版加强版 这个方程要用到牛顿迭代求解 3-2. \\4.集合幂指数在处理01状态上的应用 如果用整数指数形式表示的生成函数解决01状态上的or,and,xor操作 我们通常需要把这个过程转化为对$0,1$个数来做 但是这一类的问题，通常可以用集合幂指数轻松表示，前提是你了解$\\text{FWT}$卷积三种类型的本质过程 例题 ZJOI 2019开关","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"二次剩余(懒人模板总结)","slug":"二次剩余(懒人模板总结)","date":"2020-08-15T13:20:32.000Z","updated":"2021-05-22T03:54:11.319Z","comments":true,"path":"articles/2020/08/15/2244ecc3.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/15/2244ecc3.html","excerpt":"","text":"二次剩余(懒人模板总结)只考虑奇质数的情况 设求$\\sqrt a \\pmod P$ Part1 判断存在二次剩余即$a^{\\frac{(P-1)} {2} }=1 \\pmod P$ (对于所有$a=0,1$的情况需要特判) Part2 原根法求二次剩余先求出$P$的一个原根$g$ 那么可以用$g^k$表示出$[1,P-1]$的所有数 用$BSGS$可以在$O(\\sqrt n\\log n)$的时间内求出$a=g^k$ 如果存在原根，那么$k\\mod 2=0$ 答案就是$g^{\\frac{k} {2} }\\mod P$ 12345678910111213141516171819int Quad(int a,int k=0) &#123; if(a&lt;=1) return a; int g=Getg(P); static map &lt;int,int&gt; M; int S=sqrt(P-1); for(int i=0,t=1;i&lt;S;++i,t=1ll*t*g%P) M[t]=i; int res=0; int w=qpow(g,S); for(int i=0,t=1;i&lt;P-1;i+=S,t=1ll*t*w%P) &#123; ll x=1ll*a*qpow(t,P-2)%P; if(M.count(x)) &#123; res=M[x]+i; break; &#125; &#125; res=qpow(g,res/2); if(k) res=min(res,(P-res)%P); return res;&#125; Part3 更快的方法要先找到一个数$x$，满足不存在$\\sqrt{x^2-a}\\pmod P$ 可以随机$x$，期望可以在$O(1)$时间内找到这样的$x$ 然后构造复数$(\\alpha,\\beta)=\\alpha+\\sqrt{x^2-a}\\beta$ 求出$(x,1)^{\\frac{(P+1)} {2} }$，模拟复数乘法即可 可以证明结果没有虚部，就是答案 123456789101112131415161718192021222324int Quad(int a,int k=0) &#123; if(a&lt;=1) return a; ll x; while(1) &#123; x=1ll*rand()*rand()%P; if(qpow((x*x-a+P)%P,(P-1)/2)!=1) break; &#125; ll w=(x*x-a+P)%P; Pii res=mp(1,0),t=mp(x,1); auto Mul=[&amp;](Pii a,Pii b)&#123; // 复数乘法 int x=(1ll*a.first*b.first+1ll*a.second*b.second%P*w)%P; int y=(1ll*a.first*b.second+1ll*a.second*b.first)%P; return mp(x,y); &#125;; int d=(P+1)/2; while(d) &#123; if(d&amp;1) res=Mul(res,t); t=Mul(t,t); d&gt;&gt;=1; &#125; ll r=(res.first%P+P)%P; if(k) r=min(r,(P-r)%P); return r;&#125;","categories":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}]},{"title":"FWT (快速沃尔什变换)详解","slug":"FWT (快速沃尔什变换)详解","date":"2020-08-15T13:08:48.000Z","updated":"2021-05-22T03:54:10.946Z","comments":true,"path":"articles/2020/08/15/a72b1573.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/15/a72b1573.html","excerpt":"","text":"FWT (快速沃尔什变换)详解约定：$F’=FWT(F)$ 卷积的问题，事实上就是要构造$F’G’=(FG)’$ $\\text{FWT}$涉及的问题，我们看到是二进制位上的or ,and ,xor 但正式来说，是集合幂指数 上的 并 ， 交 ， 对称差 为了说人话，这里就不带入集合幂指数的概念了 一个常识：$\\sum_{T\\sube S}(-1)^{|T|}=[S=\\empty]$ or 和 and 卷积这两种卷积的本质是相同的，所以只解释$or$卷积 or卷积的本质就是高位前缀和 即:$F’_S=\\sum _{T\\sube S}F_T$ 正确性：即$\\forall S,F’_S \\cdot G’_S=(F\\cup G)’_S$ 左边= $F’_S \\cdot G’_S=\\sum _{T\\sube S}\\sum _{R\\sube S}F_T\\cdot G_R$ 右边= $(F\\cup G)’_S=\\sum_{T\\sube S}(F \\cup G)_S$ $=\\sum_{T\\sube S}\\sum_{A,B,A\\cup B=S}F_A\\cdot G_B$ $=\\sum_{T \\sube S}\\sum_{R \\sube S}F_T \\cdot G_R$ \\卷积实现其实第一次层循环的意思是枚举子集中和自己不同的位最高是$i$ 让$0$向$1$转移即可 12345678910void FWT(int n,ll *a)&#123; for(int i=1;i&lt;n;i&lt;&lt;=1) rep(j,i,n-1) if(j&amp;i) s[j]+=s[j^i];&#125;void FWT(int n,ll *a)&#123; for(int i=1;i&lt;n;i&lt;&lt;1) for(int l=0;l&lt;n;l+=i*2) for(int j=0;j&lt;l+i;++j) s[j+i]+=s[j];&#125; Tips:如果要卡常，可以写成类似$\\text{FFT}$的形式，因为优化了访问顺序会快一些 \\实现逆卷积把上面的加换成减，这是一个类似容斥的东西 但是因为是反解，所以这个过程我么通常称为子集反演 那么每次$0$向$1$的转移意味着多了一个不同的位置 设$F’_S=\\sum_{T\\sube S}F_T$ 实际逆卷积就是$F_S=\\sum_{T\\sube S}(-1)^{|T\\oplus S|} F’_S$ 证明如下： $\\Leftrightarrow F_S=\\sum_{T\\sube S}(-1)^{|T\\oplus S|} \\sum _{R\\in T}F_R$ $\\Leftrightarrow F_S=\\sum_{T\\sube S}F_R\\sum _{T\\sube R,R\\sube S}(-1)^{|S\\oplus R|}$ $\\Leftrightarrow F_S=\\sum_{T\\sube S}F_R\\sum _{R\\sube (S\\oplus T)}(-1)^{|R|}$ 带入上面所提到的$\\sum_{T\\sube S}(-1)^{|T|}=[S=\\empty]$，成立 12345678910void FWT(int n,ll *a,int f)&#123; for(int i=1;i&lt;n;i&lt;&lt;=1) rep(j,i,n-1) if(j&amp;i) s[j]+=f*s[j^i];&#125;void FWT(int n,ll *a,int f)&#123; for(int i=1;i&lt;n;i&lt;&lt;1) for(int l=0;l&lt;n;l+=i*2) for(int j=0;j&lt;l+i;++j) s[j+i]+=f*s[j];&#125; \\\\ Xor 卷积这里要用到一个小性质 $|A\\cap B|+|A\\cap C|\\equiv |A\\cap (B\\bigoplus C)| \\pmod 2$ 构造$F’_S=\\sum_{T}(-1)^{|S\\cap T|}F_T$ 正确性即$\\forall S,F’_S \\cdot G’_S=(F\\bigoplus G)’_S$ $F’_S\\cdot G’_S=\\sum_{T} \\sum_{R}(-1)^{|S\\cap T|+|S\\cap R|}F_T\\cdot G_R$ $=\\sum _T\\sum _R(-1)^{|(T\\bigoplus R)\\cap S|}F_T\\cdot G_R$ 显然这个式子与右边相同 \\卷积实现考虑和前面相同的方法，枚举二进制位上最高的$1$ 之前由于转移是单向的，所以只需要一次加法，这里由于有了系数同时还是双向的转移，所以要格外注意 转移系数也是比较明显的 $0\\rightarrow 0 = 1$ $0\\rightarrow 1 = 1$ $1\\rightarrow 0 = 1$ $1\\rightarrow 1 = -1$ 1234567891011121314151617181920void FWT(int n,ll *a)&#123; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; rep(j,0,n-1) if(i&amp;j) &#123; ll t=a[j+i]; a[j+i]=a[j]-t; a[j]=a[j]+t; &#125; &#125; &#125;void FWT(int n,ll *a)&#123; for(int i=1;i&lt;n;i&lt;&lt;=1)&#123; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j)&#123; ll t=a[j+i]; a[j+i]=a[j]-t; a[j]+=t; &#125; &#125; &#125;&#125; 实现逆卷积考虑再卷一次 $F’’_S=\\sum_T\\sum_R(-1)^{|S\\cap R|+|T\\cap R|}F_T$ $=\\sum_T \\sum_R (-1)^{|(S\\bigoplus T)\\cap R|}F_T$ $\\because \\sum_T (-1)^{|S\\cap T|}=\\sum_{T\\sube S}(-1)^{|T|}2^{|U|-|S|}=[S=\\empty]2^{|U|-|S|}$(其中$U$是全集) $\\therefore F’’_S=\\sum_S2^{|U|}F_S$ 所以逆卷积就是再卷一遍，最后除去$n$即可 12345678910111213141516171819202122void FWT(int n,ll *a,int f)&#123; for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; rep(j,0,n-1) if(i&amp;j) &#123; ll t=a[j+i]; a[j+i]=a[j]-t; a[j]=a[j]+t; &#125; &#125; if(f==-1) rep(i,0,n-1) a[i]/=n;&#125;void FWT(int n,ll *a,int f)&#123; for(int i=1;i&lt;n;i&lt;&lt;=1)&#123; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j)&#123; ll t=a[j+i]; a[j+i]=a[j]-t; a[j]+=t; &#125; &#125; &#125; if(f==-1) for(int i=0;i&lt;n;++i) a[i]/=n;&#125; 和上面一样的，可以写成类似$\\text{FFT}$的形式卡常","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"集训队论文 2018 - 1 浅谈生成函数在掷骰子问题上的应用长沙市长郡中学杨懋龙 阅读笔记","slug":"集训队论文 2018 - 1 浅谈生成函数在掷骰子问题上的应用长沙市长郡中学杨懋龙 阅读笔记","date":"2020-08-14T13:52:51.000Z","updated":"2021-05-22T03:54:11.415Z","comments":true,"path":"articles/2020/08/14/6ef8a13e.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/14/6ef8a13e.html","excerpt":"","text":"集训队论文 2018 - 1 浅谈生成函数在掷骰子问题上的应用长沙市长郡中学杨懋龙 阅读笔记概率生成函数对于随机非负离散变量$x$，它的概率生成函数是$F(z)=\\begin{aligned}\\sum_{i=0}^{\\infty}P(x=i)z^i\\end{aligned}$ 有性质 1.$F(1)=\\begin{aligned}\\sum_{i=0}^{\\infty}P(x=i)=1\\end{aligned}$ 2.$F'(1)=\\begin{aligned}\\sum_{i=0}^{\\infty}P(x=i)\\cdot i=E(x)\\end{aligned}$ 3.$E(x^{\\underline{k} })=F^{(k)}(1)$($x$的$k$阶下降幂) 4.$x$的方差$=\\begin{aligned}\\sum_{i=0}^{\\infty}P(x=i)\\cdot (i-E(x))^2\\end{aligned}=\\begin{aligned}\\sum_{i=0}^{\\infty}P(x=i)\\cdot i^2-2P(x=i)\\cdot i\\cdot E(x)+P(x=i)\\cdot E^2(x)\\end{aligned}$ $=E(x^2)-2E^2(x)+E^2(x)=E(x^2)-E^2(x)=E(x^{\\underline{2} })+E(x)-E^2(x)=F’’(1)+F’(1)-(F’(1))^2$ CTSC2006 歌唱王国 给定序列$A_{1.. n}$ 求从一个空序列每次放$[1,m]$随机，第一次出现$A$的期望长度 设当前对应$\\text{kmp}$位置为$i$，每次都可以转移一下 $F(n)=0$ $F(i)=\\frac{\\sum_{j=1}^m F(nxt_{i,j})} {m}+1$ $nxt$非拓扑关系，且无法枚举$1..m$ 考虑每次$\\text{kmp}$合法匹配指针最多位移一位，令$G(i)$为匹配变为$i+1$的期望次数 $G(i)=\\sum_{j=1}^{m}\\sum_{k=nxt_{i,j} }^{i} G(k)$ 设$sum_i=\\sum_1^{i}G(i)$，依次求出$[1,n-1]$所有的$G(i)$ 并不需要知道真的$nxt$数组，只需要知道$-sum_{nxt_{i,j}-1}$，每次从$fail_i$转移过来，改变一个位置的值，可以$O(1)$完成计算 即可做到$O(n)$","categories":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"学习笔记","slug":"notes","permalink":"http://chasingdeath.github.io/categories/notes/"}]},{"title":"伯努利数求解","slug":"伯努利数求解","date":"2020-08-14T13:37:57.000Z","updated":"2021-05-22T03:54:11.332Z","comments":true,"path":"articles/2020/08/14/548e8bfb.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/14/548e8bfb.html","excerpt":"","text":"伯努利数求解设伯努利数$B_i$对应的指数型生成函数$B(x)=\\sum \\frac{B_ix^i} {i!}$ $B(x)=\\frac{x} {e^x-1}$ 这个式子直接求是没有逆的。。。 换一下$\\begin{aligned} B(x)=\\frac{x} {\\begin{aligned}\\sum_{i=1}^{\\infty}\\frac{x^i} {i!}\\end{aligned} }=\\frac{1} {\\begin{aligned}\\sum_{i=1}^{\\infty}\\frac{x^{i-1} } {i!}\\end{aligned} }\\end{aligned} $ 带入前$n$项求逆即可","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"单位根反演","slug":"单位根反演","date":"2020-08-13T14:07:25.000Z","updated":"2021-05-22T03:54:11.341Z","comments":true,"path":"articles/2020/08/13/37ace200.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/13/37ace200.html","excerpt":"","text":"单位根反演最基础的用途是用于FFT中点值式转多项式 即对于$G(i)=F(\\omega_n^i)$，由$G(i)$反演得到$[x^i]F(i)$的过程，称之为单位根反演 式子非常简单 $\\sum_{j=0}^{n-1}\\omega_n^{ij}= \\left\\{\\begin{aligned} \\frac{\\omega_n^{in}-1} {\\omega_n^i-1}=0 && i\\ne 0\\\\ n && i=0\\end{aligned} \\right.$ 更简洁的式子为$\\begin{aligned}\\frac{\\sum_{j=0}^{n-1}\\omega_n^{ij} } {n}=[n|i]\\end{aligned}$ 在生成函数的化简与构造中，常用于解决$\\mod n=0$的限制 如$\\sum_{n|i}\\frac{x^i} {i!}$ 通过单位根反演转化为 $ \\begin{aligned}\\sum_{n|i}\\frac{x^i} {i!}=\\sum_{i=0}^{\\infty}\\frac{\\sum_{j=0}^{n-1}\\omega_n^{ij} } {n} \\cdot \\frac{x^i} {i!}=\\sum_{i=0}^{\\infty}\\sum_{j=0}^{n-1} \\frac{(x\\omega_n^j)^i} {i!}=\\sum_{j=0}^{n-1}e^{x\\omega_n^j}\\end{aligned}$ 作为无穷级数压缩的一种方法 但是单位根反演转化有一个非常明显的局限，就是在模意义下，$n$阶单位根很可能无法求解 现在笔者还不会求模意义下特定的$n$阶单位根。。。","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"任意模数NTT(MTT)","slug":"任意模数NTT(MTT)","date":"2020-08-13T13:11:46.000Z","updated":"2021-05-22T03:54:11.327Z","comments":true,"path":"articles/2020/08/13/32e9b745.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/13/32e9b745.html","excerpt":"","text":"任意模数NTT(MTT)模板题传送门 问题的简单描述为，求解两个值域为$\\leq 10^9$的多项式卷积对于$P\\leq 10^9$取模的结果 \\问题不能直接用NTT/FFT求解，因为均超过了值域范围(double值域承受不了) \\Solution1: 3模数NTT取几个互质的模数分别做一次，然后用中国剩余定理合并 由于值域大，通常需要多次NTT，且中国剩余定理合并常数也不小 实际代码实现也复杂，因此笔者认为不可取 \\Solution2: 拆系数FFT设$f(x)=\\sum a_ix^i$ 核心：将系数$a_i$分解成$a_i=A_i\\cdot S+C_i,b_i=B_i\\cdot S+D_i$ (其中$S\\ge \\sqrt{P}$是一个常数，$0 \\leq A_i,B_i,C_i,D_i&lt;S$) 目的是转化后使系数值域变小，double精度可以承受 则最后的答案转化为求解$A_iB_jS^2+(C_iB_j+A_iD_j)S+C_iD_j$ 即求解$A_iB_j,C_iB_j,A_iD_j,C_iD_j$，此时值域已经大大缩小 如果直接求解，可以看出要求解4次卷积，需要进行$12$次FFT，不可接受 利用复数的一些性质，有些东西我们可以一起算 构造 $f(x)=\\sum (A_i,C_i)x^i$ $g(x)=\\sum(B_i,D_i)x^i$ $f(x)g(x)=\\sum \\sum (A_iB_j-C_iD_j, A_iD_j+C_iB_j)x^{i+j}$ 此时已经得到大部分值了，再构造 $h(x)=\\sum B_ix^i$ $f(x)h(x)=\\sum \\sum (A_iB_j,C_iB_j)x^{i+j}$ 取一部分即可 最终一共有5次FFT Tips: 1.这里的负数取整一定要注意，因为C++默认是向0取整，而不是向下取整 2.实际运行表明，这样写用double 很难保证精度，应该要用long double 附: 4次FFT做MTT，但是具体证明比较反人类，而代码非常好看且好写，所以建议直接背板子 Tips: 只要使用了上面提到的最适合FFT的板子，就可以用double，甚至可以开O2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061namespace MTT&#123; const double PI=acos((double)-1); int rev[N]; struct Cp&#123; double x,y; Cp()&#123; ; &#125; Cp(double _x,double _y): x(_x),y(_y)&#123; &#125; inline Cp operator + (const Cp &amp;t) const &#123; return (Cp)&#123;x+t.x,y+t.y&#125;; &#125; inline Cp operator - (const Cp &amp;t) const &#123; return (Cp)&#123;x-t.x,y-t.y&#125;; &#125; inline Cp operator * (const Cp &amp;t) const &#123; return (Cp)&#123;x*t.x-y*t.y,x*t.y+y*t.x&#125;; &#125; &#125;A[N],B[N],C[N],w[N/2]; #define E(x) ll(x+0.5)%P void FFT(int n,Cp *a,int f)&#123; rep(i,0,n-1) if(rev[i]&lt;i) swap(a[i],a[rev[i]]); w[0]=Cp(1,0); for(reg int i=1;i&lt;n;i&lt;&lt;=1) &#123; Cp t=Cp(cos(PI/i),f*sin(PI/i)); for(reg int j=i-2;j&gt;=0;j-=2) w[j+1]=t*(w[j]=w[j&gt;&gt;1]); // 上面提到的最优板子 for(reg int l=0;l&lt;n;l+=2*i) &#123; for(reg int j=l;j&lt;l+i;j++) &#123; Cp t=a[j+i]*w[j-l]; a[j+i]=a[j]-t; a[j]=a[j]+t; &#125; &#125; &#125; if(f==-1) rep(i,0,n-1) a[i].x/=n,a[i].y/=n; &#125; void Multiply(int n,int m,int *a,int *b,int *res,int P)&#123; // [0,n-1]*[0,m-1]-&gt;[0,n+m-2] int S=(1&lt;&lt;15)-1; int R=1,cc=-1; while(R&lt;=n+m-1) R&lt;&lt;=1,cc++; rep(i,1,R) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;cc); rep(i,0,n-1) A[i]=Cp((a[i]&amp;S),(a[i]&gt;&gt;15)); rep(i,0,m-1) B[i]=Cp((b[i]&amp;S),(b[i]&gt;&gt;15)); rep(i,n,R-1) A[i]=Cp(0,0); rep(i,m,R-1) B[i]=Cp(0,0); FFT(R,A,1),FFT(R,B,1); rep(i,0,R-1) &#123; int j=(R-i)%R; C[i]=Cp((A[i].x+A[j].x)/2,(A[i].y-A[j].y)/2)*B[i]; B[i]=Cp((A[i].y+A[j].y)/2,(A[j].x-A[i].x)/2)*B[i]; &#125; FFT(R,C,-1),FFT(R,B,-1); rep(i,0,n+m-2) &#123; ll a=E(C[i].x),b=E(C[i].y),c=E(B[i].x),d=E(B[i].y); res[i]=(a+((b+c)&lt;&lt;15)+(d&lt;&lt;30))%P; &#125; &#125; #undef E&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"多项式指定大小的单位根点值式求解(含Bluestein’s Algorithm)","slug":"多项式指定大小的单位根点值式求解(含Bluestein’s Algorithm)","date":"2020-08-13T13:04:42.000Z","updated":"2021-05-22T03:54:11.357Z","comments":true,"path":"articles/2020/08/13/b5d9e614.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/13/b5d9e614.html","excerpt":"","text":"多项式指定大小的单位根点值式求解(含Bluestein’s Algorithm)下面的阐述建立于存在$n$阶单位根的前提下 (如果是NTT，必须满足$n|(P-1)$ ，否则单位根可能会变成一个复杂的多维向量) \\用卷积解决多项式与点值式的转化:Bluestein’s Algorithm设最终求得的点值式为$f(x^k)=\\sum a_i\\cdot \\omega_n^{i k}$ 其中指数为$ik$，有一种简单的转化$i\\cdot k=\\cfrac{i^2+k^2-(i-k)^2} {2}$ 由于在模意义下，$x^{\\frac{i} {2} }$次(二次剩余)是一个非常麻烦的东西，所以考虑一个更优的转化 $i\\cdot k=C(i+k,2)-C(i,2)-C(k,2)$ 这条式子的组合意义是：从集合$i,k$分别选一个，等价于从$i+k$选两个减去在$i,k$内部选两个 通过这样的转化，我们可以对于每一个$a_i$计算其对于每个$f(x^k)$的贡献 具体过程是简单的构造卷积，这里省略 \\适用于特殊情况的转化方法需要了解的是，多项式卷积的FFT/NTT不止适用与于二元分治 对于多项式$F(x)$的$d$元分治，设分治子问题的答案为$G_j(x’_i),j\\in[0,d-1]$，可以得到合并式子 $\\begin{aligned} F(x_i)=\\sum_{j=0}^{d-1}x_i^jG_j(x_i^d)=\\sum_{i=0}^{d-1}x_i^jG_j(x'_{i\\mod \\frac{n} {d} })\\end{aligned}$ 对于$n$进行质因数分解，得到$n=\\prod p_i$，带入上面的式子，带入$p_i$元分治强行求解，可以认为最终复杂度为 $O(n\\sum p_i)=O(n\\cdot \\max\\{p_i\\} \\log n)$ 因此，这种方法使用于$p_i$较小的情况 \\n元点值式的用途DFT的卷积是溢出的，$x^i$会溢出到$x^{i\\mod n}$，系数之间存在着循环关系 我们可以利用$n$元卷积做到指定大小的循环卷积，可以处理一些特定问题 例题: [CTSC2010]性能优化(使用$O(n\\log n\\log C)$的快速幂无法通过，尚未尝试Bluestein’s Algorithm)","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"伪WC2020游记","slug":"伪WC2020游记","date":"2020-08-12T04:44:03.000Z","updated":"2021-05-22T03:54:11.328Z","comments":true,"path":"articles/2020/08/12/34803047.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/12/34803047.html","excerpt":"","text":"伪WC2020游记补 是的，这是一场在8月举行的盛大的冬令营！ 而且变成了自由报名！ ~奇妙的网课体验祭~ Day1:哇路由器，哇bitmap 哇Minhash，哇随机投影，哇并行计算 工程学习祭。。。。 晚上:？？？果然是集训队选手讲题？？？ Day2嗯，是神仙讲题! 嗯，还是神仙讲题!诶怎么锅了，诶怎么又锅了?诶怎么拖了15分钟还没讲完? 晚上:？？？果然又是集训队选手讲题？？？ Day3哇怎么都变成讲神仙题目了? Day4台风困在寝室祭。。。 在寝室度过了完美的补觉日，直接错过所有讲课。。。 Day5赶回家考试祭。。。 T1 看起来十分可写，于是乎又搞了一年没搞出来 是不是大家都A了，我是不是又完蛋了，只写了暴力 T2 推出了阶的表示性质，然后误以为要$dp$，直接跳过现场 T3 看起来十分可写，令人想到某道皮配题 shi一般的代码写了一年，终于在最后一分钟交上去了哈哈哈哈 果然十分可写，爆搜+dp感觉要自己要升天 出来 哇果然升天了!!题目锅了哈哈哈哈哈哈!!只有50哈哈哈哈哈哈!!(WCWCWC) T1果然大家都没A哈哈哈哈(读入错了挂掉10分祭) T2果然大家都A了哈哈哈哈 T3这个非集选手平均分哈哈哈哈 完事儿只有100分，划水本质又暴露了。。。 Day6没错闭幕式在hdu多校期间，于是乎.~.~.~.","categories":[{"name":"游记","slug":"travel","permalink":"http://chasingdeath.github.io/categories/travel/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"游记","slug":"travel","permalink":"http://chasingdeath.github.io/categories/travel/"}]},{"title":"[HDU-6848] Expectation (2020多校7T5) (Dp)","slug":"[HDU-6848] Expectation (2020多校7T5) (dp)","date":"2020-08-11T14:22:39.000Z","updated":"2021-05-22T03:54:11.062Z","comments":true,"path":"articles/2020/08/11/9a2d4f71.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/11/9a2d4f71.html","excerpt":"","text":"[HDU-6848] Expectation (2020多校7T5) (dp)比赛时疯狂脑抽写了3个小时祭 考虑计算每条$x_i\\rightarrow x_{i+1}$的边被在所有情况下被经过的次数总和 令$dp[i][j]$为有$i$个球时，$x_j\\rightarrow x_{j+1}$这段被经过的次数总和($j\\leq 2i$) 考虑转移，对于$dp[i]$，枚举每个球向左或者右走，发现把两边的部分拉拢过来后，合并形成一条包含了原先$3$条边的新边，变成了$i-1$阶的子问题 画图理解，发现$j$这条边，在$i-1$阶的子问题上对应的编号只可能是$j,j-1,j-2$ 视选择了$j$这条边为将边一端的球滚进另一端的洞里 那么对于任意一条编号为$j$的边 $j$变为编号为$j-2$的情况为选择了编号$[1,j-1]$范围内的边 $j$变为编号为$j-1$的情况为选择了编号为$j$的边 $j$变为编号为$j$的情况为选择了编号为$[j+1,2i]$的边 对于$j$在子问题中被访问的次数可以直接$O(1)$继承过来 同时，考虑当第一次就选了$j$时，后面的操作随意，即加上$(i-1)!\\cdot 2^{i-1}$ 于是得到一个$O(n^2)$的$dp$预处理 而对于每个询问，求解$n$阶的答案复杂度为$O(n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=3010,P=998244353;int n;int dp[N][N*2],Fac[N];ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int main()&#123; rep(i,Fac[0]=1,N-1) Fac[i]=1ll*i*Fac[i-1]%P; dp[1][1]=dp[1][2]=1; int t=1; rep(i,2,N-1) &#123; t=1ll*t*(i-1)*2%P; rep(j,1,i*2) &#123; dp[i][j]=(1ll*(i*2-j)*dp[i-1][j]+1ll*dp[i-1][j-1]+1ll*(j-1)*(j&gt;=2?dp[i-1][j-2]:0)+t)%P; &#125; &#125; rep(kase,1,rd()) &#123; n=rd(); int ans=0,x=rd(); rep(i,1,n*2) &#123; int y=rd(); ans=(ans+1ll*(y-x)*dp[n][i])%P; x=y; &#125; ans=ans*qpow((P+1)/2,n)%P*qpow(Fac[n])%P; printf(&quot;%d\\n&quot;,ans); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[HDU-6847] Decision (2020多校7T4) (类欧几里得问题)","slug":"[HDU-6847] Decision (2020多校7T4) (类欧几里得问题)","date":"2020-08-11T14:07:46.000Z","updated":"2021-05-22T03:54:11.055Z","comments":true,"path":"articles/2020/08/11/2e8a8d93.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/11/2e8a8d93.html","excerpt":"","text":"[HDU-6847] Decision (2020多校7T4) (类欧几里得问题)枚举$|v_1-v_2|$后，可以递推，用含首项($v_1+v_2$)的一次函数表示函数值为$a(v_1+v_2)+b$，则问题等价于求 $\\begin{aligned} \\sum_{i=0}^n [2|(ai+b)\\mod m] \\end{aligned}$ ，其中 $n$ 对于每个 $v_1-v_2$ 是不同的 这个问题，可以转化为一个简单的类欧几里得问题 $(ai+b)\\mod m \\mod 2= ((ai+b)-(m\\mod 2)\\cdot \\lfloor \\frac{ai+b} {m}\\rfloor )\\mod 2$ 这个式子即把每次被$m$取模减少的$m$算进贡献 可以看到操作非常简单，可以直接套上万能欧几里得的板子 当然，也可以对于$m$的各种情况讨论，转化为求$\\lfloor \\frac{ai+b} {m}\\rfloor$，其主要思想还有应用 $x\\mod 2=x-2\\cdot \\lfloor \\frac{x} {2}\\rfloor$ 的转化 我比赛时去抄了自己的类欧几里得模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1e6+10;int t,a,c,m;int fx[N],fy[N];ll gcd(ll a,ll b)&#123; return b==0?a:gcd(b,a%b); &#125;ll D2(ll n)&#123; return n*(n+1)/2;&#125;ll F(ll a,ll b,ll c,ll n)&#123; if(n&lt;0) return 0; if(a==0) return (b/c)*(n+1); if(a&gt;=c || b&gt;=c) &#123; ll ans=F(a%c,b%c,c,n)+D2(n)*(a/c)+(n+1)*(b/c); return ans; &#125; ll t=(a*n+b)/c; ll ans=t*n-F(c,-b+c-1,a,t-1); return ans;&#125;ll CalcMod(int a,int b,int m,int n)&#123; return F(a,b,m,n)-F(a,b,m*2,n)*2;&#125;ll Calc(int a,int b,int n)&#123; // for i= [l,r] (ax+b) %m %2 if(~m&amp;1)&#123; // (ax+b)%2; a%=2,b%=2; if(a==0) return b*(n+1); return (n+1+b)/2; &#125; else &#123; // (ax+b) %m %2 = ((ax+b)/m + ax+b)%2 int c=a%2,d=b%2; if(c==0) &#123; // =((ax+b)/m+b)%2; if(d==0) return CalcMod(a,b,m,n); else return (n+1)-CalcMod(a,b,m,n); &#125; else &#123; // (ax+b) %m %2 = ((ax+b)/m + (x&amp;1)+d)%2 ll ans=0; // i%2 == 0 ll t=CalcMod(a*2,b,m,n/2); if(d) t=n/2+1-t; ans+=t; b+=a; // i%2 == 1 n--; if(n&lt;0) return ans; t=CalcMod(a*2,b,m,n/2); if(!d) t=n/2+1-t; ans+=t; return ans; &#125; &#125;&#125;int main()&#123; rep(kase,1,rd()) &#123; t=rd(),a=rd(),c=rd(),m=rd(); fx[0]=1,fy[0]=0; rep(i,1,t) fx[i]=1ll*fx[i-1]*a%m,fy[i]=(1ll*fy[i-1]*a+c)%m; ll ans=0; rep(i,0,t) &#123; if(i==0) &#123; ans+=Calc(fx[i]*2%m,fy[i],t); &#125; else &#123; // a&lt;b, b - a = i // a=[0,m-i] // b=[i,m] ll tmp=(1ll*i*fx[i]+fy[i])%m; ans+=Calc(fx[i]*2%m,tmp,t-i)*2; &#125; &#125; ll tmp=1ll*(t+1)*(t+1); ans=tmp-ans; ll g=gcd(tmp,ans); printf(&quot;%lld/%lld\\n&quot;,ans/g,tmp/g); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[HDU-6854] Kcats (2020多校7 T11) (笛卡尔树+区间Dp)","slug":"[HDU-6854] Kcats (2020多校7 T11) (笛卡尔树+区间dp)","date":"2020-08-11T14:06:58.000Z","updated":"2021-05-22T03:54:11.064Z","comments":true,"path":"articles/2020/08/11/91bb54d9.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/11/91bb54d9.html","excerpt":"","text":"[HDU-6854] Kcats (2020多校7 T11) (笛卡尔树+区间dp)前缀$p_1,p_2,\\cdots,p_i$的单调栈大小，即$i$号节点在全局的笛卡尔树上对应的位置的所有在左边的祖先个数 因此，区间$dp$笛卡尔树的树形，合并时，为了满足题目的限制，只需要记录左边的祖先个数$d$ 即定义$dp[l][r][d]$为区间$l,r$对应笛卡尔树子树，且根节点左祖先个数为$d$的方案数 合并两个子树时注意补上组合数，且自己这个点对于左儿子深度没有贡献 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1e2+10,P=1e9+7;int n,a[N],C[N][N],dp[N][N][N];int main()&#123; rep(i,0,N-1) rep(j,C[i][0]=1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P; rep(kase,1,rd()) &#123; rep(i,1,n=rd()) a[i]=rd(); memset(dp,0,sizeof dp); drep(i,n,1) rep(j,i,n) rep(k,i,j) rep(d,~a[k]?a[k]:1,~a[k]?a[k]:n) dp[i][j][d]=(dp[i][j][d]+1ll*(i&lt;k?dp[i][k-1][d]:1)*(k&lt;j?dp[k+1][j][d+1]:1)%P*C[j-i][k-i])%P; printf(&quot;%d\\n&quot;,dp[1][n][1]); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「联合省选 2020 A」组合数问题","slug":"「联合省选 2020 A」组合数问题","date":"2020-08-09T06:42:35.000Z","updated":"2021-05-22T03:54:11.303Z","comments":true,"path":"articles/2020/08/09/c163cc6e.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/09/c163cc6e.html","excerpt":"","text":"「联合省选 2020 A」组合数问题题意： 求$\\begin{aligned}\\sum _{k=0}^nf(k)\\cdot x^k\\cdot C(n,k)\\end{aligned}$ 显然要对于$f(k)$的每一项考虑，第$i$项的贡献 $a_i\\begin{aligned}\\sum _{k=0}^nk^i\\cdot x^k\\cdot C(n,k)\\end{aligned}$ 通用的$O(m^2)$后面的这个式子，考虑它的组合意义，假设当前有$n$个格子，每个格子被染了$[0,x]$的颜色 $x^k\\cdot C(n,k)$即枚举有$k$个格子涂了$[1,x]$的颜色，剩下涂了$0$的颜色 $k^i$的组合意义即可重复地选了$i$次，每次选出的都是在$[1,x]$颜色的格子的方案数 那么问题可以转化为强制每一次被访问的格子都是$[1,x]$，其他的格子随便涂$[0,x]$ 问题在于每次被访问的格子会重复，于是可以想到一个简单的转化，求出$i$次访问了$j$不同位置的方案数 即斯特林数$S(i,j)$，可以得到的是 $\\begin{aligned}\\sum _{k=0}^nk^i\\cdot x^k\\cdot C(n,k)=\\sum_{j=0}^iS(i,j)\\cdot \\frac{n!} {(n-j)!}\\cdot x^j(x+1)^{n-j}\\end{aligned}$ 实际上可以在$O(m^2)$递推斯特林数时就把$\\frac{n!} {(n-j)!}$加入权值，$x^j(x+1)^{n-j}$可以预处理出来 因此总复杂度就是$O(m^2)$ 1234567891011121314151617181920#include&lt;cstdio&gt;long long i,j,n,m,P,x,y,F[1010],Pow[1010],r,ans;int qpow(int x,int k) &#123; for(r=1;k;k&gt;&gt;=1,x=1ll*x*x%P) if(k&amp;1) r=r*x%P; return r; &#125;int main()&#123; freopen(&quot;problem.in&quot;,&quot;r&quot;,stdin),freopen(&quot;problem.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;n,&amp;x,&amp;P,&amp;m,&amp;y),F[0]=1,ans=qpow(x+1,n)*y%P; for(int i=0;i&lt;=m;++i) Pow[i]=1ll*qpow(x,i)*qpow(x+1,n-i)%P; for(i=1;i&lt;=m;++i) &#123; long long res=0; for(j=i,scanf(&quot;%lld&quot;,&amp;y);~j;--j) &#123; F[j]=(F[j]*j+(j?F[j-1]*(n-j+1):0))%P; // 类似斯特林数的递推 res=(res+F[j]*Pow[j])%P; &#125; ans=(ans+res*y)%P; &#125; printf(&quot;%lld&quot;,ans);&#125; 特殊的$O(m\\log^2 m)$(注意以下仅限于口胡!) 假设可以把$f(k)$转化为下降幂多项式，依然枚举每一项考虑，那么每次要求的就是 $\\begin{aligned}\\sum _{k=0}^nk^{\\underline i}\\cdot x^k\\cdot C(n,k)=i!\\sum _{k=0}^nC(k,i)\\cdot x^k\\cdot C(n,k)\\end{aligned}$ 依然考虑组合意义 $x^k\\cdot C(n,k)$即枚举有$k$个格子涂了$[1,x]$的颜色，剩下涂了$0$的颜色 $C(k,i)$的组合意义不可重复地选了$i$次，每次选出的都是在$[1,x]$颜色的格子的方案数 那么问题可以转化为强制每一次被访问的格子都是$[1,x]$，其他的格子随便涂$[0,x]$ $\\begin{aligned}\\sum _{k=0}^nk^{\\underline i}\\cdot x^k\\cdot C(n,k)=i!\\cdot C(n,i)\\cdot x^i\\cdot (x+1)^{n-i}\\end{aligned}$ (式子应该没有问题，但是下面都是口胡) 求解下降幂多项式需要多点求值，还要求很多逆元 然而对于非质数的$P$，我们求不出$i!$的逆元 (比较智障的搞法就是每次乘法都存下$P$的每个质因数个数，这样，做乘法的复杂度是$\\log P$，但是不知道最后做出的答案是不是能保证因数个数$\\ge 0$) 对于$P$为质数的情况，用$\\text{MTT}$做多项式转下降幂多项式的复杂度是$O(m\\log^2 m)$ (听说用转置原理优化的多点求值已经可以跑$10^6$啦?)","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"[HDU-6834] Yukikaze and Smooth Numbers","slug":"[HDU-6834] Yukikaze and Smooth numbers","date":"2020-08-08T13:22:49.000Z","updated":"2021-05-22T03:54:11.049Z","comments":true,"path":"articles/2020/08/08/1928e765.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/08/1928e765.html","excerpt":"","text":"[HDU-6834] Yukikaze and Smooth numbers题意：计算$[1,n]$中只包含$[1,k]$的质因数的数个数 让人联想到Min25筛的$dp$模型 设$m=\\sqrt n$，可以对于$k &gt; m$和$k\\leq m$讨论 Case1:$k\\leq m$此时可以直接套用类似Min25筛的$dp$模型求解 令$dp_{i,j}$为$[1,j]$只包含$[1,i]$的质因数的数个数 则$dp_{i,j}=\\sum_k dp_{i-1,\\lfloor \\frac{j} {prime_i^k}\\rfloor }$ 要求的是$dp_{k,n}$，第二维状态是$O(m)$级别的 直接写当然是近似于$O(m\\cdot \\pi(n))=O(\\frac{n} {\\log n})$级别的 加上Min25筛的优化，令$dp_i,j$不包含单质数和1的情况，以减少转移情况 如果从大到小考虑每个质数，那么只需要考虑$j\\ge prime_i^2$的第二维状态，以减少很多的$dp$时间 沿用Min25筛复杂度证明，是$O(\\frac{n^{\\frac{3} {4} }} {\\log n})$的 12345678910111213141516171819202122232425#define id(x) (x&lt;=m?x:cnt-n/x+1)int dp[N],g[N],st[N],cnt;if(k==1)&#123; puts(&quot;1&quot;); continue; &#125;m=sqrt(n),cnt=0;rep(i,1,n) st[++cnt]=i=n/(n/i),dp[cnt]=0; // 不包括质数本身和1int sz=1;while(pri[sz+1]&lt;=k) sz++;int p=0;rep(i,1,cnt)&#123; while(p&lt;sz &amp;&amp; pri[p+1]&lt;=st[i]) p++; g[i]=p;&#125; rep(i,1,cnt) for(ll x=pri[sz]*pri[sz];x&lt;=st[i];x*=pri[sz]) dp[i]++;for(reg int i=sz-1;i;--i) &#123; for(reg int j=cnt,tmp=pri[i]*pri[i];st[j]&gt;=tmp;--j) &#123; reg int x=st[j]; while(x&gt;=tmp) &#123; x/=pri[i]; dp[j]+=dp[id(x)]+g[id(x)]-i+1; &#125; &#125;&#125;printf(&quot;%d\\n&quot;,dp[cnt]+sz+1); \\Case2 : $k&gt; m$可以把问题转化为求不合法部分，即$\\sum_{prime_i&gt;k}\\lfloor \\frac{n} {prime_i}\\rfloor $ 采用数论分段计算$\\lfloor \\frac{n} {i}\\rfloor $，那么剩下的问题就是要求一段区间内的质数个数 同样采用类似上面的模型， 令$dp_{i,j}$为$[1,j]$内与前$[1,i]$内质数互质的个数以及这些质数本身，不包括1 12345678910111213141516int n,m;int dp[N],g[N],st[N],cnt;#define id(x) (x&lt;=m?x:cnt-n/x+1)int Count(int n) &#123; if(n&lt;N) return pcount[n]; ::n=n,m=sqrt(n),cnt=0; rep(i,1,n) st[++cnt]=i=n/(n/i),dp[cnt]=i-1; for(reg int i=1;pri[i]&lt;=m;++i) &#123; for(reg int j=cnt,tmp=pri[i]*pri[i];st[j]&gt;=tmp;--j) &#123; reg int k=st[j]/pri[i]; dp[j]-=dp[id(k)]-(i-1); &#125; &#125; return dp[cnt];&#125; 具体复杂度没有算过，应该不会太高","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[HDU - 6833] a Very Easy Math Problem (莫比乌斯反演)","slug":"[HDU - 6833] A Very Easy Math Problem (莫比乌斯反演)","date":"2020-08-08T10:22:40.000Z","updated":"2021-05-22T03:54:11.047Z","comments":true,"path":"articles/2020/08/08/30fb7c1c.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/08/08/30fb7c1c.html","excerpt":"","text":"[HDU - 6833] A Very Easy Math Problem (莫比乌斯反演)与$\\gcd$有关的问题，很容易想到莫比乌斯反演 设$G(a,n)=(\\sum_{i=1}^{\\lfloor \\frac{n} {a} \\rfloor } (ai)^k)^x$ $Ans=\\sum_{g=1}^{n} g\\cdot f(g)\\cdot \\sum _{d=1}^{\\lfloor\\frac{n} {g}\\rfloor} \\mu(d) G(gd,n)$ 对于单组询问，显然可以$O(n\\ln n)$求解 考虑优化 可以在$O(n\\ln n)$的时间内，对于每个$i$，求出$F(i)=\\sum_{d|i}\\mu(d)\\cdot \\frac{i} {d} f(\\frac{i} {d})$ 对于$G(a,n)$的求解，参数分离后发现 $G(a,n)=a^{kx}(\\sum_{i=1}^{\\lfloor \\frac{n} {a} \\rfloor } i^k)^x$ 可以预处理出$S(n)=\\sum_{i=1}^n i^{kx}\\cdot F(i)$前缀和以及$A(n)=(\\sum_{i=1}^{n}i^k)^x$，对于每个$\\lfloor \\frac{n} {a}\\rfloor $考虑即可 数论分段的复杂度为单组查询$O(\\sqrt n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=2e5+10,P=1e9+7;int T,n,k,x;int mk[N],notpri[N],pri[N],pc,w[N];ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int s[N],F[N],S[N],A[N];int main()&#123; w[1]=1; rep(i,2,N-1) &#123; if(!notpri[i]) pri[++pc]=i,w[i]=-1; for(int j=1;j&lt;=pc &amp;&amp; 1ll*i*pri[j]&lt;N;++j) &#123; notpri[i*pri[j]]=1; if(i%pri[j]==0) &#123; w[i*pri[j]]=0; break; &#125; w[i*pri[j]]=-w[i]; &#125; &#125; for(int i=2;i*i&lt;N;++i) for(int j=i*i;j&lt;N;j+=i*i) mk[j]=1; rep(i,1,N-1) if(!mk[i]) rep(j,1,(N-1)/i) F[i*j]=(F[i*j]+i*w[j]+P)%P; T=rd(),k=rd(),x=rd(); rep(i,1,N-1) S[i]=(S[i-1]+F[i]*qpow(i,1ll*k*x))%P; rep(i,1,N-1) A[i]=(A[i-1]+qpow(i,k))%P; rep(i,1,N-1) A[i]=qpow(A[i],x); rep(kase,1,T) &#123; n=rd(); ll ans=0; for(int i=1,j;i&lt;=n;i=j+1) &#123; j=n/(n/i); ans=(ans+1ll*(S[j]-S[i-1])*A[n/i])%P; &#125; ans=(ans%P+P)%P; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"},{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「十二省联考 2019」骗分过样例 ","slug":"「十二省联考 2019」骗分过样例 ","date":"2020-07-31T01:49:22.000Z","updated":"2021-05-22T03:54:11.296Z","comments":true,"path":"articles/2020/07/31/4a8da56e.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/07/31/4a8da56e.html","excerpt":"","text":"「十二省联考 2019」骗分过样例很显然，这是一道有时限的提答题!!!! 但是知识点很丰富，值得一写 Case 1-3: 1_998244353直接快速幂$19^x$，如果读入太大，指数可以$\\mod \\varphi(998244353)$ ,不谈… Case 4: 1?不知道模数，但是可以看出模数很小，随便选一个答案试出模数即可(145141?) Case5: 1?+值域非常大，就算是快速幂也显然要通过快速乘来实现，设模数为$P$ 把所有读入的数拿出来看，发现最相近的两个相差只有$2$ 意味着我们知道 $19^x \\equiv a\\pmod P,19^{x+2} \\equiv b \\pmod P$ 很显然$a\\cdot 19^2 \\mod P=b$，求出$a\\cdot 19^2-b$，分解质因数即可 实际实现可以用手写高精/Python Case6: 1_wa998244353答案的生成是，求幂次的时候乘法不开long long ，即 12int n,s=1; scanf(&quot;%d&quot;,&amp;n);for(int i=1;i&lt;=n;++i) s=s*19%998244353; 出题人的tips给了，自然溢出是非定义行为，甚至有可能导致RE 所以模拟的话，实际应该这样写 1s=int(((unsigned)s*19))%P; 可以发现，这个答案的序列近似于一个伪随机数列，学过$\\text{Pollard’s Rho}$算法就知道， 根据生日问题/生日悖论，伪随机数列期望在$O(\\sqrt n)$的时间内产生一个伪循环，因此可以快速求解 12345678910111213141516int s[300000];int T=-1,fir=-1;map &lt;int,int&gt; M;s[0]=1,M[1]=0;rep(i,1,300000)&#123; s[i]=int(((unsigned)s[i-1]*19))%P; if(M.count(s[i])) &#123; T=i-M[s[i]],fir=M[s[i]]; break; &#125; M[s[i]]=i;&#125;rep(kase,1,rd())&#123; ll x=rd&lt;ll&gt;(); printf(&quot;%d\\n&quot;,s[x&lt;=fir?x:(x-fir)%T+fir]);&#125; Case8-10: 2p判断$[l,r]$内的数是否是质数，$\\text{Miller_Rabin}$模板 Case9-10: 2u求$[L,R]$内的莫比乌斯系数$w(n)$，设$n=\\prod_1^m p_i^{c_i},c_i&gt;0$ $w(n)=\\left\\{\\begin{aligned} (-1)^m &&\\nexists c_i>1,\\\\ 0 && \\exists c_i>1\\end{aligned}\\right.$ 对于$L,R$达到$10^{18}$次时，考虑先用$[1,R^{\\frac{1} {3} }]$内的质数筛掉，那么剩下的数最多包含两个$(R^{\\frac{1} {3} },R]$内的质因数 可以开根号判断是否是平方数，用$\\text{Miller_Rabin}$判断是否是质数 由于$R-L$与$R^{\\frac{1} {3} }$同阶复杂度为$O(R^{\\frac{1} {3} }\\log R^{\\frac{1} {3} })$，常数较大 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair &lt;int,int&gt; Pii;#define pb push_back#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)char IO;template &lt;class T=int&gt; T rd()&#123; T s=0;int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1e6+10,P=998244353;ll qmul(ll x,ll y,ll P)&#123; ll z=(long double)x/P*y; ll t=(ull)x*y-(ull)z*P; t=t%P; Mod2(t); return t;&#125;ll qpow2(ll x,ll k,ll P) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=qmul(x,x,P)) if(k&amp;1) res=qmul(res,x,P); return res;&#125;ll qpow(ll x,ll k,ll P) &#123; if(P&gt;2e9) return qpow2(x,k,P); ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;char s[20000];void Solve19(ll P)&#123; scanf(&quot;%s&quot;,s+1); ll k=0; for(int i=1;s[i];++i) k=(qmul(k,10,P-1)+s[i]-&#x27;0&#x27;)%(P-1); printf(&quot;%lld\\n&quot;,qpow(19,k,P));&#125;int notpri[N],pri[N],pc,w[N];void Init()&#123; notpri[1]=w[1]=1; rep(i,2,N-1) &#123; if(!notpri[i]) pri[++pc]=i,w[i]=-1; for(int j=1;j&lt;=pc &amp;&amp; 1ll*i*pri[j]&lt;N;++j)&#123; notpri[i*pri[j]]=1; if(i%pri[j]==0) &#123; w[i*pri[j]]=0; break; &#125; w[i*pri[j]]=-w[i]; &#125; &#125;&#125;int MR(ll x)&#123; if(x==2) return 1; if(x&lt;=1 || ~x&amp;1) return 0; if(x&lt;N) return !notpri[x]; ll s=0,t=x-1; while(~t&amp;1) s++,t&gt;&gt;=1; rep(i,1,3) &#123; ll b=pri[rand()%pc+1],k; b=qpow(b,t,x); rep(j,1,s) &#123; k=qmul(b,b,x); if(k==1 &amp;&amp; b!=1 &amp;&amp; b!=x-1) return 0; b=k; &#125; if(b!=1) return 0; &#125; return 1;&#125;int chk(ll x)&#123; return x&lt;N?!notpri[x]:MR(x); &#125;char Mo(int x)&#123; return &quot;-0+&quot;[x+1]; &#125;int ans[N]; ll a[N];void QueMobius(ll l,ll r)&#123; while(l&lt;N &amp;&amp; l&lt;=r) putchar(Mo(w[l++])); if(l&gt;r) return (void)puts(&quot;&quot;); rep(i,0,r-l) ans[i]=1,a[i]=i+l; rep(i,2,N-1) if(!notpri[i]) &#123; for(ll j=(l+i-1)/i*i;j&lt;=r;j+=i) &#123; ll id=j-l; if(!ans[id]) continue; ll c=0; while(a[id]%i==0) a[id]/=i,c++; if(c&gt;1) ans[id]=0; else ans[id]*=-1; &#125; &#125; rep(i,0,r-l) if(ans[i] &amp;&amp; a[i]&gt;1) &#123; ll t=round(sqrt(a[i])); if(t*t==a[i]) ans[i]=0; else if(chk(a[i])) ans[i]=-ans[i]; &#125; rep(i,0,r-l) putchar(Mo(ans[i])); puts(&quot;&quot;);&#125;void Queg(int l,int r,int P)&#123; int t=P-1; vector &lt;int&gt; Fac; for(int i=2;i*i&lt;=t;++i) if(t%i==0)&#123; while(t%i==0) t/=i; Fac.pb(i); &#125; if(t&gt;1) Fac.pb(t); if(r!=13123110) &#123; rep(i,l,r)&#123; int f=1; for(int j:Fac) if(qpow(i,(P-1)/j,P)==1) &#123; f=0; break; &#125; putchar(&quot;.g&quot;[f]); &#125; &#125; else &#123; static int mk[13123120]; static bool copri[13123120]; int g=1; rep(i,l,r)&#123; int f=1; for(int j:Fac) if(qpow(i,(P-1)/j,P)==1) &#123; f=0; break; &#125; if(f) &#123; g=i; break; &#125; &#125; int s=1; mk[1]=0; rep(i,1,P-2) s=s*g%P,mk[s]=i; copri[0]=1; for(int i:Fac) for(int j=i;j&lt;P;j+=i) copri[j]=1; rep(i,1,P-1) putchar(&quot;g.&quot;[copri[mk[i]]]); &#125; puts(&quot;&quot;);&#125;int main()&#123; Init(); freopen(&quot;software.in&quot;,&quot;r&quot;,stdin); freopen(&quot;software.out&quot;,&quot;w&quot;,stdout); string typ; cin&gt;&gt;typ; if(typ==&quot;1_998244353&quot;) rep(kase,1,rd()) Solve19(998244353); else if(typ==&quot;1?&quot;) rep(kase,1,rd()) Solve19(1145141); else if(typ==&quot;1?+&quot;) rep(kase,1,rd()) Solve19(5211600617818708273); else if(typ==&quot;1wa_998244353&quot;) &#123; static int s[300000]; int T=-1,fir=-1; map &lt;int,int&gt; M; s[0]=1,M[1]=0; rep(i,1,300000)&#123; s[i]=int(((unsigned)s[i-1]*19))%P; if(M.count(s[i])) &#123; T=i-M[s[i]],fir=M[s[i]]; break; &#125; M[s[i]]=i; &#125; rep(kase,1,rd())&#123; ll x=rd&lt;ll&gt;(); printf(&quot;%d\\n&quot;,s[x&lt;=fir?x:(x-fir)%T+fir]); &#125; &#125; else if(typ==&quot;2p&quot;) &#123; rep(kase,1,rd()) &#123; ll l=rd&lt;ll&gt;(),r=rd&lt;ll&gt;(); for(ll i=l;i&lt;=r;++i) putchar(chk(i)?&#x27;p&#x27;:&#x27;.&#x27;); puts(&quot;&quot;); &#125; &#125; else if(typ==&quot;2u&quot;) &#123; rep(kase,1,rd()) &#123; ll l=rd&lt;ll&gt;(),r=rd&lt;ll&gt;(); QueMobius(l,r); &#125; &#125; else if(typ==&quot;2g&quot; || typ==&quot;2g?&quot;) &#123; rep(kase,1,rd())&#123; int l=rd(),r=rd(); int p=1515343657; if(l!=233333333) p=rd(); Queg(l,r,p); &#125; &#125;&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"HDU-6801 2020HDU多校第三场T11 (生成函数)","slug":"HDU-6801 2020HDU多校第三场T11 (生成函数)","date":"2020-07-31T01:21:29.000Z","updated":"2021-05-22T03:54:10.952Z","comments":true,"path":"articles/2020/07/31/8a230e4c.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/07/31/8a230e4c.html","excerpt":"","text":"HDU-6801 2020HDU多校第三场T11 (生成函数)题解又给式子不解释了。。 设未被选中的概率$q=1-p$ 设$a_i$为$c$号点被选中前有$i$个点被选中的概率，它的普通生成函数为$A(x)$ 考虑枚举$c$在第$i$次被访问到时被选中 则$c$前面的$c-1$个点在转的过程中被访问了$i$次，后面的$n-c$个点被访问了$i-1$次(可能在没有经过这么多次时就已经被删掉了，但是不影响概率的计算)，因此可以简单考虑这两种点在$c$之前被选中的概率 得到一个$A(x)$的表示 $\\begin{aligned} A(x)=\\sum_{i=1}^{\\infty}p\\cdot q^{i-1}\\cdot (q^i+(1-q^i)x)^{c-1}\\cdot (q^{i-1}+(1-q^{i-1}x))^{n-c}\\end{aligned}$ 也即题解中的式子 $\\begin{aligned} A(x)=\\sum_{i=0}^{\\infty}p\\cdot q^i\\cdot (q^{i+1}+(1-q^{i+1})x)^{c-1}\\cdot (q^i+(1-q^ix))^{n-c}\\end{aligned}$ 然后是暴力展开 $\\begin{aligned} A(x)=\\sum_{i=0}^{\\infty}p\\cdot q^i\\cdot (q^{i+1}(1-x)+x)^{c-1}\\cdot (q^i(1-x)+x)^{n-c}\\end{aligned}$ $\\begin{aligned} A(x)=\\sum_{i=0}^{\\infty}p\\cdot q^i\\cdot (\\sum_{j=0}^{c-1}C(c-1,j)\\cdot q^{(i+1)j}(1-x)^jx^{c-1-j})\\cdot (\\sum_{k=0}^{n-c}C(n-c,k)\\cdot q^{ik}(1-x)^kx^{n-c-k})\\end{aligned}$ $\\begin{aligned} A(x)=\\sum_{i=0}^{\\infty}p\\cdot q^i\\cdot \\sum_{j=0}^{c-1}\\sum_{k=0}^{n-c} C(c-1,j)\\cdot C(n-c,k)\\cdot q^{(i+1)j+ik}(1-x)^{j+k}x^{n-j-k-1}\\end{aligned}$ 这个式子极其反人类，把$i$换到右边化掉 $\\begin{aligned} A(x)=\\sum_{j=0}^{c-1}\\sum_{k=0}^{n-c} C(c-1,j)\\cdot C(n-c,k)\\cdot (1-x)^{j+k}x^{n-j-k-1}\\cdot \\sum_{i=0}^{\\infty}p\\cdot q^i q^{(i+1)j+ik}\\end{aligned}$ 右边是一个收敛的无穷等比数列 $\\begin{aligned} A(x)=\\sum_{j=0}^{c-1}\\sum_{k=0}^{n-c} C(c-1,j)\\cdot C(n-c,k)\\cdot (1-x)^{j+k}x^{n-j-k-1}\\cdot \\frac{pq^j} {1-q^{j+k+1} }\\end{aligned}$ $\\begin{aligned} A(x)=\\sum_{j=0}^{c-1}\\sum_{k=0}^{n-c} C(c-1,j)\\cdot C(n-c,k)\\cdot x^{n-j-k-1}\\frac{pq^j} {1-q^{j+k+1} }\\cdot (\\sum_{i=0}^{j+k} C(j+k,i) \\cdot (-x)^i)\\end{aligned}$ 虽然有三个循环，但是很显然可以先对于$j,k$进行一次卷积，然后再对于$j+k,-i$进行一次卷积得到 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef unsigned long long ull;typedef pair &lt;int,int&gt; Pii;#define mp make_pair#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=1&lt;&lt;21,P=998244353;int n,c,p,q;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int w[N],Fac[N+1],Inv[N+1],FInv[N+1],rev[N];void Init()&#123; Fac[0]=Fac[1]=Inv[0]=Inv[1]=FInv[0]=FInv[1]=1; rep(i,2,N) &#123; Fac[i]=1ll*Fac[i-1]*i%P; Inv[i]=1ll*(P-P/i)*Inv[P%i]%P; FInv[i]=1ll*FInv[i-1]*Inv[i]%P; &#125; w[N&gt;&gt;1]=1; ll t=qpow(3,(P-1)/N); rep(i,(N&gt;&gt;1)+1,N-1) w[i]=w[i-1]*t%P; drep(i,(N&gt;&gt;1)-1,1) w[i]=w[i&lt;&lt;1];&#125;int Init(int n)&#123; int R=1,c=-1; while(R&lt;n) R&lt;&lt;=1,c++; rep(i,1,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;c); return R;&#125;void NTT(int n,int *a,int f) &#123; rep(i,1,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t; Mod2(a[j+i]); a[j]+=t; Mod1(a[j]); &#125; &#125; &#125; if(f==-1) &#123; reverse(a+1,a+n); rep(i,0,n-1) a[i]=1ll*a[i]*Inv[n]%P; &#125;&#125;int A[N],B[N],C[N];int main()&#123; Init(); rep(kase,1,rd()) &#123; n=rd(),p=rd(),q=rd(),p=p*qpow(q)%P,q=P+1-p,c=rd(); int R=Init(n),t=1; rep(i,0,R-1) A[i]=B[i]=C[i]=0; rep(i,0,c-1) &#123; A[i]=1ll*Fac[c-1]*FInv[i]%P*FInv[c-1-i]%P*t%P; t=1ll*t*q%P; // t= q^i &#125; rep(i,0,n-c) B[i]=1ll*Fac[n-c]*FInv[i]%P*FInv[n-c-i]%P; NTT(R,A,1),NTT(R,B,1); rep(i,0,R-1) A[i]=1ll*A[i]*B[i]%P; NTT(R,A,-1); R=Init(n*2); rep(i,n,R-1) A[i]=0; rep(i,0,R-1) B[i]=0; t=1; rep(i,0,n-1) &#123; t=1ll*t*q%P; // t=q^&#123;i+1&#125; A[i]=1ll*A[i]*Fac[i]%P*qpow(P+1-t)%P; &#125; rep(i,0,n) B[n-i]=(i&amp;1)?P-FInv[i]:FInv[i]; NTT(R,A,1),NTT(R,B,1); rep(i,0,R-1) A[i]=1ll*A[i]*B[i]%P; NTT(R,A,-1); rep(i,1,n) printf(&quot;%d\\n&quot;,int(1ll*FInv[n-i]*A[2*n-i]%P*p%P)); &#125;&#125; 实际跑两次卷积，写得丑几乎就是顶着时限过去的。。","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"回文自动机 (PAM,Palindrome Automaton)","slug":"回文自动机 (PAM,Palindrome Automaton)","date":"2020-07-29T07:07:33.000Z","updated":"2021-05-22T03:54:11.345Z","comments":true,"path":"articles/2020/07/29/698ac8bb.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/07/29/698ac8bb.html","excerpt":"","text":"回文自动机 (PAM,Palindrome Automaton)如果学习了$\\text{AC}$自动机和后缀自动机($\\text{SAM}$)，那么这个冷门算法其实非常简单 约定：原字符串为$S$，长度为$|S|$ 结构介绍自动机节点意义： $\\text{PAM}$没有复杂的结构，每个节点对应了一种回文子串，节点个数$\\leq |S|+2$ 自动机的转移：$\\text{PAM}$和$\\text{AC}$自动机一样，有失配指针$fail$和匹配数组$nxt$ $fail_i$即是$i$的后缀的最长状态，$i$和$fail_i$的边构成了一棵树，但是这棵树有着两个根节点(?)，分别对应着长度为奇数/偶数的回文子串 每个转移$nxt_{i,j}$意味着在当前状态$i$的串两边增加字符$j$ 但是由于$\\text{PAM}$的构造是一个在线算法，所以如果想要像$\\text{AC}$自动机一样每次转移直接访问$nxt$，需要结束后遍历结构 构造为了便于访问，设偶数/奇数根分别为$0,1$，每个节点存储一个当前状态的长度$len$ 特别的，$len_0=0,len_1=-1$(便于让所有的串都满足$len_{nxt_{i,j} }=len_i+2$) 同时让空串对应奇数根节点，把偶数根连向奇数，即$fail_0=1$，这样就只有一个根节点了 为了在线构造方便，$\\text{PAM}$需要实现一个匹配函数$\\text{Find}(x,y)$，即在当前$x$状态找到下一个位置$S_y$的匹配状态，如果失配则返回奇数根$1$ 1234int Find(int x,int y)&#123; while(s[y]!=s[y-len[x]-1]) x=fail[x]; // 如果失配到了x=1,那么必然有s[y]=s[y] return x;&#125; 增加一个节点$S_i=c$ 首先找到一个最长的匹配，设当前前缀最长的回文后缀对应的状态为$now$，则直接为$now$匹配$S_i$即可 然后是新建状态(如果当前的回文子串还未出现过) 和$\\text{AC}$自动机类似，访问$fail$树上最近的匹配即可得到这个点的$fail$ 需要注意的点是，因为当前节点可以是根节点，寻找$fail$必须在新建转移$nxt_{now,c}$之前进行，否则可能找到的$fail$是自己 12345678void Extend(int i,int c)&#123; now=Find(now,i); if(!nxt[now][c]) &#123; fail[++cnt]=nxt[Find(fail[now],i)][c]; len[nxt[now][c]=cnt]=len[now]+2; &#125; now=nxt[now][c];&#125; 模板代码如下： 1234567891011121314151617181920212223char s[N];struct Palindrome_Automaton&#123; int len[N],fail[N],nxt[N][26],now,cnt; void Init()&#123; rep(i,0,cnt) memset(nxt,fail[i]=0,104); s[now=0]=len[1]=-1; fail[0]=fail[1]=cnt=1; &#125; int Find(int x,int y)&#123; while(s[y-len[x]-1]!=s[y]) x=fail[x]; return x; &#125; void Extend(int i,int c)&#123; now=Find(now,i); if(!nxt[now][c]) &#123; fail[++cnt]=nxt[Find(fail[now],i)][c]; len[nxt[now][c]=cnt]=len[now]+2; &#125; now=nxt[now][c]; &#125;&#125;; 拓展：回文串与$\\text{Border}$关于$\\text{Border}$ 推论1:回文串的$\\text{Border}$也是回文串 若有回文串$S$的一个$\\text{Border} :T$，则$S_{1,|T|}=S_{|S|-|T|+1,|S|}=reverse(S_{1,|T|})$ 故$T$也是一个回文串 推论2:遍历回文自动机的$fail$链，能得到当前串的所有$\\text{Border}$(基于推论1得到) 结合$\\text{kmp,AC}$与$\\text{Border}$的关系能够有更好的理解","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"二次剩余","slug":"二次剩余","date":"2020-07-26T08:25:07.000Z","updated":"2021-05-22T03:54:11.325Z","comments":true,"path":"articles/2020/07/26/98066e3c.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/07/26/98066e3c.html","excerpt":"","text":"二次剩余只考虑奇质数$P$的情况 设求$x^2\\equiv a\\pmod P$的一个$x$ 判断由费马小定理$x^{P-1}\\equiv 1 \\pmod P$，即$a^\\frac{P-1} {2}\\equiv 1 \\pmod P$ (实际并没有证明充分性。。) 不存在二次剩余即$a^\\frac{P-1} {2}\\equiv -1\\pmod P$ (对于所有$a=0,1$的情况需要特判) 原根法求二次剩余先求出$P$的一个原根$g$ 那么可以用$g^k$表示出$[1,P-1]$的所有数 用$BSGS$可以在$O(\\sqrt n\\log n)$的时间内求出$a=g^k$ 如果存在原根，那么$k\\mod 2=0$ 答案就是$g^{\\frac{k} {2} }\\mod P$ 12345678910111213141516171819int Quad(int a,int k=0) &#123; if(a&lt;=1) return a; int g=Getg(P); static map &lt;int,int&gt; M; int S=sqrt(P-1); for(int i=0,t=1;i&lt;S;++i,t=1ll*t*g%P) M[t]=i; int res=0; int w=qpow(g,S); for(int i=0,t=1;i&lt;P-1;i+=S,t=1ll*t*w%P) &#123; ll x=1ll*a*qpow(t,P-2)%P; if(M.count(x)) &#123; res=M[x]+i; break; &#125; &#125; res=qpow(g,res/2); if(k) res=min(res,(P-res)%P); return res;&#125; 更快的方法:Cipolla算法要先找到一个数$y$，满足不存在$\\sqrt{y^2-a}\\pmod P$ 可以随机$y$，期望可以两次找到这样的$y$ 构造虚数$\\omega = \\sqrt{y^2-a}$，那么答案就是$x=\\sqrt{y^2-\\omega^2}=\\sqrt{(y+\\omega)(y-\\omega)}$ 然后构造复数$(\\alpha,\\beta)=\\alpha+\\beta\\omega$ 求出$x=(y,1)^{\\frac{(P+1)} {2} }$，模拟复数乘法即可 可以证明结果没有虚部，就是答案 1234567891011121314151617181920212223242526272829int Quad(int a,int k=0) &#123; if(a&lt;=1) return a; int x; while(1) &#123; x=1ll*rand()*rand()%P; ll res=qpow((1ll*x*x-a+P)%P,(P-1)/2); if(res!=1) break; &#125; ll w=(1ll*x*x-a+P)%P; int d=(P+1)/2; ll resx=1,resy=0; ll xx=x,yy=1; while(d) &#123; if(d&amp;1) &#123; ll tx=(resx*xx+resy*yy%P*w)%P,ty=(resx*yy+resy*xx)%P; resx=tx,resy=ty; // 模拟复数乘法 &#125; ll tx=(xx*xx+yy*yy%P*w)%P,ty=2*xx*yy%P; xx=tx,yy=ty; // 模拟复数乘法 d&gt;&gt;=1; &#125; x=resx; // 答案就是实部 if(k) x=min(x,(P-x)%P); return x;&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「APIO2019」路灯 (K-D Tree / 树套树 / CDQ + 树状数组)","slug":"「APIO2019」路灯 (K-D Tree   树套树   CDQ + 树状数组)","date":"2020-07-26T06:00:03.000Z","updated":"2021-05-22T03:54:11.149Z","comments":true,"path":"articles/2020/07/26/f28e907d.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/07/26/f28e907d.html","excerpt":"","text":"「APIO2019」路灯 (K-D Tree / 树套树 / CDQ + 树状数组)首先想到一个简单的问题转化 对于一个询问，联通的时间是若干连续的区间$[L_i,R_i]$ 所有的$L_i,R_i+1$都是关键点，即由不连通变为联通的时间 和 由联通变为不连通的时间 把答案转化为$\\sum R_i+1-L_i$即可 问题转化为对于当前的操作，找到它是那些询问的关键点 如果是合并操作，被合并的两个区间之间变得联通 如果是分裂操作，裂开的两个区间之间不再联通 可以用set维护上述区间，发现每次被更新的值都是一个二维区间 算上时间这一维，问题转化为一个类 三维偏序问题，但是题限制了内存 Part1 K-D Tree限制了内存，很容易想到直接K-D Tree，实际运行也比较优秀 注意可以把要询问的点拿出来建出K-D Tree，每次区间修改即可 时间复杂度$O(n\\sqrt n)$，空间复杂度$O(n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define pb push_backtypedef pair &lt;int,int&gt; Pii;#define mp make_pairvoid cmin(int &amp;a,int b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;void cmax(int &amp;a,int b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=3e5+10,INF=1e9;int n,m,rt,col[N],opt[N],a[N],b[N];char str[N];set &lt;pair &lt;int,int&gt; &gt; st,tmp;struct Node&#123; int x,y; &#125; A[N];int cmp1(Node a,Node b)&#123; return mp(a.x,a.y)&lt;mp(b.x,b.y); &#125;int cmp2(Node a,Node b)&#123; return mp(a.y,a.x)&lt;mp(b.y,b.x); &#125;int ch[N][2],lx[N],rx[N],ly[N],ry[N],s[N],t[N];int Build(int l,int r,int d=0) &#123; if(l&gt;r) return 0; int u=(l+r)&gt;&gt;1; nth_element(A+l,A+u,A+r+1,d?cmp2:cmp1); ch[u][0]=Build(l,u-1,d^1),ch[u][1]=Build(u+1,r,d^1); lx[u]=rx[u]=A[u].x,ly[u]=ry[u]=A[u].y; for(int i:ch[u]) if(i) cmin(lx[u],lx[i]),cmin(ly[u],ly[i]),cmax(rx[u],rx[i]),cmax(ry[u],ry[i]); return u;&#125;void Upd(int x1,int x2,int y1,int y2,int u,int x) &#123; if(!u || x1&gt;rx[u] || x2&lt;lx[u] || y1&gt;ry[u] || y2&lt;ly[u]) return; if(x1&lt;=lx[u] &amp;&amp; rx[u]&lt;=x2 &amp;&amp; y1&lt;=ly[u] &amp;&amp; ry[u]&lt;=y2) return void(s[u]+=x); if(x1&lt;=A[u].x &amp;&amp; A[u].x&lt;=x2 &amp;&amp; y1&lt;=A[u].y &amp;&amp; A[u].y&lt;=y2) t[u]+=x; for(int i:ch[u]) Upd(x1,x2,y1,y2,i,x);&#125;int Que(Node x,int u,int d=0) &#123; if(A[u].x==x.x &amp;&amp; A[u].y==x.y) return s[u]+t[u]; int y=ch[u][!(d?cmp2(x,A[u]):cmp1(x,A[u]))]; return Que(x,y,d^1)+s[u];&#125;int main()&#123; n=rd(),m=rd(); scanf(&quot;%s&quot;,str+1); rep(i,1,n) col[i]=str[i]-&#x27;0&#x27;; rep(i,1,n+1) &#123; int r=i; while(col[r]) r++; st.insert(mp(i,r)); i=r; &#125; rep(i,1,m) &#123; scanf(&quot;%s&quot;,str+1); if(str[1]==&#x27;t&#x27;) opt[i]=1,a[i]=rd(); else opt[i]=2,a[i]=rd(),b[i]=rd(),tmp.insert(mp(a[i],b[i])); &#125; n=0; for(auto it:tmp) A[++n]=(Node)&#123;it.first,it.second&#125;; rt=Build(1,n); rep(i,1,m) &#123; if(opt[i]==1) &#123; int x=a[i]; if(col[x]) &#123; auto it=st.upper_bound(mp(x,INF)); it--; int l=it-&gt;first,r=it-&gt;second; st.erase(it); st.insert(mp(l,x)),st.insert(mp(x+1,r)); Upd(l,x,x+1,r,rt,i); &#125; else &#123; auto it=st.upper_bound(mp(x,INF)),tmp=it; it--; int l=it-&gt;first,r=tmp-&gt;second; st.erase(it),st.erase(tmp); st.insert(mp(l,r)),Upd(l,x,x+1,r,rt,-i); &#125; col[x]^=1; &#125; else &#123; int ans=Que((Node)&#123;a[i],b[i]&#125;,rt); auto it=st.upper_bound(mp(a[i],INF)); it--; if(it-&gt;second&gt;=b[i]) ans+=i; printf(&quot;%d\\n&quot;,ans); &#125; &#125;&#125; Part2 树套树(没有代码)由于已知查询的节点，树套树的内存可以优化到$O(n\\log n)$ 把要询问的点拉出来，每次询问在第二维中有$\\log n$次单点查询，所以需要被查询的位置一共只有$n\\log n$个 把这些会被查询的位置拿出来建成$n$棵静态的线段树，更新就直接在这些静态的线段树上区间更新即可 时间复杂度$O(n\\log ^2 n)$，空间复杂度$O(n\\log n)$ Part3 CDQ+树状数组是常规写法，不会被限制内存 CDQ一维，排序一维，树状数组一维，参见三维偏序","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"APIO","slug":"APIO","permalink":"http://chasingdeath.github.io/tags/APIO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「APIO2019」桥梁(询问分块+并查集)","slug":"「APIO2019」桥梁(询问分块+并查集)","date":"2020-07-26T05:38:06.000Z","updated":"2021-05-22T03:54:11.145Z","comments":true,"path":"articles/2020/07/26/38d18df.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/07/26/38d18df.html","excerpt":"","text":"「APIO2019」桥梁(询问分块+并查集)询问每$S$个分块后，每次对于所有块内未被更改的边 及 所有询问 排序，然后依次加入并查集，这一部分复杂度为$O(m \\frac{q} {S}(\\log m+\\alpha(n)))$ 对于$S$条被改变的边，对于每个询问分别考虑这些边的贡献，复杂度为$O(qS)$，由于涉及到并查集回撤的问题，可以使用按秩合并，复杂度为$O(qS\\log S)$ 按照上面两步暴力实现，复杂度大概可以做到$O((m+q)\\sqrt{q}\\log n)$ 实际可行的优化有： 用平衡树实现排序，每次暴力遍历，第一部分复杂度降为$O(q\\log m+m\\frac{q} {S} \\alpha(n))$ 由于最多访问到$O(S)$个联通块，第二部分用$dfs$遍历来实现，复杂度降为$O(q S \\alpha(n))$(遍历过程中要访问联通块编号) 复杂度可以降到约$O((m+q)\\sqrt {q} \\cdot \\alpha(n))$ 以下是暴力实现的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)#define pb push_backchar IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=1e5+10;int n,m,S,q,qc;struct Edge&#123; int u,v,w; bool operator &lt; (Edge __) const &#123; return w&lt;__.w; &#125;&#125; A[N],B[N],Q[N];struct Node&#123; int t,w; &#125;;vector &lt;Node&gt; G[N];int uid[N],uc,fa[N],sz[N],ux[N],uy[N],rc,ans[N];int Find(int x)&#123; while(fa[x]!=x) x=fa[fa[x]]; return x; &#125;void Union(int x,int y)&#123; x=Find(x),y=Find(y); if(x==y) return; if(sz[x]&gt;sz[y]) swap(x,y); ux[++rc]=x,uy[rc]=y; fa[x]=y,sz[y]+=sz[x]; // 按秩合并用于回撤&#125;int main()&#123; n=rd(),m=rd(); rep(i,1,m) A[i].u=rd(),A[i].v=rd(),A[i].w=rd(); S=sqrt(3*(n+m)); rep(i,1,q=rd()) &#123; ans[i]=-1; int opt=rd(),x=rd(),y=rd(); if(opt==1) G[x].pb((Node)&#123;i,y&#125;); else Q[++qc]=(Edge)&#123;i,x,y&#125;; if(qc%S==0 || i==q) &#123; if(!qc) continue; int c=0; rep(i,1,m) if(!G[i].size()) B[++c]=A[i]; else uid[++uc]=i; sort(B+1,B+c+1),sort(Q+1,Q+qc+1); rep(i,1,n) fa[i]=i,sz[i]=1; int p=c; drep(i,qc,1) &#123; while(p &amp;&amp; B[p].w&gt;=Q[i].w) Union(B[p].u,B[p].v),p--; rc=0; rep(j,1,uc) &#123; int x=uid[j],w=A[x].w; for(auto k:G[x]) if(k.t&lt;=Q[i].u) w=k.w; else break; // 找到询问时这条边的权值 if(w&gt;=Q[i].w) Union(A[x].u,A[x].v); &#125; ans[Q[i].u]=sz[Find(Q[i].v)]; drep(j,rc,1) fa[ux[j]]=ux[j],fa[uy[j]]=uy[j],sz[uy[j]]-=sz[ux[j]];// 回撤 rc=0; &#125; rep(i,1,uc) A[uid[i]].w=G[uid[i]].rbegin()-&gt;w,G[uid[i]].clear(); uc=qc=0; &#125; &#125; rep(i,1,q) if(~ans[i]) printf(&quot;%d\\n&quot;,ans[i]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"APIO","slug":"APIO","permalink":"http://chasingdeath.github.io/tags/APIO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「APIO2019」奇怪装置 ","slug":"「APIO2019」奇怪装置 ","date":"2020-07-26T04:12:55.000Z","updated":"2021-05-22T03:54:11.141Z","comments":true,"path":"articles/2020/07/26/b8f86f0a.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/07/26/b8f86f0a.html","excerpt":"","text":"「APIO2019」奇怪装置找到循环就很简单了 很显然$y$是每$B$次一循环的，对于每个相邻的$y$循环$x$的值均相差$B+1 \\pmod A$ 因此总的循环就是$B+1$对于$A$的循环乘上$B$ 即$\\frac{A} {gcd(A,B+1)}\\cdot B$ 知道循环节之后，把查询分成$O(n)$个区间，排序之后直接解决即可 如果使用基数排序即可做到$O(n)$ 以下是快排版本 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;using ll=long long;#define mp make_pairchar IO;ll rd()&#123; ll s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;int n,c,i;ll A,B,ans,r=-1,L,R;pair &lt;ll,ll&gt; S[2000010];int main()&#123; for(n=rd(),A=rd(),B=rd(),A=min(1.0*B*(A/__gcd(A,B+1)),1e18),i=1;i&lt;=n;++i) &#123; L=rd(),R=rd(); if(R-L+1&gt;=A) return printf(&quot;%lld\\n&quot;,A),0; L%=A,R%=A; L&lt;=R?S[++c]=mp(L,R):(S[++c]=mp(L,A-1),S[++c]=mp(0,R)); &#125; for(sort(S+1,S+c+1),i=1;i&lt;=c;++i) if(r&lt;=S[i].second) ans+=S[i].second-max(r,S[i].first-1),r=S[i].second; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"APIO","slug":"APIO","permalink":"http://chasingdeath.github.io/tags/APIO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「APIO2018」选圆圈(K-D Tree/CDQ+Set)","slug":"「APIO2018」选圆圈(K-D Tree CDQ+Set)","date":"2020-07-26T03:27:26.000Z","updated":"2021-05-22T03:54:11.138Z","comments":true,"path":"articles/2020/07/26/51d45953.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/07/26/51d45953.html","excerpt":"","text":"「APIO2018」选圆圈(K-D Tree/CDQ+Set)Part1 K-D Tree做法K-D Tree经常用来优化大暴力。。 把圆$(x,y,r)$视为矩形$(x-r,y-r,x+r,y+r)$，依据$(x,y)$构建K-D Tree 维护K-D Tree每个节点所有矩形最小和最大的$x,y$，通过判断当前圆与其是否有交来剪枝 删去的节点$x,y$不算进矩形范围即可 很显然这是一个最坏$O(n^2)$的算法，直接$x,y$轮换建树这样写APIO的数据已经卡过了。。 比较好的办法是按照$x,y$的方差大的一维建树，当然旋转角度也是可以的 实际运行速度堪比$O(n\\log n)$ Code1:旋转+$x,y$轮换建树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef long double db;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125; template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) f=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=3e5+10,INF=1e9+10;const db eps=1e-7;const db co=cos(1123),si=sin(1123);int n,typ;struct Node&#123; db x,y; int r,id;&#125;A[N],B[N];db Dis(db x,db y,Node z)&#123; return (x-z.x)*(x-z.x)+(y-z.y)*(y-z.y); &#125;db Dis(Node x,Node y)&#123; return Dis(x.x,x.y,y); &#125;db In(db x,db y,Node z)&#123; return Dis(x,y,z)-eps&lt;=(db)z.r*z.r; &#125;int cmp(Node x,Node y)&#123; return typ?x.x&lt;y.x:x.y&lt;y.y; &#125;int c[N],ch[N][2],rt;db lx[N],rx[N],ly[N],ry[N];void Up(int u) &#123; if(c[B[u].id]) lx[u]=ly[u]=1e18,rx[u]=ry[u]=-1e18; else lx[u]=B[u].x-B[u].r,rx[u]=B[u].x+B[u].r,ly[u]=B[u].y-B[u].r,ry[u]=B[u].y+B[u].r; for(int v:ch[u]) if(v) cmin(lx[u],lx[v]),cmax(rx[u],rx[v]),cmin(ly[u],ly[v]),cmax(ry[u],ry[v]);&#125;int Build(int l,int r) &#123; if(l&gt;r) return 0; int u=(l+r)&gt;&gt;1; nth_element(B+l,B+u,B+r+1,cmp); typ^=1; ch[u][0]=Build(l,u-1),ch[u][1]=Build(u+1,r); typ^=1; return Up(u),u;&#125;int Cross(int x,Node y)&#123; if(lx[x]&gt;rx[x]) return 0; if(In(lx[x],ly[x],y) || In(lx[x],ry[x],y) || In(rx[x],ly[x],y) || In(rx[x],ry[x],y)) return 1; if(lx[x]-eps&lt;=y.x &amp;&amp; y.x&lt;=rx[x]+eps &amp;&amp; ly[x]-eps&lt;=y.y &amp;&amp; y.y&lt;=ry[x]+eps) return 1; if(lx[x]-eps&lt;=y.x &amp;&amp; y.x&lt;=rx[x]+eps) if(In(y.x,ly[x],y) || In(y.x,ry[x],y)) return 1; if(ly[x]-eps&lt;=y.y &amp;&amp; y.y&lt;=ry[x]+eps) if(In(lx[x],y.y,y) || In(rx[x],y.y,y)) return 1; return 0;&#125;void Del(int u,Node x)&#123; if(!u || !Cross(u,x)) return; if(!c[B[u].id] &amp;&amp; Dis(x,B[u])-eps&lt;=(db)(x.r+B[u].r)*(x.r+B[u].r)) c[B[u].id]=x.id; Del(ch[u][0],x),Del(ch[u][1],x); Up(u);&#125;int main()&#123; n=rd(); rep(i,1,n) &#123; db x=rd(),y=rd(); A[i]=B[i]=(Node)&#123;x*co-y*si,x*si+y*co,rd(),i&#125;; &#125; sort(A+1,A+n+1,[&amp;](Node x,Node y)&#123; return x.r!=y.r?x.r&gt;y.r:x.id&lt;y.id;&#125;),rt=Build(1,n); rep(i,1,n) if(!c[A[i].id]) Del(rt,A[i]); rep(i,1,n) printf(&quot;%d &quot;,c[i]);&#125; \\Code2:方差建树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;using ll=long long;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125; template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char buf[200000],*p1,*p2;#define getchar() (((p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,200000,stdin))),*p1++)char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) f=IO==&#x27;-&#x27;; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;void wt(int x)&#123; static int buf[10],l=0; while(x) buf[++l]=x%10+&#x27;0&#x27;,x/=10; drep(i,l,1) putchar(buf[i]); l=0;&#125;const int N=3e5+10,INF=1e9+10;int n,typ;struct Node&#123; ll x,y,r; int id;&#125;A[N],B[N];ll Dis(ll x,ll y,Node z)&#123; return (x-z.x)*(x-z.x)+(y-z.y)*(y-z.y); &#125;ll Dis(Node x,Node y)&#123; return Dis(x.x,x.y,y); &#125;int In(ll x,ll y,Node z)&#123; return Dis(x,y,z)&lt;=z.r*z.r; &#125;int cmp(Node x,Node y)&#123; return typ?x.x&lt;y.x:x.y&lt;y.y; &#125;int c[N],ch[N][2],rt;int lx[N],rx[N],ly[N],ry[N];void Up(int u) &#123; if(c[B[u].id]) lx[u]=ly[u]=INF,rx[u]=ry[u]=-INF; else lx[u]=B[u].x-B[u].r,rx[u]=B[u].x+B[u].r,ly[u]=B[u].y-B[u].r,ry[u]=B[u].y+B[u].r; for(int v:ch[u]) if(v) cmin(lx[u],lx[v]),cmax(rx[u],rx[v]),cmin(ly[u],ly[v]),cmax(ry[u],ry[v]);&#125;int Get(int l,int r)&#123; long double _x=0,_y=0,x=0,y=0; rep(i,l,r) _x+=B[i].x,_y+=B[i].y; _x/=r-l+1,_y/=r-l+1; rep(i,l,r) x+=(B[i].x-_x)*(B[i].x-_x),y+=(B[i].y-_y)*(B[i].y-_y); return x&gt;y;&#125;int Build(int l,int r) &#123; if(l&gt;r) return 0; int u=(l+r)&gt;&gt;1; typ=Get(l,r),nth_element(B+l,B+u,B+r+1,cmp); ch[u][0]=Build(l,u-1),ch[u][1]=Build(u+1,r); return Up(u),u;&#125;int Cross(int x,Node y)&#123; if(lx[x]&gt;rx[x]) return 0; if(In(lx[x],ly[x],y) || In(lx[x],ry[x],y) || In(rx[x],ly[x],y) || In(rx[x],ry[x],y)) return 1; if(lx[x]&lt;=y.x &amp;&amp; y.x&lt;=rx[x] &amp;&amp; ly[x]&lt;=y.y &amp;&amp; y.y&lt;=ry[x]) return 1; if(lx[x]&lt;=y.x &amp;&amp; y.x&lt;=rx[x]) if(In(y.x,ly[x],y) || In(y.x,ry[x],y)) return 1; if(ly[x]&lt;=y.y &amp;&amp; y.y&lt;=ry[x]) if(In(lx[x],y.y,y) || In(rx[x],y.y,y)) return 1; return 0;&#125;void Del(int u,Node x)&#123; if(!u || !Cross(u,x)) return; if(!c[B[u].id] &amp;&amp; Dis(x,B[u])&lt;=(x.r+B[u].r)*(x.r+B[u].r)) c[B[u].id]=x.id; Del(ch[u][0],x),Del(ch[u][1],x); Up(u);&#125;int main()&#123; n=rd(); rep(i,1,n) &#123; int x=rd(),y=rd(); A[i]=B[i]=(Node)&#123;x,y,rd(),i&#125;; &#125; sort(A+1,A+n+1,[&amp;](Node x,Node y)&#123; return x.r!=y.r?x.r&gt;y.r:x.id&lt;y.id;&#125;),rt=Build(1,n); rep(i,1,n) if(!c[A[i].id]) Del(rt,A[i]); rep(i,1,n) printf(&quot;%d &quot;,c[i]);&#125; \\Part2 CDQ+Set这是一个稳定$O(n\\log ^2n)$的算法 按照$r$递减，$id$递增的顺序对于圆排序后，$CDQ$考虑$[l,mid]$对$[mid+1,r]$的贡献 先处理$[l,mid]$的部分，就能知道哪些圆可以对$[mid+1,r]$产生贡献 处理贡献时，依然把圆视为矩形，按照$x$插入、删除和查询矩形的左右边界$(x-r,y),(x+r,y)$ 插入、删除和查询均是在$set$中维护$y$的前驱后继 同时还需要交换$x,y$重新进行一遍 正确性： 与每个圆交的圆一定在$x$或$y$上与它相邻 如果这个圆在x,y上都不与它相邻还与它相交，则必然会跨过一个相邻的圆，这个圆不会被加入set 故不存在这种情况 实际运行常数很大，被K-D Tree吊起来打 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(i=a;i&lt;=b;++i)using P=pair&lt;int,int&gt;;#define M make_pair#define X first#define Y second#define S(x) 1ll*(x)*(x)const int N=1e6+10;int n,c[N],i,j,D[N];struct C&#123; int x,y,r,i; &#125; A[N]; void Upd(int i,int j) &#123; if(S(A[i].x-A[j].x)+S(A[i].y-A[j].y)&lt;=S(A[i].r+A[j].r)&amp;&amp;D[c[A[j].i]]&gt;i) c[A[j].i]=A[i].i; &#125;set&lt;P&gt;st;P I[N],E[N],Q[N];void Work(int l,int r)&#123; int mid=(l+r)&gt;&gt;1,n=0,m=0,x=0,y=0,t; rep(i,l,mid) if(c[A[i].i]==A[i].i) I[m]=M(A[i].x-A[i].r,i),E[m++]=M(A[i].x+A[i].r+1,i); rep(i,mid+1,r) Q[n++]=M(A[i].x-A[i].r,i),Q[n++]=M(A[i].x+A[i].r,i); sort(I,I+m),sort(E,E+m),sort(Q,Q+n),st.clear(); rep(i,0,n-1) &#123; while(x&lt;m&amp;&amp;I[x].X&lt;=Q[i].X) st.insert(M(A[t=I[x++].Y].y,t)); while(y&lt;m&amp;&amp;E[y].X&lt;=Q[i].X) st.erase(M(A[t=E[y++].Y].y,t)); auto j=st.lower_bound(M(A[t=Q[i].Y].y,t)); if(j!=st.end()) Upd(j-&gt;Y,t); if(j!=st.begin()) Upd((--j)-&gt;Y,t); &#125;&#125;void Solve(int l,int r) &#123; if(r-l+1&lt;=80) &#123; rep(i,l,r)if(c[A[i].i]==A[i].i)rep(j,i+1,r) Upd(i,j); return; &#125; int mid=(l+r)&gt;&gt;1; Solve(l,mid); Work(l,r);rep(i,l,r) swap(A[i].x,A[i].y); Work(l,r);rep(i,l,r) swap(A[i].x,A[i].y); Solve(mid+1,r);&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); rep(i,1,n) scanf(&quot;%d%d%d&quot;,&amp;A[i].x,&amp;A[i].y,&amp;A[i].r),A[i].i=i; sort(A+1,A+n+1,[&amp;](C x,C y)&#123;return M(-x.r,x.i)&lt;M(-y.r,y.i);&#125;); rep(i,1,n) D[A[i].i]=c[i]=i; Solve(1,n); rep(i,1,n) printf(&quot;%d &quot;,c[i]);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"APIO","slug":"APIO","permalink":"http://chasingdeath.github.io/tags/APIO/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"堆","slug":"堆","date":"2020-07-26T00:20:47.000Z","updated":"2021-05-22T03:54:11.346Z","comments":true,"path":"articles/2020/07/26/fab451a5.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/07/26/fab451a5.html","excerpt":"","text":"堆每个节点权值大于(小根堆)父亲的树形数据结构 以下均讨论小根堆的问题 普通二叉堆用数组$a[1:n]$构成一棵二叉树来维护堆操作，可以做到 1.插入元素 2.查询堆顶 3.删除堆顶或者删除特定元素(需要记录权值位置) 1.插入元素 先放到$a[n+1]$的位置，然后每次与父亲比较是否交换 1234void push(int x)&#123; a[++n]=x; for(int p=n;p&gt;1 &amp;&amp; a[p]&lt;a[p&gt;&gt;1];) swap(a[p],a[p&gt;&gt;1]),p&gt;&gt;=1;&#125; 2.删除特定元素 删除后，把$a[n]$元素放到空的位置，然后向下走，注意每次一定是把左右儿子中比较小的换上来 123456789void Delete(int x)&#123; swap(a[x],a[n--]); for(int p=x;(p&lt;&lt;1)&lt;=n;)&#123; int nxt=p&lt;&lt;1; if((p&lt;&lt;1|1)&lt;=n &amp;&amp; a[p&lt;&lt;1|1]&lt;a[p&lt;&lt;1]) nxt=p&lt;&lt;1|1; if(a[nxt]&lt;a[p]) swap(a[p],a[nxt]); else break; &#125;&#125; \\配对堆配对堆不是一个二叉树结构，所以在存储上，使用左儿子右兄弟来存储树形结构 可以实现的操作有 1.插入/删除元素，查询堆顶 2.查询堆顶 3.合并两个堆 首先要维护最基本的两个操作 1.合并两个堆 直接按照堆顶权值大小合并，接上去即可 1234567int a[N],ch[N],br[N]; //权值，儿子，兄弟int Union(int x,int y)&#123; if(!x||!y) return x|y; if(a[x]&gt;a[y]) swap(x,y); br[y]=ch[x],ch[x]=y; return x;&#125; 2.配对操作 把一个点的所有儿子两两合并之后再依次合并到一起 配对堆的所有操作都基于合并和配对实现 合并操作是$O(1)$的 配对操作单次最坏是$O(n)$，但是和$Splay$类似的，配对可以让儿子中兄弟最多的个数减半，是一个均摊$O(\\log n)$的操作，因此不可持久化，但是实际运行常数比较小 操作实现：用一个函数给$x$和$x$的右边的所有兄弟配对，递归实现 每次让$x$和右边第一个兄弟配对(即先合并)，再和右边剩下的节点合并 12345int Pair(int x)&#123; if(!x || !br[x]) return x; int y=br[x],z=br[y]; return Union(Union(x,y),Pair(z));&#125; 3.删除元素 如果删除的不是堆顶元素，还需要额外存储每个点的父亲 把被删除元素的儿子合并之后接到父亲上面 4.查询堆顶 如果是查询某个特定元素所在堆的堆顶，需要用并查集来维护 \\左偏树左偏树是一个二叉堆结构，顾名思义，向左边偏的树 左偏树判断左偏的方法是定义了一个$dis$数组，满足$\\forall dis_{lson}\\ge dis_{rson},dis_x=dis_{rson}+1$ 因此一直走右儿子的链长度就是$O(\\log n)$的 利用这个性质完成操作，每次合并之后检查$dis_{lson},dis_{rson}$是否满足条件 可以完成的操作有 1.插入节点/合并堆 2.删除节点 3.访问堆顶 4.可持久化 1.检查操作 1234void Check(int x)&#123; if(dis[ls[x]]&lt;dis[rs[x]]) swap(ls[x],rs[x]); dis[x]=dis[rs[x]]+1;&#125; 左偏树的合并操作就是 让较大的堆顶 和 小的堆顶的右儿子合并成为 新的右儿子 很显然合并次数$\\leq $两个堆的右儿子长度之和，这个操作是单次$O(\\log n)$ 12345int Union(int x,int y)&#123; if(!x||!y) return x|y; if(a[x]&gt;a[y]) swap(x,y); return rs[x]=Union(rs[x],y),;&#125; 2.删除节点 合并左右儿子后接到父亲上 3.访问堆顶 左偏树的深度没有保证，访问特定节点所在堆的堆顶需要用并查集维护 4.可持久化 由于单次访问复杂度保证了是$O(\\log n)$，因此可以对于每次合并得到的开一个新的节点存下来 即完成了可持久化操作","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「雅礼集训 2018 Day4」Magic(分治NTT)","slug":"「雅礼集训 2018 Day4」Magic(分治NTT)","date":"2020-06-18T11:16:28.000Z","updated":"2021-05-22T03:54:11.309Z","comments":true,"path":"articles/2020/06/18/d04c1a49.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/18/d04c1a49.html","excerpt":"","text":"「雅礼集训 2018 Day4」Magic(分治NTT)题目的条件简直无法计算恰好为$k$的方案数，所以考虑计算$\\ge k$的方案数 所以可以强制有$k$个相邻位置相同，但是不确定相同的是那些颜色 对每个颜色$a_i$考虑，设把$a_i$这个颜色分成了$b_i$个联通块(即强制了$a_i-b_i$个相邻位置相同) 那方案数就是$C(a_i-1,b_i-1)$(是一个简单的插板问题) 得到每种颜色的联通块个数$b_i$，那么这些联通块之间排列的方案数就是$\\frac{(\\sum b_i)!} {b_i!}$ 容易得到$a_i\\rightarrow b_i$的方案数，直接合并$b_i$的方案数，是一个背包问题，所以考虑用分治$NTT$快速合并 那么得到了$\\sum b_i=n-k$的所有方案，复杂度$O(n\\log n\\log m)$ 最后的容斥比较明显的是一个二项式反演的形式，可以$O(n)$计算 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))char IO;int rd()&#123; int s=0; while(!isdigit(IO=getchar())); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return s;&#125;const int N=1&lt;&lt;17,P=998244353;int n,m,k;int Inv[N+1],Fac[N+1],FInv[N+1];ll C(int n,int m)&#123; return n&lt;0||m&lt;0||n&lt;m? 0 : 1ll*Fac[n]*FInv[m]%P*FInv[n-m]%P; &#125;ll qpow(ll x,ll k=P-2)&#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;typedef vector &lt;int&gt; Poly;int w[N|10],rev[N];void Init()&#123; Inv[0]=Inv[1]=Fac[0]=Fac[1]=FInv[0]=FInv[1]=1; rep(i,2,N)&#123; Fac[i]=1ll*Fac[i-1]*i%P; Inv[i]=1ll*(P-P/i)*Inv[P%i]%P; FInv[i]=1ll*FInv[i-1]*Inv[i]%P; &#125; w[N&gt;&gt;1]=1; ll t=qpow(3,(P-1)/N); rep(i,(N&gt;&gt;1)+1,N-1) w[i]=w[i-1]*t%P; drep(i,(N&gt;&gt;1)-1,1) w[i]=w[i&lt;&lt;1];&#125;int Init(int n)&#123; int R=1,cc=-1; while(R&lt;n) R&lt;&lt;=1,cc++; rep(i,1,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;cc); return R;&#125;void NTT(int n,Poly &amp;a,int f)&#123; if((int)a.size()&lt;n) a.resize(n); rep(i,1,n-1) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1)&#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2)&#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t; Mod2(a[j+i]); a[j]+=t; Mod1(a[j]); &#125; &#125; &#125; if(f==-1)&#123; reverse(a.begin()+1,a.end()); rep(i,0,n-1) a[i]=1ll*a[i]*Inv[n]%P; &#125;&#125;Poly operator * (Poly a,Poly b)&#123; int n=a.size()+b.size()-1,R=Init(n); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=1ll*a[i]*b[i]%P; NTT(R,a,-1),a.resize(n); return a;&#125;Poly Solve(int l,int r)&#123; if(l==r)&#123; int x=rd(); Poly F(x+1); rep(y,1,x) F[y]=C(x-1,y-1)*FInv[y]%P; return F; &#125; int mid=(l+r)&gt;&gt;1; return Solve(l,mid)*Solve(mid+1,r);&#125;int main()&#123; freopen(&quot;magic.in&quot;,&quot;r&quot;,stdin),freopen(&quot;magic.out&quot;,&quot;w&quot;,stdout); Init(),n=rd(),m=rd(),k=rd(); Poly dp=Solve(1,n); rep(i,n,m) dp[i]=1ll*dp[i]*Fac[i]%P; int i=m-k; rep(j,n,i-1) dp[i]=(dp[i]+(((i-j)&amp;1)?-1:1)*dp[j]*C(m-j,m-i)%P+P)%P; ll ans=(dp[i]%P+P)%P; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「清华集训 2017」小 Y 和恐怖的奴隶主","slug":"「清华集训 2017」小 Y 和恐怖的奴隶主","date":"2020-06-18T09:26:29.000Z","updated":"2021-05-22T03:54:11.301Z","comments":true,"path":"articles/2020/06/18/c11193ee.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/18/c11193ee.html","excerpt":"","text":"「清华集训 2017」小 Y 和恐怖的奴隶主是不是这题太水了都没人写啊 本题官方题解提供的做法实际上复杂度非常高 Part1很显然本题的$\\text{dp}$是存储每种血量的随从数量 设状态数量的上限是$S$ 当$m=3,k=8$时，这样的状态一共有$S=165+1$种 如果直接$dp$，每次转移是$O(1)$的，可以做到$O(n\\cdot S)$，显然无法处理$n$较大的情况 用矩阵优化$\\text{dp}$转移，朴素的实现可以做到$O(T\\cdot \\log n\\cdot S^3)$ 如果预处理出转移矩阵的幂次，每次查询时只有列向量与方阵的乘法，所以复杂度是$O(\\log n\\cdot S^3+T\\log n\\cdot S^2)$ 实际极限的复杂度预估在$60\\cdot 166^3+500\\cdot 60\\cdot 166^2\\approx 11\\cdot 10^8$ 官方题解提供的做法就是在在这个算法上进行常数优化，这wtm \\Part2对于已知$m,k$来说，设每个$n$构成的答案数列为$a_n$ 预先处理一部分的答案$a_1\\cdots a_n$，使用$\\text{Berlekamp-Massey }$算法求出序列的最短线性递推 发现总是在$O(S)$的长度以后，递推序列不再改变，即总能得到一个长度为$O(S)$的全局线性递推 即总可以在$O(S^2)$的时间内求出答案序列$a_n$的线性递推式 那么对于求得的线性递推式，问题转化为对于每个查询的$n$，求常系数线性递推数列的第$n$项答案 用特征多项式的做法，可以做到单组查询$O(S\\log n\\log S)$的之间求出 那么总复杂度就是$O(S^2+T\\cdot S \\log S\\log n)$ 理论上来说，复杂度上限应该只有$166^2+500\\cdot 166\\cdot 10\\cdot 60\\approx 0.5\\cdot 10^8$ 理论上来说，这个复杂度无论是不是渐进意义下都比矩阵快 但是实际实践中，由于多项式运算的大常数，不优秀的实现下甚至可能超时 考虑到本题多查询的性质，我改变了倍增的基数$D$，并且预处理出倍增用到的$x^i\\mod \\lambda$ 预处理部分的复杂度是$O(\\log_D^n \\cdot (D-1)\\cdot S\\log S)$ 查询部分的复杂度是$O(\\log _D^n S\\log S)$ 由于我的多项式模板不够成熟 在LOJ上，经过这样的魔改，已经能跑得比矩阵块 但是在UOJ上，我同样的代码竟然慢了四倍，而这份代码在UOJ上的运行时间还略有提高 表示很是绝望。。 事实上，这种做法在$m,k$较大时同样可行，在$S$较大，$T$较小的情况下，实际运行总能有更好的表现","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"[WC2019]数树(树形dp+多项式exp)","slug":"[WC2019]数树(树形dp+多项式exp)","date":"2020-06-16T09:21:57.000Z","updated":"2021-05-22T03:54:11.089Z","comments":true,"path":"articles/2020/06/16/194ebdeb.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/16/194ebdeb.html","excerpt":"","text":"[WC2019]数树(树形dp+多项式exp)Part1相同边连接的点同一颜色，直接模拟即可 12345678910111213141516171819202122namespace pt1&#123; int fa[N],sz[N]; map &lt;int,int&gt; M[N]; int Find(int x)&#123; return fa[x]==x?x:fa[x]=Find(fa[x]); &#125; void Solve()&#123; rep(i,1,n) fa[i]=i; rep(i,2,n)&#123; int x=rd(),y=rd(); if(x&gt;y) swap(x,y); M[x][y]=1; &#125; rep(i,2,n) &#123; int x=rd(),y=rd(); if(x&gt;y) swap(x,y); if(M[x][y]) fa[Find(x)]=Find(y); &#125; int ans=1; rep(i,1,n) if(Find(i)==i) ans=1ll*ans*y%P; printf(&quot;%d\\n&quot;,ans); &#125;&#125; Part2相同边连接的点同一颜色，即在相同边构成的树上形成了若干联通块 很容易想到可以强制一些边保留，设保留$i$条边的方案数是$F_i$,则答案就是$\\sum_i F_i\\cdot y^{n-i}$ 考虑$dp$那些边相同，但是不好直接计算剩下边不同的方案，所以考虑计算最多有$i$条边相同的方案数，即 G_i=\\sum_{j=i}C(j,i)F_j二项式反演得到$F_i=\\sum_{j=i}(-1)^{j-i}C(j,i)G_j$ 设分成了$m$个联通块，大小分别为$size_i$，则这些联通块随意构成树的方案数就是$n^{m-2}\\cdot\\prod size_i$ 根据上述性质可以写出一个简单的$O(n^4)$树形dp求得$G_i$，即$dp[i][j][k]$表示在$i$的子树里，有$j$条边相同，当前还剩下一个大小为$k$的联通块,每多转移一条相同边，系数是$\\frac{1} {ny}$ 考虑优化$dp$ 1. 联通块大小的问题，可以转化为每次在联通块里选择一个关键点的方案数，$dp$第三维$0/1$表示当前联通块里是否已经选出了关键点 每次断开一个联通块时必须已经存在关键点 2. 答案是 $\\sum_i F_i\\cdot y^{n-i}$ $=\\sum_i y^{n-i} \\sum_{j=i}(-1)^{j-i}C(j,i)G_j$ $=y^n G_j\\sum_{i=0}^j(-1)^{j-i}C(j,i)y^{-i}$ 发现右边的式子$\\sum_0^j(-1)^{j-i}C(j,i)y^{-i}=(\\frac{1} {y}-1)^j$ 那么直接把$\\frac{1} {y}-1$带入作为保留一条边的转移系数，消去了第二维 那么这个$\\text{dp}$可以被优化到$O(n)$ \\1234567891011121314151617181920212223242526namespace pt2&#123; vector &lt;int&gt; G[N]; int dp[N][2],g[2],Inv; void dfs(int u,int f)&#123; dp[u][0]=dp[u][1]=1; for(int v:G[u]) if(v!=f) &#123; dfs(v,u); g[0]=g[1]=0; rep(i,0,1) rep(j,0,1) &#123; if(!i||!j) g[i|j]=(g[i|j]+1ll*dp[u][i]*dp[v][j]%P*Inv)%P; if(j) g[i]=(g[i]+1ll*dp[u][i]*dp[v][j])%P; &#125; dp[u][0]=g[0],dp[u][1]=g[1]; &#125; &#125; void Solve() &#123; rep(i,2,n) &#123; int u=rd(),v=rd(); G[u].pb(v),G[v].pb(u); &#125; Inv=(qpow(y)-1)*qpow(n)%P; dfs(1,0); ll res=dp[1][1]*qpow(y,n)%P*qpow(n,P+n-3)%P; printf(&quot;%lld\\n&quot;,res); &#125;&#125; Part3有了上面的$dp$，这一部分就简单多了，设分成了$m$个联通块，每个大小为$a_i$，则贡献为 $$\\begin{aligned}\\frac{n!\\cdot a_i^{a_i-2}\\cdot (n^{m-2})^2(\\frac{1} {y}-1)^{n-m}(\\frac{1} {n}^{n-m})^2\\cdot a_i^2} {\\prod a_i! m !}\\end{aligned}$$ 即枚举每个联通块生成树的数量，且需要考虑两棵树分别的联通块之间的连边数量，这一部分需要平方 很显然，可以直接对于$[x^i]F(x)=\\frac{1} {i!}\\cdot (\\frac{1} {n^2}\\cdot (\\frac{1} {y}-1))^{i-1} i^2i^{i-2}$这个多项式求exp得到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const int M=1&lt;&lt;18|10,K=17; typedef vector &lt;int&gt; Poly; int w[M],rev[M],Inv[M]; void Init()&#123; ll t=qpow(3,(P-1)&gt;&gt;K&gt;&gt;1); w[1&lt;&lt;K]=1; rep(i,(1&lt;&lt;K)+1,(1&lt;&lt;(K+1))-1) w[i]=w[i-1]*t%P; drep(i,(1&lt;&lt;K)-1,1) w[i]=w[i&lt;&lt;1]; Inv[0]=Inv[1]=1; rep(i,2,M-1) Inv[i]=1ll*(P-P/i)*Inv[P%i]%P; &#125; int Init(int n)&#123; int R=1,cc=-1; while(R&lt;n) R&lt;&lt;=1,cc++; rep(i,1,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;cc); return R; &#125; void NTT(int n,Poly &amp;a,int f)&#123; if((int)a.size()&lt;n) a.resize(n); rep(i,1,n-1) if(rev[i]&lt;i) swap(a[i],a[rev[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2)&#123; for(int j=l;j&lt;l+i;++j)&#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,Mod2(a[j+i]); a[j]+=t,Mod1(a[j]); &#125; &#125; &#125; if(f==-1) &#123; reverse(a.begin()+1,a.end()); rep(i,0,n-1) a[i]=1ll*a[i]*Inv[n]%P; &#125; &#125; Poly operator * (Poly a,Poly b)&#123; int n=a.size(),m=b.size(); int R=Init(n+m-1); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=1ll*a[i]*b[i]%P; NTT(R,a,-1),a.resize(n+m-1); return a; &#125; Poly Poly_Inv(Poly a)&#123; int n=a.size(); if(n==1) return &#123;(int)qpow(a[0])&#125;; Poly b=a; b.resize((n+1)/2),b=Poly_Inv(b); int R=Init(n*2); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=1ll*b[i]*(2-1ll*a[i]*b[i]%P+P)%P; NTT(R,a,-1); a.resize(n); return a; &#125; Poly Deri(Poly a)&#123; rep(i,1,a.size()-1) a[i-1]=1ll*i*a[i]%P; a.pop_back(); return a; &#125; Poly IDeri(Poly a)&#123; a.pb(0); drep(i,a.size()-2,0) a[i+1]=1ll*a[i]*Inv[i+1]%P; a[0]=0; return a; &#125; Poly Ln(Poly a)&#123; int n=a.size(); a=Deri(a)*Poly_Inv(a),a.resize(n+1); return IDeri(a); &#125; Poly Exp(Poly a)&#123; int n=a.size(); if(n==1) return Poly&#123;1&#125;; Poly b=a; b.resize((n+1)/2),b=Exp(b); b.resize(n); Poly c=Ln(b); rep(i,0,n-1) c[i]=a[i]-c[i],Mod2(c[i]); c[0]++,c=c*b; c.resize(n); return c; &#125; void Solve() &#123; int I=(qpow(y)-1)*qpow(1ll*n*n%P)%P; Init(); Poly F(n+1); for(int i=1,FInv=1;i&lt;=n;FInv=1ll*FInv*Inv[++i]%P)&#123; F[i]=qpow(I,(i-1)) * // 保留i-1条边 (i==1?1:qpow(i,i-2))%P // i个点生成树 * i%P * i%P // * FInv%P; // 阶乘常数 &#125; F=Exp(F); rep(i,1,n) F[n]=1ll*F[n]*i%P; ll res=F[n]*qpow(y,n)%P*qpow(n,2*(P+n-3))%P; printf(&quot;%lld\\n&quot;,res); &#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"WC","slug":"WC","permalink":"http://chasingdeath.github.io/tags/WC/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「FJWC2020Day5-Zzq」lg","slug":"「FJWC2020Day5-zzq」lg","date":"2020-06-16T07:33:14.000Z","updated":"2021-05-22T03:54:11.180Z","comments":true,"path":"articles/2020/06/16/b38eb13d.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/16/b38eb13d.html","excerpt":"","text":"「FJWC2020Day5-zzq」lg设模数为$P$ 考虑对于每一个$\\gcd$计算$\\text{lcm}$之积$F(m)$ 那么可以想到强制每个数都是$\\gcd$的倍数，问题转化为求$\\lfloor \\frac{m} {gcd}\\rfloor $以内所有$\\text{lcm}$的积$G(m)$ 那么对于每个质因数依次考虑,则得到一个简单的式子 $$G(m)=\\begin{aligned}\\prod p_i^{\\sum_{j=1}m^n-(m-\\lfloor \\frac{m} {p_i^j}\\rfloor )^n} \\end{aligned}$$ 其中枚举的$j$是$p_i$至少出现$j$次的方案数，枚举的$j$是$\\log m$ 级别的 肯定是先求出指数$\\mod \\varphi(P)$，可以线性预处理出所有的$i^n \\mod \\varphi(P)$ 对于每个$p_i$求出指数后还要快速幂，复杂度就是$O(|p_i|\\log P)=O(m)$，实际带有一些常数 那么求$G(m)$的复杂度上界是$O(m\\log m)$，实际上$\\lfloor \\frac{m} {i}\\rfloor $有很多重复，复杂度要低很多 得到的每个$\\gcd$的答案还要把强制取出的$\\gcd$补上，是$\\gcd^{ {\\lfloor \\frac{m} {gcd}\\rfloor }^n}$ 那么对于$G(m)$枚举倍数进行容斥的到$F(m)$即可，需要求每个$F(m)$的逆元，复杂度是$O(m(\\log P+\\log m))$ 总复杂度的上界就是$O(m\\log P)$ 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a;i&lt;=b;++i)enum&#123;N=200010,P=998244353,Phi=P-1&#125;;int n,m,p[N],mk[N],g[N],ig[N],h[N];ll qpow(ll x,ll k,ll P) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int G(int m) &#123; if(h[m]) return h[m]; ll ans=1; rep(i,2,m) if(!mk[i]) &#123; ll d=1,s=0; for(;(d*=i)&lt;=m;) s+=p[m]-p[m-m/d]; // 带入上式求出答案 ans=ans*qpow(i,(s%Phi+Phi)%Phi,P)%P; &#125; return h[m]=ans;&#125;int main()&#123; freopen(&quot;lg.in&quot;,&quot;r&quot;,stdin),freopen(&quot;lg.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,2,N-1) if(!mk[i]) for(int j=i+i;j&lt;N;j+=i) mk[j]=1; rep(i,0,m) p[i]=qpow(i,n,Phi); // 预处理出i^n mod Phi rep(i,1,m) g[i]=G(m/i)*qpow(i,p[m/i],P)%P; // 注意要补上 ll ans=1; for(int i=m;i;i--)&#123; for(int j=i+i;j&lt;=m;j+=i) g[i]=1ll*g[i]*ig[j]%P; // 容斥得到f ig[i]=qpow(g[i],P-2,P),ans=ans*qpow(g[i],i,P)%P; &#125; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"WC","slug":"WC","permalink":"http://chasingdeath.github.io/tags/WC/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[BoundedOptimization TopCoder - 12294]","slug":"[BoundedOptimization TopCoder - 12294]","date":"2020-06-14T08:09:14.000Z","updated":"2021-05-22T03:54:11.028Z","comments":true,"path":"articles/2020/06/14/ce6d4565.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/14/ce6d4565.html","excerpt":"","text":"BoundedOptimization TopCoder - 12294考虑在最优情况下，某一些数在$\\text{lowerbound}$,某一些在$\\text{upperbound}$ 确定了这些数之后，对于那些处于$(\\text{lowerbound,upperbound})$之间的数，它们的值其实是在忽略了上下界的情况下能取到的最优情况 否则只要上下移动一点就可能达到一个更优的情况 那么考虑枚举每个数的状态在$\\text{lowerbound,upperbound,(lowerbound,uppperbound)}$ 推论：在中间的数之间必然存在互相关系 假设存在两个数$x_i,x_j$之间没有互相关系，令其他数不变， 则答案式子可以表示为$ax_i+bx_j+c$的形式，改变两个数的值总能得到更优的情况 \\设处在中间位置的数为$x_1,\\cdots,x_m$，其他数为$y_1,\\cdots ,y_k$，每个数连到外面的权值总和为$s_i$ 发现在最优情况下，$\\sum x_i+\\sum y_i =MaxSum$，那么就确定了$\\sum x_i$的值，设为$Sum$ 那么答案就可以表示为$\\begin{aligned}\\frac{\\sum_ix_i\\cdot(Sum-x_i+2\\cdot s_i)} {2}\\end{aligned}+c$ 其中常数$c$是外面的数之间的总和 不考虑限制的情况下，最优情况是$x_i=\\frac{Sum+s_i} {2}$ 此时，若$\\sum x_i\\ne Sum$，是不合法的，需要调整 而让每个数改变$d$，减少的答案都是$d^2$(因为原来是在二次函数的最高点) 所以每个数都改变$\\begin{aligned}\\frac{\\sum \\frac{Sum+x_i} {2}-Sum} {m}\\end{aligned}$是最优的 注意这里计算时都是忽略了$x_1,\\cdots,x_m$的$\\text{lowerbound,upperbound}$，求出的值不一定合法 如果不合法说明至少有某个值该到上下界之后答案会更优，所以这次的答案不用考虑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)#define pb push_backtemplate &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;const int N=30;const db eps=1e-7;int G[N][N];int A[N],w[N];db val[N];class BoundedOptimization &#123;public: double maxValue(vector &lt;string&gt; Expr, vector &lt;int&gt; L, vector &lt;int&gt; R, int Max) &#123; string E=&quot;&quot;; for(string t:Expr) E+=t; memset(G,0,sizeof G); rep(i,0,E.size()-1) if(isalpha(E[i])) &#123; G[E[i]-&#x27;a&#x27;][E[i+1]-&#x27;a&#x27;]=G[E[i+1]-&#x27;a&#x27;][E[i]-&#x27;a&#x27;]=1; i++; &#125; int n=L.size(); db ans=0; rep(S,0,pow(3,n)-1) &#123; int T=S,m=0; db res=0,sum=0; rep(i,0,n-1) &#123; w[i]=T%3; if(!w[i]) A[++m]=i; else val[i]=(w[i]==1?L[i]:R[i]),sum+=val[i]; T/=3; &#125; int fl=sum&lt;=Max; rep(i,1,m) rep(j,i+1,m) if(!G[A[i]][A[j]]) fl=0; if(!fl) continue; db left=Max-sum; rep(i,1,m) &#123; db c=left; rep(j,0,n-1) if(w[j] &amp;&amp; G[A[i]][j]) c+=val[j]*2; val[A[i]]=c/2; sum+=val[A[i]]; &#125; if(m)&#123; db t=(sum-Max)/m; rep(i,1,m) val[A[i]]-=t; &#125; rep(i,0,n-1) if(val[i]&lt;L[i]-eps || val[i]&gt;R[i]+eps) fl=0; if(!fl) continue; rep(i,0,n-1) rep(j,i+1,n-1) if(G[i][j]) res+=val[i]*val[j]; cmax(ans,res); &#125; return ans; &#125;&#125;;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[MapGuessing TopCoder - 12152]","slug":"[MapGuessing TopCoder - 12152]","date":"2020-06-13T01:31:43.000Z","updated":"2021-05-22T03:54:11.071Z","comments":true,"path":"articles/2020/06/13/3ff13b33.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/13/3ff13b33.html","excerpt":"","text":"MapGuessing TopCoder - 12152做得我很迷 首先是可以把问题转化为，每次操作之后会让原序列的限制条件变为：不考虑某一些位置时合法 枚举每个开始位置，依次考虑每一个操作，如果有一个位置被改为不同，就是不合法的 对于每一个开始位置，能得到的的最优限制条件都是唯一的，因为只要是合法的，一定取最后一个合法的位置，才能尽可能多地覆盖一些位置 那么我们得到了$|goal|$个这样的限制条件$S_i$，设$n=|goal|$ 直接计算肯定会算重，考虑一个简单的容斥 $\\begin{aligned}Answer=\\sum_{T\\ne \\empty}(-1)^{|T|+1}2^{|S_{T_1}\\cap \\cdots \\cap S_{T_{|T|} }|}\\end{aligned}$ 就是枚举选择一个限制的集合，求出他们的并集 直接枚举复杂度当然是$O(2^{|n|})$，如果$\\text{dfs}$枚举，当前状态为$0$时，可以直接返回答案 估计一下这个$\\text{dfs}$的复杂度 设操作过程中指针左右移动的距离是$L$，那么最多存在$n-L$个合法的开始位置，每个状态最多包含$L$个$1$ 很显然枚举的上限是$\\min\\{2^{n-L},2^{L} \\}$，即受到开始位置的个数和可能出现的1个数的限制 当$n-L=L$时，复杂度达到上限是$O(2^{\\frac{n} {2} })$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)set &lt;ll&gt; st;ll S[40];int now[40],cnt;ll dfs(int p,ll State)&#123; if(p==cnt+1) return (1ll&lt;&lt;__builtin_popcountll(State)); // 枚举完毕 if(State==0) return 0; // 剪枝，注意因为是后面的所有1,-1相加，所以是return 0而不是1 return dfs(p+1,State)-dfs(p+1,State&amp;S[p]); // 直接处理容斥系数&#125;class MapGuessing &#123;public: long long countPatterns(string S, vector &lt;string&gt; code) &#123; string C=&quot;&quot;; for(string t:code) C+=t; int n=S.size(); st.clear(); rep(i,0,n-1) &#123; int p=i,f=1; ll lst=0; // 记录最后一个合法的即可 rep(i,0,n-1) now[i]=0; for(char c:C) &#123; if(c==&#x27;&lt;&#x27;) p--; if(c==&#x27;&gt;&#x27;) p++; if(c==&#x27;0&#x27;) now[p]=1; if(c==&#x27;1&#x27;) now[p]=2; if(p&lt;0 || p&gt;=n)&#123; f=0; break; &#125; int fl=1; ll T=0; rep(i,0,n-1) &#123; if(!now[i]) continue; if(now[i]-1!=S[i]-&#x27;0&#x27;)&#123; fl=0; break; &#125; else T|=1ll&lt;&lt;i; &#125; if(!fl) continue; lst=T; &#125; if(!f) continue; st.insert(-lst); &#125; cnt=0; for(ll x:st) &#123; ll y=-x; int f=1; rep(i,1,cnt) if((::S[i]&amp;y)==y)&#123; f=0; break; &#125; if(f) ::S[++cnt]=y; &#125; //初始系数是-1 ll ans=(1ll&lt;&lt;n)-dfs(1,(1ll&lt;&lt;n)-1); // 注意枚举出来会把T=emptyset的情况算进去，要去掉 return ans; &#125;&#125;;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"Berlekamp-Massey 算法(最短线性递推)","slug":"Berlekamp-Massey 算法(最短线性递推)","date":"2020-06-12T09:58:21.000Z","updated":"2021-05-22T03:54:10.742Z","comments":true,"path":"articles/2020/06/12/e19b6223.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/12/e19b6223.html","excerpt":"","text":"Berlekamp-Massey 算法(最短线性递推)参考文献：2019集训队论文，钟子谦《两类递推数列的性质和应用》给出了详细阐述 算法简介对于一个$n$个元素的数列$a_{1,\\cdots, n}$，求出它的最短线性递推式 即求最小的$m$和对应的$r_1,\\cdots r_m$使得$\\forall i\\in [m+1,n],a_i=\\sum_{j=1}^{m}a_{i-j}r_j$ 很显然使用高斯消元算法可以在$O(n^3)$的时间内求解 而$\\text{Berlekamp-Massey(BM)}$算法是通过依次对于前$i$项构造， 添加每一项时在$O(n)$的时间内找到一个可行的构造方法，将复杂度降低到了$O(n^2)$ \\\\算法过程为了更好描述，设 $r$的阶为$d(r)$ $\\lambda(n,r)=\\sum_{i=1}^{d(r)}a_{n-i}r_i$ $\\Delta(n,r)=a_n-\\lambda (n,r)$ 考虑依次加入每个数$a_i$，设当前$d(r)=m$，上一次的递推是$p$,$p$出现不匹配的位置是$f$ 特别的，初始状态的递推是$r=\\{ \\},f=0$ $1.\\Delta(i,r)=0$，那么不需要扩展 2.$\\Delta(i,r)\\ne 0$ $\\text{i}.m=0$，即插入了第一个$a_i\\ne 0$，初始化$d(r’)=i,r_j=0$，此时显然成立 $\\text{ii}.m\\ne 0$ 我们的构造思路是找到一个$r’$使得$\\forall j\\in[d(r’),i-1],\\lambda(j,r’)=0\\and \\lambda (n,r’)=\\Delta(i-1,r)$ 那么当前合法的转移就是$r+r’$ 设$t=\\frac{\\Delta(n,r)} {\\Delta(f,p)}$ 构造$r’=t \\cdot x^{i-f-1}(1-p)$ 写出来就是 $r’=\\{\\underbrace{0,\\cdots,0},t\\cdot (1-p)\\}$ $ \\ \\ \\ \\ \\ \\ \\ \\ i-f-1$个$0$ $r’=\\{\\underbrace{0,\\cdots,0},t,-t\\cdot p_{1},-t\\cdot p_{2}\\cdots,-t\\cdot p_{d(p)} \\}$ $ \\ \\ \\ \\ \\ \\ \\ \\ i-f-1$个$0$ 此时，$d(r’)=i-f+d(p)$ 当$j\\in [d(r’)+1,i-1]$时，$\\lambda(j,r’)=\\sum_{k=i-f}^{d(r’)}a_{j-k}r’_k$ $=t\\cdot( a_{j-(i-f)}-\\lambda(j-(i-f),p))$ 由于$p$对于$j\\in[d(r’)+1-(i-f),i-1-(i-f)]=[d(p)+1,f-1]$，$p$这个递推式成立 即$\\lambda(j,r’)=0$ 当$j=i$时， $\\lambda(i,r’)=t\\cdot (a_{i-(i-f)}-\\lambda(i-(i-f),p))=t\\cdot \\Delta(f,p)$ 即$\\lambda (i,r’)=\\Delta(n,r)$ 完成了我们想要的构造，所以每次记录上一次的失配位置，即可找到最小递推式 然后，上面的构造方法只满足构造出一个合法的线性递推式，并没有证明是$m$是最小的 但是在OI竞赛中，通常我们只是需要快速求出递推式，并不要求最短线性递推 如果想要看到严谨的证明还请移步2019集训队论文","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「余姚中学 2019 联测 Day 6」解码","slug":"「余姚中学 2019 联测 Day 6」解码","date":"2020-06-11T06:18:31.000Z","updated":"2021-05-22T03:54:11.288Z","comments":true,"path":"articles/2020/06/11/c545b4f2.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/11/c545b4f2.html","excerpt":"","text":"「余姚中学 2019 联测 Day 6」解码先不考虑求$p,q$ 根据人人都知道的欧拉定理$x^c\\equiv x^{c\\mod \\varphi(n)} (\\mod n)$ 那么$\\varphi(n)=(p-1)(q-1)$，而$(c,\\varphi(n))=1$ 所以求出$\\frac{1} {c} \\pmod {\\varphi(n)}$ 带入原来的式子$(x^c)^{\\frac{1} {c}\\pmod {\\varphi(n)} }\\equiv x^1\\pmod n$ 即$x=m^{\\frac{1} {c}\\pmod {\\varphi(n)} }\\pmod n$ 求逆最好用扩展欧几里得算法，复杂度为$O(\\log n)$ 那么直接快速幂即可，但是如果快速幂套快速乘复杂度为$O(\\log ^2)$，实际常数极大，很有可能超时(如果用long double O(1)快速乘另谈。。。) 由于知道$p,q$可以分别求出$m^{\\frac{1} {c}\\pmod {\\varphi(n)} }\\pmod p$，$m^{\\frac{1} {c}\\pmod {\\varphi(n)} }\\pmod q$ 然后中国剩余定理合并，即$O(\\log n)$ 现在问题是求$p,q$ 对于前3档分，由于素数密度是$O(\\log n)$的，所以$\\sqrt n -p$期望只有$\\log n$ 而对于最后一档分，考虑更好表示，枚举$p+q$解出答案，发现 $4n\\leq (p+q)^2= (q-p)^2+4pq\\leq \\lambda^2+4n$ 即$2\\sqrt{n}\\leq (p+q)\\le \\sqrt{\\lambda^2+4n}$ 由于$n\\ge p^2\\ge 10^{18},\\lambda \\leq 3\\cdot 10^5$，这个范围实际非常非常非常非常小，大概只有$22$ tips:实际上$4n$可能爆long long 枚举$p+q$之后，$O(1)$解出$p,q$即可 竟然有人问怎么解$p,q$，我震惊了 $q-p=\\sqrt{(p+q)^2-4n}$，然后判一下是不是整数就好了 写的时候害怕sqrt炸精度，很多奇怪的语句请忽略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;#define reg registertypedef long long ll;typedef unsigned long long ull;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)#define pb push_back#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))template &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; if(a&gt;b) a=b; &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; if(a&lt;b) a=b; &#125;char IO;template&lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=3e5+10;ll n,m,c;ll qmul(ll x,ll k,ll P)&#123; k=(k%P+P)%P; ll res=0; for(;k;k&gt;&gt;=1,x=(x+x)%P) if(k&amp;1) res=(res+x)%P; return res;&#125;ll qpow(ll x,ll k,ll P) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;void Exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0) x=1,y=0; else Exgcd(b,a%b,y,x),y-=a/b*x;&#125;ll Inv(ll a,ll P)&#123; ll x,y; Exgcd(a,P,x,y); return (x%P+P)%P;&#125;int main()&#123; freopen(&quot;rsa.in&quot;,&quot;r&quot;,stdin),freopen(&quot;rsa.out&quot;,&quot;w&quot;,stdout); rep(kase,1,rd()) &#123; n=rd&lt;ll&gt;(),m=rd&lt;ll&gt;(),c=rd&lt;ll&gt;(); ll T=sqrt(n),p=-1,q; for(ll i=T;i&gt;=T-100;--i) if(n%i==0) &#123; p=i,q=n/i; break; &#125; if(p==-1) &#123; // 2*sqrt(n) &lt;= p+q &lt;= sqrt(4*n+lambda * lambda) //ll R=ceil(sqrt((long double)4*n+9e10)+1); ll L=ceil(sqrt(n+0.5)); if((L-1)*(L-1)&gt;=n) L--; for(ll x=2*L;;++x) &#123; ull y=x*x-4*(ull)n; // x=p+q // t=q-p ull t=sqrt(y); if((t+1)*(t+1)==y) t++; if((t-1)*(t-1)==y) t--; if(t*t==y) &#123; p=(x-t)/2; q=(x+t)/2; break; &#125; &#125; &#125; ll t=Inv(c,(p-1)*(q-1)); // t= 1/c (mod phi(n)) ll k1=p,b1=qpow(m%p,t,p); ll k2=q,b2=qpow(m%q,t,q); // k1 x + b1 = k2 y + b2 // k1 x = b2-b1 (mod k2) // x= (b2-b1)/k1; // x&#x27; = (b2-b1)/k1 (mod k2) * k1 + b1 ll inv=qpow(k1,k2-2,k2); b1=(b2-b1)%k2*inv%k2 * k1+b1; k1*=k2; b1=(b1%k1+k1)%k1; printf(&quot;%lld\\n&quot;,b1); &#125;&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"第二类斯特林数","slug":"第二类斯特林数","date":"2020-06-10T05:43:45.000Z","updated":"2021-05-22T03:54:11.399Z","comments":true,"path":"articles/2020/06/10/6040b743.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/10/6040b743.html","excerpt":"","text":"第二类斯特林数$S(n,m): n$个点分成$m$个相同集合 带入定义，递推式为$S(n,m)=S(n-1,m-1)+m\\cdot S(n-1,m)$ 转化$x^n$ $x^n$的组合意义是把$n$个点随意放到$x$个不同位置里，枚举那些位置放了点，则 x^n=\\sum_0^x C(x,i)i!S(n,i)有一些涉及到$x^n\\rightarrow (x+1)^n$可以展开之后带入递推式快速转移 容斥/二项式反演得到 S(n,m)=\\frac{\\sum_{i=0}^m (-1)^{m-i}C(m,i) i^n} {m!}即$S(n,m)$的通项公式 下降幂多项式卷积$x^{\\underline n}=\\frac{x!} {(x-n)!}$ 下降幂多项式$F(x)$的$EGF$是 $EGF(F(x))=\\sum_{i=0}^{\\infty}\\frac{x^i} {i!}\\sum_{j=0}^{n} \\frac{i!} {(i-j)!}\\cdot F_j$ $EGF(F(x))=\\sum_{i=0}^{\\infty}x^i \\sum_{j=0}^{n} \\frac{1} {(i-j)!}\\cdot F_j$ 换一下顺序 $EGF(F(x))=\\sum_{i=0}^{n} F_i \\sum_{j=i}^{\\infty}\\frac{1} {(j-i)!} x^j$ $EGF(F(x))=\\sum_{i=0}^{n} F_i \\cdot x^i \\sum_{j=0}^{\\infty}\\frac{1} {j!} x^j$ $EGF(F(x))=\\sum_{i=0}^{n} F_i \\cdot x^i e^x$ 那么直接卷积就可以得到$F(x)$的$EGF$，然后点值对应相乘 卷回来的时候 $EGF(F(x))=\\sum_{i=0}^{n} F_i \\cdot x^ie^x$ $F_i=\\frac{EGF(F(x))} {x^ie^x}$ 那么就直接卷上$e^{-x}$就可以了 普通多项式转下降幂多项式带入$x^n$的第二类斯特林数展开式，$x^n=\\sum C(x,i)i!S(n,i)=\\sum x^{\\underline i}S(n,i)$ $G(x)=\\sum [x^i]F(x)\\sum x^{\\underline j}S(i,j)$ $G(x)=\\sum [x^i]F(x)\\sum x^{\\underline j}\\sum \\frac{(-1)^{j-k} C(j,k) k^i} {j!}$ $G(x)=\\sum [x^i]F(x)\\sum x^{\\underline j}\\sum \\frac{(-1)^{j-k} k^i} {k!(j-k)!}$ 是一个三元的卷积优化，比较复杂 $i\\rightarrow j,[x^{\\underline j}]G(x)=\\frac{(-1)^{j-k}[x^i]F(x) k^i} {(j-k)!k!}$ 考虑分步优化 Part1 $i\\rightarrow k$先计算出$H(k)=\\sum [x^i]F(x) k^i$ 发现$[x^i]H(x)=F(i)$，多项式多点求值得到 Part2 $k\\rightarrow j$对于已经得到的$H(x)$ $[x^{\\underline j}]G(x)=\\sum \\frac{(-1)^{j-k}[x^k]H(x)} {k!(j-k)!}$ 可以直接卷积得到 下降幂多项式转普通多项式求出$F(x)$的$EGF$，然后带入前$n$项的值，快速插值回来即可","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"多项式Polynomial","slug":"多项式Polynomial","date":"2020-06-10T03:55:24.000Z","updated":"2021-05-22T03:54:11.348Z","comments":true,"path":"articles/2020/06/10/4ee37ab1.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/10/4ee37ab1.html","excerpt":"","text":"多项式Polynomial前置知识$\\text{NTT}$ 所有操作均在对$P=\\text{998244353}$取模下进行 代码在最下面 下文中$\\pmod {x^n}$表示求出了多项式的前$n$项 $[x^i]F(x)$表示$F(x)$第$i$项的系数 每个小问题的模板题都可以在洛谷上找到 1.多项式求乘法逆(为什么叫做乘法逆?因为还有求$G(x)=\\frac{1} {F(x)}\\pmod {M(x)}的$) 求 $G(x)\\equiv \\frac{1} {F(x)} \\pmod {x^n}$ 形象化的理解就是$F(x)\\cdot G(x) \\pmod {x^n}$只有第一项是$1$，其他项都是$0$ 这个由于是第一个操作，很多人还并不是很能理解多项式操作到底是什么东西，所以讲多一点 Part1 O($n^2$)为了便于理解这个问题，先考虑一个最简单的模拟 $[x^i]F\\cdot G(x)=\\sum [x^j]F(x)[x^{i-j}]G(x)$ 第一项$[x^0]G(x)=\\frac{1} {[x^0]F(0)} \\pmod P$，因此求逆的前提条件是$[x^0]F(x)\\ne 0$ 考虑从$1$到$n-1$依次求出每一项，先从前面的项中得到所有$j&gt;0$的和$Sum$，然后带入$j=0$时知道 [x^i]G(x)=-\\frac{Sum=\\sum_{j=1}^{j\\leq i}[x^j]F(x)[x^{i-j}]G(x)} {[x^0]F(0)}\\ Part2 O($n\\log^2n$)上面这个式子是一个类似$dp$转移的东西，可以直接分治NTT优化掉 \\ Part3 $O(n\\log n)$考虑递归求解，设已经求出了 H(x)\\equiv \\frac{1} {F(x)},\\pmod {x^{\\frac{n} {2} }}其中递归边界是$n=1$时,$[x^0]G(x)=\\frac{1} {[x^0]F(0)} \\pmod P$，因此求逆的前提条件是$[x^0]F(x)\\ne 0$ 则 H(x)\\equiv G(x)\\pmod {x^{\\frac{n} {2} }}H(x)-G(x)\\equiv 0\\pmod {x^{\\frac{n} {2} }}我们对于$H(x)-G(x)$平方，结果的前$n$项不可能由两个$\\ge \\frac{n} {2}$的项相乘得到，而前$\\frac{n} {2}$项都是$0$，所以 (H(x)-G(x))^2\\equiv 0\\pmod {x^n}所以通过平方可以扩大模数，这很常用 展开平方的式子 H(x)^2-2G(x)H(x)+G(x)^2\\equiv 0\\pmod {x^n}两边乘上$F(x)$ H(x)^2F(x)-2H(x)+G(x)\\equiv 0\\pmod {x^n}G(x)\\equiv 2H(x)-H(x)^2F(x)\\pmod {x^n}带入这个式子倍增求解即可 分析复杂度，每次有一个$H(x)^2F(x)$，可以通过$NTT$求出，倍增过程中访问的长度是$O(n+\\frac{n} {2}+\\frac{n} {4}…)=O(n)$ 所以总复杂度就是$O(n\\log n)$ \\ 2.多项式开根号求$G(x)^2\\equiv F(x) \\pmod {x^n}$ 同样的，递归求解，设已经求出了，递归边界是$n=1$时,$[x^0]G(x)=\\sqrt{[x^0]F(x)}\\pmod P$ 可以发现我们需要求二次剩余。。。但是一般题目保证了$[x^0]F(x)\\in\\{0,1\\}$ 设已经求出$H(x)^2\\equiv F(x) \\pmod{ x^{\\lceil \\frac{n} {2} \\rceil} }$ H(x)\\equiv G(x) \\pmod {x^{\\lceil \\frac{n} {2}\\rceil} }H(x)^2-2G(x)H(x)+G(x)^2\\equiv 0\\pmod {x^n}H(x)^2-2G(x)H(x)+F(x)\\equiv 0 \\pmod {x^n}G(x)\\equiv \\frac{H(x)^2+F(x)} {2H(x)} \\pmod {x^n}带入这个式子倍增求解即可 复杂度为$O(n\\log n)$ \\ 3.多项式求$\\ln$G(x)\\equiv \\ln F(x) \\pmod {x^n}G'(x)\\equiv F'(x)\\frac{1} {F(x)} \\pmod {x^n}求出$G’(x)$，然后求原函数即可 复杂度为$O(n\\log n)$ \\ 4.多项式求exp(牛顿迭代)把题目转化为，对于函数$f(G)=\\ln G-F$ 求出在$\\mod x^n$意义下的零点 其中$f(x)=\\ln x-c$ 考虑迭代求解，设已经求出$H(x)=e^{F(x)}\\pmod {x^{\\frac{n} {2} }}$ 边界条件是$[x^0]H(x)=e^{[x^0]F(x)}$(由于没有办法求$e^x$在模意义下的值，所以通常必须要满足$[x^0]F(x)=0$) 带入牛顿迭代的结果 G=H-\\frac{f(H)} {f'(H)}=H(F-\\ln H+1)每次求$ln $复杂度和$NTT$相同，所以总复杂度为$O(n\\log n)$ 事实上这个还有优化的余地，就是在求$ln$的时候，多项式逆的部分可以同步倍增求出，不需要每次都倍增一下(但是好像效果并不是特别明显) \\\\ 5.多项式$k$次幂$G(x)\\equiv F(x)^k\\pmod {x^n}$ $\\ln G(x)=k \\ln F(x) \\pmod {x^n}$ 求出$\\ln G(x)$之后，$exp$回来即可 由于要求$ln$，所以这样求的条件是$[x^0]F(x)=1$ 很显然这个方法对于开根号也是适用的 复杂度$O(n\\log n)$ \\\\\\ 6.多项式带余除法可以参考神仙miskcoo的博客 应用：多项式多点求值，常系数线性齐次递推 \\以上是基本运算，如果不想继续吸多项式请直接跳到最下面的代码 多项式与点值式 下降幂多项式初步 \\\\ \\\\\\ 所有的操作均用$\\text{vector} $来实现，主要是为了理清思路，并且清零问题上会比较容易解决，同时对于每次计算完多项式的长度的要求会显得更加严格 稍微整理了一下，没怎么卡过常，所以应该还是比较可读的 代码总览(请使用C++11,O2编译运行) 基本运算的总模板题Loj - 150 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include&lt;bits/stdc++.h&gt;using namespace std;#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define reg registertypedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)#define pb push_backtemplate &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int MaxK=19;const int N=(1&lt;&lt;MaxK)+10,P=998244353;int n,k;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;namespace Polynomial&#123; typedef vector &lt;int&gt; Poly; void Show(Poly a,int k=0)&#123; if(!k)&#123; for(int i:a) printf(&quot;%d &quot;,i); puts(&quot;&quot;); &#125; else for(int i:a) printf(&quot;%d\\n&quot;,i); &#125; int K; int rev[N]; int Mod_Inv[N],Fac[N],FInv[N]; int w[1&lt;&lt;MaxK|10]; void Init_w() &#123; // NTT的系数预处理 K=MaxK; //while((1&lt;&lt;K)&lt;=n+1) K++; int t=qpow(3,(P-1)&gt;&gt;K); K--; w[1&lt;&lt;K]=1; rep(i,(1&lt;&lt;K)+1,(1&lt;&lt;(K+1))-1) w[i]=1ll*w[i-1]*t%P; drep(i,(1&lt;&lt;K)-1,1) w[i]=w[i&lt;&lt;1]; Mod_Inv[0]=Mod_Inv[1]=Fac[0]=Fac[1]=FInv[0]=FInv[1]=1; rep(i,2,(1&lt;&lt;K)) &#123; Mod_Inv[i]=1ll*(P-P/i)*Mod_Inv[P%i]%P; FInv[i]=1ll*FInv[i-1]*Mod_Inv[i]%P; Fac[i]=1ll*Fac[i-1]*i%P; &#125; &#125; int Init(int n)&#123; // 翻转数组预处理 int R=1,cc=-1; while(R&lt;n) R&lt;&lt;=1,cc++; rep(i,1,R-1) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;cc); return R; &#125; void NTT(int n,Poly &amp;a,int f)&#123; // NTT板子 rep(i,0,n-1) if(rev[i]&lt;i) swap(a[i],a[rev[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1) &#123; int *e=w+i; for(int l=0;l&lt;n;l+=i*2) &#123; for(int j=l;j&lt;l+i;++j) &#123; int t=1ll*a[j+i]*e[j-l]%P; a[j+i]=a[j]-t,Mod2(a[j+i]); a[j]+=t,Mod1(a[j]); &#125; &#125; &#125; if(f==-1) &#123; reverse(a.begin()+1,a.begin()+n); ll base=Mod_Inv[n]; rep(i,0,n-1) a[i]=a[i]*base%P; &#125; &#125; Poly operator * (Poly a,Poly b)&#123; int n=a.size()+b.size()-1; int R=Init(n); a.resize(R),b.resize(R); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=1ll*a[i]*b[i]%P; NTT(R,a,-1); a.resize(n); return a; &#125; Poly operator + (Poly a,Poly b) &#123; int n=max(a.size(),b.size()); a.resize(n),b.resize(n); rep(i,0,n-1) a[i]+=b[i],Mod1(a[i]); return a; &#125; Poly operator - (Poly a,Poly b) &#123; int n=max(a.size(),b.size()); a.resize(n),b.resize(n); rep(i,0,n-1) a[i]-=b[i],Mod2(a[i]); return a; &#125; Poly Inv(Poly a) &#123; // 多项式乘法逆，注意这里求出的是前a.size()项 int n=a.size(); if(n==1) return Poly&#123;(int)qpow(a[0],P-2)&#125;; Poly b=a; b.resize((n+1)/2); b=Inv(b); int R=Init(n&lt;&lt;1); a.resize(R),b.resize(R); NTT(R,a,1),NTT(R,b,1); rep(i,0,R-1) a[i]=(2-1ll*a[i]*b[i]%P+P)*b[i]%P; NTT(R,a,-1); a.resize(n); return a; &#125; Poly operator / (Poly a,Poly b)&#123; // 多项式带余除法 reverse(a.begin(),a.end()),reverse(b.begin(),b.end()); int n=a.size(),m=b.size(); a.resize(n-m+1),b.resize(n-m+1),b=Inv(b); a=a*b,a.resize(n-m+1); reverse(a.begin(),a.end()); return a; &#125; Poly operator % (Poly a,Poly b) &#123; // 多项式取模 int n=b.size()-1; if((int)a.size()&lt;=n) return a; Poly t=a/b; if((int)t.size()&gt;n) t.resize(n); t=t*b; t.resize(n); a.resize(n); return a-t; &#125; int Quad(int a,int k=0) &#123; // 二次剩余(不是原根法),用于求Sqrt if(a&lt;=1) return a; ll x; while(1) &#123; x=1ll*rand()*rand()%P; if(qpow((x*x-a+P)%P,(P-1)/2)!=1) break; &#125; ll w=(x*x-a+P)%P; ll rx=1,ry=0,xx=x,xy=1,tx,ty; int d=(P+1)/2; while(d) &#123; if(d&amp;1) &#123; tx=(rx*xx+ry*xy%P*w)%P,ty=(rx*xy+ry*xx)%P; rx=tx,ry=ty; &#125; tx=(xx*xx+xy*xy%P*w)%P,ty=2*xx*xy%P; xx=tx,xy=ty; d&gt;&gt;=1; &#125; ll res=(rx%P+P)%P; if(k) res=min(res,(P-res)%P); return res; &#125; Poly Sqrt(Poly a)&#123; // 多项式开根号 int n=a.size(); if(n==1) return Poly&#123;Quad(a[0],1)&#125;; Poly b=a; b.resize((n+1)/2),b=Sqrt(b),b.resize(n); Poly c=Inv(b); int R=Init(n*2); a.resize(R),c.resize(R); NTT(R,a,1),NTT(R,c,1); rep(i,0,R-1) a[i]=1ll*a[i]*c[i]%P; NTT(R,a,-1); a.resize(n); rep(i,0,n-1) a[i]=1ll*(P+1)/2*(a[i]+b[i])%P; return a; &#125; Poly Deri(Poly a)&#123; //求导 rep(i,1,a.size()-1) a[i-1]=1ll*i*a[i]%P; a.pop_back(); return a; &#125; Poly IDeri(Poly a) &#123; //原函数 a.pb(0); drep(i,a.size()-1,1) a[i]=1ll*a[i-1]*Mod_Inv[i]%P; a[0]=0; return a; &#125; Poly Ln(Poly a)&#123; // 多项式求Ln int n=a.size(); a=Inv(a)*Deri(a),a.resize(n-1); return IDeri(a); &#125; Poly Exp(Poly a)&#123; // 多项式Exp int n=a.size(); if(n==1) return Poly&#123;1&#125;; Poly b=a; b.resize((n+1)/2),b=Exp(b); b.resize(n); Poly c=Ln(b); rep(i,0,n-1) c[i]=a[i]-c[i],Mod2(c[i]); c[0]++,b=b*c; b.resize(n); return b; &#125; Poly Pow(Poly x,int k) &#123; // 多项式k次幂 x=Ln(x); rep(i,0,x.size()-1) x[i]=1ll*x[i]*k%P; return Exp(x); &#125; Poly EvaluateTemp[N&lt;&lt;1]; void EvaluateSolve1(Poly &amp;a,int l,int r,int p=1)&#123; if(l==r) &#123; EvaluateTemp[p]=Poly&#123;P-a[l],1&#125;; return; &#125; int mid=(l+r)&gt;&gt;1; EvaluateSolve1(a,l,mid,p&lt;&lt;1),EvaluateSolve1(a,mid+1,r,p&lt;&lt;1|1); EvaluateTemp[p]=EvaluateTemp[p&lt;&lt;1]*EvaluateTemp[p&lt;&lt;1|1]; &#125; void EvaluateSolve2(Poly &amp;res,Poly F,int l,int r,int p=1)&#123; if(l==r)&#123; res[l]=F[0]; return; &#125; int mid=(l+r)&gt;&gt;1; EvaluateSolve2(res,F%EvaluateTemp[p&lt;&lt;1],l,mid,p&lt;&lt;1); EvaluateSolve2(res,F%EvaluateTemp[p&lt;&lt;1|1],mid+1,r,p&lt;&lt;1|1); &#125; Poly Evaluate(Poly a,Poly b,int flag=1)&#123; // 多项式多点求值 Poly res(b.size()); if(flag) EvaluateSolve1(b,0,b.size()-1); EvaluateSolve2(res,a,0,b.size()-1); return res; &#125; Poly InterpolationSolve(Poly &amp;T,int l,int r,int p=1)&#123; if(l==r) return Poly&#123;T[l]&#125;; int mid=(l+r)&gt;&gt;1; return InterpolationSolve(T,l,mid,p&lt;&lt;1)*EvaluateTemp[p&lt;&lt;1|1]+InterpolationSolve(T,mid+1,r,p&lt;&lt;1|1)*EvaluateTemp[p&lt;&lt;1]; &#125; Poly Interpolation(Poly X,Poly Y)&#123; // 多项式快速插值 int n=X.size(); EvaluateSolve1(X,0,n-1); Poly T=Evaluate(Deri(EvaluateTemp[1]),X,0); rep(i,0,n-1) T[i]=Y[i]*qpow(T[i])%P; return InterpolationSolve(T,0,n-1); &#125; void FFPTrans(Poly &amp;a,int f)&#123; // FFP&lt;-&gt;EGF int n=a.size(); Poly b(n); if(f==1) rep(i,0,n-1) b[i]=FInv[i]; else rep(i,0,n-1) b[i]=(i&amp;1)?P-FInv[i]:FInv[i]; a=a*b; a.resize(n); &#125; Poly FFPMul(Poly a,Poly b)&#123; // FFP卷积 int n=a.size()+b.size()-1; a.resize(n),b.resize(n); FFPTrans(a,1),FFPTrans(b,1); rep(i,0,n-1) a[i]=1ll*a[i]*b[i]%P*Fac[i]%P; FFPTrans(a,-1); return a; &#125; Poly PolyToFFP(Poly F)&#123; // 多项式转FFP int n=F.size(); Poly G(n); rep(i,0,n-1) G[i]=i; G=Evaluate(F,G); rep(i,0,n-1) F[i]=1ll*G[i]*FInv[i]%P; FFPTrans(F,-1); return F; &#125; Poly FFPToPoly(Poly F)&#123; // FFP转多项式 FFPTrans(F,1); int n=F.size(); Poly X(n); rep(i,0,n-1) X[i]=i,F[i]=1ll*F[i]*Fac[i]%P; EvaluateSolve1(X,0,n-1); rep(i,0,n-1) &#123; F[i]=1ll*F[i]*FInv[i]%P*FInv[n-i-1]%P; if((n-i-1)&amp;1) F[i]=(P-F[i])%P; &#125; return InterpolationSolve(F,0,n-1); &#125;&#125;using namespace Polynomial;int main()&#123; int n=rd(); Init_w(); Poly F(n); rep(i,0,n-1) F[i]=rd(); Show(PolyToFFP(F));&#125; \\\\\\","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「余姚中学 2019 联测 Day 4」随机除法","slug":"「余姚中学 2019 联测 Day 4」随机除法","date":"2020-06-08T04:07:42.000Z","updated":"2021-05-22T03:54:11.286Z","comments":true,"path":"articles/2020/06/08/3f20d38a.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/08/3f20d38a.html","excerpt":"","text":"「余姚中学 2019 联测 Day 4」随机除法好题，难就难在转移的高位前缀和 首先是一个浅显的$\\text{dp}$状态，令$n=\\Pi prime_i^{c_i}$ 则状态只跟$\\{c_i\\}$有关，这是一个可重集合，强制定义$c_i\\ge c_{i-1}$最小表示出所有不同状态 搜索一下$\\text{dp}$状态，发现只有$170000$左右的状态数 直接枚举因数转移复杂度显然是升天的，直接枚举子集状态转移复杂度也很高，并且不好确定系数 所以用一个高位前缀和处理优化枚举因数的转移 再说一遍，是高位前缀和枚举因数的转移，不同的因数可能对应同一个状态 常见的高位前缀和是$dp_{i,S}=dp_{i-1,S}+dp_{i,S-\\{S_i\\} }$ 转移具有单调性，对于状态排序之后，定义辅助数组$dp_{i,j}$表示对于$i$这个状态 它的子集(注意这个子集是未排序的)中和它不同的最低位置$\\ge j$的总和 计算高位前缀和时，每次转移只会对于一个位置改变 枚举状态时，取得位置是$j$，调用时需要排序 而排完序之后$j$可能会后移，所以需要定义成$\\ge j$的，否则会算多 比如转移$(1,1,1)\\leftarrow (0,1,1),(1,0,1),(1,1,0)$ 如果定义成$\\le j$的状态，三种状态转移之后都变成$(1,1,0)$ 原先在这个状态里的三个位置编号是$(0,1,2)$ 如果都去$(1,1,0)$这个状态里转移过来，原先$(0,1,2)$对应的下标位置改变，变成 $(1,2,0)$ $(0,2,1)$ $(0,1,2)$ 我们访问的时候访问的应该是子状态中不同位置$\\le j$的总和 而从这个下标改变的状态里转移过来时，原先$&gt;j$的下标被移移动进$\\le j$的范围 再转移就错了 所以正确定义状态之后就可以高位前缀和了 存储和访问状态可以用$\\text{Hash,Trie,int128}$三种方法存储，$\\text{int128}$真香啊 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef __int128 Node;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))const int N=180000,P=1e9+7;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res; &#125;Node Max,st[N];int m,a[100],cnt,dp[N][20],F[N],pri[]=&#123;0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79&#125;;char str[30];int Find(Node s)&#123; return lower_bound(st+1,st+cnt+1,s)-st; &#125;void Load(Node s)&#123; rep(i,1,20) a[i]=0; for(int i=1;i&lt;=20 &amp;&amp; s&gt;1; ++i) while(s%pri[i]==0) s=s/pri[i],a[i]++;&#125;void dfs(int p,int lst,Node s) &#123; st[++cnt]=s; rep(i,1,lst) &#123; if((s*=pri[p])&gt;Max) return; dfs(p+1,i,s); &#125;&#125;int main()&#123; freopen(&quot;div.in&quot;,&quot;r&quot;,stdin),freopen(&quot;div.out&quot;,&quot;w&quot;,stdout); Max=1e12,Max=Max*Max; dfs(1,100,1); fprintf(stderr,&quot;States Number = %d\\n&quot;,cnt); sort(st+1,st+cnt+1); rep(i,2,cnt) &#123; Node now; Load(now=st[i]); int c=1; rep(i,1,18) c=1ll*c*(a[i]+1)%P; drep(j,18,0) &#123; if(!a[j]) dp[i][j]=dp[i][j+1]; else &#123; int k=j; while(k&gt;1 &amp;&amp; a[k-1]==a[k]) --k; int p=Find(now/pri[j]); drep(d,j,k) &#123; dp[i][d]=dp[i][d+1]+dp[p][d]; Mod1(dp[i][d]); &#125; j=k; &#125; &#125; F[i]=(dp[i][1]+c)*qpow(c-1)%P; rep(j,1,18) dp[i][j]+=F[i],Mod1(dp[i][j]); &#125; while(~scanf(&quot;%s%d&quot;,str,&amp;m)) &#123; Node n=0; for(int i=0;str[i];++i) n=n*10+(str[i]-&#x27;0&#x27;); rep(i,1,m) &#123; int x;scanf(&quot;%d&quot;,&amp;x); a[i]=0; while(n%x==0) n=n/x,a[i]++; &#125; sort(a+1,a+m+1,greater &lt;int&gt; ()); n=1; rep(i,1,m) rep(j,1,a[i]) n=n*pri[i]; printf(&quot;%d\\n&quot;,F[Find(n)]); &#125;&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"类欧几里得","slug":"类欧几里得","date":"2020-06-05T05:57:27.000Z","updated":"2021-05-22T03:54:11.403Z","comments":true,"path":"articles/2020/06/05/e2a238e9.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/05/e2a238e9.html","excerpt":"","text":"类欧几里得对于给定的元$a,b,c,n$ 设$f(i)=\\lfloor\\frac{ai+b} {c}\\rfloor$ 求 F(a,b,c,n)=\\sum_0^nf(i)G(a,b,c,n)=\\sum_0^nf(i)^2H(a,b,c,n)=\\sum_0^ni\\cdot f(i)Part1$a\\ge c$ 或 $b\\ge c$\\lfloor\\frac{ai+b} {c}\\rfloor=\\lfloor\\frac{(a \\mod c)i+(b \\mod c)} {c}\\rfloor+i\\lfloor \\frac{a} {c}\\rfloor +\\lfloor \\frac{b} {c}\\rfloorF(a,b,c,n)=F(a\\mod c,b\\mod c,c,n)+\\frac{n(n+1)\\lfloor\\frac{a} {c}\\rfloor} {2}+(n+1)\\lfloor\\frac{b} {c}\\rfloor$a&lt;c$ 且 $b&lt;c$F(a,b,c,n) =\\sum_0^n f(i)= \\sum_{i=0}^n\\sum_{j=0}^{f(i)-1} 1= \\sum_{i=0}^n\\sum_{j=0}^{\\infty}[j","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"[SweetFruits TopCoder - 12141](Matrix-Tree)","slug":"[SweetFruits TopCoder - 12141](Matrix-Tree)","date":"2020-06-04T08:17:09.000Z","updated":"2021-05-22T03:54:11.080Z","comments":true,"path":"articles/2020/06/04/58ead950.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/04/58ead950.html","excerpt":"","text":"SweetFruits TopCoder - 12141(Matrix-Tree)问题看起来很复杂，不可写，所以先考虑分解一下 假设最后生效的点集为$V$，那么答案只和$\\sum sweetness[V_i]$和$|V|$有关 所以可以考虑对于每一种$|V|$，先预处理出方案数 得知每一种$|V|$的方案数之后，可以用$\\text{meet in the middle}$法枚举得到$\\sum sweetness[V_i]\\leq maxsweetness$的方案数 方案数是有限制的生成树个数，所以考虑用$\\text{Matrix-Tree}$求 限定有$a$个点生效，$b$个点不生效，$c$个点是$-1$ 那么可能出现的边是$a-a,a-c,b-c$三种 但是我们无法保证$a$中的点一定生效，所以可以用容斥/二项式反演得到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;using namespace std;#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define reg registertypedef long long ll;#define rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)#define pb push_backtemplate &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=50,P=1e9+7;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int n,m;struct Mat&#123; int a[N][N]; Mat()&#123; memset(a,0,sizeof a); &#125; int Det(int n)&#123; // 用于Matrix-Tree的 static int G[N][N]; rep(i,1,n) rep(j,1,n) G[i][j]=a[i][j]; int res=1; rep(i,1,n) &#123; if(!G[i][i]) rep(j,i+1,n) if(G[j][i])&#123; res=P-res; swap(G[i],G[j]); break; &#125; if(!G[i][i]) continue; ll Inv=qpow(a[i][i]); rep(j,i+1,n) &#123; ll t=a[j][i]*Inv%P; rep(k,i,n) a[j][k]=(a[j][k]-1ll*a[i][k]*t%P+P)%P; &#125; &#125; rep(i,1,n) res=1ll*res*a[i][i]%P; return res; &#125;&#125;;int w[N],G[N][N],C[N][N];void Init()&#123; rep(i,0,N-1) rep(j,C[i][0]=1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P; rep(i,0,n) &#123; Mat T; rep(j,1,m) &#123; // -1 rep(k,1,n+m) T.a[j][k]=-1; T.a[j][j]=n+m-1; &#125; rep(j,m+1,m+i) &#123; // 生效 rep(k,1,m+i) if(j!=k) T.a[j][k]=-1; T.a[j][j]=m+i-1; &#125; rep(j,m+i+1,m+n) &#123; // 不生效 rep(k,1,m) T.a[j][k]=-1; T.a[j][j]=m; &#125; w[i]=T.Det(n+m-1); &#125; rep(i,0,n) rep(j,0,i-1) w[i]=(w[i]-1ll*C[i][j]*w[j]%P+P)%P; // 容斥/二项式反演&#125;int val[N];vector &lt;int&gt; st[N/2];int Meet_In_The_Middle(int Max)&#123; int ans=0,mid=n/2; rep(i,0,mid) st[i].clear(); rep(S,0,(1&lt;&lt;mid)-1) &#123; int c=0,s=0; rep(i,0,mid-1) if(S&amp;(1&lt;&lt;i)) s+=val[i],c++; if(s&lt;=Max) st[c].pb(s); &#125; rep(i,0,mid) sort(st[i].begin(),st[i].end()); rep(S,0,(1&lt;&lt;(n-mid))-1) &#123; int c=0,s=0; rep(i,0,n-mid-1) if(S&amp;(1&lt;&lt;i)) s+=val[i+mid],c++; if(s&gt;Max) continue; rep(j,0,mid) &#123; int x=upper_bound(st[j].begin(),st[j].end(),Max-s)-st[j].begin(); if(x) ans=(ans+1ll*x*w[c+j])%P; &#125; &#125; return ans;&#125;class SweetFruits &#123;public: int countTrees(vector &lt;int&gt; Val, int Max) &#123; sort(Val.begin(),Val.end(),greater &lt;int&gt; ()); m=0; while(Val.size() &amp;&amp; *Val.rbegin()==-1) m++,Val.pop_back(); n=Val.size(); rep(i,0,n-1) val[i]=Val[i]; Init(); return Meet_In_The_Middle(Max); &#125;&#125;;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://chasingdeath.github.io/tags/Atcoder/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"[CosmicBlocks - TopCoder- 12034] (网络流)","slug":"[CosmicBlocks - TopCoder- 12034] (网络流)","date":"2020-06-04T05:19:46.000Z","updated":"2021-05-22T03:54:11.044Z","comments":true,"path":"articles/2020/06/04/79697e32.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/04/79697e32.html","excerpt":"","text":"CosmicBlocks - TopCoder- 12034 (网络流)注意题目定义的同构是存在不同的颜色覆盖关系，而不是存在不同的排列顺序 所以先枚举每一层放了那些颜色，再枚举那些颜色之间有覆盖 每一层的颜色划分数很少，最多可能同时存在的覆盖关系是$9$种，枚举复杂度最多是$2^9$，然后可以$2^n\\cdot n\\ \\text{dp}$出拓扑序列的个数 问题在于如何快速又方便地判断对于当前情况是否存在方案 一种方法是上下界网络流 按照层之间的关系，覆盖关系就连$[1,+\\infty)$的边，同时源点向$1$层的点连$[0,+\\infty)$的边，每个点都向汇点连$[0,\\infty)$的边 注意由于要限制流过每个点的流量，每个点要拆成两个点中间连$[num_i,num_i]$的边 最后判断一下有源汇可行流即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;bits/stdc++.h&gt;using namespace std;#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define reg registertypedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)#define pb push_backtemplate &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;static const int N=20,INF=1e8+10;int n,m,ans,L,R;int cnt[N],id[N];vector &lt;int&gt; G[N];int GS[N];vector &lt;int&gt; Layer[N];int Calc_DAG() &#123; // 计算拓扑序列的个数 static int dp[1&lt;&lt;6]; int A=(1&lt;&lt;n)-1; rep(i,0,A) dp[i]=0; dp[0]=1; rep(S,0,A-1) rep(i,0,n-1) if((~S&amp;(1&lt;&lt;i)) &amp;&amp; (S&amp;GS[i+1])==GS[i+1]) dp[S|(1&lt;&lt;i)]+=dp[S]; return dp[A];&#125;int ind[N];struct Limited_Flow&#123; // 有源汇可行流 static const int M=300; int S,T; struct Edge&#123; int to,nxt,w; &#125; e[M]; int head[N],ecnt; void clear()&#123; rep(i,1,n*2+4) head[i]=0; ecnt=0; &#125; #define erep(u,i) for(int i=head[u];i;i=e[i].nxt) void AddEdge(int u,int v,int w) &#123; e[ecnt]=(Edge)&#123;v,head[u],w&#125;,head[u]=ecnt++; &#125; void Link(int u,int v,int w)&#123; AddEdge(u,v,w),AddEdge(v,u,0); &#125; int dis[N]; int Bfs()&#123; static queue &lt;int&gt; que; rep(i,1,T) dis[i]=INF; dis[S]=0,que.push(S); while(!que.empty()) &#123; int u=que.front(); que.pop(); erep(u,i) &#123; int v=e[i].to,w=e[i].w; if(!w || dis[v]&lt;=dis[u]+1) continue; dis[v]=dis[u]+1,que.push(v); &#125; &#125; return dis[T]&lt;INF; &#125; int Dfs(int u,int flowin)&#123; if(u==T) return flowin; int flowout=0; erep(u,i) &#123; int v=e[i].to,w=e[i].w; if(!w || dis[v]!=dis[u]+1) continue; int t=Dfs(v,min(flowin-flowout,w)); e[i].w-=t,e[i^1].w+=t,flowout+=t; if(flowin==flowout) break; &#125; if(!flowout) dis[u]=0; return flowout; &#125; int Dinic()&#123; int ans=0; while(Bfs()) ans+=Dfs(S,INF); return ans; &#125; int Check()&#123; erep(S,i) if(e[i].w) return 0; erep(T,i) if(e[i^1].w) return 0; return 1; &#125;&#125; Flow;void Extend_Edge(int u,int v,int L,int R)&#123; ind[u]-=L,ind[v]+=L; Flow.Link(u,v,R-L);&#125;int Check()&#123; rep(i,1,n*2+4) ind[i]=0; Flow.clear(); rep(i,1,n) Extend_Edge(i*2-1,i*2,cnt[i],cnt[i]); rep(i,1,n) if(id[i]==1) Extend_Edge(n*2+1,i*2-1,cnt[i],cnt[i]); rep(u,1,n) for(int v:G[u]) Extend_Edge(u*2,v*2-1,1,INF); rep(i,1,n) Extend_Edge(i*2,n*2+2,0,INF); Extend_Edge(n*2+2,n*2+1,0,INF); rep(i,1,n*2+2) &#123; if(ind[i]&gt;0) Flow.Link(n*2+3,i,ind[i]); if(ind[i]&lt;0) Flow.Link(i,n*2+4,-ind[i]); &#125; Flow.S=n*2+3,Flow.T=n*2+4; Flow.Dinic(); return Flow.Check();&#125;void Dfs_GetDAG(int p) &#123; // dfs枚举覆盖关系 if(p==n+1) &#123; int Ways=Calc_DAG(); if(Ways&lt;L || Ways&gt;R) return; ans+=Check(); return; &#125; if(id[p]==m) return Dfs_GetDAG(p+1); int n=Layer[id[p]+1].size(); rep(S,0,(1&lt;&lt;n)-1) &#123; rep(i,0,n-1) if(S&amp;(1&lt;&lt;i)) G[p].pb(Layer[id[p]+1][i]),GS[p]|=1&lt;&lt;(Layer[id[p]+1][i]-1); Dfs_GetDAG(p+1); G[p].clear(),GS[p]=0; &#125;&#125;void Dfs_Getlayer(int num,int fir,int chosennumber)&#123; // dfs枚举层的情况 if(chosennumber==n) &#123; m=num; rep(i,1,m) Layer[i].clear(); rep(i,1,n) Layer[id[i]].pb(i); Dfs_GetDAG(1); return; &#125; rep(i,fir,n) if(!id[i]) &#123; id[i]=num; Dfs_Getlayer(num,i+1,chosennumber+1); id[i]=0; &#125; if(fir!=1) Dfs_Getlayer(num+1,1,chosennumber);&#125;class CosmicBlocks &#123;public: int getNumOrders(vector &lt;int&gt; a, int Min, int Max) &#123; L=Min,R=Max; n=a.size(),ans=0; rep(i,0,n-1) cnt[i+1]=a[i]; Dfs_Getlayer(1,1,0); return ans; &#125;&#125;;//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"[BZOJ1852] [MexicoOI06]最长不下降序列(贪心)","slug":"[BZOJ1852] [MexicoOI06]最长不下降序列(贪心)","date":"2020-06-02T13:52:27.000Z","updated":"2021-05-22T03:54:11.019Z","comments":true,"path":"articles/2020/06/02/f85684e1.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/02/f85684e1.html","excerpt":"","text":"[BZOJ1852] [MexicoOI06]最长不下降序列(贪心)考虑如下贪心 （我将问题反过来考虑，也就是要满足$A_i &gt; \\max_{j=1}^{j &lt; i} {B_j}$） 首先对于读入的$(A,B)$，按照$B$的值递增排序 (选出的答案序列不一定是其中一个有序的子序列) 答案序列存在若干个$B$递增的位置，设它们是$\\{a_i\\},a_{i-1}&lt;a_i$ 合法的递增序列需要满足的限制是$A_{a_i}&gt;B_{a_{i-1} }$ 考虑剩下的部分即$j\\in[a_{i-1}+1,a_i-1]$，那么这些点放在$a_i$后面一定是最优的(因为此时不会改变最大的$B$)，此时限制它们的$B$就是$B_{a_i}$ 即这一部分中满足$A_j&gt;B_{a_i}$的$j$均可以选出来 为了便于表示，设$C(l,r)=|\\{i|i\\in[l,r],A_i&gt;B_{r+1} \\}|$，可以通过一个主席树维护 定义$dp_i$表示当前以$i$为最大的$B$的答案，特别的，$dp_0$表示序列为空$A_0=B_0=-\\infty$ 枚举每个$i$进行转移 朴素的转移就是可以枚举上一个位置$j$，$O(n^2)$转移 需要找到前面第一个能把$i$接上去的$j$即可，即第一个$B_r&lt;A_i(j\\ge 0)$的位置，那么合法的决策位置就是$[0,r]$ 则$dp_i=\\max_0^r\\{dp_j+1+C(j+1,i-1)\\}$ 设最优决策点为$k\\in[0,r]$，影响最优决策点位置的有两个方面 从$[j+1,i-1]$这一段点考虑，$j$越小时，就会有越多的点对被$B_i$限制，也就是说$j$越大，对于中间这一段来说越优 但是从$dp_j$的角度考虑，并不是$j$越大越好，因为可能存在一个$A_j$特别小限制了前面递增点列的选择 推论：如果前面存在一个$A_j&gt;B_i$，那么$k\\ge j$ 事实上应该说成$dp_j+C(j+1,i-1)\\ge\\forall d\\in[0,j-1],dp_d+C(d+1,i-1)$ 综合上面两条来看，如果$A_j&gt;B_i$意味着把它放进递增序列里绝对是优的，因为不会对前面的点产生不良限制 消除了不良限制之后，就满足最优性了 所以发现最优决策点的范围缩小到了$[l=max\\{k|A_k&gt;B_i\\},r]$ 发现决策范围内的$C(l+1,i-1)=C(l+2,i-1)=\\cdots=C(r+1,i-1)$ 所以$dp_i=\\max_l^r\\{dp_j\\}+C(r+1,i-1)=max_0^r\\{dp_j\\}+C(r+1,i-1)$ 所以可以直接维护一个前缀最大值，每次二分找到那个$r$，求出$C(r+1,i-1)$即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const int N=2e5+10,K=15; int n; struct Node&#123; int a,b; bool operator &lt; (const Node __) const &#123; return b&lt;__.b; &#125;&#125;A[N];int h[N],hc;int dp[N]; int rt[N*K],s[N*K],ls[N*K],rs[N*K],cnt;void Add(int p,int pre,int l,int r,int x) &#123; s[p]=s[pre]+1; if(l==r) return; int mid=(l+r)&gt;&gt;1; ls[p]=ls[pre],rs[p]=rs[pre]; x&lt;=mid?Add(ls[p]=++cnt,ls[pre],l,mid,x):Add(rs[p]=++cnt,rs[pre],mid+1,r,x);&#125; int Que(int pl,int pr,int l,int r,int ql,int qr) &#123; if(ql&gt;qr) return 0; if(ql==l&amp;&amp;qr==r) return s[pr]-s[pl]; int mid=(l+r)&gt;&gt;1; if(qr&lt;=mid) return Que(ls[pl],ls[pr],l,mid,ql,qr); else if(ql&gt;mid) return Que(rs[pl],rs[pr],mid+1,r,ql,qr); else return Que(ls[pl],ls[pr],l,mid,ql,mid)+Que(rs[pl],rs[pr],mid+1,r,mid+1,qr);&#125; int main()&#123; rep(i,1,n=rd()) &#123; A[i].a=rd(),A[i].b=rd(); h[++hc]=A[i].a,h[++hc]=A[i].b; &#125; sort(h+1,h+hc+1),hc=unique(h+1,h+hc+1)-h-1; sort(A+1,A+n+1); rep(i,1,n) &#123; A[i].a=lower_bound(h+1,h+hc+1,A[i].a)-h; A[i].b=lower_bound(h+1,h+hc+1,A[i].b)-h; Add(rt[i]=++cnt,rt[i-1],1,hc,A[i].a); &#125; rep(i,1,n) &#123; int l=1,r=i-1,res=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(A[mid].b&lt;A[i].a) l=mid+1,res=mid; else r=mid-1; &#125; dp[i]=max(dp[i-1],dp[res]+1+Que(rt[res],rt[i-1],1,hc,A[i].b+1,hc)); &#125; int ans=dp[n]; printf(&quot;%d\\n&quot;,ans);&#125; 附：离线做法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;using namespace std;#define reg registertypedef long long ll;#define rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)char IO;int rd()&#123; int s=0,f=0; while(!isdigit(IO=getchar())) f|=(IO==&#x27;-&#x27;); do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=2e5+10,K=15;int n;struct Node&#123; int a,b; bool operator &lt; (const Node __)const&#123; return b&lt;__.b; &#125;&#125;A[N];struct Query&#123; int x,p,id,k; bool operator &lt; (const Query __)const&#123; return p&lt;__.p; &#125;&#125;Q[N&lt;&lt;1];int qc,h[N],hc,dp[N];int L[N],Ans[N];int s[N];void Add(int p,int x)&#123; while(p) s[p]+=x,p-=p&amp;-p; &#125;int Que(int p)&#123; int res=0; while(p&lt;=hc) res+=s[p],p+=p&amp;-p; return res;&#125;int main()&#123; rep(i,1,n=rd()) &#123; A[i].a=rd(),A[i].b=rd(); h[++hc]=A[i].a,h[++hc]=A[i].b; &#125; sort(h+1,h+hc+1),hc=unique(h+1,h+hc+1)-h-1; sort(A+1,A+n+1); rep(i,1,n) &#123; A[i].a=lower_bound(h+1,h+hc+1,A[i].a)-h; A[i].b=lower_bound(h+1,h+hc+1,A[i].b)-h; &#125; rep(i,1,n) &#123; int l=1,r=i-1,res=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(A[mid].b&lt;A[i].a) l=mid+1,res=mid; else r=mid-1; &#125; L[i]=res; if(i-1&gt;L[i]) Q[++qc]=(Query)&#123;A[i].b+1,i-1,i,1&#125;,Q[++qc]=(Query)&#123;A[i].b+1,L[i],i,-1&#125;; &#125; sort(Q+1,Q+qc+1); int p=1; rep(i,0,n) &#123; if(i) Add(A[i].a,1); while(p&lt;=qc &amp;&amp; Q[p].p&lt;=i) Ans[Q[p].id]+=Q[p].k*Que(Q[p].x),p++; &#125; rep(i,1,n) dp[i]=max(dp[i-1],dp[L[i]]+1+Ans[i]); int ans=dp[n]; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「SDOI2017」树点涂色(LCT+线段树)","slug":"「SDOI2017」树点涂色(LCT+线段树)","date":"2020-06-02T10:46:30.000Z","updated":"2021-05-22T03:54:11.247Z","comments":true,"path":"articles/2020/06/02/1cf68a90.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/02/1cf68a90.html","excerpt":"","text":"「SDOI2017」树点涂色(LCT+线段树)可以发现更新操作就是$\\text{LCT}$的$\\text{Access}$操作，这个操作复杂度是$O(n\\log n)$的 因此，考虑对于每次的$\\text{Access}$操作，维护每个点到根的路径上不同的权值个数 每次$\\text{Access}$操作只设计到合并两个链/断开一条链两种操作，可以通过线段树维护子树修改 那么修改的复杂度就是$O(n\\log^2 n)$ 对于二操作，自己模拟一下就知道，就是两个点的答案-2$\\cdot \\text{LCA}$答案+1 实现上有一些细节，就是更新的子树根节点是需要查询得到的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697const int N=1e5+10;int n,m;vector &lt;int&gt; G[N];int L[N],R[N],dfn;int son[N][2],fa[N],tfa[N][18],dep[N],id[N];int s[N&lt;&lt;2],t[N&lt;&lt;2],mi[N];void Upd(int p,int l,int r,int ql,int qr,int x) &#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; t[p]+=x; return; &#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid) Upd(p&lt;&lt;1,l,mid,ql,qr,x); if(qr&gt;mid) Upd(p&lt;&lt;1|1,mid+1,r,ql,qr,x); s[p]=max(t[p&lt;&lt;1]+s[p&lt;&lt;1],t[p&lt;&lt;1|1]+s[p&lt;&lt;1|1]);&#125;int Que(int p,int l,int r,int ql,int qr) &#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) return s[p]+t[p]; int mid=(l+r)&gt;&gt;1,res=-1e9; if(ql&lt;=mid) cmax(res,Que(p&lt;&lt;1,l,mid,ql,qr)); if(qr&gt;mid) cmax(res,Que(p&lt;&lt;1|1,mid+1,r,ql,qr)); return res+t[p];&#125;int Que(int p,int l,int r,int x) &#123; int res=0; while(1) &#123; if(l==r) return res+s[p]+t[p]; int mid=(l+r)&gt;&gt;1; res+=t[p]; if(x&lt;=mid) p&lt;&lt;=1,r=mid; else p=p&lt;&lt;1|1,l=mid+1; &#125;&#125;void Build(int p,int l,int r) &#123; if(l==r) &#123; s[p]=dep[id[l]]+1; return; &#125; int mid=(l+r)&gt;&gt;1; Build(p&lt;&lt;1,l,mid),Build(p&lt;&lt;1|1,mid+1,r); s[p]=max(s[p&lt;&lt;1],s[p&lt;&lt;1|1]);&#125;int dir(int x)&#123; return son[fa[x]][1]==x; &#125;int isroot(int x)&#123; return !fa[x] || (son[fa[x]][0]!=x &amp;&amp; son[fa[x]][1]!=x); &#125; void Up(int p) &#123; mi[p]=son[p][0]?mi[son[p][0]]:p; &#125;void rotate(int u) &#123; int f=fa[u],ff=fa[f],d=dir(u); fa[u]=ff; if(!isroot(f)) son[ff][dir(f)]=u; son[f][d]=son[u][!d]; if(son[u][!d]) fa[son[u][!d]]=f; son[u][!d]=f,fa[f]=u; Up(f),Up(u);&#125;void Splay(int x)&#123; for(;!isroot(x);rotate(x)) if(!isroot(fa[x])) rotate((dir(x)^dir(fa[x]))?x:fa[x]); &#125;void Access(int x) &#123; for(int t=0,y;x;t=x,x=fa[x]) &#123; Splay(x),y=son[x][1]; if(y) Upd(1,1,n,L[mi[y]],R[mi[y]],1); if(t) Upd(1,1,n,L[mi[t]],R[mi[t]],-1); son[x][1]=t,Up(x); &#125;&#125; // LCT模板void dfs(int u,int f) &#123; mi[u]=u,fa[u]=tfa[u][0]=f,id[L[u]=++dfn]=u; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];++i) tfa[u][i]=tfa[tfa[u][i-1]][i-1]; for(int v:G[u]) if(v!=f) dep[v]=dep[u]+1,dfs(v,u); R[u]=dfn;&#125;int LCA(int x,int y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=0,del=dep[x]-dep[y];(1&lt;&lt;i)&lt;=del;++i) if(del&amp;(1&lt;&lt;i)) x=tfa[x][i]; if(x==y) return x; drep(i,17,0) if(tfa[x][i]!=tfa[y][i]) x=tfa[x][i],y=tfa[y][i]; return tfa[x][0];&#125;int main()&#123; n=rd(),m=rd(); rep(i,2,n) &#123; int u=rd(),v=rd(); G[u].pb(v),G[v].pb(u); &#125; dfs(1,0),Build(1,1,n); rep(i,1,m) &#123; int opt=rd(); if(opt==1) Access(rd()); else if(opt==2) &#123; int x=rd(),y=rd(),z=LCA(x,y); printf(&quot;%d\\n&quot;,Que(1,1,n,L[x])+Que(1,1,n,L[y])-2*Que(1,1,n,L[z])+1); &#125; else &#123; int x=rd(); printf(&quot;%d\\n&quot;,Que(1,1,n,L[x],R[x])); &#125; &#125;&#125;","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"HDU-5608","slug":"HDU-5608","date":"2020-06-01T11:14:42.000Z","updated":"2021-05-22T03:54:10.948Z","comments":true,"path":"articles/2020/06/01/5a5b3a76.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/06/01/5a5b3a76.html","excerpt":"","text":"HDU-5608题意：$G(n)=n^2−3n+2=\\sum_{d|n}F(d)$，求$\\sum_1^nF(i)$ 反演得到：$F(n)=\\sum_{d|n}\\mu(d)G(\\frac{n} {d})$ 则$\\sum_1^nF(i)=\\sum_i\\sum_{d|i}\\mu(d)G(\\frac{i} {d})$ $\\sum_1^nF(i)=\\sum_{i=1}^{n}G(i)\\sum_{j=1}^{\\lfloor \\frac{n} {i}\\rfloor }\\mu(j)$ 问题就是要快速求$G(i)$前缀和和$\\mu(i)$前缀和 第一个是$O(1)$求，第二个是杜教筛 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int N=5e6+10,P=1e9+7;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;const int Inv6=qpow(6);int n;char notpri[N],w[N];int pri[N/4],pc,Sw[N];map &lt;int,int&gt; M;int SumG(int n)&#123; // O(1)求出G函数的前缀和 ll ans=1ll*n*(n+1)%P*(2*n+1)%P*Inv6%P; ans=(ans-3ll*n*(n+1)/2%P+2*n)%P; ans=(ans%P+P)%P; return ans;&#125;int Sumw(int n)&#123; // 杜教筛求mobius函数前缀和 if(n&lt;N) return Sw[n]; if(M.count(n)) return M[n]; int ans=1; for(int i=2,j;i&lt;=n;i=j+1) &#123; j=n/(n/i); ans-=(j-i+1)*Sumw(n/i); &#125; return M[n]=ans;&#125;int SumF(int n)&#123; // 答案 int ans=0; for(int i=1,j;i&lt;=n;i=j+1) &#123; j=n/(n/i); ans=(ans+1ll*(SumG(j)-SumG(i-1))*Sumw(n/i))%P; &#125; ans=(ans%P+P)%P; return ans;&#125;int main()&#123; w[1]=1; rep(i,2,N-1) &#123; if(!notpri[i]) pri[++pc]=i,w[i]=-1; for(int j=1;j&lt;=pc &amp;&amp; 1ll*i*pri[j]&lt;N;++j) &#123; notpri[i*pri[j]]=1; if(i%pri[j]==0) &#123; w[i*pri[j]]=0; break; &#125; w[i*pri[j]]=-w[i]; &#125; &#125; rep(i,1,N-1) Sw[i]=Sw[i-1]+w[i]; rep(kase,1,rd()) printf(&quot;%d\\n&quot;,SumF(rd()));&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"HDU-5869 Different GCD Subarray Query(树状数组)","slug":"HDU-5869 Different GCD Subarray Query(树状数组)","date":"2020-05-29T14:22:49.000Z","updated":"2021-05-22T03:54:10.950Z","comments":true,"path":"articles/2020/05/29/2d8e51f2.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/05/29/2d8e51f2.html","excerpt":"","text":"HDU-5869 Different GCD Subarray Query(树状数组)先不考虑查询的区间$[L,R]$ 首先我们枚举一个$\\gcd$区间的$l$，考虑不同的$\\gcd(l..r)$实际上只有$\\log n$个，因为每次改变，$\\gcd$的值至少减少一倍 维护一个倍增数组，可以$\\log n$二分出下一个$\\gcd$不同的$r$，统计出每一个的$r$，那么就能得到$n\\log n$个不同的区间 问题就转化为求$[L,R]$包含的权值不同的$[l,r]$个数 那么可以把同一种权值的区间拉出来，离线之后，按照$l$和$L$倒序，每次对于$[l,r]$更新的区间就是$r$到这个权值之前出现过的最小$r$ 一共有$n\\log n$个更新，用树状数组维护区间更新，复杂度$O(n\\log^2n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const int N=1e5+10,P=1e9+7;ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b); &#125;int n,m;int a[N];struct BIT&#123; int s[N]; void clear()&#123; rep(i,1,n) s[i]=0; &#125; void Add(int p,int x) &#123; while(p&lt;=n) s[p]+=x,p+=p&amp;-p; &#125; int Que(int p)&#123; int res=0; while(p) res+=s[p],p-=p&amp;-p; return res; &#125;&#125;Tree;struct Query&#123; int p,id; &#125;;struct Update&#123; int p,x; &#125;;vector &lt;Query&gt; Q[N];vector &lt;Update&gt; U[N];int A[N],ans[N],G[N][18];int apr[N],apc,mk[N*10];void AddUpdate(int l,int r,int x) &#123; if(!mk[x]) apr[++apc]=x,mk[x]=n+1; if(r&gt;=mk[x]) return; U[l].pb((Update)&#123;r,1&#125;),U[l].pb((Update)&#123;mk[x],-1&#125;); mk[x]=r;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; rep(i,1,n) &#123; A[i]=rd(),Q[i].clear(),U[i].clear(); &#125; drep(i,n,1) &#123; G[i][0]=A[i]; for(int j=1;i+(1&lt;&lt;j)&lt;=n+1;++j) G[i][j]=gcd(G[i][j-1],G[i+(1&lt;&lt;(j-1))][j-1]); int x=A[i],r=i; while(r&lt;=n) &#123; AddUpdate(i,r,x); drep(j,17,0) if(r+(1&lt;&lt;j)&lt;=n+1 &amp;&amp; G[r][j]%x==0) r+=1&lt;&lt;j; x=gcd(x,A[r]); &#125; &#125; rep(i,1,m) &#123; int l=rd(),r=rd(); Q[l].pb((Query)&#123;r,i&#125;); &#125; Tree.clear(); drep(i,n,1) &#123; for(auto j:U[i]) Tree.Add(j.p,j.x); for(auto j:Q[i]) ans[j.id]=Tree.Que(j.p); &#125; rep(i,1,m) printf(&quot;%d\\n&quot;,ans[i]); rep(i,1,apc) mk[apr[i]]=0; apc=0; &#125;&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"Burnside & Polya","slug":"Burnside & Polya","date":"2020-05-27T14:22:14.000Z","updated":"2021-05-22T03:54:10.745Z","comments":true,"path":"articles/2020/05/27/b57b24d8.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/05/27/b57b24d8.html","excerpt":"","text":"Burnside &amp; Polya前置知识首先，要引入一些群论的概念，但是也不需要太懂 如果你不想听我讲 一个集合$S$，我们定义两种相同，即表观相同和本质相同 称对于集合的一种操作为置换 每一个对于集合的置换都是一种广义的对称，关于操作$x$对称的两个集合本质相同 即对于置换$S$得到$S’$，则$S$,$S’$关于这个置换对称，同时$S,S’$本质相同 群就是一些集合和一些操作(称作置换)的组合 对于一个$n$元序列$p_i$，我们认为它是我们的集合，我们定义序列的对称是可以通过首尾相接乘环之后相同 如有$S=\\{2,1,1\\},S’=\\{1,2,1\\}$ 我们可以说$S,S’$向右移动1个位置这个置换对称 我们暂且定义这个操作为$+1$，即定义置换的操作符号为$+$ 而要表示一个群，则所有置换必须满足的条件是 封闭性：置换$x$可以通过其他置换叠加得到，同时任何置换的叠加所产生的置换也在原先的置换集合里 结合律：即对于三个置换$a,b,c,(a+b)+c=a+(b+c)$ 单位元：存在一个置换$e$对于其他所有的置换满足$e+a=a+e=a$ 逆元：即对于每个置换$a$，存在置换$b$使得置换$a+b=e$ 对于上面提到的环序列问题 置换集合是$\\{+0,+1,\\cdots,+n-1\\}$，两个置换叠加的结果是要对于$n$取模的，所以显然满足上面的性质 Burnside对于一个群$G$ 其中所有本质不同的集合个数可以表示为 \\frac{\\sum_{置换x}所有集合中操作之后表观不变的个数} {置换个数}显然也等于 \\frac{\\sum_{集合S}所有置换中操作之后表观不变的个数} {置换个数}如对于$\\{1,1,2\\}$，三种置换之后得到$\\{1,1,2\\},\\{1,2,1\\},\\{2,1,1\\}$ 感性证明如下： 考虑每一种本质不同的集合$S$ 对于$S$执行每一种置换$x$，会产生若干个表观相同的置换集合 这些集合的总大小就是总的置换个数 对于每一个操作集合$Set$对应的表观元素$T$,$Set$本身是封闭的 存在$|Set|$种置换可以从$S$得到$T$ 同时也存在$|Set|$种置换满足$T$置换之后表观不变 因为可以先对$T$执行一个$Set$中置换的逆置换，然后再分别叠加以置换集合中所有的置换 根据群的封闭性，叠加之后的置换集合等价于原先的置换集合，而原先的置换集合里有$|Set|$个会得到$T$ 所以一个本质不同的集合被分散到这些集合里，最后一共还是被算了置换个数次 Tips:这里一定要注意的是，即便没有元素对于置换$x$对称，也必须要算进总的置换个数里 举个例子： 如果有$2$个$0$和$2$个$1$组成的环序列，手玩一下知道方案数是$2$ 实际的置换是$+0,+1,+2,+3$ 对称的个数是$6,0,2,0$ 实际上把这个问题扩展到$n$个，就会发现奇数的置换都是不存在对称的 (甚至只保留偶数的置换同样满足群的性质),但是也必须计算$2n$个置换,因为环序列的置换就是$2n$个，不会因为具体情况不存在而改变 Polya 定理$\\text{Polya}$定理，事实上就是对于每个置换，归纳了一下快速求出表观不变的元素个数的方法 也就是对于一个类似环序列的置换，置换之后表观不变，那么集合元素之间就存在一些相等关系，这些关系把集合元素之间的分成若干个循环，循环内的集合元素相同，通过求循环个数来快速求表观不变的元素个数 如对于环序列的问题，集合$S$,置换$+x$的循环个数就是$\\gcd(i,|S|)$ 实际上，具体的问题直接在$\\text{Burnside}$引理的基础上自己归纳总结快速求的方法是最好的","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"「ZJOI2019」开关","slug":"「ZJOI2019」开关","date":"2020-05-27T03:51:40.000Z","updated":"2021-05-22T03:54:11.279Z","comments":true,"path":"articles/2020/05/27/6d7d5b1e.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/05/27/6d7d5b1e.html","excerpt":"","text":"「ZJOI2019」开关神题 前言设$\\text{FWT}_{\\oplus}(F(x))=F’(x)$ 关于$\\text{FWT}_{\\oplus}$的展开式子，我发现大部分人都不晓得。。。。 $[x^S]F’(x)=\\sum_T(-1)^{|S\\cap T|} [x^T]F(x)$ $F(x)=\\frac{F’’(x)} {2^n}$ 详细可以看这个 定义$\\bigoplus$为两个多项式的异或卷积 $\\times$为两个多项式对应项直接相乘 $[x^S]F(x)$表示$F(x)$的第$S$项的系数 正文翻转过程是一个$\\oplus$的过程，所以考虑用集合幂指数配合$\\text{FWT}_\\oplus$构造和求解方程 事实上问题等价于从初始状态$S$跑到$\\empty$的期望次数 设从$S$到$\\empty$的期望次数生成函数为$F(x)$，其中$[x^{\\empty}]F(x)=0$ 设转移函数$G(x),[x^{ \\{i\\} }]G(x)=p_i$ 那么我们的方程就是$F(x)\\bigoplus G(x)+\\sum x^S+cx^{\\empty}=F(x)$ 其中$x^S$表示这次转移之后答案要加一 由于直接这样转移得到的方程显然是无穷解的，因为无法保证$[x^{\\empty}]F(x)=0$ 所以我们用一个常数项$cx^{\\empty}$平衡这个问题，$c$现在是未知的 $\\because F(x)\\bigoplus G(x)+\\sum x^S+cx^{\\empty}=F(x)$ $\\therefore (F(x)\\bigoplus G(x)+\\sum x^S+cx^{\\empty})’=F’(x)$ $\\therefore F’(x)\\times G’(x)+(\\sum x^S+cx^{\\empty})’=F’(x)$ 我们模拟一下$G’(x)$ $[x^S]G’(x)=\\sum_i(-1)^{|S\\cap \\{i\\}|}[x^{ \\{i\\} }]G(x)=\\sum_{i\\notin S}p_i-\\sum_{i\\in S}p_i$ 再卷一下$(\\sum x^S+cx^{\\empty})’$ $(\\sum x^S)’=\\sum_S\\sum_T(-1)^{|S\\cap T|}x^S$ $\\because (-1)^{|S\\cap T|} =\\sum_{T\\subset S}(-1)^|T|\\cdot 2^{n-|S|}=[S=\\empty]2^{n-|S|}$ $\\therefore (\\sum x^S)’=2^n x^{\\empty}$ $(cx^{\\empty})’=\\sum c\\cdot x^S$ 然后我们带入反解$[x^S]F’(x)$ 当$S=\\empty$时, 则$[x^S]F’(x)\\cdot [x^S]G’(x)+2^n+c=[x^S]F’(x)$ 然后发现此时$[x^S]G’(x)=1$，那么就意味着$2^n+c=0$ 解出了$c=-2^n$，但是此时我们实际上并不知道$[x^{\\empty}]F’(x)$的值 当$S\\ne \\empty$时 $[x^S]F’(x)\\cdot [x^S]G’(x)+c=[x^S]F’(x）$ $[x^S]F’(x)(1-[x^S]G’(x))=c$ [x^S]F'(x)=-\\frac{2^n} {1-\\sum_{i\\notin S}p_i+\\sum_{i\\in S}p_i}=-\\frac{2^n} {2\\sum_{i\\in S}p_i} 我们考虑要求出$[x^\\empty]F’(x)$的值 由$[x^{\\empty}]F(x)=2^{-n}\\cdot \\sum [x^S] F’(x)=0$ [x^\\empty]F'(x)-\\sum_{S\\ne \\empty}\\frac{2^n} {2\\sum_{i\\in S}p_i}=0那么我们由$F’(x)$回代得到$[x^S]F(x)(S \\ne \\empty)$ [x^S]F(x)=2^{-n}\\cdot \\sum_T(-1)^{|S\\cap T|}[x^T]F'(x)=2^{-n}([x^\\empty]F'(x)+\\sum_{T\\ne \\empty}(-1)^{|S\\cap T|}[x^T]F'(x))=\\sum_{T\\ne\\empty}\\frac{1} {2\\sum_{i\\in T}p_i}+2^{-n}\\sum_{T\\ne \\empty}(-1)^{|S\\cap T|}[x^T]F'(x)=\\sum_{T\\ne \\empty,|S\\cap T|\\mod 2=1} \\frac{1} {\\sum_{i\\in T} p_i}下面是一个背包，跑的同时统计一下就好了$|S\\cap T|$的奇偶性就好了 然后会发现事实上并没有必要特判$S=\\empty$的情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cctype&gt;#include&lt;vector&gt;using namespace std;#define reg registertypedef long long ll;#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)#define pb push_backtemplate &lt;class T&gt; inline void cmin(T &amp;a,T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; inline void cmax(T &amp;a,T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;int rd()&#123; int s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=5e4,P=998244353;int n;int s[N],a[N],sum;int dp[110][N][2]; // 背包表示p之和为i，有j个不同的方案数ll Inv[N]; ll c;ll qpow(ll x,ll k) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125; int main()&#123; freopen(&quot;switch.in&quot;,&quot;r&quot;,stdin),freopen(&quot;switch.out&quot;,&quot;w&quot;,stdout); n=rd(); rep(i,1,n) s[i]=rd(); dp[0][0][0]=1; rep(i,1,n) &#123; int x=rd(); rep(j,0,sum) rep(k,0,1) rep(d,0,1) dp[i][j+d*x][k^(d&amp;&amp;s[i])]=(dp[i][j+d*x][k^(d &amp;&amp; s[i])]+dp[i-1][j][k])%P; sum+=x; &#125; Inv[0]=Inv[1]=1; rep(i,2,sum) Inv[i]=(P-P/i)*Inv[P%i]%P; ll ans=0; rep(i,1,sum) ans=(ans+Inv[i]*dp[n][i][1])%P; // 因为最后统计的时候没有空集，所以i从1开始 printf(&quot;%lld\\n&quot;,ans*sum%P);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"JOI","slug":"JOI","permalink":"http://chasingdeath.github.io/tags/JOI/"},{"name":"各省OI","slug":"各省OI","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E7%9C%81OI/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"「CTS2019 | CTSC2019」重复(Kmp)","slug":"「CTS2019   CTSC2019」重复(Kmp)","date":"2020-05-22T05:18:31.000Z","updated":"2021-05-22T03:54:11.173Z","comments":true,"path":"articles/2020/05/22/5e01d3e8.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/05/22/5e01d3e8.html","excerpt":"","text":"「CTS2019 | CTSC2019」重复(Kmp) Part1首先我们考虑对于一个已经确定的$t$串，如何检查是否合法 对于$s$串建立$\\text{kmp}$($\\text{kmp}$自动机当然可以)， 如果当前$\\text{kmp}$指针$j$在$\\text{fail}$树上的祖先所对应的所有下一个位置$s[ancestor+1]$中，存在一个字符，$t$中当前位置的字符$t[i]&lt;s[ancestor+1]$ 那么就是存在一个”有意义的串”,并且这个串和s串第一个不同的位置就是$ancestor+1$ 所以可以预处理一个$fail$树上祖先最大的$s[ancestor+1],Max[state]$ 123456789101112131415161718192021222324rep(i,1,n) Max[i-1]=s[i];Max[n]=&#x27;a&#x27;;//边界条件cmax(Max[1],Max[0]);rep(i,2,n) &#123; int j=nxt[i-1]; while(j &amp;&amp; s[i]!=s[j+1]) j=nxt[j]; if(s[i]==s[j+1]) ++j; nxt[i]=j; cmax(Max[i],Max[j]);&#125;//预处理Maxrep(i,0,n) &#123; if(i&lt;n) Trans[i][s[i+1]-&#x27;a&#x27;]=i+1; rep(j,0,25) if(j!=s[i+1]-&#x27;a&#x27;) Trans[i][j]=Trans[nxt[i]][j];&#125;//kmp自动机，不要再暴力了rep(i,m+1,n+m) t[i]=t[i-m]; // 延长到n+m就够了int j=0,f=0;rep(i,1,n+m)&#123; if(t[i]&lt;Max[j]) &#123; // 存在一个位置满足即可 f=1; break; &#125; j=Trans[j][t[i]-&#x27;a&#x27;];&#125; 配合dfs枚举，可以拿到pts10 Part2设状态转移为$Trans[state][c]$ 把kmp状态压进dp状态里 如果把问题直接放到无穷意义下来看 那么跑够长度之后，后面的任意加入$m$次字符都会构成一个循环 枚举循环开始状态为$st$，$\\text{dp}$走了$m$步回到$st$的方案数 如果计算合法方案数，那么还要多一维，所以直接计算不合法方案，也就是 $Trans[state][Max[state]..25]$这一段转移是不会出现合法情况的 最后减一下 复杂度$O(m\\cdot n^2)$ 12345678910111213141516171819202122232425namespace pt2&#123; int dp[2][N]; void Solve()&#123; int cur=0,ans=0; rep(st,0,n) &#123; // 枚举初始状态 rep(i,0,n) dp[cur][i]=dp[!cur][i]=0; dp[cur][st]=1; rep(t,1,m) &#123; cur^=1; rep(i,0,n) if(dp[!cur][i])&#123; rep(c,Max[i]-&#x27;a&#x27;,25) &#123;//只转移不合法的 dp[cur][Trans[i][c]]+=dp[!cur][i]; Mod1(dp[cur][Trans[i][c]]); &#125; dp[!cur][i]=0; &#125; &#125;// 走m步回到st ans+=dp[cur][st],Mod1(ans); &#125; ans=(qpow(26,m)-ans+P)%P;//减一下 printf(&quot;%d\\n&quot;,ans); &#125;&#125; Part3观察上面一档情况，合法的转移$Trans[state][Max[state]..25]$ 如果枚举下一个字符$c&gt;Max[state]$，那么在$s$串中就找不到任何匹配了，下一个状态就是$0$ 否则，下一个状态就是$Trans[state][c]$ 也就是说，每个点出发其实只有两种情况，一种是一定会经过$0$的 所以对于这个环是否经过$0$进行讨论 如果不经过$0$，那么考虑直接从$st$出发走$m$步非0转移即可 经过$0$的，预处理一个从$0$出发，走了$i$步第一次回到$0$的方案数 $[st\\rightarrow 0,0\\rightarrow 0,0\\rightarrow 0…,0\\rightarrow st]$ 长成这个样子的转移 枚举第一个$st\\rightarrow 0$的时间，后面可以预处理出来 复杂度$O(n\\cdot m)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;#define pb push_back#define reg registertypedef long long ll;#define Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))#define Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))#define rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)#define drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)template &lt;class T&gt; void cmin(T &amp;a, T b)&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;template &lt;class T&gt; void cmax(T &amp;a, T b)&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;char IO;template &lt;class T=int&gt; T rd()&#123; T s=0; int f=0; while(!isdigit(IO=getchar())) if(IO==&#x27;-&#x27;) f=1; do s=(s&lt;&lt;1)+(s&lt;&lt;3)+(IO^&#x27;0&#x27;); while(isdigit(IO=getchar())); return f?-s:s;&#125;const int N=2010,P=998244353;int n,m;char s[N];int Max[N],nxt[N],Trans[N][26];ll qpow(ll x,ll k=P-2) &#123; ll res=1; for(;k;k&gt;&gt;=1,x=x*x%P) if(k&amp;1) res=res*x%P; return res;&#125;int st[N][N]; // 从i出发，走了j步第一次到0int dp[N][N]; // 从0出发，走了i步，到了j,如果到0就不进行转移 int main()&#123; freopen(&quot;repeat.in&quot;,&quot;r&quot;,stdin),freopen(&quot;repeat.out&quot;,&quot;w&quot;,stdout); m=rd(); scanf(&quot;%s&quot;,s+1),n=strlen(s+1); rep(i,1,n) Max[i-1]=s[i]; Max[n]=&#x27;a&#x27;; cmax(Max[1],Max[0]); rep(i,2,n) &#123; int j=nxt[i-1]; while(j &amp;&amp; s[i]!=s[j+1]) j=nxt[j]; if(s[i]==s[j+1]) ++j; nxt[i]=j; cmax(Max[i],Max[j]); &#125; rep(i,0,n) &#123; if(i&lt;n) Trans[i][s[i+1]-&#x27;a&#x27;]=i+1; rep(j,0,25) if(j!=s[i+1]-&#x27;a&#x27;) Trans[i][j]=Trans[nxt[i]][j]; &#125; int ans=0; st[0][0]++; rep(i,1,n) &#123; int j=i,f=1; rep(k,1,m) &#123; st[i][k]+=25-(Max[j]-&#x27;a&#x27;),j=Trans[j][Max[j]-&#x27;a&#x27;]; if(!j) &#123; st[i][k]++,f=0; break; &#125; &#125; if(j==i) ans+=f; &#125; dp[0][0]=1; rep(i,1,m) &#123; rep(j,0,n) if(dp[i-1][j]) &#123; dp[i][Trans[j][Max[j]-&#x27;a&#x27;]]+=dp[i-1][j],Mod1(dp[i][Trans[j][Max[j]-&#x27;a&#x27;]]); dp[i][0]=(dp[i][0]+1ll*(25-(Max[j]-&#x27;a&#x27;))*dp[i-1][j])%P; &#125; &#125; rep(i,0,n) &#123; // 枚举初始状态 rep(j,0,m) if(st[i][j] &amp;&amp; dp[m-j][i]) &#123; // 枚举走了几步第一次到0 ans=(ans+1ll*st[i][j]*dp[m-j][i])%P; &#125; &#125; ans=(qpow(26,m)-ans+P)%P; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"CTSC","slug":"CTSC","permalink":"http://chasingdeath.github.io/tags/CTSC/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]},{"title":"反演","slug":"反演","date":"2020-05-22T02:31:45.000Z","updated":"2021-05-22T03:54:11.343Z","comments":true,"path":"articles/2020/05/22/c9b378cc.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/05/22/c9b378cc.html","excerpt":"","text":"反演 什么是反演对于已知$F_i=\\sum a_{i,j}\\cdot G_j$ 反演得到$G_i=\\sum b_{i,j} \\cdot F_j$ $\\text{NTT,FFT,FWT}$的逆卷积都可以认为是一种反演 子集反演即反解高位前缀和 常见我们写成代码是 12345void FWT(int n,int *a,int f)&#123; for(int i=1;i&lt;n;i&lt;&lt;=1) for(int j=1;j&lt;n;++j) if(j&amp;i) a[j]+=a[j^i]*f;&#125; $F_S=\\sum_{T\\subset S}G_T$ 则$G_S=\\sum_{T\\subset S}(-1)^{|T\\oplus S|} F_S$ 证明 $G_S=\\sum_{T\\subset S}(-1)^{|T\\oplus S|} F_S$ $\\Leftrightarrow G_S=\\sum_{T\\subset S}(-1)^{|T\\oplus S|} \\sum _{R\\subset T}F_R$ $\\Leftrightarrow G_S=\\sum_{T\\subset S}G_R\\sum _{T\\subset R,R\\subset S}(-1)^{|S\\oplus R|}$ $\\Leftrightarrow G_S=\\sum_{T\\subset S}G_R\\sum _{R\\subset (S\\oplus T)}(-1)^{|R|}$ $\\Leftrightarrow \\sum _{T\\subset S}G_T[S\\oplus T=\\empty]$ 成立 莫比乌斯反演设$n$的质因数分解为$n=\\Pi_1^m p_i^{c_i}$ 前置知识：莫比乌斯系数 $\\mu(n)=\\left\\{ \\begin{aligned} 1 && n=1 \\\\ (-1)^m && c_i=1 \\\\ 0 && \\exists c_i>1\\end{aligned} \\right.$ 性质：$\\sum_{i|n}\\mu(i)=[n=1]$ 证明： $\\because c_i&gt;1\\Rightarrow \\mu(n)=0$ $\\therefore c_i\\in \\{0,1\\}$ $\\therefore \\sum _{i|n} \\mu(i)=\\sum_{S\\in\\{p_i\\} }(-1)^{|S|}=[m=0]$ 若$F_i=\\sum _{j|i}G_i$ 则$G_i=\\sum_{j|i}\\mu(\\frac{i} {j})F(j)$ 证明 $G_i=\\sum_{j|i}\\mu(\\frac{i} {j})F(j)$ $\\Leftrightarrow G_i=\\sum_{j|i}\\mu(\\frac{i} {j})\\sum _{k|j}G_k$ $\\Leftrightarrow G_i=\\sum_{j|i}G_j\\sum _{k|\\frac{i} {j} }\\mu(k)$ 带入上面的$\\mu(n)$性质，这个式子成立 \\二项式反演前置知识 $\\sum_0^nC(n,i)=[n=0]$$G_i=\\sum _{0}^{i}C(i,j)\\cdot F_j$ 直接容斥这个式子，就能得到 $F_i=G_i-\\sum_{j&lt;i}C(i,j)\\cdot F_j$ 但是容斥过程是$n^2$的，如果$n$较大，用分治$\\text{NTT}$实现也是$n\\log ^2n$ 所以需要二项式反演 反演:$G_i=\\sum _{0}^{i}C(i,j)\\cdot F_j\\Leftrightarrow F_i=\\sum_0^i (-1)^{i-j}\\cdot C(i,j)\\cdot G_j$ 有时候看到是$G_i=\\sum _{i}^{n}C(j,i)\\cdot F_j\\Leftrightarrow F_i=\\sum_i^n (-1)^{i-j}\\cdot C(j,i)\\cdot G_j$ 证明 $F_i=\\sum_i^n (-1)^{i-j} \\cdot C(j,i)\\cdot G_j$ $\\Leftrightarrow F_i=\\sum_i^n(-1)^{i-j}\\cdot C(i,j)\\sum_j^nC(j,k)\\cdot F_k$ $\\Leftrightarrow F_i=\\sum_0^i F_j\\sum_j^iC(i,k)\\cdot C(k,j) \\cdot (-1)^{i-k}$ $\\Leftrightarrow \\sum_j^iC(i,k)\\cdot C(k,j) \\cdot (-1)^{i-k}=[i=j]$ $\\because C(i,k)\\cdot C(k,j)=\\frac{i!} {j!(i-k)!(k-j)!}$ $=\\frac{i!} {j!(i-j)!}\\cdot \\frac{(i-j)!} {(i-k)!(k-j)!}=C(i,j)\\cdot C(i-j,i-k)$ $\\sum_j^iC(i,k)\\cdot C(k,j) \\cdot (-1)^{i-k}=C(i,j)\\sum_0^{i-j}(-1)^kC(i-j,k)=[i=j]C(i,j)=[i=j]$ 待补。。。","categories":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}],"tags":[{"name":"default tag","slug":"default-tag","permalink":"http://chasingdeath.github.io/tags/default-tag/"}],"keywords":[{"name":"default category","slug":"none","permalink":"http://chasingdeath.github.io/categories/none/"}]},{"title":"LOJ3120「CTS2019 | CTSC2019」珍珠","slug":"LOJ3120「CTS2019   CTSC2019」珍珠","date":"2020-05-21T06:05:07.000Z","updated":"2021-05-22T03:54:10.966Z","comments":true,"path":"articles/2020/05/21/c33588be.html","link":"","permalink":"http://chasingdeath.github.io/articles/2020/05/21/c33588be.html","excerpt":"","text":"LOJ3120「CTS2019 | CTSC2019」珍珠只是想要祭奠做的时候死去的我 约定下文中的$d$为题目中的$D$ Part1先从最最暴力的定义转移(可以跳过这个) $S$表示个数为奇数的颜色集合 转移多项式(集合幂指数)$F(x)=\\sum_0^d x^{ \\{i\\} }$ $\\text{FWT}$得到 $F’(x)=\\sum (d-2|S|)x^S$ $(F(x)^n)’=\\sum (d-2|S|)^nx^S$ $\\text{IFWT}$得到 $2^d F(x)^n=\\sum_S \\sum_T (-1)^{|S\\cap T|}(d-2|T|)^n x^{S} $ 答案就是 $2^d Ans=\\sum_S\\sum_T(-1)^{|S\\cap T|}(d-2|T|)^n[|S|\\leq Lim]$ 如果枚举$|S|,|T|,|S\\cap T|$进行统计，会出现3个元，无法直接优化到$O(n\\log n)$ Part2设最后得到每一种颜色的个数为$c_i,\\sum c_i=n$ 方案数就是$\\frac{n!} {\\Pi c_i!}$，很符合指数型生成函数吧 考虑最朴素的生成函数表示法，考虑每种颜色的选的个数 个数无限制的生成函数$F_0(x)=\\sum \\frac{x^i} {i!}=e^x$ 个数为奇数的生成函数$F_1(x)=\\frac{x^{1} } {1!}+\\frac{x^{3} } {3!}+\\cdots=\\frac{e^x-e^{-x} } {2}$ 个数为偶数的生成函数$F_2(x)=\\frac{x^0} {0!}+\\frac{x^2} {2!}+\\cdots=\\sum \\frac{e^x+e^{-x} } {2}$ $F_1^i=2^{-i}\\sum (-1)^jC(i,j)e^{(i-2j)x}$ $F_2^i=2^{-i}\\sum C(i,j)e^{(i-2j)x}$ 设选中$i$个奇数的答案为$G_i$ $G_i=n!C(n,i)[x^n]F_1^iF_2^{d-i}$ $=n!C(n,i)[x^n]2^{-d}\\sum_j\\sum_k C(i,j)(-1)^je^{(i-2j)x} C(n-i,k)e^{(n-i-2k)x}$ 代$e^{ax}=\\sum \\frac{(ax)^i} {i!}$，约去$n!$ $=C(n,i)[x^n]2^{-d}\\sum_j\\sum_k C(i,j)C(n-i,k)(-1)^j (n-2k-2j)^n$ 诶好像和Part1一样。。。 暴毙结束。。。。 Part3上面这两种方法都要枚举三个元，无法优化，所以考虑先重复计算，再容斥掉 计算$\\ge i$个方案数，然后容斥回去 设最终答案序列为$H$ 我们可以快速求出选中$i$个奇数且带重复的方案数$G_i$ $G_i=\\sum C(j,i)H_j=[x^n]C(d,i)F_1(x)^iF_0(x)^{d-i}$(强制选$i$个剩下未知) $G_i=C(d,i) \\cdot n! \\cdot [x^n]\\sum (-1)^je^{(d-2j)x}\\cdot C(i,j)\\cdot {2^{-i} }$ 代$e^{ax}=\\sum \\frac{(ax)^i} {i!}$，约去$n!$ $G_i=C(d,i) \\cdot \\sum (-1)^j(d-2j)^n\\cdot C(i,j)\\cdot {2^{-i} }$ 卷积一次可以得到$G$ 最后的容斥就是二项式反演 $H_i=\\sum_{j\\ge i}(-1)^{j-i}G_jC(j,i)$ 再卷积求出$H$","categories":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}],"tags":[{"name":"各大OJ","slug":"各大OJ","permalink":"http://chasingdeath.github.io/tags/%E5%90%84%E5%A4%A7OJ/"},{"name":"CTSC","slug":"CTSC","permalink":"http://chasingdeath.github.io/tags/CTSC/"}],"keywords":[{"name":"题解","slug":"solutions","permalink":"http://chasingdeath.github.io/categories/solutions/"}]}]}