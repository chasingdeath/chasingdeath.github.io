[{"url":"/2021/05/20/CF1368G - Shifting Dominoes/","content":"# CF1368G - Shifting Dominoes\n\n### 题目大意\n\n给定一个被$1\\times 2$的骨牌（横向或者竖向）铺满的方格图\n\n现在可以拿走一个骨牌，之后任意一个骨牌可以沿着其放置方向左右移动至多一步\n\n求最终两个空位所在不同位置的方案数\n\n<br>\n\n### 分析\n\n观察一个空位的移动\n\n如果上/下/左/右边是一条骨牌，则可以移动到该骨牌所在的上/下/左/右边方格\n\n将这个移动方式构成一个有向图（当然忽略反复横跳的情况）\n\n大胆猜测此时你会发现它是 **两片外向树森林**，下面说明三个充分条件\n\n1.跳跃的过程为$(x,y)\\rightarrow (x\\pm 2,y\\pm 2)$，显然$x+y$的奇偶性不变，故可以黑白染色分为两部分\n\n2.一个点至多有一条入边：一个点的入边只能来自其所在骨牌的另一边\n\n3.图中不存在环：\n\n假设构成了一个环，此时这些边对应的骨牌围成一个不规则的环\n\n从环的某一个角出发，向四周走，发现其余所有点总能完成一一匹配\n\n也就是说，环内部包含的点个数为奇数，显然不存在这样的覆盖方案\n\n<br>\n\n### 答案计算\n\n考虑移除一张骨牌生成两个点$(x,y)$，两个点分属于两片森林，并且可以向下走\n\n不妨求出森林的$\\text{dfs}$序，此时问题变成了一个二维空间矩形覆盖问题\n\n可以扫描线+线段树解决\n\n```cpp\nconst int N=2e5+10;\n\nint n,m,d;\nstring s[N];\nint I(int x,int y){ return (x-1)*m+y; }\nll ans;\n\nvector <int> G[N];\nint col(int u){ return ((u-1)%m+(u-1)/m)&1; }\n\nvoid Link(int u,int v){ G[u].pb(v),ind[v]++; }\nint ind[N],L[N],R[N],dfn;\nvoid dfs(int u,int f){\n\tL[u]=++dfn;\n\tfor(int v:G[u]) if(v!=f) dfs(v,u);\n\tR[u]=dfn;\n}\n\n// 线段树维护扫描过程中第二维未被覆盖的点个数\nstruct Node{\n\tint mi,x;\n\tNode operator + (const Node _) const {\n\t\tNode res;\n\t\tres.mi=min(mi,_.mi),res.x=0;\n\t\tif(mi==res.mi) res.x+=x;\n\t\tif(_.mi==res.mi) res.x+=_.x;\n\t\treturn res;\n\t}\n} tr[N<<2];\nint t[N<<2];\nvoid Down(int p){\n\tif(!t[p]) return;\n\trep(i,p<<1,i+1) t[i]+=t[p],tr[i].mi+=t[p];\n\tt[p]=0;\n}\nvoid Upd(int p,int l,int r,int ql,int qr,int x){\n\tif(ql<=l && r<=qr) {\n\t\tt[p]+=x,tr[p].mi+=x;\n\t\treturn;\n\t}\n\tDown(p);\n\tint mid=(l+r)>>1;\n\tif(ql<=mid) Upd(p<<1,l,mid,ql,qr,x);\n\tif(qr>mid) Upd(p<<1|1,mid+1,r,ql,qr,x);\n\ttr[p]=tr[p<<1]+tr[p<<1|1];\n}\n\nstruct Update{\n\tint p,l,r,x;\n\tbool operator < (const Update __) const { return p<__.p; }\n} U[N*2];\nint C;\n\nvoid Add(int x,int y){\n\tif(col(x)) swap(x,y);\n\tU[++C]=(Update){L[x],L[y],R[y],1};\n\tU[++C]=(Update){R[x]+1,L[y],R[y],-1};\n}\nvoid Build(int p,int l,int r){\n\ttr[p]=(Node){0,r-l+1};\n\tif(l==r) return;\n\tint mid=(l+r)>>1;\n\tBuild(p<<1,l,mid),Build(p<<1|1,mid+1,r);\n}\n\nint main(){\n\tn=rd(),m=rd();\n\trep(i,1,n) {\n\t\tcin>>s[i];\n\t\trep(j,1,m) {\n\t\t\tif(s[i][j-1]=='U') if(i>1) Link(I(i-1,j),I(i+1,j));\n\t\t\tif(s[i][j-1]=='D') if(i<n) Link(I(i+1,j),I(i-1,j));\n\t\t\tif(s[i][j-1]=='L') if(j>1) Link(I(i,j-1),I(i,j+1));\n\t\t\tif(s[i][j-1]=='R') if(j<m) Link(I(i,j+1),I(i,j-1));\n\t\t}\n\t}\n    // 获得dfs序\n\trep(i,1,n*m) if(!ind[i]) dfs(i,0);\n\trep(i,1,n) {\n\t\trep(j,1,m) {\n\t\t\tif(s[i][j-1]=='U') Add(I(i,j),I(i+1,j));\n\t\t\tif(s[i][j-1]=='L') Add(I(i,j),I(i,j+1));\n\t\t}\n\t}\n\tBuild(1,1,dfn);\n\tsort(U+1,U+C+1);\n\tint p=1;\n\trep(i,1,dfn) {\n\t\twhile(p<=C && U[p].p<=i) Upd(1,1,dfn,U[p].l,U[p].r,U[p].x),p++;\n\t\tint c=dfn-(tr[1].mi==0?tr[1].x:0);\n\t\tans+=c;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2021/05/20/CF1366G - Construct the String/","content":"# CF1366G - Construct the String\n\n### 题目大意\n\n给定一个初始串$S$和目标串$T$\n\n其中$S$除了包含字母外还包含删除标记'.'\n\n具体的$S$表示的字符串$f(S)$，就是依次加入每个字母，或者在删除标记处删除上一个字符（不存在这个字符则非法）\n\n求删除$S$中最少的字符，使得$f(S')=T$\n\n<br>\n\n### 吐槽\n\n$O(n^2)$出$n\\leq 10^4$???\n\n<br>\n\n<br>\n\n### 朴素dp分析\n\n这种题目容易想到记录在$T$中匹配位置的$dp$，通过枚举$S$的每一个字符\n\n1.匹配\n\n2.手动删除\n\n3.被'.'删除\n\n然而被'.'删除的情况实际难以处理，因为无法额外记录待定的'.'个数\n\n<br>\n\n### 基于括号树的思路\n\n考虑对于不完全的括号序列的包含关系建立树，注意到\n\n1.一个已经和'.'匹配的字符，不需要考虑它被手动删除的情况\n\n2.一个字符能够保留，当且仅当所有跨过其的右括号被删除\n\n跨过其的右括号即祖先中的右括号\n\n所以此时dp决策可以简单地归纳为\n\n1.保留一整个匹配括号的子树，进入后面的匹配\n\n2.否则，删除右括号，并且决定自己这个字符是否匹配，然后递归进入子树\n\n~~代码没写~~\n\n<br>\n\n### 更简洁的表述\n\n实际上与上面类似，但是更加简化了模型，转移可以简单归纳为\n\n1.匹配当前字符\n\n2.删除当前字符\n\n3.找到当前字符匹配右括号，跳过这一段\n\n原理：\n\n实际上朴素dp缺陷就在于：\n\n如果当前这个字符被后面的某一个'.'删除，却又无法匹配时，无法被加入状态\n\n此时手动补充直接跳到删除这个字符的位置\n\n充分性理解：在新串中匹配该字符的右括号 和 当前后缀中匹配该字符的括号相同\n\n如果要让这个字符被'.'删除，那么到当前后缀中匹配该字符的括号为止，中间的部分不可能保留\n\n手动删除只会让匹配该字符的括号右移，这不会更优\n\n```cpp\nconst int N=10010,P=1e9+7;\n\nint n,m;\nchar s[N],t[N];\nint dp[N][N];\n\nint main(){\n\tscanf(\"%s%s\",s,t),n=strlen(s),m=strlen(t);\n\trep(i,0,n) memset(dp[i],63,(min(m,i)+2)<<2);\n\trep(i,*dp[0]=0,n-1) {\n\t\tif(s[i]!='.') {\n\t\t\tint j=i,c=0;\n\t\t\tdo c+=s[j++]=='.'?-1:1;\n\t\t\twhile(c && j<n);\n\t\t\tif(!c) rep(k,0,min(m,i)) cmin(dp[j][k],dp[i][k]);\n\t\t}\n\t\trep(j,0,min(m,i)) {\n\t\t\tcmin(dp[i+1][j],dp[i][j]+1);\n\t\t\tif(s[i]==t[j]) cmin(dp[i+1][j+1],dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][m]);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2021/05/20/CF1305G - Kuroni and Antihype/","content":"# CF1305G - Kuroni and Antihype\n\n### 题目大意\n\n有$n$个人，每个人有一个权值$a_i$\n\n每个人可以自己选择放入集合，不获得分数\n\n或者一个已经在集合中的人$i$可以把一个$a_i \\ \\text{and}\\  a_j=0$的$j$放入集合，并且获得$a_i$的分数\n\n求最大得分总和\n\n<br>\n\n### 模型分析\n\n按照原题的模型分析，视$a_i\\rightarrow a_j$为一条权值为$a_i$边，则实际上求的是 **最大外向森林**\n\n考虑加入$a_0=0$，且$a_0$初始在集合中，一个人自己放入集合视作被$0$放入集合\n\n那么问题简化为求以0为根的 **最大外向树**\n\n进一步观察会发现：\n\n在外向树上每个点贡献次数就是$a_i\\cdot (deg_i-1)$\n\n那么最大化$a_i\\cdot (deg_i-1)$等价于最大化$\\sum a_i\\cdot deg_i$\n\n那么我们将一条边的权值$a_i\\rightarrow a_j$改为$a_i+a_j$，此时边双向权值相同\n\n问题就变成了求最大生成树\n\n<br>\n\n### 计算生成树\n\n~~只有暴力解法~~\n\n倒着枚举$a_i+a_j=S$，枚举$S$的子集$T$就能确定两个点\n\n并查集处理加边即可，复杂度为$O(\\cfrac{3^{18}}{2}\\cdot \\alpha(n))$\n\n$\\text{CodeForces}$真的有点快！！\n\n```cpp\nconst int N=1<<18,INF=1e9+10;\n\nint n,a[N],F[N];\nll ans;\nint Find(int x){ return F[x]==x?x:F[x]=Find(F[x]); }\n\nint main(){\n\tn=rd();\n\trep(i,1,n) {\n\t\tint x=rd();\n\t\ta[x]++,ans-=x;\n\t}\n\ta[0]++;\n\trep(i,0,N-1) F[i]=i;\n\tdrep(i,N-1,1) {\n\t\tfor(int S=i,T;(S^i)<=S;S=(S-1)&i) if(a[S] && a[T=S^i] && Find(S)!=Find(T)) {\n\t\t\tans+=1ll*(a[S]+a[T]-1)*i;\n\t\t\ta[S]=a[T]=1,F[Find(S)]=Find(T);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2021/05/20/CF1299D - Around the World/","content":"# CF1299D - Around the World\n\n### 题目大意\n\n给定一张带权无向图，满足经过1号点不存在长度$>3$的简单环\n\n求删除1号点所连边的一个子集，使得剩下的边构成的图满足\n\n不存在一条 **非完全重复** 回路 异或和为0\n\n非完全重复即所有边恰好被经过偶数次的回路\n\n边权$<32$\n\n<br>\n\n### 分析\n\n考虑如何判定0回路\n\n1.任意一个回路由同一连通块内的环叠加产生\n\n2.将所有$\\text{dfs}$树上的环边提取出来，无法加入线性基时则存在0回路\n\n线性基是重要的判断0回路的方法，因此考虑直接将线性基压进状态进行$dp$\n\n<br>\n\n### dp\n\n删除1所连边后，对于每个连通块考虑计算\n\n设连通块内环边的线性基为$D$（加入每条都能成功插入，否则直接跳过该连通块）\n\n包含$C$条连接1的边\n\n仍需考虑经过1的环边，题目限制了这样的环边在每个连通块内最多有一条\n\n不妨提取这条边，设其所在三元环权为$L$\n\n那么转移分为3种\n\n1.不选这个连通块\n\n2.选择连通块内所有边，但是不选三元环，即$3\\cdot 2^{C-2}-1$ (如果存在$L$)\n\n暴力合并$dp$状态中的线性基和$D$即可，依次插入$D$中的每条基\n\n3.额外再选择$L$，$2^{C-2}$\n\n状压线性基容易发现线性基最多有15个位置可能出现1，可以暴力二进制存下来\n\n实际上，合法的线性基通过高斯消元之后种类非常少，因此复杂度有保证\n\n```cpp\nconst int N=1e5+10,P=1e9+7;\n\nint n,m;\nvector <Pii> G[N];\n\nll qpow(ll x,ll k=P-2) {\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\n\n#define Gauss   rep(i,0,4) if(d[i]) rep(j,i+1,4) if(d[j]&(1<<i)) d[j]^=d[i];\\\n\t\t\t\tdrep(i,4,0) D=(D<<(i+1))|d[i];\n\nint Ins(int &D,int x){\n\tint d[5];\n\trep(i,0,4) d[i]=D&((1<<(i+1))-1),D>>=i+1;\n\tint f=0;\n\tdrep(i,4,0) if(x&(1<<i)) {\n\t\tif(d[i]) x^=d[i];\n\t\telse { f=1,d[i]=x; break; }\n\t}\n\tif(!f) return 0;\n\tGauss;\n\treturn 1;\n}\n\nint Uni(int &D,int E){\n\tif(!E) return 1;\n\tint d[5];\n\trep(i,0,4) d[i]=D&((1<<(i+1))-1),D>>=i+1;\n\trep(i,0,4) {\n\t\tint x=E&((1<<(i+1))-1); E>>=i+1;\n\t\tif(!x) continue;\n\t\tint f=0;\n\t\tdrep(i,4,0) if(x&(1<<i)) {\n\t\t\tif(d[i]) x^=d[i];\n\t\t\telse { f=1,d[i]=x; break; }\n\t\t}\n\t\tif(!f) return 0;\n\t}\n\tGauss;\n\treturn 1;\n}\n\nstruct Table{\n\tint val[1<<15],a[1<<15],c;\n\tvoid Add(int x,int v) {\n\t\tif(!val[x]) a[c++]=x;\n\t\tval[x]+=v,Mod1(val[x]);\n\t}\n\tvoid clr(){\n\t\trep(i,0,c-1) val[a[i]]=0;\n\t\tc=0;\n\t}\n} dp[2];\n\nint vis[N],dfn,dis[N],D,F,E[N],L,C;\nvoid dfs(int u) {\n\tvis[u]=++dfn;\n\tif(~E[u]) C++;\n\tfor(Pii i:G[u]) if(i.first!=1) {\n\t\tint v=i.first;\n\t\tif(~E[u] && ~E[v]) L=E[u]^E[v]^i.second; // 找到了一个经过1的三元环\n\t\tif(!vis[v]) dis[v]=dis[u]^i.second,dfs(v);\n\t\telse if(vis[v]>vis[u]) {\n\t\t\tF&=Ins(D,dis[v]^dis[u]^i.second);\n\t\t}\n\t}\n}\n\nint main(){\n\tn=rd(),m=rd();\n\trep(i,1,m) {\n\t\tint u=rd(),v=rd(),w=rd();\n\t\tG[u].pb(mp(v,w)),G[v].pb(mp(u,w));\n\t}\n\trep(i,1,n) E[i]=-1;\n\tfor(Pii i:G[1]) E[i.first]=i.second;\n\tint cur=0;\n\tdp[0].Add(0,1);\n\tfor(Pii i:G[1]) {\n\t\tint v=i.first;\n\t\tif(vis[v]) continue;\n\t\tF=1,D=C=0,L=-1,dfs(v);\n\t\tif(!F) continue;\n\t\tdp[!cur].clr();\n\t\tif(~L) C-=2;\n\t\tC=qpow(2,C);\n\t\trep(i,0,dp[cur].c-1) {\n\t\t\tint x=dp[cur].a[i],y=dp[cur].val[x];\n\t\t\tdp[!cur].Add(x,y);\n\t\t\tif(Uni(x,D)) {\n\t\t\t\tdp[!cur].Add(x,((~L?3ll:1ll)*C-1)*y%P);\n\t\t\t\tif(~L && Ins(x,L)) dp[!cur].Add(x,1ll*y*C%P);\n\t\t\t}\n\t\t}\n\t\tcur^=1;\n\t}\n\tint ans=0;\n\trep(i,0,dp[cur].c-1) (ans+=dp[cur].val[dp[cur].a[i]])%=P;\n\tprintf(\"%d\\n\",ans);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2021/05/20/CF1288F - Red-Blue Graph/","content":"# CF1288F - Red-Blue Graph\n\n### 题目大意\n\n给定一个二部图，每条边可以为红色/蓝色/无色，且一条边为红色需要付出$r$的代价，为蓝色需要$b$的代价\n\n每个点可以为红色/蓝色/无色\n\n1.如果该点为红色，则其所连的边中红色边边数 **严格大于** 蓝色边边数\n\n2.如果该点为蓝色，则其所连的边中蓝色边边数 **严格大于** 红色边边数\n\n求最小化代价满足上述限制\n\n<br>\n\n### 分析\n\n~~二分图果然和网络流密不可分~~\n\n考虑从奇怪的题目中归纳一个费用流模型\n\n用一个点的流量表示红色边-蓝色边的数量，将问题描述为\n\n1.一条边如果为红色，那么所关联的点从$S$强制得到$1$的流量\n\n2.一个边如果选蓝色，那么所关联的点强制向$T$流$1$的流量\n\n3.如果一个点为红色，那么它最终应该仍然有流量多\n\n那么强制这个点必须还能向$T$流$1$的流量，剩余随意\n\n4.如果一个点为蓝色，那么它最终应该仍然流量不足\n\n那么强制这个点必须从$S$得到$1$的流量，剩余随意\n\n然而这个模型无法解决一条边对于其两端点的决策\n\n<br>\n\n常见的处理二分图思路：考虑将右半边图红蓝反着建立\n\n此时令一条边对应的中继节点从$S$得到$2$的流量\n\n这个节点向左边的点流0，表示这条边选择蓝色\n\n这个节点向左边的点流1，表示这条边选择白色\n\n这个节点向左边的点流2，表示这条边选择红色\n\n同时将代价加入即可\n\n这样给每个点额外增加了一个基准偏移的流量，需要简单处理一下\n\n用代价为$-\\infty$的边表示这条边强制选择\n\n注意最终求出的是最小费用，而不是最大流\n\n```cpp\nconst int N=2e5+10,INF=1e9+10;\n\nint n1,n2,S,T,V,m,r,b;\nstruct Edge{\n\tint to,nxt,w,c;\n} e[N];\nint head[N],ecnt=1;\nvoid AddEdge(int u,int v,int w,int c){\n\te[++ecnt]=(Edge){v,head[u],w,c};\n\thead[u]=ecnt;\n}\nvoid Link(int u,int v,int w,int c){ AddEdge(u,v,w,c),AddEdge(v,u,0,-c); }\n\nll ans,dis[N];\nchar s[N];\nint inq[N],pre[N],w[N];\n\nint main(){\n\tn1=rd(),n2=rd(),m=rd(),r=rd(),b=rd(),S=n1+n2+1,T=S+1,V=T;\n\tscanf(\"%s\",s+1);\n\trep(i,1,n1) {\n\t\tif(s[i]=='R') Link(i,T,1,-INF),ans+=INF,Link(i,T,INF,0);\n\t\tif(s[i]=='B') Link(S,i,1,-INF),ans+=INF,Link(S,i,INF,0);\n\t\tif(s[i]=='U') Link(S,i,INF,0),Link(i,T,INF,0);\n\t}\n\tscanf(\"%s\",s+1);\n\trep(i,1,n2) {\n\t\tif(s[i]=='B') Link(i+n1,T,1,-INF),ans+=INF,Link(i+n1,T,INF,0);\n\t\tif(s[i]=='R') Link(S,i+n1,1,-INF),ans+=INF,Link(S,i+n1,INF,0);\n\t\tif(s[i]=='U') Link(S,i+n1,INF,0),Link(i+n1,T,INF,0);\n\t}\n\trep(i,1,m) {\n\t\tint u=rd(),v=rd()+n1;\n\t\tLink(S,++V,2,-INF),ans+=2*INF;\n\t\tLink(V,u,1,0),Link(V,v,1,0);\n\t\tLink(V,u,1,r),Link(V,v,1,b);\n\t\tLink(u,T,1,-INF),ans+=INF;\n\t\tLink(v,T,1,-INF),ans+=INF;\n\t}\n\twhile(1) {\n\t\tstatic queue <int> que;\n\t\trep(i,1,V) dis[i]=1e18;\n\t\tdis[S]=0,que.push(S),w[S]=INF;\n\t\twhile(!que.empty()) {\n\t\t\tint u=que.front(); que.pop();\n\t\t\tinq[u]=0;\n\t\t\tfor(int i=head[u];i;i=e[i].nxt) {\n\t\t\t\tint v=e[i].to,c=e[i].c;\n\t\t\t\tif(!e[i].w || dis[v]<=dis[u]+c) continue;\n\t\t\t\tdis[v]=dis[u]+c,w[v]=min(e[i].w,w[u]),pre[v]=i;\n\t\t\t\tif(!inq[v]) que.push(v),inq[v]=1;\n\t\t\t}\n\t\t}\n\t\tif(dis[T]>0) break;\n\t\tint c=w[T]; ans+=dis[T]*c;\n\t\tfor(int u=T;u!=S;u=e[pre[u]^1].to) {\n\t\t\t//cout<<u<<endl;\n\t\t\te[pre[u]].w-=c,e[pre[u]^1].w+=c;\n\t\t}\n\t}\n\tif(ans>INF) puts(\"-1\");\n\telse {\n\t\tprintf(\"%lld\\n\",ans);\n\t\trep(u,T+1,T+m) {\n\t\t\tint c=0;\n\t\t\tfor(int i=head[u];i;i=e[i].nxt) if(e[i].to<=n1) c+=e[i^1].w;\n\t\t\tputchar(\"BUR\"[c]);\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2021/05/20/CF1276F - Asterisk Substrings/","content":"# CF1276F - Asterisk Substrings\n\n### 题目大意\n\n给定串$S,|S|=n$，设一个串的子串集合为$Sub(S)$\n\n求$|Sub(S) \\cup Sub(*+S[2:n])\\cup Sub(S[1:1]+*+S[3:n])\\cup \\cdots|$\n\n其中*表示特殊字符而不是通配符\n\n<br>\n\n### 分析\n\n对于不包含*的串，显然就是$Sub(S)$，可以通过后缀数组，后缀自动机来计算\n\n对于包含*的串，考虑分两部分计算\n\n<br>\n\n#### 1.对于后面接的串$T$分类\n\n对于后面接的串$T$，$T$在原串$S$出现的位置对应后缀数组上一段$\\text{rank}$区间$[l,r]$\n\n考虑按照原串后缀数组的$\\text{height}$建立笛卡尔树，此时容易发现，不同的$[l,r]$就是\n\n笛卡尔树上每一个节点对应的区间，而这个$[l,r]$出现的个数就是$height_u-height_{fa_u}$\n\n<br>\n\n#### 2.对于每一个$[l,r]$计算前面接的串$R$的种类\n\n那么在前面接的串$R$就是从$[l,r]$中$sa[i]-2$对应的所有前缀中\n\n选择某一条后缀得到\n\n在笛卡尔树上计算时，我们需要从儿子中合并两段$[l,r],[l',r']$，计算不同串个数\n\n也就是说我们需要动态维护一个集合$Set$为反串后缀的子集，并且计算这些后缀能够构成的串种类\n\n对于$Set$为全集的情况，我们知道答案就是$\\sum |suf_i|-\\sum height_i$\n\n这条式子的意义实际上是：\n\n按照$\\text{rank}$考虑每一个后缀，减去前面已经出现过的所有串，就是减去和前面串最大的$\\text{LCP}$\n\n由于$\\text{LCP}(i,j)$取决于中间$height$的最小值，按$\\text{rank}$加入时$\\text{LCP}$的最大值就是$height_{i-1}$\n\n<br>\n\n那么这个计算思路对于$Set$中元素不连续的情况显然依然成立\n\n只需要动态维护出现位置的$\\text{rank}$，不断减去相邻两个位置$i,j$的$\\text{LCP}$即可\n\n用$\\text{std::set}$+启发式合并即可$O(n\\log ^2n)$维护，$\\text{LCP}$用后缀数组$\\text{RMQ}$即可$O(1)$求（实际上带一个$\\log $也不影响总复杂度）\n\n或许用线段树合并可以做到$O(n\\log n)$\n\n代码的话$\\downarrow $，有轻度封装\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) f|=IO=='-';\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nenum{N=100010};\nint n,m;\nchar s[N];\nstruct Suffix_Array{\nint rk[N<<1],tmp[N],cnt[N],sa[N],lcp[N];\nvoid Build() {\n\trep(i,1,n) cnt[s[i]-'a']++;\n\trep(i,1,25) cnt[i]+=cnt[i-1];\n\trep(i,1,n) rk[i]=cnt[s[i]-'a'];\n\tdrep(i,n,1) sa[cnt[s[i]-'a']--]=i;\n\tfor(int m=n,k=1;;k<<=1) {\n\t\tint h=0;\n\t\trep(i,n-k+1,n) tmp[++h]=i;\n\t\trep(i,1,n) if(sa[i]>k) tmp[++h]=sa[i]-k;\n\t\n\t\trep(i,1,n) cnt[rk[sa[i]]]=i;\n\t\tdrep(i,n,1) sa[cnt[rk[tmp[i]]]--]=tmp[i];\n\t\t\n\t\trep(i,1,n) tmp[sa[i]]=tmp[sa[i-1]]+(rk[sa[i]]!=rk[sa[i-1]]||rk[sa[i-1]+k]!=rk[sa[i]+k]);\n\t\trep(i,1,n) rk[i]=tmp[i];\n\t\tif((m=rk[sa[n]])==n) break;\n\t}\n\tint h=0;\n\trep(i,1,n) {\n\t\tint j=sa[rk[i]-1];\n\t\tif(h) h--;\n\t\twhile(s[i+h]==s[j+h]) h++;\n\t\tlcp[rk[i]-1]=h;\n\t}\n}\n} ;\n\nstruct LCPer:Suffix_Array{\nint st[20][N],Log[N];\nvoid Init() {\n\trep(i,2,n) Log[i]=Log[i>>1]+1;\n\trep(i,1,n) st[0][i]=lcp[i];\n\trep(i,1,Log[n]) {\n\t\tint len=1<<(i-1);\n\t\trep(j,1,n-len+1) st[i][j]=min(st[i-1][j],st[i-1][j+len]);\n\t}\n}\nint LCP(int i,int j) {\n\tif(i==j) return n-sa[i]+1;\n\tif(i>j) swap(i,j);\n\tj--;\n\tint d=Log[j-i+1];\n\treturn min(st[d][i],st[d][j-(1<<d)+1]);\n}\n} S;\n\nstruct SA_Solver:Suffix_Array{\nint stk[N],top,ls[N],rs[N],mk[N];\nll ans,F[N*2];\nset <int> st[N*2];\nvoid dfs(int &u,int l,int r,int lst){\n\tif(l==r) {\n\t\tu=++m;\n\t\tint p=sa[l];\n\t\tif(p>2) {\n\t\t\tint q=n-(p-2)+1;\n\t\t\tF[u]=n-q+1;\n\t\t\tst[u].insert(S.rk[q]);\n\t\t}\n\t\tif(p>1) ans+=1ll*(n-p+1-lst)*(F[u]+1);\n\t\treturn;\n\t}\n\tdfs(ls[u],l,u,lcp[u]),dfs(rs[u],u+1,r,lcp[u]);\n\tif(st[ls[u]].size()>st[rs[u]].size()) swap(ls[u],rs[u]);\n\tswap(st[u],st[rs[u]]),F[u]=F[ls[u]]+F[rs[u]];\n\n\tint t=-1;\n\tfor(int i:st[ls[u]]) {\n\t\tif(~t) F[u]+=S.LCP(t,i);\n\t\tt=i;\n\t\tauto r=st[u].upper_bound(i);\n\t\tif(r!=st[u].end()) F[u]-=S.LCP(i,*r);\n\t\tif(r!=st[u].begin()) {\n\t\t\tauto l=r; l--;\n\t\t\tif(r!=st[u].end()) F[u]+=S.LCP(*l,*r);\n\t\t\tF[u]-=S.LCP(*l,i);\n\t\t}\n\t\tst[u].insert(i);\n\t}\n\tans+=1ll*(lcp[u]-lst)*(F[u]+1);\n}\nvoid Solve(){\n\trep(i,1,n-1) {\n\t\twhile(top && lcp[stk[top]]>lcp[i]) ls[i]=stk[top--];\n\t\tif(top) rs[stk[top]]=i;\n\t\tstk[++top]=i;\n\t}\n\trep(i,1,n-1) mk[ls[i]]=mk[rs[i]]=1;\n\n\trep(i,1,n) ans+=n-i+1-lcp[i];\n\tans++;\n\tint lst=-1;\n\trep(i,1,n) if(S.sa[i]>1) {\n\t\tans+=n-S.sa[i]+1;\n\t\tif(~lst) ans-=min(S.LCP(i,lst),min(n-S.sa[i]+1,n-S.sa[lst]+1));\n\t\tlst=i;\n\t}\n\tans++;\n\trep(i,1,n-1) if(!mk[i]) dfs(i,1,n,0);\n\tprintf(\"%lld\\n\",ans);\n}\n} T;\n\nint main(){\n\tscanf(\"%s\",s+1),n=m=strlen(s+1);\n\tif(n==1) return puts(\"3\"),0;\n\tT.Build(),reverse(s+1,s+n+1),S.Build(),S.Init();\n\tT.Solve();\n}\n```\n\n\n\n\n\n\n\n"},{"url":"/2021/05/20/CF1264E - Beautiful League/","content":"# CF1264E - Beautiful League\n\n### 题目大意\n\n给定一张竞赛图，其中一些边已经确定\n\n现在求确定剩余边的方向，使得最终图上三元环个数最大\n\n<br>\n\n### 分析\n\n~~三元问题着实难以处理~~\n\n考虑什么样的三个点$(x,y,z)$无法构成一个环：\n\n三个点恰好存在一个点$x$得到两条入边，即$x\\leftarrow y,x\\leftarrow z$\n\n此时无法构成环\n\n<br>\n\n于是问题转化为统计$x$的入度$ind_x$，减少的三元环个数就是$\\sum \\binom{ind_i}{2}$\n\n考虑用网络流计算答案，每一条边$(u,v)$可以选择从$S$流向$u$或者$v$\n\n一个点得到$i$的流量付出$\\binom{i}{2}$的代价流出$T$\n\n因此每个点向$T$连$n-1$条流量为$1$，代价分别为为$\\binom{j}{2}-\\binom{j-1}{2}$的边\n\n求满流最小费用即可，输出方案容易根据流量情况判断\n\n复杂度为$O(\\text{MCMF}(n^2,n^2))$ 或者$O(\\text{MCMF}(n,n^2))$\n\n```cpp\nconst int N=2e5+10,INF=1e9+10;\n\nint n,m,S,T,V;\nstruct Edge{\n\tint to,nxt,w,c;\n} e[N];\nint head[N],ecnt=1;\nvoid AddEdge(int u,int v,int w,int c){\n\te[++ecnt]=(Edge){v,head[u],w,c};\n\thead[u]=ecnt;\n}\nvoid Link(int u,int v,int w,int c){ AddEdge(u,v,w,c),AddEdge(v,u,0,-c); }\n\nint ans,dis[N];\nchar s[N];\nint inq[N],pre[N],w[N];\nint mk[110][110];\n\nint main(){\n\tn=rd(),m=rd(),S=n+1,T=V=S+1;\n\trep(i,1,n) rep(j,1,n-1) Link(i,T,1,j*(j-1)/2-(j-1)*(j-2)/2);\n\tmemset(mk,-1,sizeof mk);\n\twhile(m--) {\n\t\tint u=rd(),v=rd();\n\t\tif(u<v) mk[u][v]=1;\n\t\telse mk[v][u]=0;\n\t}\n\trep(i,1,n) rep(j,i+1,n) {\n\t\tLink(S,++V,1,0);\n\t\tif(mk[i][j]!=0) Link(V,j,1,0);\n\t\tif(mk[i][j]!=1) Link(V,i,1,0);\n\t}\n\twhile(1) {\n\t\tstatic queue <int> que;\n\t\trep(i,1,V) dis[i]=INF;\n\t\tdis[S]=0,que.push(S),w[S]=INF;\n\t\twhile(!que.empty()) {\n\t\t\tint u=que.front(); que.pop();\n\t\t\tinq[u]=0;\n\t\t\tfor(int i=head[u];i;i=e[i].nxt) {\n\t\t\t\tint v=e[i].to,c=e[i].c;\n\t\t\t\tif(!e[i].w || dis[v]<=dis[u]+c) continue;\n\t\t\t\tdis[v]=dis[u]+c,w[v]=min(e[i].w,w[u]),pre[v]=i;\n\t\t\t\tif(!inq[v]) que.push(v),inq[v]=1;\n\t\t\t}\n\t\t}\n\t\tif(dis[T]==INF) break;\n\t\tint c=w[T]; ans+=dis[T]*c;\n\t\tfor(int u=T;u!=S;u=e[pre[u]^1].to) e[pre[u]].w-=c,e[pre[u]^1].w+=c;\n\t}\n\tmemset(mk,0,sizeof mk);\n\trep(a,1,n) rep(b,a+1,n) {\n\t\tint u=++T;\n\t\tfor(int i=head[u];i;i=e[i].nxt) if(e[i].to<=n && !e[i].w) {\n\t\t\tif(e[i].to==b) mk[a][b]=1;\n\t\t\telse mk[b][a]=1;\n\t\t}\n\t}\n\trep(i,1,n) {\n\t\trep(j,1,n) putchar(mk[i][j]+'0');\n\t\tputs(\"\");\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2021/05/20/CF1221G - Graph And Numbers/","content":"# CF1221G - Graph And Numbers\n\n### 题目大意\n\n给定一个$n$点$m$边的无向图，$n\\leq 40$\n\n求给所有点01染色，满足\n\n至少存在一条边两边的点均为0\n\n至少存在一条边两边的点一个为0，一个为1\n\n至少存在一条边两边的点均为1\n\n的方案数\n\n<br>\n\n### 分析\n\n**至少存在** 问题并不好处理，由于限制有3个，可以通过$2^3$种情况容斥得到\n\n设三种边类型为0,1,2\n\n即计算\n\n1.不存在0\n\n2.不存在1\n\n3.不存在2\n\n4.不存在01\n\n5.不存在02\n\n6.不存在12\n\n7.不存在012\n\n### 逐个击破\n\n2.即计算所有边连接两个点染色相同方案数，统计连通块即可\n\n4/6即统计所有点两边都是1/0的方案数\n\n5即统计所有边两端点颜色不同的方案数，即二分图染色数\n\n7.即m=0\n\n1,3类似，可以归纳为每条边两端的点至少有一个为1\n\n~~似乎有点类似一般图独立集个数的求解~~\n\n由于$n\\leq 40$，考虑 $\\text{meet in the middle}$ 做\n\n枚举半边，判断集合内部是否有非法边，然后根据集合之间的非法边以及自己集合内部为0的点\n\n确定另一个集合必须选择为1的点集\n\n因此需要一个父集前缀和\n\n```cpp\nconst int N=45;\n\nint n,m;\nint G[N][N];\nll E[N]; // 这东西居然要开long long\n\nll Solve0(){\n\tstatic int S[1<<20];\n\tll ans=0;\n\tint m=n/2,A=(1<<m)-1;\n\trep(i,0,(1<<m)-1) {\n\t\tll T=0;\n\t\trep(j,0,m-1) if(~i&(1<<j)) T|=E[j];\n\t\tS[i]=(~i&T&A)==0;\n\t}\n    // 父集前缀和\n\tfor(int i=1;i<=A;i<<=1) for(int l=0;l<=A;l+=i*2) for(int j=l;j<l+i;++j) S[j]+=S[j+i];\n\trep(i,0,(1<<(n-m))-1) {\n\t\tll T=0;\n\t\trep(j,0,n-m-1) if(~i&(1<<j)) T|=E[j+m];\n\t\tif((T>>m)&~i) continue;\n\t\tT&=A,ans+=S[T];\n\t}\n\treturn ans;\n}\n\nll Solve1(){\n\tstatic int vis[N];\n\tfunction<void(int)> dfs=[&](int u) {\n\t\tif(vis[u]) return;\n\t\tvis[u]=1;\n\t\trep(i,0,n-1) if(G[u][i]) dfs(i);\n\t};\n\tll ans=1;\n\trep(i,0,n-1) if(!vis[i]) dfs(i),ans<<=1;\n\treturn ans;\n}\n\nll Solve01(){\n\tll ans=1;\n\trep(i,0,n-1) if(!E[i]) ans<<=1;\n\treturn ans;\n}\n\nll Solve02(){\n\tstatic int vis[N],fl=1;\n\tfunction <void(int,int)> dfs=[&](int u,int c) {\n\t\tif(vis[u]) {\n\t\t\tif(vis[u]!=c) fl=0;\n\t\t\treturn;\n\t\t}\n\t\tvis[u]=c;\n\t\trep(i,0,n-1) if(G[u][i]) dfs(i,3-c);\n\t};\n\n\tll ans=1;\n\trep(i,0,n-1) if(!vis[i]) dfs(i,1),ans<<=1;\n\treturn fl*ans;\n}\n\n\nint main(){\n\tn=rd(),m=rd();\n\trep(i,1,m) {\n\t\tint x=rd()-1,y=rd()-1;\n\t\tG[x][y]=G[y][x]=1;\n\t\tE[x]|=1ll<<y,E[y]|=1ll<<x;\n\t}\n\tll ans=1ll<<n;\n\tans-=2*Solve0(),ans-=Solve1();\n\tans+=2*Solve01()+Solve02();\n\tif(m==0) ans-=1ll<<n;\n\tprintf(\"%lld\\n\",ans);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2021/05/20/CF1217F - Forced Online Queries Problem/","content":"# CF1217F - Forced Online Queries Problem\n\n### 题目大意\n\n$n$个点无向图，$m$次操作，每次加入/删除一条边，或者查询两个点连通性\n\n$lst$为上次查询的连通性情况，即$lst=\\{0,1\\}$\n\n加密方式为$x=(x'+lst-1)\\mod n+1$\n\n<br>\n\n### 吐槽\n\n~~如果你管这叫Forced Online？~~\n\n<br>\n\n### 分析\n\n### 无强制在线\n\n如果没有这个假的强制在线，考虑用线段树分治解决\n\n预处理每条边出现的时间区间$[L,R]$，加入线段树，用按秩合并并查集维护加边和回撤即可\n\n<br>\n\n### 伪强制在线\n\n依然是预处理每条边的时间区间\n\n虽然我们无法确定一条边**存在**的时间区间\n\n但是我们可以确定一条边**可能存在，或者说可能被修改**的时间区间\n\n一次修改对应两条可能的边，对于两种可能都加入两条边对应的时间节点\n\n每次加边修改指定边，对于涉及的两条边，修改之后判断是否存在\n\n然后对于存在的边，将这条边从现在开始到 **下一个时间节点** 出现之间都插入即可\n\n注意这个线段树分治是\"半在线\"的，即要一边处理操作一边插入修改\n\n由于修改的区间和目前遍历的区间不交，所以容易实现\n\n```cpp\nconst int N=2e5+10;\n\nint n,m,c;\nmap <int,int> M[N],I[N];\nvector <int> T[N*2];\nint P[N*2];\n\n\nint stk[N],top,S[N],F[N];\nint Find(int x){\n\twhile(F[x]!=x) x=x[F][F];\n\treturn x;\n}\nvoid Union(int x,int y){\n\tx=Find(x),y=Find(y);\n\tif(x==y) return;\n\tif(S[x]>S[y]) swap(x,y);\n\tF[x]=y,S[y]+=S[x],stk[++top]=x;\n}\nvoid Back(){\n\tint x=stk[top--];\n\tS[F[x]]-=S[x],F[x]=x;\n}\n\nvector <Pii> G[N<<2];\nvoid Add(int p,int l,int r,int ql,int qr,Pii x){\n\tif(ql>qr) return;\n\tif(ql<=l && r<=qr) return G[p].pb(x);\n\tint mid=(l+r)>>1;\n\tif(ql<=mid) Add(p<<1,l,mid,ql,qr,x);\n\tif(qr>mid) Add(p<<1|1,mid+1,r,ql,qr,x);\n}\nint opt[N],A[N],B[N],lst;\nvoid Solve(int p,int l,int r){\n\tint tmp=top;\n\tfor(Pii t:G[p]) Union(t.first,t.second);\n\tif(l==r) {\n\t\tint x=(A[l]+lst-1)%n+1;\n\t\tint y=(B[l]+lst-1)%n+1;\n\t\tif(x>y) swap(x,y);\n\t\tif(opt[l]==1) {\n\t\t\tM[x][y]^=1;\n\t\t\trep(i,0,1) {\n\t\t\t\tint x=(A[l]+i-1)%n+1;\n\t\t\t\tint y=(B[l]+i-1)%n+1;\n\t\t\t\tif(x>y) swap(x,y);\n\t\t\t\tint id=I[x][y];\n\t\t\t\tP[id]++;\n\t\t\t\tif(M[x][y]) Add(1,1,m,l+1,T[id][P[id]]-1,mp(x,y));\n\t\t\t}\n\t\t} else {\n\t\t\tlst=Find(x)==Find(y);\n\t\t\tputchar(lst+48);\n\t\t}\n\t} else {\n\t\tint mid=(l+r)>>1;\n\t\tSolve(p<<1,l,mid),Solve(p<<1|1,mid+1,r);\n\t}\n\twhile(top>tmp) Back();\n}\n\nint main(){\n\tn=rd(),m=rd();\n\trep(i,1,n) F[i]=i,S[i]=1;\n\trep(i,1,m) {\n\t\topt[i]=rd(),A[i]=rd(),B[i]=rd();\n\t\tif(opt[i]==1) rep(lst,0,1) {\n\t\t\tint x=(A[i]+lst-1)%n+1;\n\t\t\tint y=(B[i]+lst-1)%n+1;\n\t\t\tif(x>y) swap(x,y);\n\t\t\tif(!I[x][y]) I[x][y]=++c;\n\t\t\tT[I[x][y]].pb(i);\n\t\t}\n\t}\n\trep(i,1,c) T[i].pb(m+1);\n\tSolve(1,1,m);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2021/05/20/CF1201E2 - Knightmare (hard)/","content":"# CF1201E2 - Knightmare (hard)\n\n### 题目大意\n\n$n\\times m(2|n,2|m)$的棋盘上有两个 马 ~~(Knight是国际象棋)~~ 分别位于$S_1=(x_1,y_1),S_2=(x_2,y_2)$\n\n他们分别要到达$T_1=(\\frac{n}{2},\\frac{m}{2}),T_2=(\\frac{n}{2}+1,\\frac{m}{2})$\n\n一方胜利的情况是：\n\n1.吃掉另一方\n\n2.到达自己的目标位置，且这个位置不能被另一方吃掉\n\n你可以选定操作先手还是后手，要求和交互器交互，并且在**350**步内取胜\n\n<br>\n\n### 分析\n\n首先是一个重要的性质：**双方必然有一方永远无法吃掉另一方**\n\n考虑象棋的移动，每次$(x\\pm 1,y\\pm 2)$或者$(x\\pm 2,y\\pm 1)$\n\n每次操作，必然导致$x+y\\mod 2$改变，在双方轮流操作的过程中\n\n必然有一方走的时候永远无法和另一方同奇偶，也就是无法吃掉另一方\n\n<br>\n\n在此基础上，考虑几种情况\n\n设$D(a,b)$为$a,b$两点的距离，$f$为先手是否永远不会被吃\n\n1.先手可以在不被后手吃掉的情况下到达目标，且先于后手\n\n先于后手即$D(S_1,T_1)\\leq D(S_2,T_2)$\n\n先手不被后手吃掉的情况\n\n1.$f$ ： 显然\n\n2.$D(S_1,T_1)<D(S_2,T_1)$：\n\n此时，假设后手存在一个吃掉先手的策略\n\n那么后手经过这个吃掉先手的点到达$T_1$的最短路一定和先手相同，故矛盾\n\n\n\n<br>\n\n2.后手可以在不被先手吃掉的情况下到达目标，且先于先手\n\n$D(S_1,T_1)>D(S_2,T_2)$\n\n对称情况\n\n1.$not\\  f$ \n\n2.$D(S_2,T_2)<D(S_1,T_2)-1$\n\n以上两种情况均直接冲最短路到达目标\n\n<br>\n\n3.双方均无法安全直接抵达目标\n\n此时，考虑选择不会被吃的一方操作\n\n由于自己是无敌的，可以考虑先猛扑对方的终点\n\n3.1 $f=true$，选择先手\n\n先走到$T_2$堵住后手，然后可以绕三步到达$T_1$\n\n先手占据$T_2$时，后手无法到达$T_2$\n\n走第一步时，由于先手限制着，后手无法进入$T_2$\n\n走第二步时，根据奇偶性分析，后手无法到达$T_2$的奇偶性\n\n第三步到达目标\n\n3.2$f=false$，同理\n\n\n\n### 实现\n\n可以好好封装一下\n\n~~我曾经以为不用读入~~\n\n由于交互器下面读入的参数可能会让交互器走智障操作\n\n如果能吃掉对方，一定要直接吃掉\n\n```cpp\nconst int N=1010,INF=1e9+10;\nconst int dx[]={1,1,-1,-1,2,2,-2,-2};\nconst int dy[]={2,-2,2,-2,1,-1,1,-1};\n\nint n,m,opt;\nint x=-2,y=-2;\nvoid input(){ \n\tx=rd(),y=rd(); \n\tif(x==-1) exit(0);\n}\nvoid CB(){ puts(\"BLACK\"),fflush(stdout),input(); }\nvoid CW(){ puts(\"WHITE\"),fflush(stdout); }\n\nstruct Bfser{\n\tint dis[N][N],pre[N][N];\n\tint QX[N*N],QY[N*N],L,R;\n\tint u,v;\n\tint Reach() {\n\t\tint a=abs(u-x),b=abs(y-v);\n\t\tif(a>b) swap(a,b);\n\t\treturn a==1 && b==2;\n\t}\n\tvoid Bfs(int x,int y){\n\t\tu=x,v=y;\n\t\tQX[L=R=1]=x,QY[1]=y,pre[x][y]=-1,dis[x][y]=1;\n\t\tfor(;L<=R;) {\n\t\t\tx=QX[L],y=QY[L++];\n\t\t\trep(i,0,7) {\n\t\t\t\tint x1=x+dx[i],y1=y+dy[i];\n\t\t\t\tif(x1<1 || y1<1 || x1>n || y1>m || dis[x1][y1]) continue;\n\t\t\t\tdis[x1][y1]=dis[x][y]+1,QX[++R]=x1,QY[R]=y1,pre[x1][y1]=i;\n\t\t\t}\n\t\t}\n\t}\n\tvoid Go(int d,int k=1) {\n\t\tif(Reach()) printf(\"%d %d\\n\",x,y),fflush(stdout),exit(0);\n\t\tprintf(\"%d %d\\n\",u+=dx[d],v+=dy[d]),fflush(stdout);\n\t\tif(k) input();\n\t}\n\tvoid Go(int x,int y,int k) {\n\t\tvector <int> s;\n\t\twhile(~pre[x][y]) {\n\t\t\tint t=pre[x][y];\n\t\t\ts.pb(t),x-=dx[t],y-=dy[t];\n\t\t}\n\t\tdrep(i,s.size()-1,0) Go(s[i],k+i);\n\t}\n} B,W;\n\nint main(){\n\tn=rd(),m=rd();\n\tint x1=rd(),y1=rd(),x2=rd(),y2=rd();\n\tW.Bfs(x1,y1),B.Bfs(x2,y2);\n\tint f=((x1+y1)&1)!=((x2+y2)&1);\n\tif(W.dis[n/2][m/2]<=B.dis[n/2+1][m/2] && (f || W.dis[n/2][m/2]<B.dis[n/2][m/2])) {\n\t\tCW(),x=x2,y=y2,W.Go(n/2,m/2,0);\n\t} else if(B.dis[n/2+1][m/2]<W.dis[n/2][m/2] && (B.dis[n/2+1][m/2]<W.dis[n/2+1][m/2]-1 || !f)) {\n\t\tCB(),B.Go(n/2+1,m/2,0);\n\t} else if(f) {\n\t\tCW(),x=x2,y=y2,W.Go(n/2+1,m/2,1);\n\t\tW.Go(2),W.Go(5),W.Go(7,0);\n\t} else {\n\t\tCB(),B.Go(n/2,m/2,1);\n\t\tB.Go(0),B.Go(7),B.Go(5,0);\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2021/05/20/CF1187G - Gang Up/","content":"# CF1187G - Gang Up\n\n### 题目大意\n\n有$k$个人在一张无向图上往1走，可以选择在原地不动或者走一条边\n\n一个人在$x$时间到达目的地的代价是$c\\cdot x$，$c$是常数\n\n一条边同一时间被$x$个人经过的代价是$x^2\\cdot d$，$d$是常数\n\n最小化代价\n\n<br>\n\n### 分析\n\n无法贪心，无法最短路的题目，那就先试试网络流\n\n考虑将时间和位置压在一起建立节点，时间$\\leq n+k$\n\n$(t,u)\\rightarrow (t+1,u) $\n\n$(t,u)\\rightarrow (t+1,v)$\n\n在原地保持的边代价为$c$，流量$\\infty$\n\n在两点间移动的代价由于与个数有关，可以建立$k$条边\n\n每条代价是$d(i^2-(i-1)^2)+c=c+(2i-1)d$\n\n得到一个$O((n+k)n)$点数$O((n+k)m\\cdot k)$边数的图\n\n然后可以考虑依次将每个人加入流量\n\n但是实际上，并不需要显式地将所有边连出来跑网络流\n\n每次加入一个点看做一个带回撤的最短路问题，有效的边只有$(n+k)m$条\n\n因此复杂度为$O(k\\cdot \\text{SPFA}((n+k)n,(n+k)m))$\n\n```cpp\nconst int N=110,INF=1e9+10;\n\nint n,m,k,C,D;\nint a[N];\nstruct Edge{\n\tint to,nxt;\n} e[N<<1];\nint head[N],ecnt=1;\nvoid AddEdge(int u,int v){\n\te[++ecnt]=(Edge){v,head[u]};\n\thead[u]=ecnt;\n}\n\nint dis[N][N],pre[N][N],inq[N][N],G[N][N],W[N][N];\nstatic queue <Pii> que;\nvoid Upd(int x,int y,int d,int p){\n\tif(dis[x][y]>d) {\n\t\tdis[x][y]=d,pre[x][y]=p;\n\t\tif(!inq[x][y]) inq[x][y]=1,que.push(mp(x,y));\n\t}\n}\n\nint cnt[N][N];\n\nint main(){\n\tn=rd(),m=rd(),k=rd(),C=rd(),D=rd();\n\trep(i,1,k) a[i]=rd();\n\trep(i,1,m) {\n\t\tint u=rd(),v=rd();\n\t\tAddEdge(u,v),AddEdge(v,u);\n\t\trep(j,1,n+k) G[j][i*2]=G[j][i*2+1]=1;\n\t}\n\tint ans=0;\n\trep(_,1,k) {\n\t\tint u=a[_];\n\t\trep(i,1,n+k) rep(j,1,n) dis[i][j]=INF;\n\t\tdis[1][u]=0,que.push(mp(1,u));\n\t\tint tu=1,ti=-1,mi=1e9;\n\t\twhile(!que.empty()) {\n\t\t\tint t=que.front().first,u=que.front().second; que.pop();\n\t\t\tinq[t][u]=0;\n\t\t\tif(u==1 && dis[t][u]<mi) mi=dis[t][u],ti=t,tu=u;\n\t\t\tif(t>1 && W[t-1][u]) Upd(t-1,u,dis[t][u]-C,1001);\n\t\t\tif(t<n+k) Upd(t+1,u,dis[t][u]+C,1002);\n\t\t\tfor(int i=head[u];i;i=e[i].nxt) {\n\t\t\t\tint v=e[i].to;\n\t\t\t\tif(G[t-1][i^1]>1) Upd(t-1,v,dis[t][u]-(G[t-1][i^1]-2)*D-C,-(i^1));\n\t\t\t\tif(t<n+k) Upd(t+1,v,dis[t][u]+G[t][i]*D+C,i);\n\t\t\t}\n\t\t}\n\t\tans+=mi;\n\t\twhile(tu!=u || ti!=1) {\n\t\t\tint t=pre[ti][tu];\n\t\t\tif(t==1001) --W[ti++][tu];\n\t\t\telse if(t==1002) W[--ti][tu]++;\n\t\t\telse if(t<0) G[ti][-t]-=2,tu=e[-t].to,ti++;\n\t\t\telse G[ti-1][t]+=2,tu=e[t^1].to,ti--;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2021/05/20/CF1379E - Inverse Genealogy/","content":"# CF1379E - Inverse Genealogy\n\n### 题目大意\n\n给定$n,k$，要求构造一棵二叉树满足\n\n1.除了叶子以外的节点有两个儿子\n\n2.称一个节点是特殊的：两个儿子中，一个儿子$size$至少是另一个的两倍  \n\n要求特殊的节点恰好有$k$个\n\n<br>\n\n### 分析\n\n首先考虑一些简单的情况\n\n1.$2|n$时不存在合法二叉树\n\n2.$n$个节点的树，能够包含$0$个特殊节点当且仅当$\\exists 2^i-1=n$\n\n也就是能够构成一棵完美二叉树\n\n3.除了$2$情况外的树，顺次放置每个节点得到的二叉树恰好包含1一个特殊点\n\n那么当$k\\leq 1$时的情况均可以被解决\n\n否则，考虑通过加上一条极长的链来构造\n\n即构造一个一边儿子大小为1，另一边顺次相接的链，这样能够做到最大利用点数\n\n最多能得到$\\frac{n-3}{2}$个特殊点\n\n然而我们必须处理剩余点的分配，下面给出的构造能够解决$k\\in [2,\\frac{n-3}{2}]$的情况\n\n### 通用构造\n\n~~经过不断尝试得到的构造方法，好像很强~~\n\n假设得到一条长度为$m$且右偏的上述链，将剩下的点分配到两个地方\n\n1.根的左儿子\n\n2.链底的右儿子\n\n分配方式就是顺次放置每个节点得到的二叉树\n\n设剩下节点个数+根的左儿+链底的右儿子$=c$\n\n设$f(n)=1-[\\exists 2^i-1=n]$，特别的，当$2|n$时，$f(n)=\\infty$\n\n假设根的左儿子分配大小为$x$，则新的树特殊点数目就是\n\n$m-2+f(x)+f(c-x)+[c-x\\ge 3]+[x\\ge 2(n-1-x) \\text{  or  } (n-1-x)\\ge 2x]$\n\n枚举每一个$x\\in[1,c-1]$，判定上式是否成立即可\n\n```cpp\nconst int N=1e5+10;\n\n#define NO puts(\"NO\"),exit(0)\n\nint n,m;\nint fa[N];\n\nint chk(int a,int b) {\n\tif(a>b) swap(a,b);\n\treturn a*2<=b;\n}\n\nvoid Out(){\n\tputs(\"YES\");\n\trep(i,1,n) printf(\"%d \",fa[i]);\n\texit(0);\n}\n\nint Get(int l,int r) {\n\trep(i,l+1,r) fa[i]=l-1+(i-l+1)/2;\n\treturn l;\n}\n\nint Mincost(int x){\n\tif(~x&1) return 1e9;\n\trep(i,0,17) if(x+1==(1<<i)) return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tn=rd(),m=rd();\n\tif(Mincost(n)==m) Get(1,n),Out();\n\tif(m==0) NO;\n\tif(~n&1) NO;\n\tif((m+1)*2>=n) NO;\n\tint r=(m+1)*2+1;\n\tif(r==n) {\n\t\trep(i,1,m+1) fa[i*2]=i*2-1,fa[i*2+1]=i*2-1;\n\t\tOut();\n\t}\n\n\tr-=2;\n\tint c=n-r+2;\n\tif(m>1) rep(x,1,c-1) if(Mincost(x)+Mincost(c-x)-!chk(c-x,n-1-(c-x))+(x>=3)==1) {\n\t\trep(i,1,m) fa[i*2]=i*2-1,fa[i*2+1]=i*2-1;\n\t\tint t=max(0,r-2);\n\t\tfa[Get(r-1,r+x-2)]=t;\n\t\tfa[2]=t;\n\t\tfa[Get(r+x-1,n)]=1;\n\t\tOut();\n\t}\n\tNO;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"Hello World","url":"/2021/05/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]