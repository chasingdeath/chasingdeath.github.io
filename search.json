[{"title":"CF1477E - Nezzar and Tournaments","url":"/2021/05/21/CF1477E - Nezzar and Tournaments/","content":"# CF1477E - Nezzar and Tournaments\n\n### 题目大意\n\n有两队人$a_i,i\\in[1,n],b_j,j\\in[1,m]$，现在把他们放在一起排成一行$c_i$\n\n顺次给每个人计分，初始$s_0=k$\n\n{%raw%}$s_i=\\max\\{0,s_{i-1}+c_i-c_{\\max\\{i-1,1\\}}\\}$}{%endraw%}\n\n现在要最大化每个$a_i$所在位置的$s_i$之和 与 $b_i$所在$s_i$之和 的差\n\n支持修改和对于不同$k$查询\n\n<br>\n\n### 分析\n\n考虑$k=0$简单情况\n\n1.若$s_i$不清零，则$s_i=c_i-lst$，其中$lst$表示上一个被清零位置的$c_j$\n\n2.$s_i$清零，则$c_i<lst$\n\n容易发现，{%raw%}$\\displaystyle s_i=c_i-\\min_{j\\leq i}\\{ c_j\\}${%endraw%}\n\n<br>\n\n那么对于含$k$的情况，类似可以得到\n\n{%raw%}$\\displaystyle s_i=k-c_1+c_i+\\max\\{0,c_1-k-\\min_{j\\leq i}\\{c_j\\}\\}${%endraw%}\n\n假设我们固定了一个$c_1$，现在考虑对于剩下的$a_i,b_j$排出一个最优的排列\n\n容易发现，$k-c_1+c_i$的贡献时固定的，只有前缀最小值会影响答案\n\n我们希望对于$b_i$，前缀最小值较大，$a_i$反之\n\n那么容易发现可以先降序排列$b_j$，再正序排列$a_i$\n\n此时$b_{\\min}$可以贡献给$a_i$的前缀最小值，同时$b_j$的前缀最小值能够取到最大\n\n<br>\n\n此时，不妨设$c_1=t$，$\\min\\{a_i,b_i\\}=Min$\n\n在$\\min\\{c_j\\}=c_1$时，$\\max$里的东西没有贡献，故可以得到\n\n1.对于每个$a_i$，若它没有被放在$c_1$，则贡献$k-t+a_i+\\max\\{0,t-k-Min\\}$\n\n2.对于每个$b_i$（不特殊考虑第一个），则贡献$-(k-t+b_i+\\max\\{0,t-k-b_i\\})$（忽略最小值为$t$的情况）\n\n则最终式子为\n\n$\\displaystyle f(t)=(n-[t\\in a_i])\\cdot  \\max\\{0,t-k-Min\\}-\\sum \\max\\{0,t-k-b_i\\}+(m-n)t+C$\n\n其中$C=(n-m)k+\\sum a_i-\\sum b_i$\n\n容易发现$f(t)$是关于$t$的分段一次函数，根据斜率变化情况分析，极值位置仅$O(1)$个\n\n那么对于$a_i$作为$t$和$b_j$作为$t$的情况，分别计算$f(t)$的极值位置\n\n极值位置需要一个$k$大查询和$\\text{lower_bound}$\n\n计算$f(t)$需要一个前缀查询\n\n我用$\\text{BIT}$充当平衡树来维护，复杂度为$O((n+m+q)\\log 10^6)$\n\n```cpp\nconst int N=1e6+10,INF=1e9+10;\n\nint n,m,q;\nint a[N],b[N];\nstruct BIT{\n\tll s[N];\n\tint c[N],n;\n\tvoid Init(int m){ n=m; }\n\tvoid Add(int p,int x,int y){\n\t\tp++;\n\t\twhile(p<N) s[p]+=x,c[p]+=y,p+=p&-p;\n\t}\n\tll Que(int p){\n\t\tp++;\n\t\tif(p<=0) return 0;\n\t\tll sum=0,cnt=0,t=p-1;\n\t\twhile(p) sum+=s[p],cnt+=c[p],p-=p&-p;\n\t\treturn t*cnt-sum;\n\t}\n\tint Rank(int p){\n\t\tif(p<0) return 0; // 一些奇怪的边界特判 ，防止查询越界\n\t\tp++,cmin(p,N-1);\n\t\tint res=0;\n\t\twhile(p) res+=c[p],p-=p&-p;\n\t\treturn res;\n\t}\n\tint Kth(int k){ // 注意一定要避免找到并不存在的数值\n\t\tcmin(k,n),cmax(k,1);\n\t\tint p=0;\n\t\tdrep(i,19,0) if(p+(1<<i)<N && c[p+(1<<i)]<k) k-=c[p+=1<<i];\n\t\treturn p;\n\t}\n\tint Prev(int x) { return Kth(Rank(x)); }\n\tint Next(int x) { return Kth(min(n,Rank(x)+1)); }\n} A,B;\n\nll delta;\nvoid AddA(int x,int k){\n\tdelta+=x*k;\n\tA.Add(x,x*k,k);\n}\nvoid AddB(int x,int k){\n\tdelta-=x*k;\n\tB.Add(x,x*k,k);\n}\n\nll QueA(ll k){\n\tll Min=min(A.Kth(1),B.Kth(1));\n\tauto F=[&](ll t){ return (n-1)*max(0ll,t-k-Min)-B.Que(t-k)+(m-n)*t; };\n\tll ans=max(F(A.Kth(1)),F(A.Kth(n)));\n\tint p=B.Kth(m-1)+k;\n\tcmax(ans,F(A.Prev(p))),cmax(ans,F(A.Next(p)));\n\treturn ans;\n}\n\nll QueB(ll k){\n\tll Min=min(A.Kth(1),B.Kth(1));\n\tauto F=[&](ll t){ return n*max(0ll,t-k-Min)-B.Que(t-k)+(m-n)*t; };\n\tll ans=max(F(B.Kth(1)),F(B.Kth(m)));\n\tint p=B.Kth(m)+k;\n\tcmax(ans,F(B.Prev(p))),cmax(ans,F(B.Next(p)));\n\treturn ans;\n}\n\nll Que(ll k){\n\treturn max(QueA(k),QueB(k))+delta+(n-m)*k;\n}\n\nint main(){\n\tn=rd(),m=rd(),q=rd(),A.Init(n),B.Init(m);\n\trep(i,1,n) AddA(a[i]=rd(),1);\n\trep(i,1,m) AddB(b[i]=rd(),1);\n\twhile(q--) {\n\t\tint opt=rd();\n\t\tif(opt==1) {\n\t\t\tint x=rd(),y=rd();\n\t\t\tAddA(a[x],-1),AddA(a[x]=y,1);\n\t\t} else if(opt==2) {\n\t\t\tint x=rd(),y=rd();\n\t\t\tAddB(b[x],-1),AddB(b[x]=y,1);\n\t\t} else printf(\"%lld\\n\",Que(rd()));\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["贪心","数据结构"],"categories":["题解"]},{"title":"[AtCoder Regular Contest 115]  D","url":"/2021/05/21/[AtCoder Regular Contest 115]  D/","content":"# [AtCoder Regular Contest 115](https://atcoder.jp/contests/arc115) #D\n\n### Solution1\n\n考虑用$\\text{FWT}$来理解这个式子，容易发现$\\text{FWT}$之后求积的式子，满足\n\n对于任意$(u_i,v_i)$\n\n如果$u_i,v_i$中有一者被选择，答案为0，否则权值$\\times 2$\n\n那么显然对于一个连通块，设其大小为$c$，放在一起考虑\n\n在$\\text{FWT}$的式子里它们同时出现或者同时不出现\n\n枚举最后$\\text{FWT}$回来时的项与在这$c$个位置中出现$i$个\n\n对于选择这个连通块的情况，贡献为$(-1)^i$\n\n对于不选的情况，贡献为$1$\n\n显然只有$2|i$时贡献为2，乘上组合数完成转移，连通块之间背包合并\n\n就能得到最终计算答案的项中出现了几个1，然后与$\\text{FWT}$的系数合并即可\n\n$$  \\ $$\n\n### Solution2\n\n对于一个连通块，考虑取出一个生成树\n\n容易发现，仅使用这个生成树上的边，就能构成任何一个包含$2k$个奇点的情况\n\n对于多余的边，类似异或线性基，它们都是可选可不选的\n\n于是直接统计答案即可\n\n\n\nSol1 和 Sol2 的式子是一样的\n\n```cpp\nconst int N=5010,P=998244353;\nint n,m,dp[N];\nll qpow(ll x,ll k=P-2){\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\nvector <int> G[N];\nint c,vis[N],C[N][N];\nvoid dfs(int u){\n\tif(vis[u]) return;\n\tvis[u]=1,c++;\n\tfor(int v:G[u]) dfs(v);\n}\n\nint main(){\n\tn=rd(),m=rd();\n\trep(i,0,n) rep(j,*C[i]=1,i) C[i][j]=C[i-1][j]+C[i-1][j-1],Mod1(C[i][j]);\n\trep(i,1,m) {\n\t\tint u=rd(),v=rd();\n\t\tG[u].pb(v),G[v].pb(u);\n\t}\n\tdp[0]=1;\n\trep(u,1,n) if(!vis[u]) {\n\t\tc=0,dfs(u);\n\t\tdrep(i,n,0) {\n\t\t\tint s=0;\n\t\t\trep(j,0,min(i,c)) if(~j&1) {\n\t\t\t\ts=(s+2ll*dp[i-j]*C[c][j])%P;\n\t\t\t}\n\t\t\tdp[i]=s;\n\t\t}\n\t}\n\tint d=qpow(2,P-1-n+m);\n\trep(i,0,n) printf(\"%d\\n\",int(1ll*dp[i]*d%P));\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[BJ United Round  3] 押韵","url":"/2021/05/21/[BJ United Round  3] 押韵/","content":"# [BJ United Round #3] 押韵\n\n先%%%%%%%%%%%%%%%%% EI\n\n$$ \\ $$\n\n$$ \\ $$\n\n下文默认模数为$P$\n\n简要题意：求：用$k$种元素，每种元素使用$d$的倍数次，排成一个长度为$nd$的序列 的方案数\n\n这个题目的设定就让人想到两个离不开的元素 ： ~~(模数暗示了？)~~\n\n指数型生成函数 + 单位根反演\n\n显然可以得到每一种元素的指数型生成函数为\n\n$\\begin{aligned} \\text{EGF(Element)}=F(x)=\\sum_{d|i} \\frac{x^i}{i!}\\end{aligned}$\n\n带入单位根反演$\\begin{aligned}\\ [d|n]=\\frac{\\sum_0^{d-1} \\omega_d^{in}}{d}\\end{aligned}$\n\n即$F(x)=\\begin{aligned}\\frac{1}{d}\\cdot \\sum_{i=0}^{d-1}e^{\\omega_d^ix}\\end{aligned}$\n\n而总的生成函数就是 $G(x)=F^k(x)$\n\n即$\\begin{aligned} G(x)=\\frac{1}{d^k}\\cdot (\\sum_{i=0}^{d-1}e^{\\omega_d^ix})^k\\end{aligned}$\n\n其中的和式幂次展开会得到一个$k^d$项的多项式，我们要求$[x^n]G(x)$，就需要展开得到每一项的幂系数\n\n所以显然我们需要先合并同类项一下。。。\n\n而幂系数是一个单位根之和的形式，这就需要我们寻找单位根之间的关系\n\n这里得到一个思路：用$d$次单位根中的$\\varphi(d)$个作为基底，以简单的 有理数/整系数 表示出所有的$\\omega_d^i$\n\n$$ \\ $$\n\n对于$d=4$的情况比较简单，$\\varphi(d)=2$，可以得到四个单位根分别为$1,\\omega,-1,-\\omega$\n\n可以枚举得到的和为$x+y\\omega$，然后求系数\n\n优先考虑组合意义，可以发现就是在平面上每次可以走四个方向，$k$步之后最终到达$(x,y)$的方案数\n\n两个维度分立的情况，还需要枚举每个维度走了几步，所以用一种巧妙的转化两个维度联系在一起\n\n将平面旋转$\\frac{\\pi}{8}$，并且扩大$\\sqrt 2$倍，得到新的坐标为$(x-y,x+y)$，新的行走方向是$(+1,+1),(-1,-1),(-1,+1),(+1,-1)$\n\n这样以来，每次每个维度都有行走，可以确定每个维度$+1$和$-1$的次数，直接组合数排列即可得到答案\n\n$$ \\ $$\n\n$$ \\ $$\n\n对于$d=6$，甚至是更一般的情况的情况\n\n只在代数层面来看单位根似乎十分抽象，不如从复平面单位根上找一找灵感\n\n下面是$d=6$的情形\n\n![planeomega.png](https://i.loli.net/2021/01/30/Bb3vJq1TGPgtfs2.png)\n\n\n\n$\\varphi(6)=2$，假设以$\\overrightarrow{OA},\\overrightarrow{OB}$作为基底，可以直观地得到基底表达\n\n\n\n|                                  | $\\overrightarrow{OA}=1$ | $\\overrightarrow{OB}=\\omega$ |\n| -------------------------------- | ----------------------- | ---------------------------- |\n| $\\overrightarrow{OA}=\\omega_6^0$ | 1                       | 0                            |\n| $\\overrightarrow{OB}=\\omega_6^1$ | 0                       | 1                            |\n| $\\overrightarrow{OC}=\\omega_6^2$ | -1                      | 1                            |\n| $\\overrightarrow{OD}=\\omega_6^3$ | -1                      | 0                            |\n| $\\overrightarrow{OE}=\\omega_6^4$ | 0                       | -1                           |\n| $\\overrightarrow{OF}=\\omega_6^5$ | 1                       | -1                           |\n\n由此我们得到了一个$\\varphi(d)$维数的表达方法\n\n把每一维看做不同元，也就是说，得到了一个$\\varphi(d)$维，$O(1)$次的多项式，需要我们求高维多项式幂次\n\n令$N=k^{\\varphi(d)}$\n\n直接压位暴力多项式复杂度为$O(N\\log N-N\\log^2N)$，而且面临着模数难以处理，常数大的问题\n\n所以$\\text{EI}$又用出了一个巧妙的暴力方法解决这个问题，以$d=6$为例，先做一下处理，得到要求的多项式\n\n~~似乎每次$k$次幂总是求导+递推？~~\n\n$f(x,y)=x^2y+xy^2+y^2+y+x+x^2,g(x,y)=f^k(x,y)$\n\n$g(x,y)$对于$x$求偏导，得到$g'(x,y)=kf^{k-1}(x,y)f'(x,y)$\n\n即$g'(x,y)f(x,y)=kg(x,y)f'(x,y)$\n\n$f'(x,y)=2xy+2x+y^2+1$\n\n然后我们要解这个方程，考虑乘积为$[x^ny^m]$一项两边的系数\n\n左边$=[x^{n-2}y^{m-1}]+[x^{n-1}y^{m-2}]+[x^{n}y^{m-2}]+[x^{n}y^{m-1}]+[x^{n-1}y^{m}]+[x^{n-2}y^{m}]$\n\n换成$g(x,y)$的系数应该是\n\n左边$=(n-1)[x^{n-1}y^{m-1}]+n[x^{n}y^{m-2}]+(n+1)[x^{n+1}y^{m-2}]+(n+1)[x^{n+1}y^{m-1}]+n[x^{n}y^{m}]+(n-1)[x^{n-1}y^{m}]$\n\n右边$=2k[x^{n-1}y^{m-1}]+2k[x^{n-1}y^m]+k[x^ny^{m-2}]+k[x^ny^m]$\n\n其中$[x^{n+1}y^{m-1}]$只出现了一次，按照先$n$递增再$m$递增的顺序进行递推，即\n\n$\\begin{aligned}\\ [x^ny^m]=\\frac{2k[x^{n-2}y^{m}]+2k[x^{n-2}y^{m+1}]+k[x^{n-1}y^{m-1}]+k[x^{n-1}y^{m+1}]}{n}\\end{aligned}$\n\n$\\begin{aligned}-\\frac{(n-2)[x^{n-2}y^{m}]+(n-1)[x^{n-1}y^{m-1}]+n[x^{n}y^{m-1}]+(n-1)[x^{n-1}y^{m+1}]+(n-2)[x^{n-2}y^{m+1}]}{n}\\end{aligned}$\n\n边界条件是 $\\begin{aligned}\\ [x^i]=[y^i](i\\ge k)=\\binom{k}{i-k}\\end{aligned}$ (由系数$x,x^2$或$y,y^2$得到)\n\n由此带入递推即可\n\n综上，得到的每项的系数的复杂度为$O(d\\cdot k^{\\varphi(d)})$ ，其中$d$为递推每项需要的时间\n\n由系数得到答案仍然需要一次快速幂，因此依然带一个$\\log P$\n\n\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair <int,int> Pii;\n#define reg register\n#define pb push_back\n#define mp make_pair\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ a=min(a,b); }\ntemplate <class T> inline void cmax(T &a,T b){ a=max(a,b); }\n\nchar IO;\nint rd(){\n    int s=0,f=0;\n    while(!isdigit(IO=getchar())) if(IO=='-') f=1;\n    do s=(s<<1)+(s<<3)+(IO^'0');\n    while(isdigit(IO=getchar()));\n    return f?-s:s;\n}\n\nconst int N=2e3+10,P=1049874433,G=7;\n\nint n,k,d;\nll qpow(ll x,ll k=P-2) {\n    k%=P-1;\n    ll res=1;\n    for(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n    return res;\n}\nint w[100],C[N][N],I[N*2];\n\nint main() {\n    n=rd(),k=rd(),d=rd();\n    w[0]=1,w[1]=qpow(G,(P-1)/d);\n    rep(i,2,90) w[i]=1ll*w[i-1]*w[1]%P;\n    rep(i,0,k) rep(j,C[i][0]=1,i) C[i][j]=C[i-1][j]+C[i-1][j-1],Mod1(C[i][j]);\n    I[0]=I[1]=1;\n    rep(i,2,k*2) I[i]=1ll*(P-P/i)*I[P%i]%P;\n    if(d==1){\n        int ans=qpow(k,1ll*d*n);\n        printf(\"%d\\n\",ans);\n    } else if(d==2) {\n        int ans=0;\n        rep(i,0,k) ans=(ans+qpow((1ll*w[0]*i+1ll*w[1]*(k-i))%P,1ll*d*n)*C[k][i])%P;\n        ans=ans*qpow(qpow(d,k))%P;\n        printf(\"%d\\n\",ans);\n    } else if(d==3) {\n        int ans=0;\n        rep(i,0,k) rep(j,0,k-i) \n            ans=(ans+qpow((1ll*w[0]*i+1ll*w[1]*j+1ll*w[2]*(k-i-j))%P,1ll*d*n)*C[i+j][i]%P*C[k][i+j])%P;\n        ans=ans*qpow(qpow(d,k))%P;\n        printf(\"%d\\n\",ans);\n    } else if(d==4) {\n        int ans=0;\n        rep(i,-k,k) rep(j,-k,k) if(abs(i)+abs(j)<=k && (k-i-j)%2==0) {\n            ll x=qpow((1ll*w[0]*i+1ll*w[1]*j)%P,1ll*d*n);\n            ll y=1ll*C[k][(abs(i-j)+k)/2]*C[k][(k+abs(i+j))/2]%P;\n            ans=(ans+x*y)%P;\n        }\n        ans=(ans+P)*qpow(qpow(d,k))%P;\n        printf(\"%d\\n\",ans);\n    } else {\n        static int F[N*2][N*2];\n        int ans=0;\n        rep(i,0,k*2) rep(j,max(k-i,0),min(2*k,3*k-i)) {\n            if(i==0) F[i][j]=C[k][j-k];\n            else if(j==0) F[i][j]=C[k][i-k];\n            else {\n                int s=(2ll*k*(i>1?F[i-2][j]+F[i-2][j+1]:0)+1ll*k*(F[i-1][j-1]+F[i-1][j+1]))%P;\n                int t=((i>1?1ll*(i-2)*(F[i-2][j]+F[i-2][j+1]):0)+\n                    1ll*(i-1)*F[i-1][j-1]+1ll*i*F[i][j-1]+1ll*(i-1)*F[i-1][j+1])%P;\n                F[i][j]=1ll*(s-t+P)*I[i]%P;\n            }\n            ans=(ans+qpow((1ll*w[0]*(i-k)+1ll*w[1]*(j-k))%P,1ll*d*n)*F[i][j])%P;\n        }\n        ans=(ans+P)*qpow(qpow(d,k))%P;\n        printf(\"%d\\n\",ans);\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[BZOJ1852] [MexicoOI06]最长不下降序列(贪心)","url":"/2021/05/21/[BZOJ1852] [MexicoOI06]最长不下降序列(贪心)/","content":"# [BZOJ1852] [MexicoOI06]最长不下降序列(贪心)\n\n考虑如下贪心\n\n（我将问题反过来考虑，也就是要满足$A_i > \\max_{j=1}^{j < i}{B_j}$）\n\n首先对于读入的$(A,B)$，按照$B$的值递增排序\n\n**(选出的答案序列不一定是其中一个有序的子序列)**\n\n答案序列存在若干个$B$递增的位置，设它们是$\\{a_i\\},a_{i-1}<a_i$\n\n合法的递增序列需要满足的限制是$A_{a_i}>B_{a_{i-1}}$\n\n考虑剩下的部分即$j\\in[a_{i-1}+1,a_i-1]$，那么这些点放在$a_i$后面一定是最优的(因为此时不会改变最大的$B$)，此时限制它们的$B$就是$B_{a_i}$\n\n即这一部分中满足$A_j>B_{a_i}$的$j$均可以选出来\n\n为了便于表示，设$C(l,r)=|\\{i|i\\in[l,r],A_i>B_{r+1}\\}|$，可以通过一个主席树维护\n\n-------------------------------\n\n定义$dp_i$表示当前以$i$为最大的$B$的答案，特别的，$dp_0$表示序列为空$A_0=B_0=-\\infty$\n\n枚举每个$i$进行转移\n\n朴素的转移就是可以枚举上一个位置$j$，$O(n^2)$转移\n\n需要找到前面第一个能把$i$接上去的$j$即可，即第一个$B_r<A_i(j\\ge 0)$的位置，那么合法的决策位置就是$[0,r]$\n\n则$dp_i=\\max_0^r\\{dp_j+1+C(j+1,i-1)\\}$\n\n设最优决策点为$k\\in[0,r]$，影响最优决策点位置的有两个方面\n\n从$[j+1,i-1]$这一段点考虑，$j$越小时，就会有越多的点对被$B_i$限制，也就是说$j$越大，对于中间这一段来说越优\n\n但是从$dp_j$的角度考虑，并不是$j$越大越好，因为可能存在一个$A_j$特别小限制了前面递增点列的选择\n\n>  推论：如果前面存在一个$A_j>B_i$，那么$k\\ge j$\n\n事实上应该说成$dp_j+C(j+1,i-1)\\ge\\forall d\\in[0,j-1],dp_d+C(d+1,i-1)$\n\n综合上面两条来看，如果$A_j>B_i$意味着把它放进递增序列里绝对是优的，因为不会对前面的点产生不良限制\n\n消除了不良限制之后，就满足最优性了\n\n所以发现最优决策点的范围缩小到了$[l=max\\{k|A_k>B_i\\},r]$\n\n发现决策范围内的$C(l+1,i-1)=C(l+2,i-1)=\\cdots=C(r+1,i-1)$\n\n所以$dp_i=\\max_l^r\\{dp_j\\}+C(r+1,i-1)=max_0^r\\{dp_j\\}+C(r+1,i-1)$\n\n所以可以直接维护一个前缀最大值，每次二分找到那个$r$，求出$C(r+1,i-1)$即可\n\n```cpp\nconst int N=2e5+10,K=15;\n \nint n;\n \nstruct Node{\n    int a,b;\n    bool operator < (const Node __) const {\n        return b<__.b;\n    }\n}A[N];\nint h[N],hc;\nint dp[N];\n \nint rt[N*K],s[N*K],ls[N*K],rs[N*K],cnt;\nvoid Add(int p,int pre,int l,int r,int x) {\n    s[p]=s[pre]+1;\n    if(l==r) return;\n    int mid=(l+r)>>1;\n    ls[p]=ls[pre],rs[p]=rs[pre];\n    x<=mid?Add(ls[p]=++cnt,ls[pre],l,mid,x):Add(rs[p]=++cnt,rs[pre],mid+1,r,x);\n}\n \nint Que(int pl,int pr,int l,int r,int ql,int qr) {\n    if(ql>qr) return 0;\n    if(ql==l&&qr==r) return s[pr]-s[pl];\n    int mid=(l+r)>>1;\n    if(qr<=mid) return Que(ls[pl],ls[pr],l,mid,ql,qr);\n    else if(ql>mid) return Que(rs[pl],rs[pr],mid+1,r,ql,qr);\n    else return Que(ls[pl],ls[pr],l,mid,ql,mid)+Que(rs[pl],rs[pr],mid+1,r,mid+1,qr);\n}\n \nint main(){\n    rep(i,1,n=rd()) {\n        A[i].a=rd(),A[i].b=rd();\n        h[++hc]=A[i].a,h[++hc]=A[i].b;\n    }\n    sort(h+1,h+hc+1),hc=unique(h+1,h+hc+1)-h-1;\n    sort(A+1,A+n+1);\n    rep(i,1,n) {\n        A[i].a=lower_bound(h+1,h+hc+1,A[i].a)-h;\n        A[i].b=lower_bound(h+1,h+hc+1,A[i].b)-h;\n        Add(rt[i]=++cnt,rt[i-1],1,hc,A[i].a);\n    }\n    rep(i,1,n) {\n        int l=1,r=i-1,res=0;\n        while(l<=r) {\n            int mid=(l+r)>>1;\n            if(A[mid].b<A[i].a) l=mid+1,res=mid;\n            else r=mid-1;\n        }\n        dp[i]=max(dp[i-1],dp[res]+1+Que(rt[res],rt[i-1],1,hc,A[i].b+1,hc));\n    }\n    int ans=dp[n];\n    printf(\"%d\\n\",ans);\n}\n \n \n \n \n```\n\n\n\n\n\n附：离线做法\n\n```cpp\n#include<cstdio>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\n\n#define reg register\ntypedef long long ll;\n#define rep(i,a,b) for(reg int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(reg int i=a,i##end=b;i>=i##end;--i)\n\nchar IO;\nint rd(){\n\tint s=0,f=0;\n\twhile(!isdigit(IO=getchar())) f|=(IO=='-');\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=2e5+10,K=15;\n\nint n;\nstruct Node{\n\tint a,b;\n\tbool operator < (const Node __)const{ return b<__.b; }\n}A[N];\nstruct Query{\n\tint x,p,id,k;\n\tbool operator < (const Query __)const{ return p<__.p; }\n}Q[N<<1];\n\nint qc,h[N],hc,dp[N];\nint L[N],Ans[N];\n\nint s[N];\nvoid Add(int p,int x){ while(p) s[p]+=x,p-=p&-p; }\nint Que(int p){\n\tint res=0;\n\twhile(p<=hc) res+=s[p],p+=p&-p;\n\treturn res;\n}\n\nint main(){\n\trep(i,1,n=rd()) {\n\t\tA[i].a=rd(),A[i].b=rd();\n\t\th[++hc]=A[i].a,h[++hc]=A[i].b;\n\t}\n\tsort(h+1,h+hc+1),hc=unique(h+1,h+hc+1)-h-1;\n\tsort(A+1,A+n+1);\n\trep(i,1,n) {\n\t\tA[i].a=lower_bound(h+1,h+hc+1,A[i].a)-h;\n\t\tA[i].b=lower_bound(h+1,h+hc+1,A[i].b)-h;\n\t}\n\trep(i,1,n) {\n\t\tint l=1,r=i-1,res=0;\n\t\twhile(l<=r) {\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(A[mid].b<A[i].a) l=mid+1,res=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tL[i]=res;\n\t\tif(i-1>L[i]) Q[++qc]=(Query){A[i].b+1,i-1,i,1},Q[++qc]=(Query){A[i].b+1,L[i],i,-1};\n\t}\n\tsort(Q+1,Q+qc+1);\n\tint p=1;\n\trep(i,0,n) {\n\t\tif(i) Add(A[i].a,1);\n\t\twhile(p<=qc && Q[p].p<=i) Ans[Q[p].id]+=Q[p].k*Que(Q[p].x),p++;\n\t}\n\trep(i,1,n) dp[i]=max(dp[i-1],dp[L[i]]+1+Ans[i]);\n\tint ans=dp[n];\n\tprintf(\"%d\\n\",ans);\n}\n\n```","tags":["default tag"],"categories":["default category"]},{"title":"[BZOJ2688]Green Hackenbush","url":"/2021/05/21/[BZOJ2688]Green Hackenbush/","content":"# [BZOJ2688]Green Hackenbush\n\n题意: 有$n$棵随机的二叉树，每棵只知道大小为$a_i$\n\n博弈:每次选取一个子树删掉，只剩根不能操作，求先手获胜概率\n\n考虑这个博弈，求出一棵树的$\\text{SG}$值\n\n显然有:\n\n1.只有一个点的树的$\\text{SG}$值为0\n\n2.多个树组合的问题为$\\text{SG}$值异或\n\n暴力$dp$，对于树$T$求答案，设$T$所有可行的后继状态集合为$N(T)$，则得到$\\text{SG}$值的表达式为\n\n$\\text{SG}(T)=\\text{mex}_{R\\in N(T)}\\lbrace\\text{SG(R)}\\rbrace $\n\n直接求解复杂度过高，考虑归纳性质\n\n性质:\n\n1.一棵根节点只有一个儿子的树，其$\\text{SG}$值为儿子的$\\text{SG}$值+1\n\n考虑归纳证明:\n\n设子树为$T$，令$T+u$表示$T$子树上面接上自己作为根，问题变为求证$\\text{SG}(T+u)=\\text{SG}(T)+1$\n\n设已经归纳证明所有$T$的子联通块成立\n\n我们要求$\\text{SG}(T+u)$\n\n$\\text{SG}(T+u)=\\text{mex}\\{\\text{SG}(u),\\forall _{R\\in N(T)}\\text{SG}(R+u)\\}$\n\n由归纳的性质有\n\n$\\forall _{R\\subsetneq T}\\text{SG}(R+T)=\\text{SG}(R)+1$\n\n又因为$\\text{SG}(u)=0$，看做把所有儿子的情况平移了1，0的位置由自己占据，因而上式成立\n\n2.多叉树的问题可以归纳为 **根分别接上每个儿子得到的树** 的问题的组合\n\n因为儿子之间实际互不干扰，比较容易理解\n\n由此得到，一棵树的$\\text{SG}$值为其所有儿子的$\\text{SG}$值+1的异或和\n\n令$dp_{n,i}$为一棵$n$个节点的二叉树$\\text{SG}$值为$i$的概率，为了便于转移，设空树的$\\text{SG}$值为-1\n\n考虑直接枚举两棵子树的大小和$\\text{SG}$值\n\n考虑对于$n$个节点的二叉树，设其左儿子为$i$时的总概率为$F_i$\n\n得到的$\\text{dp}$转移是\n\n$dp_{n,(a+1)\\oplus (b+1)}\\leftarrow {dp_{i,a}\\cdot dp_{n-i-1,b}\\cdot F_i}$\n\n我们知道$n$个节点的二叉树方案数为$Catalan(n)=\\frac{(2n)!}{n!(n+1)!}$\n\n由此得到$\\begin{aligned} F_i=\\frac{Catalan(i)Catalan(n-i-1)}{Catalan(n)}\\end{aligned} $\n\n此题范围可以直接带入$Catalan(i)$求解，但是依然要提一下递推的做法（似乎精度更有保障?）\n\n$\\begin{aligned} F_i=\\frac{\\frac{(2i)!}{i!(i+1)!}\\cdot \\frac{(2n-i-2)!}{(n-i-1)!(n-i)!}}{\\frac{(2n)}{n!(n+1)!}}\\end{aligned} $\n\n递推求解$F_i$，每次$i$改变一阶乘只会改变1或者2，因此由$F_{i-1}$得到$F_i$的递推式为\n\n$F_i=\\left\\{ \\begin{aligned}\\frac{n(n+1)}{2n(2n-1)}&& i=0\\\\ F_{i-1}\\cdot \\frac{2i(2i-1)}{(i+1)i}\\frac{(n-i+1)(n-i)}{2(n-i)(2n-2i-1)} && i\\in[1,n-1]\\end{aligned}\\right.$\n\n化简之后应该是\n\n$F_i=\\left\\{ \\begin{aligned}\\frac{(n+1)}{2(2n-1)}&& i=0\\\\ F_{i-1}\\cdot \\frac{(2i-1)}{(i+1)}\\frac{(n-i+1)}{(2n-2i-1)} && i\\in[1,n-1]\\end{aligned}\\right.$\n\n至此得到一个朴素的$O(n^4)$预处理，由于是异或，可以用$\\text{FWT}_{\\oplus}$求解，复杂度为$O(n^3)$\n\n对于输入的每棵树，类似背包地叠加概率即可，复杂度为$O(n^3)$\n\n以下是朴素dp代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\n#define rep(i,a,b) for(reg int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(reg int i=a,i##end=b;i>=i##end;--i)\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=128;\n\nint n;\ndb dp[N][N];\n\nvoid FWT(db *a,int f){\n\tfor(int i=1;i<N;i<<=1){\n\t\tfor(int l=0;l<n;l+=i*2) {\n\t\t\tfor(int j=l;j<l+i;j++){\n\t\t\t\tdb t=a[j+i];\n\t\t\t\ta[j+i]=a[j]-t;\n\t\t\t\ta[j]+=t;\n\t\t\t}\n\t\t}\n\t}\n\tif(f==-1) rep(i,0,N-1) a[i]/=N;\n}\n\ndb F[N],G[N];\n\nint main(){\n\tdp[0][0]=1,dp[1][0]=1;\n\trep(i,2,100) {\n\t\tF[0]=1.0/(2*i)/(2*i-1)*(i+1)*i;\n\t\trep(j,1,i-1) {\n\t\t\tF[j]=F[j-1] *  (2*j)*(2*j-1)/(j+1)/j   * 1.0/(2*(i-j))/(2*(i-j)-1)*(i-j+1)*(i-j);\n\t\t}\n\t\trep(a,0,i-1) rep(h1,0,N-1) if(dp[a][h1]>0) {\n\t\t\trep(h2,0,N-1) if(dp[i-a-1][h2]) {\n\t\t\t\tint nxt=0;\n\t\t\t\tif(a>0) nxt^=h1+1;\n\t\t\t\tif(i-1-a>0) nxt^=h2+1;\n\t\t\t\tdp[i][nxt]+=dp[a][h1]*dp[i-a-1][h2]*F[a];\n\t\t\t}\n\t\t}\n\t}\n\tn=rd();\n\trep(i,0,N-1) F[i]=0;\n\tF[0]=1;\n\trep(i,1,n) {\n\t\tint x=rd();\n\t\trep(j,0,N-1) G[j]=0;\n\t\trep(j,0,N-1) if(F[j]) rep(k,0,N-1) G[j^k]+=F[j]*dp[x][k];\n\t\trep(j,0,N-1) F[j]=G[j];\n\t}\n\tdb ans=0;\n\trep(i,1,N-1) ans+=F[i];\n\tprintf(\"%.6lf\\n\",ans);\n}\n\n\n```\n\n以下是FWT优化代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\n#define rep(i,a,b) for(reg int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(reg int i=a,i##end=b;i>=i##end;--i)\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=128;\n\nint n;\ndb dp[N][N],T[N][N];\n\nvoid FWT(db *a,int f){\n\tfor(int i=1;i<N;i<<=1){\n\t\tfor(int l=0;l<N;l+=i*2) {\n\t\t\tfor(int j=l;j<l+i;j++){\n\t\t\t\tdb t=a[j+i];\n\t\t\t\ta[j+i]=a[j]-t;\n\t\t\t\ta[j]+=t;\n\t\t\t}\n\t\t}\n\t}\n\tif(f==-1) rep(i,0,N-1) a[i]/=N;\n}\n\ndb F[N],G[N];\n\nint main(){\n\tdp[0][0]=1,dp[1][0]=1;\n\tT[0][0]=1,T[1][1]=1;\n\tFWT(T[0],1),FWT(T[1],1);\n\n\trep(i,2,100) {\n\t\tF[0]=1.0/(2*i)/(2*i-1)*(i+1)*i;\n\t\trep(j,1,i-1) {\n\t\t\tF[j]=F[j-1] *  (2*j)*(2*j-1)/(j+1)/j   * 1.0/(2*(i-j))/(2*(i-j)-1)*(i-j+1)*(i-j);\n\t\t}\n\t\trep(j,0,i-1) rep(k,0,N-1) dp[i][k]+=T[j][k]*T[i-j-1][k]*F[j];\n\t\tFWT(dp[i],-1);\n\t\trep(j,0,N-2) T[i][j+1]=dp[i][j];\n\t\tFWT(T[i],1);\n\t}\n\tn=rd();\n\trep(i,0,N-1) F[i]=0;\n\tF[0]=1;\n\trep(i,1,n) {\n\t\tint x=rd();\n\t\trep(j,0,N-1) G[j]=0;\n\t\trep(j,0,N-1) if(F[j]) rep(k,0,N-1) G[j^k]+=F[j]*dp[x][k];\n\t\trep(j,0,N-1) F[j]=G[j];\n\t}\n\tdb ans=0;\n\trep(i,1,N-1) ans+=F[i];\n\tprintf(\"%.6lf\\n\",ans);\n}\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[BZOJ4331] [JSOI2012]越狱老虎桥","url":"/2021/05/21/[BZOJ4331] [JSOI2012]越狱老虎桥/","content":"# [BZOJ4331] [JSOI2012]越狱老虎桥\n\n题意: 在任意加入一条边的情况下，求 割一条边使图不从1联通的最小割边的 最大值\n\n首先根据题目的意思，可以下对这个无向图中 进行**边双联通分量** 缩点\n\n建出一棵边双生成树，树边即为原图的割边，树边带权\n\n割掉双联通分量内部的边显然没有意义，所以忽略掉他们，下文所提的均是树上节点和边\n\n在不额外加边的情况下，而割掉树边会使子树内部的点断开\n\n在加入边的情况下，若加入一条$1-u$的边，则形成了一个$1-u$的环，环是无法通过割开一条边断开的\n\n而连接树上两个节点$(u,v)$的情况，把图展开后，就会发现，就是把$u,v$路径上所有的点都缩进了同一个环\n\n此时断掉环上的边显然不合法，而不在环上的边，只需要随便断掉一条，就能让一个点不连通\n\n也就是说，答案是 (去掉某个点对$(u,v)$路径上的所有边，剩下的边中最小值) 的最大值\n\n设答案为$ans$\n\n这个问题实际上等价于所有的$e\\in E,w(e)\\leq ans$的边无法被一条路径完全覆盖\n\n做法1:\n\n考虑二分答案，把每条$e\\in E,w(e)\\leq ans$的边的权值设为1，求出直径长度判断是否可以用一条路径完全覆盖即可\n\n复杂度为$O(n\\log n)$\n\n做法2:\n\n实际上这个问题就是 (选择了合法的3条边中边权的最大值) 的最小值\n\n对于当前节点$u$，实际合法情况有\n\n1.选择了一条祖先的边，和2条儿子岔开的边\n\n2.选择了3条垂下的岔开的边，这个合并时比较诡异可以看代码\n\n$\\text{dp}$维护即可，复杂度为$O(n)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(2)\ntypedef long long ll;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,const T &b){ ((a>b)&&(a=b)); }\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=5e5+10,INF=1e9+10;\n\nint n,m;\nstruct Edge{\n\tint to,nxt,w;\n} e[N*6];\nint head[N],ecnt;\nvoid AddEdge(int u,int v,int w) {\n\te[++ecnt]=(Edge){v,head[u],w};\n\thead[u]=ecnt;\n}\n#define erep(u,i) for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to)\n\nint low[N],t[N],id[N],scc,dfn;\nint stk[N],top;\nvoid dfs(int u,int f) {\n\tlow[u]=t[u]=++dfn;\n\tstk[++top]=u;\n\terep(u,i) if(v!=f) {\n\t\tif(!t[v]) dfs(v,u),cmin(low[u],low[v]);\n\t\telse cmin(low[u],t[v]);\n\t}\n\tif(low[u]==t[u]){\n\t\tint v; ++scc;\n\t\tdo v=stk[top--],id[v]=scc;\n\t\twhile(v!=u);\n\t}\n}\n\nint head2[N];\nvoid AddEdge2(int u,int v,int w) {\n\te[++ecnt]=(Edge){v,head2[u],w};\n\thead2[u]=ecnt;\n}\n#define erep2(u,i) for(int i=head2[u],v=e[i].to,w=e[i].w;i;i=e[i].nxt,v=e[i].to,w=e[i].w)\n\nint ans=INF;\nint dp[N][4],tmp[4],g[N];\n\nvoid dfs1(int u,int f) {\n\tdp[u][0]=0,dp[u][1]=dp[u][2]=dp[u][3]=INF;\n\terep2(u,i) if(v!=f) {\n\t\tg[v]=min(g[u],w),dfs1(v,u);\n\t\tmemset(tmp,63,sizeof tmp);\n\t\trep(j,0,3) {\n\t\t\tcmin(tmp[j],dp[u][j]);\n\t\t\tif(j<3) cmin(tmp[j+1],max(dp[u][j],w));\n\t\t\trep(k,0,3-j) cmin(tmp[j+k],max(dp[u][j],dp[v][k]));\n\t\t}\n\t\trep(j,0,3) dp[u][j]=tmp[j];\n\t}\n\tcmin(ans,dp[u][3]);\n\tcmin(ans,max(g[u],dp[u][2]));\n}\n\n\nint main(){\n\tn=rd(),m=rd();\n\trep(i,1,m) {\n\t\tint u=rd(),v=rd(),w=rd();\n\t\tAddEdge(u,v,w),AddEdge(v,u,w);\n\t}\n\tdfs(1,0);\n\trep(u,1,n) erep(u,i) if(id[u]!=id[v]) AddEdge2(id[u],id[v],e[i].w);\n\tg[id[1]]=INF,dfs1(id[1],0);\n\tprintf(\"%d\\n\",ans==INF?-1:ans);\n}\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[BoundedOptimization TopCoder - 12294]","url":"/2021/05/21/[BoundedOptimization TopCoder - 12294]/","content":"# [BoundedOptimization TopCoder - 12294](https://vjudge.net/problem/TopCoder-12294)\n\n考虑在最优情况下，某一些数在$\\text{lowerbound}$,某一些在$\\text{upperbound}$\n\n确定了这些数之后，对于那些处于$(\\text{lowerbound,upperbound})$之间的数，它们的值其实是在**忽略了上下界的情况下能取到的最优情况**\n\n否则只要上下移动一点就可能达到一个更优的情况\n\n那么考虑枚举每个数的状态在$\\text{lowerbound,upperbound,(lowerbound,uppperbound)}$\n\n推论：在中间的数之间必然存在互相关系\n\n假设存在两个数$x_i,x_j$之间没有互相关系，令其他数不变，\n\n则答案式子可以表示为$ax_i+bx_j+c$的形式，改变两个数的值总能得到更优的情况\n\n$$ \\ $$\n\n设处在中间位置的数为$x_1,\\cdots,x_m$，其他数为$y_1,\\cdots ,y_k$，每个数连到外面的权值总和为$s_i$\n\n发现在最优情况下，$\\sum x_i+\\sum y_i =MaxSum$，那么就确定了$\\sum x_i$的值，设为$Sum$\n\n那么答案就可以表示为$\\begin{aligned}\\frac{\\sum_ix_i\\cdot(Sum-x_i+2\\cdot s_i)}{2}\\end{aligned}+c$\n\n其中常数$c$是外面的数之间的总和\n\n不考虑限制的情况下，最优情况是$x_i=\\frac{Sum+s_i}{2}$\n\n此时，若$\\sum x_i\\ne Sum$，是不合法的，需要调整\n\n而让每个数改变$d$，减少的答案都是$d^2$(因为原来是在二次函数的最高点)\n\n所以每个数都改变$\\begin{aligned}\\frac{\\sum \\frac{Sum+x_i}{2}-Sum}{m}\\end{aligned}$是最优的\n\n注意这里计算时都是**忽略了**$x_1,\\cdots,x_m$的$\\text{lowerbound,upperbound}$，求出的值不一定合法\n\n如果不合法说明至少有某个值该到上下界之后答案会更优，所以这次的答案不用考虑\n\n\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\n#define pb push_back\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\nconst int N=30;\nconst db eps=1e-7;\n\nint G[N][N];\nint A[N],w[N];\ndb val[N];\n\nclass BoundedOptimization {\npublic:\n\tdouble maxValue(vector <string> Expr, vector <int> L, vector <int> R, int Max) {\n\t\tstring E=\"\";\n\t\tfor(string t:Expr) E+=t;\n\t\tmemset(G,0,sizeof G);\n\t\trep(i,0,E.size()-1) if(isalpha(E[i])) {\n\t\t\tG[E[i]-'a'][E[i+1]-'a']=G[E[i+1]-'a'][E[i]-'a']=1;\n\t\t\ti++;\n\t\t}\n\t\tint n=L.size();\n\t\tdb ans=0;\n\t\trep(S,0,pow(3,n)-1) {\n\t\t\tint T=S,m=0;\n\t\t\tdb res=0,sum=0;\n\t\t\trep(i,0,n-1) {\n\t\t\t\tw[i]=T%3;\n\t\t\t\tif(!w[i]) A[++m]=i;\n\t\t\t\telse val[i]=(w[i]==1?L[i]:R[i]),sum+=val[i];\n\t\t\t\tT/=3;\n\t\t\t}\n\t\t\tint fl=sum<=Max;\n\t\t\trep(i,1,m) rep(j,i+1,m) if(!G[A[i]][A[j]]) fl=0;\n\t\t\tif(!fl) continue;\n\t\t\tdb left=Max-sum; \n\t\t\trep(i,1,m) {\n\t\t\t\tdb c=left;\n\t\t\t\trep(j,0,n-1) if(w[j] && G[A[i]][j]) c+=val[j]*2;\n\t\t\t\tval[A[i]]=c/2;\n\t\t\t\tsum+=val[A[i]];\n\t\t\t}\n\t\t\tif(m){\n\t\t\t\tdb t=(sum-Max)/m;\n\t\t\t\trep(i,1,m) val[A[i]]-=t;\n\t\t\t}\n\t\t\trep(i,0,n-1) if(val[i]<L[i]-eps || val[i]>R[i]+eps) fl=0;\n\t\t\tif(!fl) continue;\n\t\t\trep(i,0,n-1) rep(j,i+1,n-1) if(G[i][j]) res+=val[i]*val[j];\n\t\t\tcmax(ans,res);\n\t\t}\n\t\treturn ans;\t\n\t}\n};\n\n```\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[COCI2010-2011 2] CRNI(单调栈)","url":"/2021/05/21/[COCI2010-2011 2] CRNI(单调栈)/","content":"#  [COCI2010-2011#2] CRNI(单调栈)\n\n## 问题分析\n\n首先考虑两个不相交的矩形可能存在的位置关系，我将其分成\n\n1.左右\n\n2.上下\n\n3.左上右下\n\n4.左下右上\n\n发现1,2,3,4之间有相交,考虑四种情况的答案应该是1+2-3-4\n\n## 统计方法\n\n核心: 统计以一个点作为顶点的矩形数量\n\n以统计$i,j$为右下角的矩形为例，先不考虑矩形大小>1的限制\n\n显然可以在线性时间内处理得到每个$i,j$向上连续延伸的连续1长度，设其为$U_{i,j}$\n\n假设枚举了$i$，从左到右依次扫描$j$，则得到$i,j$位置的答案应该是\n\n$$\\begin{aligned} \\sum_{k=1}^{j} \\min_{d=k}^j\\lbrace U_{i,d}\\rbrace\\end{aligned} $$\n\n这条式子中，相当于枚举了$i,(k,j)$为底，统计向上延伸的最长长度\n\n这个式子可以用**单调栈**在线性时间内求解，其过程可以描述为\n\n1.每次插入元素$U_{i,j}$，得到它的影响区间$k\\in [L,j]$\n\n2.将原先单调栈内$k\\in [L,j]$这段区间的答案减掉，改为$U_{i,j}\\cdot (j-L+1)$\n\n类似的，可以通过改变循环顺序和额外记录向下延伸的长度$D_{i,j}$来统计四种顶点的答案(详细见代码)\n\n然后可以用前缀和帮助统计以上4种答案，枚举一个端点，另一个查询前缀和即可\n\ntips: 注意累和顺序，~~前缀和要开long long~~\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=1e3+10;\n\nint n;\nchar a[N][N];\nint D[N][N],U[N][N]; //i,j向下/上延伸的最长长度\nint stk[N],c[N],top;\nint CRR[N][N]; // 以i,j为右下角的矩形个数\nint CLL[N][N]; // 以i,j为左上角的矩形个数\nint CLR[N][N]; // 以i,j为右上角的矩形个数\nint CRL[N][N]; // 以i,j为左下角的矩形个数\nll SLL[N][N],SRL[N][N]; // 前缀和\n\nint main(){\n\tn=rd();\n\trep(i,1,n) scanf(\"%s\",a[i]+1);\n\trep(i,1,n) rep(j,1,n) if(a[i][j]=='C') U[i][j]=U[i-1][j]+1;\n\tdrep(i,n,1) rep(j,1,n) if(a[i][j]=='C') D[i][j]=D[i+1][j]+1;\n\trep(i,1,n) {\n\t\t// 统计四种端点的情况\n\t\ttop=0;\n\t\tint now=0;\n\t\trep(j,1,n) {\n\t\t\tint x=U[i][j],cnt=1;\n\t\t\twhile(top && stk[top]>=x) cnt+=c[top],now-=c[top]*stk[top],top--;\n\t\t\tstk[++top]=x,c[top]=cnt; now+=x*cnt;\n\t\t\tCRR[i][j]=max(now-1,0);\n\t\t}\n\n\t\tnow=top=0;\n\t\trep(j,1,n) {\n\t\t\tint x=D[i][j],cnt=1;\n\t\t\twhile(top && stk[top]>=x) cnt+=c[top],now-=c[top]*stk[top],top--;\n\t\t\tstk[++top]=x,c[top]=cnt; now+=x*cnt;\n\t\t\tCLR[i][j]=max(now-1,0);\n\t\t}\n\n\t\tnow=top=0;\n\t\tdrep(j,n,1) {\n\t\t\tint x=U[i][j],cnt=1;\n\t\t\twhile(top && stk[top]>=x) cnt+=c[top],now-=c[top]*stk[top],top--;\n\t\t\tstk[++top]=x,c[top]=cnt; now+=x*cnt;\n\t\t\tCRL[i][j]=max(now-1,0);\n\t\t}\n\n\t\tnow=top=0;\n\t\tdrep(j,n,1) {\n\t\t\tint x=D[i][j],cnt=1;\n\t\t\twhile(top && stk[top]>=x) cnt+=c[top],now-=c[top]*stk[top],top--;\n\t\t\tstk[++top]=x,c[top]=cnt; now+=x*cnt;\n\t\t\tCLL[i][j]=max(now-1,0);\n\t\t}\n\t}\n\n\tdrep(i,n,1) drep(j,n,1) SLL[i][j]=SLL[i+1][j]+SLL[i][j+1]-SLL[i+1][j+1]+CLL[i][j];\n\trep(i,1,n) drep(j,n,1) SRL[i][j]=SRL[i-1][j]+SRL[i][j+1]-SRL[i-1][j+1]+CRL[i][j];\n\t// 前缀和\n\n\tll ans=0;\n\trep(i,1,n) rep(j,1,n) if(CRR[i][j]) ans+=CRR[i][j]*(SLL[i+1][1]+SLL[1][j+1]-SLL[i+1][j+1]);\n\trep(i,1,n) rep(j,1,n) ans-=CLR[i][j]*SRL[i-1][j+1];\n\t// 统计4种情况\n\tprintf(\"%lld\\n\",ans%10007);\n}\n\n\n\n```","tags":["default tag"],"categories":["default category"]},{"title":"[COCI2010-2011 7] UPIT","url":"/2021/05/21/[COCI2010-2011 7] UPIT/","content":"# [COCI2010-2011#7] UPIT\n\n约定:视$n,q$同阶\n\n看一下题目的操作\n\n1.区间赋值\n\n2.区间差分加\n\n3.插入元素\n\n4.区间查询\n\n我们知道1,2操作都是可以用懒标记维护的，具体过程可能有一点细节\n\n1.记录区间差分加的过程，要记录等差数列首项和公差，两个等差数列相加直接首项和公差都相加即可\n\n2.区间赋值的优先级要高于加法，即打上赋值标记就要清空加法标记，标记下传时注意先下传赋值标记\n\n然后具体问题落到如何实现插入元素这个操作上\n\n### 块状链表\n\n对于静态的数组，可以直接静态分块来做\n\n而要动态插入时，找到对应块，插入即可，但是涉及到编号问题\n\n所以需要每个块维护一个$Size$，块内每个元素维护一个标号$id_i$\n\n同时需要对于块的$Size$累前缀和$SumSize$，则块$i$内编号为$j$的元素在数组中的实际编号为$SumSize_{i-1}+j$\n\n插入时把整个块内的元素取出重新标号即可\n\n但是这样插入后，一个块的$Size$会变大，再实现分块的操作时复杂度没有保证\n\n因此需要加入一个操作:当$Size_i>2\\sqrt n$时,$O(n)$重构整个序列，这样每$\\sqrt n$次插入操作会导致一次重构，复杂度为均摊的$O(n\\sqrt n)$\n\n然后可以用类似分块的方法来直接维护\n\n$$ \\ $$\n\n### 线段树\n\n静态的操作线段树可以直接维护\n\n在线段树上额外维护一个01，表示这个元素是否出现\n\n将插入操作转化为在让对应位置的0变为1，但是由于不知道插入后的位置，所以不能直接操作\n\n于是有两种解决办法\n\n#### 暴力值域\n\n静态情况下我们对于$[1,n]$建树，但是动态可以对于$[1,n\\cdot q]$建函数式线段树\n\n### 离线\n\n离线维护，预处理出插入的位置\n\n$$ \\ $$\n\n### 平衡树\n\n~~下面是安利时间~~\n\n来学Treap吧\n\n它可以 \n\n1.查询k大\n\n2.插入元素\n\n3.区间修改\n\n4.区间翻转\n\n5.可持久化!!\n\n~~6.吊打Splay~~\n\nTreap 即树堆，意思是在满足二叉查找树的性质同时满足二叉堆的性质\n\n给定每个节点一个额外的随机权值，让二叉查找树对于这个权值满足堆的性质即可\n\n这样构造的二叉查找树，树高是$O(\\log n)$的\n\n#### 带旋Treap\n\n像普通二叉查找树一样每次插入节点到叶子位置后，可能不满足二叉堆的性质，因此需要不断向上zig/zag来调整满足\n\n区间操作可以尝试像写线段树一样写\n\n但是它不可持久化\n\n#### 非旋Treap\n\n维护两个基础操作\n\n1.平衡树合并，操作需要满足两棵树的大小顺序确定，返回新的根\n\n2.平衡树分裂为$[1,d],[d+1,n]$的两部分，返回两棵树的根\n\n1.合并操作$x,y$\n\n按照节点的权值比较谁是平衡树的根，然后将根的左/右子树与另一棵树合并作为新的子树，递归实现\n\n2.分裂$x,d$\n\n维护$Size$判断是要分裂左子树还是右子树，将子树分裂得到的部分作为$x$新的子树，递归实现即可\n\n```cpp\ntypedef pair <int,int> Pii;\n#define mp make_pair\nint Union(int x,int y) {\n\tif(!x || !y) return x|y;\n\tDown(x),Down(y);\n\tif(key[x]<key[y]) return rs[x]=Union(rs[x],y),Up(x),x;\n\treturn ls[y]=Union(x,ls[y]),Up(y),y;\n}\n\nPii Split(int x,int d){\n\tif(!x) return mp(x,x);\n\tif(sz[x]<=d) return mp(x,0);\n\tif(d==0) return mp(0,x);\n\tDown(x);\n\tif(sz[ls[x]]+1<=d) {\n\t\tPii y=Split(rs[x],d-sz[ls[x]]-1);\n\t\treturn rs[x]=y.first,Up(x),mp(x,y.second);\n\t} else {\n\t\tPii y=Split(ls[x],d);\n\t\treturn ls[x]=y.second,Up(x),mp(y.first,x);\n\t}\n}\n```\n\n插入操作可以分裂前$k$个，将新节点和得到的两棵树按次合并\n\n区间更新可以分裂两次，将对应区间的子树操作即可\n\n\n\n## Code\n\n块状链表\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(2)\ntypedef double db;\ntypedef long double ldb;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair <int,int> Pii;\n#define reg register\n#define pb push_back\n#define mp make_pair\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n \n \nchar IO;\ntemplate <class T=int> T rd(){\n    T s=0; int f=0;\n    while(!isdigit(IO=getchar())) if(IO=='-') f=1;\n    do s=(s<<1)+(s<<3)+(IO^'0');\n    while(isdigit(IO=getchar()));\n    return f?-s:s;\n}\n \nconst int N=2e5+10;\n \nint n,m,cnt;\nint head[N],nxt[N],sz[N];\nstruct Node{ int rk,id; } E[N];\nll s[N],st[N],t[N],d[N],a[N]; \nint ssz[N];\n \nll Get(ll l,ll r){ return (r-l+1)*(l+r)/2; }\nvoid Down(int p) {\n    s[p]=0;\n    for(int i=head[p];i;i=nxt[i]) {\n        if(~st[p]) a[E[i].id]=st[p];\n        a[E[i].id]+=1ll*(E[i].rk-1)*d[p]+t[p];\n        s[p]+=a[E[i].id];\n    }\n    st[p]=-1,t[p]=d[p]=0;\n}\nvoid Up(int p) {\n    s[p]=0;\n    for(int i=head[p];i;i=nxt[i]) s[p]+=a[E[i].id];\n}\n \nvoid Build() {\n    sort(E+1,E+n+1,[&](Node x,Node y){ return x.rk<y.rk; });\n    rep(i,0,cnt) sz[i]=head[i]=0,st[i]=-1;\n    rep(i,1,n) {\n        int p=i/cnt+1;\n        nxt[i]=head[p],E[i].rk=++sz[p];\n        head[p]=i;\n    }\n    rep(i,1,cnt) ssz[i]=ssz[i-1]+sz[i],Up(i);\n}\n \nvoid Break(){\n    rep(i,1,cnt) {\n        sz[i]+=sz[i-1],Down(i);\n        for(int j=head[i];j;j=nxt[j]) E[j].rk+=sz[i-1];\n    }\n    Build();\n}\n \nint Get(int x){\n    x--;\n    int l=1;\n    while(sz[l]<=x) x-=sz[l++];\n    return l;\n}\n \nvoid Insert(int p,int x){\n    int l=p<=n?Get(p):cnt;\n    Down(l),p-=ssz[l-1];\n    for(int i=head[l];i;i=nxt[i]) if(E[i].rk>=p) E[i].rk++;\n    a[++n]=x,E[n]=(Node){p,n},nxt[n]=head[l],head[l]=n;\n    sz[l]++,s[l]+=x;\n    if(sz[l]>cnt*2.4) Break();\n    rep(i,1,cnt) ssz[i]=ssz[i-1]+sz[i];\n}\n \nvoid Set(int l,int r,int x) {\n    int p1=Get(l),p2=Get(r);\n    if(p1==p2) {\n        Down(p1);\n        for(int i=head[p1];i;i=nxt[i]) if(ssz[p1-1]+E[i].rk>=l && ssz[p1-1]+E[i].rk<=r) a[E[i].id]=x;\n        Up(p1);\n        return;\n    }\n    Down(p1),Down(p2);\n    s[p1]=s[p2]=0;\n    for(int i=head[p1];i;i=nxt[i]) {\n        if(ssz[p1-1]+E[i].rk>=l) a[E[i].id]=x;\n        s[p1]+=a[E[i].id];\n    }\n    for(int i=head[p2];i;i=nxt[i]) {\n        if(ssz[p2-1]+E[i].rk<=r) a[E[i].id]=x;\n        s[p2]+=a[E[i].id];\n    }\n    rep(i,p1+1,p2-1) st[i]=x,d[i]=t[i]=0,s[i]=1ll*x*sz[i];\n}\n \nvoid Add(int l,int r,int x) {\n    int p1=Get(l),p2=Get(r);\n    if(p1==p2) {\n        Down(p1);\n        for(int i=head[p1];i;i=nxt[i]) if(ssz[p1-1]+E[i].rk>=l && ssz[p1-1]+E[i].rk<=r) a[E[i].id]+=1ll*(ssz[p1-1]+E[i].rk-l+1)*x;\n        Up(p1);\n        return;\n    }\n    Down(p1),Down(p2);\n    s[p1]=s[p2]=0;\n    for(int i=head[p1];i;i=nxt[i]) {\n        if(ssz[p1-1]+E[i].rk>=l) a[E[i].id]+=1ll*(ssz[p1-1]+E[i].rk-l+1)*x;\n        s[p1]+=a[E[i].id];\n    }\n    for(int i=head[p2];i;i=nxt[i]) {\n        if(ssz[p2-1]+E[i].rk<=r) a[E[i].id]+=1ll*(ssz[p2-1]+E[i].rk-l+1)*x;\n        s[p2]+=a[E[i].id];\n    }\n    rep(i,p1+1,p2-1) {\n        t[i]+=1ll*(ssz[i-1]-l+2)*x,d[i]+=x;\n        s[i]+=Get(ssz[i-1]-l+2,ssz[i]-l+1)*x;\n    }\n}\n \nll Que(int l,int r) {\n    int p1=Get(l),p2=Get(r);\n    ll ans=0;\n    Down(p1),Down(p2);\n    if(p1==p2) {\n        Down(p1);\n        for(int i=head[p1];i;i=nxt[i]) if(ssz[p1-1]+E[i].rk>=l && ssz[p1-1]+E[i].rk<=r) ans+=a[E[i].id];\n        return ans;\n    }\n    Down(p1),Down(p2);\n    for(int i=head[p1];i;i=nxt[i]) if(ssz[p1-1]+E[i].rk>=l) ans+=a[E[i].id];\n    for(int i=head[p2];i;i=nxt[i]) if(ssz[p2-1]+E[i].rk<=r) ans+=a[E[i].id];\n    rep(i,p1+1,p2-1) ans+=s[i];\n    return ans;\n}\n \nint main(){\n    n=rd(),m=rd();\n    cnt=ceil(sqrt(n+m));\n    rep(i,1,n) a[i]=rd(),E[i]=(Node){i,i};\n    Build();\n    rep(i,1,m) {\n        int opt=rd();\n        if(opt==1) {\n            int l=rd(),r=rd(),x=rd();\n            Set(l,r,x);\n        } else if(opt==2) {\n            int l=rd(),r=rd(),x=rd();\n            Add(l,r,x);\n        } else if(opt==3) {\n            int p=rd(),x=rd();\n            Insert(p,x);\n        } else if(opt==4) {\n            int l=rd(),r=rd();\n            printf(\"%lld\\n\",Que(l,r));\n        }\n    }\n}\n \n \n \n \n \n```\n\n旋Treap:\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(2)\ntypedef double db;\ntypedef long double ldb;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair <int,int> Pii;\n#define reg register\n#define pb push_back\n#define mp make_pair\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=2e5+10;\n\nint n;\nint rt,son[N][2],fa[N];\nll s[N],t[N],d[N],st[N],val[N];\nll sz[N],key[N];\n\nvoid Up(int p) {\n\ts[p]=s[son[p][0]]+s[son[p][1]]+val[p];\n\tsz[p]=sz[son[p][0]]+sz[son[p][1]]+1;\n}\nvoid Set(int p,ll x){\n\tt[p]=d[p]=0,st[p]=val[p]=x,s[p]=sz[p]*x;\n}\nvoid Add(int p,ll x,ll d) {\n\tval[p]+=x+d*sz[son[p][0]];\n\ts[p]+=sz[p]*(sz[p]-1)/2*d+x*sz[p];\n\tt[p]+=x,::d[p]+=d;\n}\nvoid Down(int p) {\n\tif(~st[p]) Set(son[p][0],st[p]),Set(son[p][1],st[p]),st[p]=-1;\n\tif(t[p] || d[p]) Add(son[p][0],t[p],d[p]),Add(son[p][1],t[p]+(sz[son[p][0]]+1)*d[p],d[p]),t[p]=d[p]=0;\n}\n\nvoid rotate(int u) {\n\tint f=fa[u],ff=fa[f],d=son[f][1]==u;\n\tfa[u]=ff; if(ff) son[ff][son[ff][1]==f]=u;\n\tson[f][d]=son[u][!d]; if(son[u][!d]) fa[son[u][!d]]=f;\n\tson[u][!d]=f,fa[f]=u;\n\tUp(f),Up(u);\n}\n\nvoid Insert(int p,int x){\n\tint v=++n;\n\tval[v]=s[v]=x,sz[v]=1,st[v]=-1,key[v]=rand();\n\tif(!rt){ rt=v; return; }\n\tint u=rt;\n\twhile(u) {\n\t\tDown(u);\n\t\tif(sz[son[u][0]]>=p) {\n\t\t\tif(!son[u][0]) { son[fa[v]=u][0]=v; break; }\n\t\t\tu=son[u][0]; \n\t\t} else {\n\t\t\tp-=sz[son[u][0]]+1;\n\t\t\tif(!son[u][1]) { son[fa[v]=u][1]=v; break; }\n\t\t\tu=son[u][1];\n\t\t}\n\t}\n\twhile(fa[v] && key[v]<key[fa[v]]) rotate(v);\n\tif(!fa[v]) rt=v;\n\twhile(fa[v]) Up(v=fa[v]);\n}\n\nvoid Set(int p,int l,int r,int x) {\n\tif(!p || r<=0 || l>sz[p]) return;\n\tif(l<=1 && r>=sz[p]) return Set(p,x);\n\tint t=sz[son[p][0]]+1;\n\tDown(p),Set(son[p][0],l,r,x),Set(son[p][1],l-t,r-t,x);\n\tif(t>=l && t<=r) val[p]=x;\n\tUp(p);\n}\n\nvoid Add(int p,int l,int r,ll x,ll d) {\n\tif(!p || r<=0 || l>sz[p]) return;\n\tif(l<=1 && r>=sz[p]) return Add(p,x,d);\n\tint t=sz[son[p][0]]+1;\n\tDown(p),Add(son[p][0],l,r,x,d),Add(son[p][1],l-t,r-t,x+d*t,d);\n\tif(t>=l && t<=r) val[p]+=(t-1)*d+x;\n\tUp(p);\n}\n\nll Que(int p,int l,int r) {\n\tif(!p || r<=0 || l>sz[p]) return 0;\n\tif(l<=1 && r>=sz[p]) return s[p];\n\tll t=sz[son[p][0]]+1,res=0;\n\tDown(p),res+=Que(son[p][0],l,r),res+=Que(son[p][1],l-t,r-t);\n\tif(t>=l && t<=r) res+=val[p];\n\treturn res;\n}\n\nint main(){\n\tint n=rd(),m=rd();\n\trep(i,0,n-1) Insert(i,rd());\n\twhile(m--) {\n\t\tint opt=rd();\n\t\tif(opt==1) {\n\t\t\tint l=rd(),r=rd();\n\t\t\tSet(rt,l,r,rd());\n\t\t} else if(opt==2) {\n\t\t\tint l=rd(),r=rd(),x=rd();\n\t\t\tAdd(rt,l,r,x-1ll*(l-1)*x,x);\n\t\t} else if(opt==3) {\n\t\t\tint x=rd(),y=rd();\n\t\t\tInsert(x-1,y);\n\t\t} else {\n\t\t\tint l=rd(),r=rd();\n\t\t\tprintf(\"%lld\\n\",Que(rt,l,r));\n\t\t}\n\t}\n}\n\n\n\n```\n\n非旋Treap:\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair <int,int> Pii;\n#define mp make_pair\nint rd(){\n    char c;int s=0;\n    while((c=getchar())<48);\n    do s=s*10+c-48;\n    while((c=getchar())>47);\n    return s;\n}\nenum{N=200010};\nint n,m,rt,ls[N],rs[N],key[N];\nll s[N],t[N],d[N],st[N],val[N],sz[N];\n \ninline void Up(int p) {\n    s[p]=s[ls[p]]+s[rs[p]]+val[p];\n    sz[p]=sz[ls[p]]+sz[rs[p]]+1;\n}\ninline void Set(int p,ll x){ t[p]=d[p]=0,st[p]=val[p]=x,s[p]=sz[p]*x; }\ninline void Add(int p,ll x,ll d) {\n    val[p]+=x+d*sz[ls[p]];\n    s[p]+=sz[p]*(sz[p]-1)/2*d+x*sz[p];\n    t[p]+=x,::d[p]+=d;\n}\ninline void Down(int p) {\n    ~st[p] && (Set(ls[p],st[p]),Set(rs[p],st[p]),st[p]=-1);\n    (t[p] || d[p]) && (Add(ls[p],t[p],d[p]),Add(rs[p],t[p]+(sz[ls[p]]+1)*d[p],d[p]),t[p]=d[p]=0);\n}\nint Union(int x,int y) {\n    if(!x || !y) return x|y;\n    return key[x]<key[y]?(Down(x),rs[x]=Union(rs[x],y),Up(x),x):(Down(y),ls[y]=Union(x,ls[y]),Up(y),y);\n}\nPii Split(int x,int d){\n    if(sz[x]<=d) return mp(x,0);\n    if(d==0) return mp(0,x);\n    Down(x);\n    if(sz[ls[x]]+1<=d) {\n        Pii y=Split(rs[x],d-sz[ls[x]]-1);\n        return rs[x]=y.first,Up(x),mp(x,y.second);\n    } else {\n        Pii y=Split(ls[x],d);\n        return ls[x]=y.second,Up(x),mp(y.first,x);\n    }\n}\n \nint main(){\n    n=rd(),m=rd();\n    for(int i=1;i<=n+m;++i) key[i]=rand(),st[i]=-1,sz[i]=1;\n    for(int i=1;i<=n;++i) val[i]=s[i]=rd(),rt=Union(rt,i);\n    while(m--){\n        int opt=rd();\n        if(opt==3) {\n            Pii t=Split(rt,rd()-1); ++n,val[n]=s[n]=rd();\n            rt=Union(Union(t.first,n),t.second);\n        } else {\n            int l=rd(),r=rd();\n            Pii a=Split(rt,l-1),b=Split(a.second,r-l+1);\n            if(opt==1) Set(b.first,rd());\n            else if(opt==2) {int x=rd(); Add(b.first,x,x); }\n            else if(opt==4) printf(\"%lld\\n\",s[b.first]);\n            rt=Union(Union(a.first,b.first),b.second);\n        }\n    }\n}\n \n```\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[CSP-S 2020 T3] 动物园 (拓扑排序)","url":"/2021/05/21/[CSP-S 2020 T3] 动物园 (拓扑排序)/","content":"# [CSP-S 2020 T3] 动物园 (拓扑排序)\n\n很难考虑每个操作的顺序，但由于操作比较简单，可以直接考虑每个操作贡献的权值\n\n一个操作的权值可以定义为：每次这个操作执行之后后，后面所有的乘法操作的积\n\n如果没有递归，只需要倒序枚举一次调用情况，就能知道所有的权值\n\n对于递归的情况，显然函数之间的递归关系构成一张拓扑图，可以考虑预处理出每个操作的乘法操作之积\n\n对于所有的函数，同样能得到一个权值，接下来的操作只需要把每个存在递归的函数不断将权值向下传给子函数\n\n如果把最终的调用序列看做一个主函数，那么对于这个操作实际也是一样的做法\n\n即：倒序枚举一次累积，然后乘上自己的权值下传即可\n\nTips: 最后加入贡献时，注意先将所有数的权值乘上全局乘法倍数，然后再依次处理每个加法操作\n\n````cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\nchar IO;\nint rd(){ \n\tint s=0,f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=1e5+10,P=998244353;\n\nint n,m;\nint A[N],T[N],H[N]; \n// A为原数组，T为乘法积，H为函数调用权值\nint O[N],X[N],Y[N];\nint B[N*11],C,L[N],R[N],ind[N];\nint Q[N],QL,QR;\n\nint main() {\n\t//freopen(\"call.in\",\"r\",stdin),freopen(\"call.out\",\"w\",stdout);\n\trep(i,1,n=rd()) A[i]=rd();\n\tm=rd()+1; // 令m+1号为主函数\n\trep(i,1,m) {\n\t\tO[i]=i<m?rd():3,T[i]=1;\n\t\tif(O[i]==1) X[i]=rd(),Y[i]=rd();\n\t\telse if(O[i]==2) T[i]=rd();\n\t\telse {\n\t\t\tL[i]=C+1,R[i]=C+=rd();\n\t\t\trep(j,L[i],R[i]) ind[B[j]=rd()]++;\n\t\t}\n\t}\n\trep(i,QL=1,m) if(!ind[i]) Q[++QR]=i;\n\twhile(QL<=QR) {\n\t\tint u=Q[QL++];\n\t\tif(O[u]==3) rep(j,L[u],R[u]) if(--ind[B[j]]==0) Q[++QR]=B[j];\n\t}\n\tdrep(k,m,1){\n\t\tint u=Q[k];\n\t\tif(O[u]==3) rep(j,L[u],R[u]) T[u]=1ll*T[u]*T[B[j]]%P;\n\t}\n\t\n\trep(i,H[m]=1,n) A[i]=1ll*A[i]*T[m]%P;\n\trep(k,1,m) {\n\t\tint u=Q[k],x=1;\n\t\tdrep(j,R[u],L[u]){\n\t\t\tint v=B[j];\n\t\t\tH[v]=(H[v]+1ll*x*H[u])%P;\n\t\t\tx=1ll*x*T[v]%P;\n\t\t}\n\t\tif(O[u]==1) A[X[u]]=(A[X[u]]+1ll*H[u]*Y[u])%P;\n\t}\n\trep(i,1,n) printf(\"%d \",A[i]); puts(\"\");\n}\n````\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[CosmicBlocks - TopCoder- 12034] (网络流)","url":"/2021/05/21/[CosmicBlocks - TopCoder- 12034] (网络流)/","content":"# [CosmicBlocks - TopCoder- 12034](https://vjudge.net/problem/TopCoder-12034) (网络流)\n\n注意题目定义的同构是存在不同的颜色覆盖关系，而不是存在不同的排列顺序\n\n所以先枚举每一层放了那些颜色，再枚举那些颜色之间有覆盖\n\n每一层的颜色划分数很少，最多可能同时存在的覆盖关系是$9$种，枚举复杂度最多是$2^9$，然后可以$2^n\\cdot n\\ \\text{dp}$出拓扑序列的个数\n\n问题在于如何快速又方便地判断对于**当前情况是否存在方案**\n\n一种方法是**上下界网络流**\n\n按照层之间的关系，覆盖关系就连$[1,+\\infty)$的边，同时源点向$1$层的点连$[0,+\\infty)$的边，每个点都向汇点连$[0,\\infty)$的边\n\n注意由于要限制流过每个点的流量，每个点要拆成两个点中间连$[num_i,num_i]$的边\n\n最后判断一下**有源汇可行流**即可\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define reg register\ntypedef long long ll;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\n#define pb push_back\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\nchar IO;\nint rd(){\n\tint s=0;\n\tint f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\n\n\nstatic const int N=20,INF=1e8+10;\nint n,m,ans,L,R;\nint cnt[N],id[N];\nvector <int> G[N];\nint GS[N];\nvector <int> Layer[N];\n\nint Calc_DAG() { // 计算拓扑序列的个数\n\tstatic int dp[1<<6];\n\tint A=(1<<n)-1;\n\trep(i,0,A) dp[i]=0;\n\tdp[0]=1;\n\trep(S,0,A-1) rep(i,0,n-1) if((~S&(1<<i)) && (S&GS[i+1])==GS[i+1]) dp[S|(1<<i)]+=dp[S];\n\treturn dp[A];\n}\n\nint ind[N];\nstruct Limited_Flow{ // 有源汇可行流\n\tstatic const int M=300;\n\tint S,T;\n\tstruct Edge{\n\t\tint to,nxt,w;\n\t} e[M];\n\tint head[N],ecnt;\n\tvoid clear(){\n\t\trep(i,1,n*2+4) head[i]=0;\n\t\tecnt=0;\n\t}\n\t#define erep(u,i) for(int i=head[u];i;i=e[i].nxt)\n\tvoid AddEdge(int u,int v,int w) { e[ecnt]=(Edge){v,head[u],w},head[u]=ecnt++; } \n\tvoid Link(int u,int v,int w){ AddEdge(u,v,w),AddEdge(v,u,0); }\n\tint dis[N];\n\n\tint Bfs(){\n\t\tstatic queue <int> que;\n\t\trep(i,1,T) dis[i]=INF; dis[S]=0,que.push(S);\n\t\twhile(!que.empty()) {\n\t\t\tint u=que.front(); que.pop();\n\t\t\terep(u,i) {\n\t\t\t\tint v=e[i].to,w=e[i].w;\n\t\t\t\tif(!w || dis[v]<=dis[u]+1) continue;\n\t\t\t\tdis[v]=dis[u]+1,que.push(v);\n\t\t\t}\n\t\t}\n\t\treturn dis[T]<INF;\n\t}\n\tint Dfs(int u,int flowin){\n\t\tif(u==T) return flowin;\n\t\tint flowout=0;\n\t\terep(u,i) {\n\t\t\tint v=e[i].to,w=e[i].w;\n\t\t\tif(!w || dis[v]!=dis[u]+1) continue;\n\t\t\tint t=Dfs(v,min(flowin-flowout,w));\n\t\t\te[i].w-=t,e[i^1].w+=t,flowout+=t;\n\t\t\tif(flowin==flowout) break;\n\t\t}\n\t\tif(!flowout) dis[u]=0;\n\t\treturn flowout;\n\t}\n\tint Dinic(){\n\t\tint ans=0;\n\t\twhile(Bfs()) ans+=Dfs(S,INF);\n\t\treturn ans;\n\t}\n\tint Check(){\n\t\terep(S,i) if(e[i].w) return 0;\n\t\terep(T,i) if(e[i^1].w) return 0;\n\t\treturn 1;\n\t}\n} Flow;\n\nvoid Extend_Edge(int u,int v,int L,int R){\n\tind[u]-=L,ind[v]+=L;\n\tFlow.Link(u,v,R-L);\n}\n\nint Check(){\n\trep(i,1,n*2+4) ind[i]=0;\n\tFlow.clear();\n\trep(i,1,n) Extend_Edge(i*2-1,i*2,cnt[i],cnt[i]);\n\trep(i,1,n) if(id[i]==1) Extend_Edge(n*2+1,i*2-1,cnt[i],cnt[i]);\n\trep(u,1,n) for(int v:G[u]) Extend_Edge(u*2,v*2-1,1,INF);\n\trep(i,1,n) Extend_Edge(i*2,n*2+2,0,INF);\n\tExtend_Edge(n*2+2,n*2+1,0,INF);\n\n\trep(i,1,n*2+2) {\n\t\tif(ind[i]>0) Flow.Link(n*2+3,i,ind[i]);\n\t\tif(ind[i]<0) Flow.Link(i,n*2+4,-ind[i]);\n\t}\n\tFlow.S=n*2+3,Flow.T=n*2+4;\n\n\tFlow.Dinic();\n\treturn Flow.Check();\n}\n\nvoid Dfs_GetDAG(int p) { // dfs枚举覆盖关系\n\tif(p==n+1) {\n\t\tint Ways=Calc_DAG();\n\t\tif(Ways<L || Ways>R) return;\n\t\tans+=Check();\n\t\treturn;\n\t}\n\tif(id[p]==m) return Dfs_GetDAG(p+1);\n\tint n=Layer[id[p]+1].size();\n\trep(S,0,(1<<n)-1) {\n\t\trep(i,0,n-1) if(S&(1<<i)) G[p].pb(Layer[id[p]+1][i]),GS[p]|=1<<(Layer[id[p]+1][i]-1);\n\t\tDfs_GetDAG(p+1);\n\t\tG[p].clear(),GS[p]=0;\n\t}\n}\n\nvoid Dfs_Getlayer(int num,int fir,int chosennumber){ // dfs枚举层的情况\n\tif(chosennumber==n) {\n\t\tm=num;\n\t\trep(i,1,m) Layer[i].clear();\n\t\trep(i,1,n) Layer[id[i]].pb(i);\n\t\tDfs_GetDAG(1);\n\t\treturn;\n\t}\n\trep(i,fir,n) if(!id[i]) {\n\t\tid[i]=num;\n\t\tDfs_Getlayer(num,i+1,chosennumber+1);\n\t\tid[i]=0;\n\t}\n\tif(fir!=1) Dfs_Getlayer(num+1,1,chosennumber);\n}\n\nclass CosmicBlocks {\npublic:\n\tint getNumOrders(vector <int> a, int Min, int Max) {\n\t\tL=Min,R=Max;\n\t\tn=a.size(),ans=0; rep(i,0,n-1) cnt[i+1]=a[i];\n\t\tDfs_Getlayer(1,1,0);\n\t\treturn ans;\n\t}\n};\n\n//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!\n\n```\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[Codechef March Challenge 2021 Random Walk Queries(RWALKS) (动态点分治) ]","url":"/2021/05/21/[Codechef March Challenge 2021 Random Walk Queries(RWALKS) (动态点分治) ]/","content":"# [Codechef March Challenge 2021 Random Walk Queries(RWALKS) (动态点分治) ](https://www.codechef.com/MARCH21B/problems/RWALKS)\n\n题目大意：\n\n对于给定的无根树$T$，要求强制在线维护两种操作\n\n1.游走$(u,d)$，以$u$为根在树上游走，从$u$开始，最多走$d$步，每次随机从儿子中选择一个点\n\n2.查询$u$，当前$u$被遍历的期望次数\n\n$$ \\ $$\n\n~~灵光一闪想到这么个憨批树上结构~~\n\n对于更新$(u,d)$，考虑$u$ **跨过当前点分根** 到达其他点分子树里的贡献\n\n一个点由当前点分根到达的概率是一个定值，可以预处理出来，并在查询时计算\n\n因此更新贡献时，可以描述为$dep\\leq d$的点接受到 以$x$的概率访问当前点分根\n\n可以简单用树状数组维护\n\n为了剔除对于自己所在子树的非法贡献，需要额外开一些树状数组来维护\n\n一个节点有$\\log n$个点分父节点，每次需要两次树状数组查询\n\n因此查询部分复杂度为$O(m\\log ^2n)$，预处理以及空间复杂度为$O(n\\log n)$\n\n```cpp\nconst int N=2e5+10,K=19,P=1e9+7;\n\nint n,m,I[N];\nstruct Edge{\n\tint to,nxt;\n}e[N<<1];\nint head[N],ecnt,deg[N];\nvoid AddEdge(int u,int v){\n\te[++ecnt]=(Edge){v,head[u]};\n\thead[u]=ecnt,deg[v]++;\n}\n#define erep(u) for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to)\n\nstruct BIT{\n\tint n;\n\tvector <int> s;\n\tBIT(){};\n\tBIT(int n):n(n){ s.resize(n+1); }\n\tvoid Add(int p,int x){ \n\t\tfor(cmin(p,n);p;p-=p&-p) s[p]+=x,Mod1(s[p]);\n\t}\n\tint Que(int p){\n\t\tint res=0;\n\t\twhile(p<=n) res+=s[p],Mod1(res),p+=p&-p;\n\t\treturn res;\n\t}\n} T[N];\nvector <BIT> G[N];\n//  Dep:点分树上的dep，id:节点在每层的编号， dep:节点在每层的dep，s:节点在每层由根到达的系数\nint Dep[N],id[K][N],dep[K][N],s[K][N],vis[N],sz[N],fa[N],Root;\n\nint mi,rt;\nvoid FindRt(int n,int u,int f){\n\tint ma=0; sz[u]=1;\n\terep(u) if(v!=f && !vis[v]) {\n\t\tFindRt(n,v,u);\n\t\tsz[u]+=sz[v],cmax(ma,sz[v]);\n\t}\n\tcmax(ma,n-sz[u]);\n\tif(mi>ma) mi=ma,rt=u;\n}\n\nint D,maxd;\nvoid dfs(int u,int f,int id){\n\tcmax(maxd,dep[D][u]=dep[D][f]+1),::id[D][u]=id;\n\terep(u) if(v!=f && !vis[v]) {\n\t\ts[D][v]=1ll*s[D][u]*I[deg[u]-1]%P;\n\t\tdfs(v,u,id);\n\t}\n}\n\n// 预处理点分治，开树状数组\nint Divide(int n,int u){\n\tmi=1e9,FindRt(n,u,0),u=rt;\n\tint sonc=0;\n\tvis[u]=s[Dep[u]=D][u]=1,id[D][u]=-1;\n\tint t=0;\n\terep(u) if(!vis[v]) {\n\t\tmaxd=0;\n\t\ts[D][v]=1,dfs(v,u,sonc);\n\t\tG[u].pb(BIT(maxd));\n\t\tsonc++;\n\t\tcmax(t,maxd);\n\t}\n\tT[u]=BIT(t);\n\terep(u) if(!vis[v]) {\n\t\tif(sz[v]>sz[u]) sz[v]=n-sz[u];\n\t\tD++,fa[Divide(sz[v],v)]=u,D--;\n\t}\n\treturn u;\n}\n\nint sum[N];\nint Que(int u){\n\tll ans=sum[u];\n\tfor(int v=u,d=Dep[v];(d--,v=fa[v]);) \n\t\tans=(ans+ 1ll* (T[v].Que(dep[d][u])+G[v][id[d][u]].Que(dep[d][u])) *s[d][u])%P;\n\treturn (ans%P+P)%P;\n}\nvoid Upd(int u,int d){\n\tsum[u]++,Mod1(sum[u]),T[u].Add(d,I[deg[u]]);\n\tfor(int v=fa[u],D=Dep[u]-1;v;v=fa[v],D--) {\n\t\tif(d<dep[D][u]) continue;\n\t\tint x=1ll*I[deg[u]]*s[D][u]%P;\n\t\tsum[v]+=x,Mod1(sum[v]);\n\t\tx=1ll*x*I[deg[v]-1]%P;\n\t\tT[v].Add(d-dep[D][u],x),G[v][id[D][u]].Add(d-dep[D][u],P-x);\n\t}\n}\n\nint lst;\nint Get() { return (rd()+lst)%n+1; }\n\nint main(){\n\tI[0]=I[1]=1;\n\trep(i,2,N-1) I[i]=1ll*(P-P/i)*I[P%i]%P;\n\tn=rd(),m=rd();\n\trep(i,2,n){\n\t\tint u=rd(),v=rd();\n\t\tAddEdge(u,v),AddEdge(v,u);\n\t}\n\tRoot=Divide(n,1);\n\twhile(m--) {\n\t\tint opt=rd();\n\t\tif(opt==1) {\n\t\t\tint u=Get(),d=Get();\n\t\t\tUpd(u,d);\n\t\t} else printf(\"%d\\n\",lst=Que(Get()));\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[HDU - 6833] a Very Easy Math Problem (莫比乌斯反演)","url":"/2021/05/21/[HDU - 6833] A Very Easy Math Problem (莫比乌斯反演)/","content":"# [HDU - 6833] A Very Easy Math Problem (莫比乌斯反演)\n\n与$\\gcd$有关的问题，很容易想到莫比乌斯反演\n\n设$G(a,n)=(\\sum_{i=1}^{\\lfloor \\frac{n}{a} \\rfloor } (ai)^k)^x$\n\n$Ans=\\sum_{g=1}^{n} g\\cdot f(g)\\cdot \\sum _{d=1}^{\\lfloor\\frac{n}{g}\\rfloor} \\mu(d) G(gd,n)$\n\n对于单组询问，显然可以$O(n\\ln n)$求解\n\n考虑优化\n\n可以在$O(n\\ln n)$的时间内，对于每个$i$，求出$F(i)=\\sum_{d|i}\\mu(d)\\cdot \\frac{i}{d} f(\\frac{i}{d})$\n\n对于$G(a,n)$的求解，参数分离后发现 $G(a,n)=a^{kx}(\\sum_{i=1}^{\\lfloor \\frac{n}{a} \\rfloor } i^k)^x$\n\n可以预处理出$S(n)=\\sum_{i=1}^n i^{kx}\\cdot F(i)$前缀和以及$A(n)=(\\sum_{i=1}^{n}i^k)^x$，对于每个$\\lfloor \\frac{n}{a}\\rfloor $考虑即可\n\n数论分段的复杂度为单组查询$O(\\sqrt n)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\nchar IO;\ntemplate <class T=int> T rd(){\n    T s=0; int f=0;\n    while(!isdigit(IO=getchar())) if(IO=='-') f=1;\n    do s=(s<<1)+(s<<3)+(IO^'0');\n    while(isdigit(IO=getchar()));\n    return f?-s:s;\n}\n\nconst int N=2e5+10,P=1e9+7;\n\nint T,n,k,x;\nint mk[N],notpri[N],pri[N],pc,w[N];\nll qpow(ll x,ll k=P-2) {\n    ll res=1;\n    for(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n    return res;\n}\nint s[N],F[N],S[N],A[N];\n\n\nint main(){\n    w[1]=1;\n    rep(i,2,N-1) {\n        if(!notpri[i]) pri[++pc]=i,w[i]=-1;\n        for(int j=1;j<=pc && 1ll*i*pri[j]<N;++j) {\n            notpri[i*pri[j]]=1;\n            if(i%pri[j]==0) {\n                w[i*pri[j]]=0;\n                break;\n            }\n            w[i*pri[j]]=-w[i];\n        }\n    }\n    for(int i=2;i*i<N;++i) for(int j=i*i;j<N;j+=i*i) mk[j]=1;\n    rep(i,1,N-1) if(!mk[i]) rep(j,1,(N-1)/i) F[i*j]=(F[i*j]+i*w[j]+P)%P;\n    T=rd(),k=rd(),x=rd();\n    rep(i,1,N-1) S[i]=(S[i-1]+F[i]*qpow(i,1ll*k*x))%P;\n    rep(i,1,N-1) A[i]=(A[i-1]+qpow(i,k))%P;\n    rep(i,1,N-1) A[i]=qpow(A[i],x);\n    rep(kase,1,T) {\n        n=rd();\n        ll ans=0;\n        for(int i=1,j;i<=n;i=j+1) {\n            j=n/(n/i);\n            ans=(ans+1ll*(S[j]-S[i-1])*A[n/i])%P;\n        }\n        ans=(ans%P+P)%P;\n        printf(\"%lld\\n\",ans);\n    }\n}\n\n```\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[HDU-6834] Yukikaze and Smooth Numbers","url":"/2021/05/21/[HDU-6834] Yukikaze and Smooth numbers/","content":"# [HDU-6834] Yukikaze and Smooth numbers\n\n题意：计算$[1,n]$中只包含$[1,k]$的质因数的数个数\n\n让人联想到Min25筛的$dp$模型\n\n设$m=\\sqrt n$，可以对于$k > m$和$k\\leq m$讨论\n\n## Case1:$k\\leq m$\n\n此时可以直接套用类似Min25筛的$dp$模型求解\n\n令$dp_{i,j}$为$[1,j]$只包含$[1,i]$的质因数的数个数\n\n则$dp_{i,j}=\\sum_k dp_{i-1,\\lfloor \\frac{j}{prime_i^k}\\rfloor }$\n\n要求的是$dp_{k,n}$，第二维状态是$O(m)$级别的\n\n直接写当然是近似于$O(m\\cdot \\pi(n))=O(\\frac{n}{\\log n})$级别的\n\n加上Min25筛的优化，令$dp_i,j$不包含单质数和1的情况，以减少转移情况\n\n如果从大到小考虑每个质数，那么只需要考虑$j\\ge prime_i^2$的第二维状态，以减少很多的$dp$时间\n\n沿用Min25筛复杂度证明，是$O(\\frac{n^{\\frac{3}{4}}}{\\log n})$的\n\n```cpp\n#define id(x) (x<=m?x:cnt-n/x+1)\n\nint dp[N],g[N],st[N],cnt;\n\nif(k==1){ puts(\"1\"); continue; }\nm=sqrt(n),cnt=0;\nrep(i,1,n) st[++cnt]=i=n/(n/i),dp[cnt]=0; // 不包括质数本身和1\nint sz=1;\nwhile(pri[sz+1]<=k) sz++;\nint p=0;\nrep(i,1,cnt){\n    while(p<sz && pri[p+1]<=st[i]) p++;\n    g[i]=p;\n}    \nrep(i,1,cnt) for(ll x=pri[sz]*pri[sz];x<=st[i];x*=pri[sz]) dp[i]++;\nfor(reg int i=sz-1;i;--i) {\n    for(reg int j=cnt,tmp=pri[i]*pri[i];st[j]>=tmp;--j) {\n        reg int x=st[j];\n        while(x>=tmp) {\n            x/=pri[i];\n            dp[j]+=dp[id(x)]+g[id(x)]-i+1;\n        }\n    }\n}\nprintf(\"%d\\n\",dp[cnt]+sz+1);\n```\n\n$$\\ $$\n\n## Case2 : $k> m$\n\n可以把问题转化为求不合法部分，即$\\sum_{prime_i>k}\\lfloor \\frac{n}{prime_i}\\rfloor $\n\n采用数论分段计算$\\lfloor \\frac{n}{i}\\rfloor $，那么剩下的问题就是要求一段区间内的质数个数\n\n同样采用类似上面的模型，\n\n令$dp_{i,j}$为$[1,j]$内与前$[1,i]$内质数互质的个数以及这些质数本身，不包括1 \n\n```cpp\nint n,m;\nint dp[N],g[N],st[N],cnt;\n#define id(x) (x<=m?x:cnt-n/x+1)\n\nint Count(int n) {\n    if(n<N) return pcount[n];\n    ::n=n,m=sqrt(n),cnt=0;\n    rep(i,1,n) st[++cnt]=i=n/(n/i),dp[cnt]=i-1;\n    for(reg int i=1;pri[i]<=m;++i) {\n        for(reg int j=cnt,tmp=pri[i]*pri[i];st[j]>=tmp;--j) {\n            reg int k=st[j]/pri[i];\n            dp[j]-=dp[id(k)]-(i-1);\n        }\n    }\n    return dp[cnt];\n}\n```\n\n具体复杂度没有算过，应该不会太高\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[HDU-6883] Coin Game(2020HDU多校第十场T7)","url":"/2021/05/21/[HDU-6883] Coin Game(2020HDU多校第十场T7)/","content":"# [HDU-6883] Coin Game(2020HDU多校第十场T7)\n\n题目给出的模型看起来比较奇怪，但是简单推理后，发现可以转化为一个简单的01背包问题\n\n对于题目给定的权值$a_i,b_i$，分为$a_i,a_i+b_i$两个物品，发现可以得到这个机器的所有合法贡献情况\n\n也就是说，有两种大小分别为$1,2$的物品，要做01背包\n\n这个刚刚在[WC2020](https://www.cnblogs.com/chasedeath/p/13460468.html)考过。。。\n\n设两类转化后的权值分别为$a_i,b_i$，则转移过程可以简单描述为\n\n1.将两类权值分别从大到小排序\n\n2.将dp值转化为在两个序列中分别选取一段前缀和\n\n3.转移时枚举下一次决策的选取是那种物品，选取最优一个，记录指针转移即可\n\n主要复杂度可能还在于排序，Trick:有一点卡内存\n\n但是实测桶排和直接sort好像差距不大。。。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n\nconst int N=5e6+10,INF=1e9;\n\nint n,m;\nint a[N],b[N];\null k1,k2;\nint Shift(){\n    ull k3=k1,k4=k2;\n    k1=k4;\n    k3^=k3<<23;\n    k2=k3^k4^(k3>>17)^(k4>>26);\n    return (k2+k4)%10000000+1;\n}\nint A[N*3],B[N*3]; // 记录在两个序列中的指针\nll dp[3]; // dp数组滚动了一下\n\nint main(){\n    while(~scanf(\"%d%d%llu%llu\",&n,&m,&k1,&k2)) {\n        rep(i,1,n) a[i]=Shift(),b[i]=Shift()+a[i];\n        sort(a+1,a+n+1,greater<int>()),sort(b+1,b+n+1,greater<int>());\n\n        A[0]=B[0]=1;\n        rep(i,0,2) dp[i]=0;\n        ll ans=0;\n        int cur=0;\n        rep(i,0,m) {\n            if(i+1<=m && A[i]<=n) {\n                int nxt=(cur+1)%3;\n                if(dp[cur]+a[A[i]]>dp[nxt]) dp[nxt]=dp[cur]+a[A[i]],A[i+1]=A[i]+1,B[i+1]=B[i];\n            }\n            if(i+2<=m && B[i]<=n) {\n                int nxt=(cur+2)%3;\n                if(dp[cur]+b[B[i]]>dp[nxt]) dp[nxt]=dp[cur]+b[B[i]],A[i+2]=A[i],B[i+2]=B[i]+1;\n            }\n            ans^=dp[cur];\n            cur=(cur+1)%3;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}\n\n\n```\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[NOI Online  3 提高组] 优秀子序列","url":"/2021/05/21/[NOI Online  3 提高组] 优秀子序列/","content":"#  [NOI Online #3 提高组] 优秀子序列\n\n这个题怎么不直接取名\n\n[集合幂级数$\\text{exp}$](https://www.cnblogs.com/chasedeath/p/13891189.html)呢\n\n优秀的子序列中任意两个元素01位无交，这是一个标准的子集卷积形式\n\n$\\varphi$的计算显然与$a_i$的卷积独立，可以线性筛/埃氏筛\n\n### 暴力\n\n可以暴力$3^{18}$过，枚举时为了避免重复可以通过强制枚举的数包含最高位的1\n\n注意$a_i=0$要特殊处理\n\n```cpp\nbool Mbe;\nconst int N=1<<18,P=1e9+7;\n\nint n,cnt0=1;\nll qpow(ll x,ll k=P-2){\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\nint Phi[N+1],notpri[N+1];\nint F[N],C[N],cnt[N];\n\nint main(){\n\tPhi[1]=1;\n\trep(i,2,N) if(!notpri[i]) {\n\t\tPhi[i]=i-1;\n\t\tfor(int j=i+i;j<=N;j+=i) {\n\t\t\tnotpri[j]=1;\n\t\t\tif(!Phi[j]) Phi[j]=j;\n\t\t\tPhi[j]=Phi[j]/i*(i-1);\n\t\t}\n\t}\n\tn=rd();\n\trep(i,1,N-1) cnt[i]=cnt[i&(i-1)]+1;\n\tF[0]=1;\n\trep(i,1,n) {\n\t\tint x=rd();\n\t\tif(!x) F[0]*=2,Mod1(F[0]);\n\t\telse C[x]++;\n\t}\n\tint ans=0;\n\trep(S,0,N-1) {\n\t\tif(S) for(int T=S;_builtin_clz(S)==__builtin_clz(T);T=(T-1)&S) F[S]=(F[S]+1ll*F[S^T]*C[T])%P;\n\t\tans=(ans+1ll*F[S]*Phi[S+1])%P;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\n```\n\n### 集合幂级数\n\n就是直接套集合幂计数的$\\text{exp}$\n\n同样要特殊处理$a_i=0$的\n\n```cpp\nconst int N=1<<18,P=1e9+7;\nint F[N][19],Inv[20];\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\nchar buf[200000],*p1,*p2;\n#define getchar() (((p1==p2)&&(p2=(p1=buf)+fread(buf,1,200000,stdin))),*p1++)\nchar IO;\nint rd(){\n\tint s=0; static char c;\n\twhile(c=getchar(),c<48);\n\tdo s=(s<<1)+(s<<3)+(c^'0');\n\twhile(c=getchar(),c>47);\n\treturn s;\n}\nbool Mbe;\n\nint n,m,cnt0=1,U;\nll qpow(ll x,ll k=P-2){\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\nint Phi[N+1],notpri[N+1],pri[N/4],pc;\n\nvoid Exp(int *a){\n\tstatic int b[N];\n\trep(i,1,n) b[i-1]=1ll*a[i]*i%P;\n\trep(i,0,n-1) {\n\t\tint s=b[i];\n\t\trep(j,1,i) s=(s+1ll*a[j]*b[i-j])%P;\n\t\ta[i+1]=1ll*s*Inv[i+1]%P;\n\t}\n}\n\nint main(){\n\tInv[0]=Inv[1]=1;\n\trep(i,2,18) Inv[i]=1ll*(P-P/i)*Inv[P%i]%P;\n\tn=rd();\n\trep(i,1,n) {\n\t\tint x=rd(); cmax(U,x);\n\t\tif(!x) cnt0*=2,Mod1(cnt0);\n\t\telse F[x][__builtin_popcount(x)]++;\n\t}\n\tPhi[1]=1;\n\tfor(n=1;(1<<n)<=U;)n++;\n\tm=1<<n;\n\trep(i,2,m) {\n\t\tif(!notpri[i]) pri[++pc]=i,Phi[i]=i-1;\n\t\tfor(int j=1;j<=pc && 1ll*i*pri[j]<=m;++j){\n\t\t\tnotpri[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0) {\n\t\t\t\tPhi[i*pri[j]]=Phi[i]*pri[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tPhi[i*pri[j]]=Phi[i]*(pri[j]-1);\n\t\t}\n\t}\n\tfor(int i=1;i<m;i<<=1) for(int l=0;l<m;l+=i*2) for(int j=l;j<l+i;++j) rep(k,1,n) F[j+i][k]+=F[j][k],Mod1(F[j+i][k]);\n\trep(i,0,m-1) Exp(F[i]);\n\tfor(int i=1;i<m;i<<=1) for(int l=0;l<m;l+=i*2) for(int j=l;j<l+i;++j) rep(k,1,n) F[j+i][k]-=F[j][k],Mod2(F[j+i][k]);\n\tint ans=0;\n\trep(S,1,m-1) ans=(ans+1ll*F[S][__builtin_popcount(S)]*Phi[S+1])%P;\n\tans=1ll*(ans+1)*cnt0%P;\n\tprintf(\"%d\\n\",ans);\n}\n```\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[NOI Online 2021 提高组] 愤怒的小N","url":"/2021/05/21/[NOI Online 2021 提高组] 愤怒的小N/","content":"# [NOI Online 2021 提高组] 愤怒的小N\n\n### 暴力\n\n倍增维护$[x,x+2^d)$内部所有$b$的权值和 以及$a$的，用多项式表示\n\n具体的，维护两个多项式$F_0(x),F_1(x)$，每次倍增的转移如下\n\n$F_0(x)\\leftarrow F_0(x)+F_1(x+d)$\n\n$F_1(x)\\leftarrow F_1(x)+F_0(x+d)$\n\n因此暴力倍增复杂度为$O(nk^2)$，实现上需要记录每次倍增之后多项式与答案的前面部分相拼接需要额外的偏移\n\n$$ \\ $$\n\n### 优化\n\n如果你输出多项式，就会发现，倍增$k$次之后，所有$a,b$位置对应的多项式就完全相同了\n\n形式化地理解这个过程\n\n一开始，$F_0(x)=A(x),F_1(x)=0$，其中$A(x)$为读入的多项式\n\n进行一次转移后，$F_0(x),F_1(x)$的第$k-1$项只受到对方的$k-1$项和自己的$k-1$项影响\n\n因此一次转移后$[x^{k-1}]F_0(x)=[x^{k-1}]F_1(x)$\n\n下一次转移，第$k-2$项值只受到对方的$k-2$项，已经已经确定相同的$k-1$项影响\n\n这个过程不断进行，第$i$次倍增会使得$[k-i,k-1]$项相同\n\n$$ \\ $$\n\n对于$k$次倍增之后，后面多出来的部分，可以直接求一个多项式前缀和，然后除2得到答案\n\n多项式前缀和容易通过拉格朗日插值解决，复杂度为$O(k^2)$\n\n预处理前面的多项式复杂度为$O(k^3)$，求后面的式子为$O(k^2)$，预处理$n$的值复杂度为$O(\\log n)$\n\n因此复杂度为$O(\\log n+k^3)$\n\n$$ \\ $$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair <int,int> Pii;\n#define reg register\n#define mp make_pair\n#define pb push_back\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) f|=IO=='-';\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=5e5+10,M=510,INF=1e9+10,P=1e9+7;\n\nint n,m;\nchar s[N];\nint D[N],T[N];\n// D[i]预处理倍增求出的每项对于答案贡献时存在的偏移\n// T[i]预处理每个位后面1的个数\nint A[N],F[2][M],G[2][M],C[M][M];\nint Pow[N];\nll qpow(ll x,ll k=P-2){\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\nint X[M],Y[M];\nint Lagrange(int x,int n,int *X,int *Y){\n\tint ans=0;\n\trep(i,0,n) {\n\t\tll s=1;\n\t\trep(j,0,n) if(i!=j) s=s*(X[i]-X[j])%P;\n\t\ts=qpow(s);\n\t\trep(j,0,n) if(i!=j) s=s*(x-X[j])%P;\n\t\tans=(ans+s*Y[i])%P;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tfreopen(\"angry.in\",\"r\",stdin),freopen(\"angry.out\",\"w\",stdout);\n\tscanf(\"%s\",s),n=strlen(s),reverse(s,s+n);\n\tm=rd();\n\trep(i,0,m-1) A[i]=F[0][i]=rd();\n\trep(i,0,m) rep(j,*C[i]=1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%P;\n\tint ans=0,x=2;\n\trep(i,1,n-1) D[i-1]=x*(s[i]=='1'),x=x*2%P,T[i-1]=(s[i]=='1');\n\tdrep(i,n-1,0) D[i]+=D[i+1],Mod1(D[i]),T[i]^=T[i+1];\n\tx=1;\n\trep(i,0,min(m-1,n-1)) {\n\t\tif(s[i]=='1') {\n\t\t\tint t=1;\n\t\t\trep(j,0,m-1) {\n\t\t\t\tans=(ans+1ll*t*F[!T[i]][j])%P;\n\t\t\t\tt=1ll*t*D[i]%P;\n\t\t\t}\n\t\t}\n\t\trep(d,0,1) rep(j,0,m-1) G[d][j]=F[d][j];\n\t\trep(j,*Pow=1,m-1) Pow[j]=1ll*Pow[j-1]*x%P;\n\t\trep(j,0,m-1) rep(k,0,j) {\n\t\t\tF[0][k]=(F[0][k]+1ll*C[j][k]*Pow[j-k]%P*G[1][j])%P;\n\t\t\tF[1][k]=(F[1][k]+1ll*C[j][k]*Pow[j-k]%P*G[0][j])%P;\n\t\t}\n\t\tx=x*2%P;\n\t}\n    // 倍增到前k-1项\n\tif(m>=n) return printf(\"%d\\n\",ans),0;\n    // 预处理拉格朗日插值\n\trep(i,0,m) {\n\t\tX[i]=i,x=1;\n\t\trep(j,0,m-1) {\n\t\t\tY[i]=(Y[i]+1ll*A[j]*x)%P;\n\t\t\tx=1ll*x*i%P;\n\t\t}\n\t\tif(i) Y[i]+=Y[i-1],Mod1(Y[i]);\n\t}\n\tans=(ans+1ll*Lagrange(D[m-1]-1,m,X,Y)*(P+1)/2)%P;\n\tprintf(\"%d\\n\",ans);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[NOI Online 2021 提高组] 积木小赛","url":"/2021/05/21/[NOI Online 2021 提高组] 积木小赛/","content":"# [NOI Online 2021 提高组] 积木小赛\n\n题目大意：给定串$A$,$B$，求$B$中有多少本质不同的连续子段是$A$的子序列\n\n$n\\leq 3000$\n\n暴力枚举$B$中的子段，同步维护与$A$的匹配指针$p$\n\n每次插入一个字符$c$，找到$A$中$p+1$之后第一个字符$c$，令匹配指针跳过去\n\n可以预处理出这样的下一个字符$nxt_{i,c}$，完成$O(1)$匹配\n\n除此以外，我们还需要对于本质不同去重\n\n如果用$\\text{trie}$树去重，需要开一个$\\frac{n^2}{2}\\cdot 26$的数组，面临着内存不够的问题\n\n~~你可以信仰不开这么大~~\n\n也可以去学习一下$\\text{DAT(Double Array Trie)}$算法\n\n也可以用$\\text{hash+set/map/hash table/sort unique}$\n\n也可以用链表暴力存储trie树的情况，每次暴力for过去找儿子\n\n这样内存均为$O(n^2)$\n\n以下是链表trie树的版本\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair <int,int> Pii;\n#define reg register\n#define mp make_pair\n#define pb push_back\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) f|=IO=='-';\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=3010,M=N*N/2,INF=1e9+10;\nbool Mbe;\n\nint n;\nint nxt[N][26];\nchar A[N],B[N];\nstruct Edge{ int c,to,nxt; } e[M];\nint head[M],cnt;\n\nbool Med;\nint main(){\n\t//fprintf(stderr,\"%.2lf\\n\",(&Med-&Mbe)/1024.0/1024.0);\n\tfreopen(\"block.in\",\"r\",stdin),freopen(\"block.out\",\"w\",stdout);\n\tn=rd(),scanf(\"%s%s\",A+1,B+1);\n\tdrep(i,n,1) {\n\t\trep(j,0,25) nxt[i][j]=nxt[i+1][j];\n\t\tnxt[i][A[i]-'a']=i;\n\t}\n\trep(i,1,n) {\n\t\tint u=0,p=0;\n\t\trep(j,i,n) {\n\t\t\tint c=B[j]-'a';\n\t\t\tif(!(p=nxt[p+1][c])) break;\n\t\t\tint v=-1;\n\t\t\tfor(int k=head[u];k;k=e[k].nxt) if(e[k].c==c) { v=e[k].to; break; }\n\t\t\tif(~v) u=v;\n\t\t\telse {\n\t\t\t\tv=++cnt;\n\t\t\t\te[v]=(Edge){c,v,head[u]};\n\t\t\t\thead[u]=v,u=v;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cnt);\n}\n```\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[MapGuessing TopCoder - 12152]","url":"/2021/05/21/[MapGuessing TopCoder - 12152]/","content":"## [MapGuessing TopCoder - 12152](https://vjudge.net/problem/TopCoder-12152)\n\n做得我很迷\n\n首先是可以把问题转化为，每次操作之后会让原序列的限制条件变为：不考虑某一些位置时合法\n\n枚举每个开始位置，依次考虑每一个操作，如果有一个位置被改为不同，就是不合法的\n\n对于每一个开始位置，能得到的的**最优限制条件**都是唯一的，因为只要是合法的，一定取最后一个合法的位置，才能尽可能多地覆盖一些位置\n\n那么我们得到了$|goal|$个这样的限制条件$S_i$，设$n=|goal|$\n\n直接计算肯定会算重，考虑一个简单的容斥\n\n$\\begin{aligned}Answer=\\sum_{T\\ne \\empty}(-1)^{|T|+1}2^{|S_{T_1}\\cap \\cdots \\cap S_{T_{|T|}}|}\\end{aligned}$\n\n就是枚举选择一个限制的集合，求出他们的并集\n\n直接枚举复杂度当然是$O(2^{|n|})$，如果$\\text{dfs}$枚举，当前状态为$0$时，可以直接返回答案\n\n估计一下这个$\\text{dfs}$的复杂度\n\n设操作过程中指针左右移动的距离是$L$，那么最多存在$n-L$个合法的开始位置，每个状态最多包含$L$个$1$\n\n很显然枚举的上限是$\\min\\{2^{n-L},2^{L}\\}$，即受到**开始位置的个数**和**可能出现的1个数**的限制\n\n当$n-L=L$时，复杂度达到上限是$O(2^{\\frac{n}{2}})$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\nset <ll> st;\nll S[40];\nint now[40],cnt;\nll dfs(int p,ll State){\n\tif(p==cnt+1) return (1ll<<__builtin_popcountll(State)); // 枚举完毕\n\tif(State==0) return 0; // 剪枝，注意因为是后面的所有1,-1相加，所以是return 0而不是1\n\treturn dfs(p+1,State)-dfs(p+1,State&S[p]);  // 直接处理容斥系数\n}\n\nclass MapGuessing {\npublic:\n\tlong long countPatterns(string S, vector <string> code) {\n\t\tstring C=\"\";\n\t\tfor(string t:code) C+=t;\n\t\tint n=S.size();\n\t\tst.clear();\n\t\trep(i,0,n-1) {\n\t\t\tint p=i,f=1;\n\t\t\tll lst=0; // 记录最后一个合法的即可\n\t\t\trep(i,0,n-1) now[i]=0;\n\t\t\tfor(char c:C) {\n\t\t\t\tif(c=='<') p--;\n\t\t\t\tif(c=='>') p++;\n\t\t\t\tif(c=='0') now[p]=1;\n\t\t\t\tif(c=='1') now[p]=2;\n\t\t\t\tif(p<0 || p>=n){ f=0; break; }\n\t\t\t\tint fl=1;\n\t\t\t\tll T=0;\n\t\t\t\trep(i,0,n-1) {\n\t\t\t\t\tif(!now[i]) continue;\n\t\t\t\t\tif(now[i]-1!=S[i]-'0'){ fl=0; break; }\n\t\t\t\t\telse T|=1ll<<i;\n\t\t\t\t}\n\t\t\t\tif(!fl) continue;\n\t\t\t\tlst=T;\n\t\t\t}\n\t\t\tif(!f) continue;\n\t\t\tst.insert(-lst);\n\t\t}\n\t\tcnt=0;\n\t\tfor(ll x:st) {\n\t\t\tll y=-x;\n\t\t\tint f=1;\n\t\t\trep(i,1,cnt) if((::S[i]&y)==y){ f=0; break; }\n\t\t\tif(f) ::S[++cnt]=y;\n\t\t}\n        //初始系数是-1\n\t\tll ans=(1ll<<n)-dfs(1,(1ll<<n)-1); // 注意枚举出来会把T=emptyset的情况算进去，要去掉\n\t\treturn ans;\n\t}\n};\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[SweetFruits TopCoder - 12141](Matrix-Tree)","url":"/2021/05/21/[SweetFruits TopCoder - 12141](Matrix-Tree)/","content":"# [SweetFruits TopCoder - 12141](https://vjudge.net/problem/TopCoder-12141)(Matrix-Tree)\n\n问题看起来很复杂，不可写，所以先考虑分解一下\n\n假设最后生效的点集为$V$，那么答案只和$\\sum sweetness[V_i]$和$|V|$有关\n\n所以可以考虑对于每一种$|V|$，先预处理出方案数\n\n得知每一种$|V|$的方案数之后，可以用$\\text{meet in the middle}$法枚举得到$\\sum sweetness[V_i]\\leq maxsweetness$的方案数\n\n方案数是有限制的生成树个数，所以考虑用$\\text{Matrix-Tree}$求\n\n限定有$a$个点生效，$b$个点不生效，$c$个点是$-1$\n\n那么可能出现的边是$a-a,a-c,b-c$三种\n\n但是我们无法保证$a$中的点一定生效，所以可以用容斥/二项式反演得到\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n\n#define reg register\ntypedef long long ll;\n#define rep(i,a,b) for(reg int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(reg int i=a,i##end=b;i>=i##end;--i)\n\n#define pb push_back\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\nchar IO;\nint rd(){\n\tint s=0;\n\tint f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=50,P=1e9+7;\n\nll qpow(ll x,ll k=P-2) {\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\n\nint n,m;\n\nstruct Mat{\n\tint a[N][N];\n\tMat(){ memset(a,0,sizeof a); }\n\tint Det(int n){  // 用于Matrix-Tree的\n\t\tstatic int G[N][N];\n\t\trep(i,1,n) rep(j,1,n) G[i][j]=a[i][j];\n\t\tint res=1;\n\t\trep(i,1,n) {\n\t\t\tif(!G[i][i]) rep(j,i+1,n) if(G[j][i]){ res=P-res; swap(G[i],G[j]); break; }\n\t\t\tif(!G[i][i]) continue;\n\t\t\tll Inv=qpow(a[i][i]);\n\t\t\trep(j,i+1,n) {\n\t\t\t\tll t=a[j][i]*Inv%P;\n\t\t\t\trep(k,i,n) a[j][k]=(a[j][k]-1ll*a[i][k]*t%P+P)%P;\n\t\t\t}\n\t\t}\n\t\trep(i,1,n) res=1ll*res*a[i][i]%P;\n\t\treturn res;\n\t}\n};\n\nint w[N],G[N][N],C[N][N];\nvoid Init(){\n\trep(i,0,N-1) rep(j,C[i][0]=1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P;\n\trep(i,0,n) {\n\t\tMat T;\n\t\trep(j,1,m) { // -1\n\t\t\trep(k,1,n+m) T.a[j][k]=-1;\n\t\t\tT.a[j][j]=n+m-1;\n\t\t}\n\t\trep(j,m+1,m+i) { // 生效\n\t\t\trep(k,1,m+i) if(j!=k) T.a[j][k]=-1;\n\t\t\tT.a[j][j]=m+i-1;\n\t\t}\n\t\trep(j,m+i+1,m+n) { // 不生效\n\t\t\trep(k,1,m) T.a[j][k]=-1;\n\t\t\tT.a[j][j]=m;\n\t\t}\n\t\tw[i]=T.Det(n+m-1);\n\t}\n\trep(i,0,n) rep(j,0,i-1) w[i]=(w[i]-1ll*C[i][j]*w[j]%P+P)%P; // 容斥/二项式反演\n}\n\nint val[N];\nvector <int> st[N/2];\n\n\nint Meet_In_The_Middle(int Max){\n\tint ans=0,mid=n/2;\n\trep(i,0,mid) st[i].clear();\n\trep(S,0,(1<<mid)-1) {\n\t\tint c=0,s=0;\n\t\trep(i,0,mid-1) if(S&(1<<i)) s+=val[i],c++;\n\t\tif(s<=Max) st[c].pb(s);\n\t}\n\trep(i,0,mid) sort(st[i].begin(),st[i].end());\n\trep(S,0,(1<<(n-mid))-1) {\n\t\tint c=0,s=0;\n\t\trep(i,0,n-mid-1) if(S&(1<<i)) s+=val[i+mid],c++;\n\t\tif(s>Max) continue;\n\t\trep(j,0,mid) {\n\t\t\tint x=upper_bound(st[j].begin(),st[j].end(),Max-s)-st[j].begin();\n\t\t\tif(x) ans=(ans+1ll*x*w[c+j])%P;\n\t\t}\n\t}\n\treturn ans;\n}\n\nclass SweetFruits {\npublic:\n\tint countTrees(vector <int> Val, int Max) {\n\t\tsort(Val.begin(),Val.end(),greater <int> ());\n\t\tm=0; while(Val.size() && *Val.rbegin()==-1) m++,Val.pop_back();\n\t\tn=Val.size();\n\t\trep(i,0,n-1) val[i]=Val[i];\n\t\tInit();\n\t\treturn Meet_In_The_Middle(Max);\n\t}\n};\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[TopCoder - 12244 SRM 559 Round1 Div1] CircusTents","url":"/2021/05/21/[TopCoder - 12244 SRM 559 Round1 Div1] CircusTents/","content":"# [TopCoder - 12244 SRM 559 Round1 Div1] CircusTents\n\n小而精的计算几何题\n\n题目大意：有$n$个实心圆（不能从内部经过）\n\n在第一个圆上选出一个点，使得**从其他任意圆上到达它的最小距离** 最大\n\n分析：要最小值最大，显然可以想到二分答案\n\n不能穿过其他圆这一条件让计算答案变得十分困难，但是可以发现，如果路径经过了一号圆以外的圆\n\n那么从路径与该圆的交点直接过去的距离一定更近\n\n也就是说，可以把 距离 看做 可以穿过一号圆以外的圆 的距离\n\n考虑从一个圆$O$到达一号圆上的某一点$X$的最小距离，大致可以成两种情况\n\n1.$OX$连线不穿过一号圆，那么可以直接走$OX$连线\n\n![QQ截图20201102162335.png](https://i.loli.net/2020/11/02/RHD3wZ6kJSYGfez.png)\n\n最优路径就是绿色线\n\n2.先走一条切线，然后绕着圆周走一段\n\n![QQ截图20201102162651.png](https://i.loli.net/2020/11/02/8hYsmXMJkcq9DUS.png)\n\n其中$Y$是$O$点对于一号圆的切线的切点，绿色线+圆弧是最优路径\n\n那么二分答案$mid$之后，可以发现满足距离$\\ge mid$的选点位置是一段圆弧，可以从角度取交集判断是否有解\n\n实现上，可以先把一号圆平移到远点\n\n然后对于其他的圆，按照角度范围是否在切线内部可以分类讨论\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,const T &b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,const T &b){ ((a<b)&&(a=b)); }\n\nconst int N=110;\nconst db eps=1e-10,Pi=acos(-1),D=2*Pi;\n\nint n;\nstruct Cir{\n    int x,y,r;\n}A[N];\n\ndb X[N],Y[N],H[N];\nint C,S[N];\ndb Norm(db x){ return x<0?x+D:x; }\nint I(db x){ return lower_bound(H+1,H+C+1,x)-H; }\n\nint Check(db L){\n    memset(S,0,sizeof S);\n    H[1]=0,H[C=2]=D;\n    rep(i,1,n) {\n        db dis=A[i].x*A[i].x+A[i].y*A[i].y;\n        db t=sqrt(dis-A[0].r*A[0].r)-A[i].r;\n        //t为走过切线的距离\n        dis=sqrt(dis);\n        if(dis-A[0].r-A[i].r>=L){ X[i]=0,Y[i]=D; continue; }\n        db l,r;\n        if(t>=L) {\n            // 说明范围在切线位置以内\n            // 此时，满足d=dis((x0,y0),A[i].O)-A[i].r>=L\n            db a=dis,b=A[0].r,c=L+A[i].r;\n            db co=(a*a+b*b-c*c)/(2*a*b);\n            //余弦定理\n            db x=acos(co),y=atan2(A[i].y,A[i].x);\n            l=y+x,r=y-x+D;\n        } else {\n            db d=acos(A[0].r/dis);\n            db x=atan2(A[i].y,A[i].x);\n            db y=(L-t)/A[0].r+d;\n            // 圆弧长度/半径得到圆弧弧度\n            if(y>Pi) return 0; // 特判一下全部覆盖的情况\n            l=x+y,r=x-y+D;\n        }\n        // 求 [l,r] 的交\n        if(r>D) l-=D,r-=D;\n        if(r<=0) l+=D,r+=D;\n        H[++C]=Norm(X[i]=l),H[++C]=Y[i]=r;\n    }\n\n    sort(H+1,H+C+1);\n    rep(i,1,n) {\n        if(X[i]>=0) S[I(X[i])]++,S[I(Y[i])]--;\n        else S[I(0)]++,S[I(Y[i])]--,S[I(X[i]+D)]++,S[I(D)]--;\n    }\n    // 暴力求交\n    rep(i,1,C) if((S[i]+=S[i-1])==n) return 1;\n    return 0;\n}\n\nclass CircusTents {\n    public:\n        double findMaximumDistance(vector <int> _x, vector <int> _y, vector <int> _r) {\n            n=_x.size()-1;\n            rep(i,0,n) A[i]=(Cir){_x[i]-_x[0],_y[i]-_y[0],_r[i]};\n\n            db l=0,r=1e5;\n            while(r-l>eps) {\n                db mid=(l+r)/2;\n                if(Check(mid)) l=mid;\n                else r=mid;\n            }\n            return l;\n        }\n};\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[USACO 2020 February Platinum]Help Yourself","url":"/2021/05/21/[USACO 2020 February Platinum]Help Yourself/","content":"# [USACO 2020 February Platinum]Help Yourself\n\n真的很套路。。。\n\n考虑将区间$(L_i,R_i)$按照左端点排序，依次考虑每个区间的贡献\n\n\n\n令$dp_i$表示当前所有选择的右端点中最大的为$i$时的方案数\n\n加入区间$(L,R)$时\n\n1.所有$i<L$的部分一定会断开成两个区间，转移时个数+1\n\n2.当$i\\ge L$时，$dp_i$向$dp_{\\max\\lbrace R,i\\rbrace}$转移，分两类讨论即可\n\n不考虑个数的问题，直接转移是$O(n^2)$的，但是可以用线段树优化到$n\\log n$\n\n(比较麻烦，需要实现区间查询，单点修改，区间乘法)\n\n考虑个数$k$次幂，一种暴力的办法是存下$dp_{i,j}$，但是转移会变成$O(n^2\\log n)$\n\n对于当前个数为$c$的情况，如果新增一个联通块，即变为$c+1$，答案由$c^k$ 变为$(c+1)^k$\n\n考虑直接用二项式定理展开这个式子，需要记录$c^i(i\\in [0,k])$的所有答案，再$O(k^2)$完成+1操作\n\n结合线段树，维护$nk$个值，复杂度为$O(n(k\\log n +k^2))$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair <int,int> Pii;\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=2e5+10,P=1e9+7;\n\nint n,k;\nPii A[N];\nint C[11][11];\nint s[N<<2][11],res[11];\nint t[N<<2];\nvoid Up(int p) {\n\trep(i,0,k) s[p][i]=s[p<<1][i]+s[p<<1|1][i],Mod1(s[p][i]);\n}\nvoid Down(int p) {\n\tif(t[p]==1) return;\n\tt[p<<1]=1ll*t[p<<1]*t[p]%P;\n\tt[p<<1|1]=1ll*t[p<<1|1]*t[p]%P;\n\trep(i,0,k) {\n\t\ts[p<<1][i]=1ll*s[p<<1][i]*t[p]%P;\n\t\ts[p<<1|1][i]=1ll*s[p<<1|1][i]*t[p]%P;\n\t}\n\tt[p]=1;\n}\n\nvoid Que(int p,int l,int r,int ql,int qr) {\n\tif(ql<=l && r<=qr) {\n\t\trep(i,0,k) res[i]+=s[p][i],Mod1(res[i]);\n\t\treturn;\n\t}\n\tDown(p);\n\tint mid=(l+r)>>1;\n\tif(ql<=mid) Que(p<<1,l,mid,ql,qr);\n\tif(qr>mid) Que(p<<1|1,mid+1,r,ql,qr);\n}\n\nvoid Upd(int p,int l,int r,int ql,int qr) {\n\tif(ql<=l && r<=qr) {\n\t\trep(i,0,k) s[p][i]*=2,Mod1(s[p][i]);\n\t\tt[p]*=2,Mod1(t[p]);\n\t\treturn;\n\t}\n\tDown(p);\n\tint mid=(l+r)>>1;\n\tif(ql<=mid) Upd(p<<1,l,mid,ql,qr);\n\tif(qr>mid) Upd(p<<1|1,mid+1,r,ql,qr);\n\tUp(p);\n}\nvoid Upd(int p,int l,int r,int x){\n\tif(l==r){\n\t\trep(i,0,k) s[p][i]+=res[i],Mod1(s[p][i]);\n\t\treturn;\n\t}\n\tDown(p);\n\tint mid=(l+r)>>1;\n\tx<=mid?Upd(p<<1,l,mid,x):Upd(p<<1|1,mid+1,r,x);\n\tUp(p);\n}\n\n\nint main(){\n\tn=rd(),k=rd();\n\trep(i,1,n) A[i].first=rd(),A[i].second=rd();\n\tsort(A+1,A+n+1);\n\trep(i,1,N*4-1) t[i]=1;\n\trep(i,0,k) rep(j,C[i][0]=1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P;\n\t\n\tres[0]=1;\n\tUpd(1,0,n*2,0);\n\n\trep(t,1,n) {\n\t\tint l=A[t].first,r=A[t].second;\n\t\tUpd(1,0,n*2,r,n*2);\n\t\t\n\t\tmemset(res,0,sizeof res);\n\t\tQue(1,0,n*2,0,l-1);\n\t\tdrep(i,k,0) rep(j,0,i-1) res[i]=(res[i]+1ll*C[i][j]*res[j])%P;\n\t\tUpd(1,0,n*2,r);\n\n\t\tmemset(res,0,sizeof res);\n\t\tQue(1,0,n*2,l,r-1);\n\t\tUpd(1,0,n*2,r);\n\t\t\n\t}\n\tprintf(\"%d\\n\",s[1][k]);\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[WC2020] 选课 (枚举+Dp)","url":"/2021/05/21/[WC2020] 选课 (枚举+dp)/","content":"# [WC2020] 选课 (枚举+dp)\n\n题面数据范围锅了导致枚举炸裂，写了正解却只有50分。。。。。。。\n\n[正确题面可以查看LOJ](https://loj.ac/problem/3331)\n\n记限制涉及到的不同的点个数为$P$\n\n首先是不同的会被限制的个数$\\leq 12$，所以应该直接枚举这些点的状态，枚举部分的复杂度是$O(2^P)$\n\n~~(然后我枚举了$p$，实际$p\\leq 66$啊啊啊啊啊啊)~~\n\n对于没有被限制的点，可以优先预处理出每个类型的答案，注意到$L=T-\\sum s_i\\leq 40$，则可以每次只取出长度为$O(L)$ 的这一部分，类型之间合并为$O(ML^2)$的复杂度\n\n或许比较难的点是在于每种类型内的合并，注意到$w\\in\\{1,2,3\\}$\n\n把每种$w$排序后，令$dp_i$为总权值为$i$的最小花费，同时记录最小花费时选取的三种$w$的个数，最优决策肯定是取最小的几个\n\n每次转移，可以直接枚举选取的$w$，在排序好的数组上找到下一个最小花费\n\nps:事实证明，这个做法显然是假的，但是为什么就是没卡掉呢？正确的做法是先dp，w=1或2，再和3的暴力合并求出最大的$L$个值，这样的复杂度为$O(NL)$\n\nps2:后来测试，这个错误做法在值域只有200的情况下，随机情况下，整个值域中的错误率只有1/100~1/1000左右，而答案需要用到的部分又奇少，只有L个，于是乎，~~嘿嘿嘿嘿~~\n\n如果用这种邪教写法，预处理的转移复杂度就是$O(N)$的\n\n每次枚举之后，把被改变的几个类型答案重新计算，重新合并，这一部分复杂度就是$O(PL^2)$的\n\n算上$2^P$次枚举，得到总复杂度是$O(N+2^PPL^2)$\n\n[Code](https://loj.ac/submission/897600)","tags":["default tag"],"categories":["default category"]},{"title":"[WC2019]数树(树形dp+多项式exp)","url":"/2021/05/21/[WC2019]数树(树形dp+多项式exp)/","content":"# [WC2019]数树(树形dp+多项式exp)\n\n## Part1\n\n相同边连接的点同一颜色，直接模拟即可\n\n```cpp\nnamespace pt1{\n\tint fa[N],sz[N];\n\tmap <int,int> M[N];\n\tint Find(int x){ return fa[x]==x?x:fa[x]=Find(fa[x]); }\n\tvoid Solve(){\n\t\trep(i,1,n) fa[i]=i;\n\t\trep(i,2,n){\n\t\t\tint x=rd(),y=rd();\n\t\t\tif(x>y) swap(x,y);\n\t\t\tM[x][y]=1;\n\t\t}\n\t\trep(i,2,n) {\n\t\t\tint x=rd(),y=rd();\n\t\t\tif(x>y) swap(x,y);\n\t\t\tif(M[x][y]) fa[Find(x)]=Find(y);\n\t\t}\n\t\tint ans=1;\n\t\trep(i,1,n) if(Find(i)==i) ans=1ll*ans*y%P;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\n```\n\n\n\n## Part2\n\n相同边连接的点同一颜色，即在相同边构成的树上形成了若干联通块\n\n很容易想到可以强制一些边保留，设保留$i$条边的方案数是$F_i$,则答案就是$\\sum_i F_i\\cdot y^{n-i}$\n\n考虑$dp$那些边相同，但是不好直接计算剩下边不同的方案，所以考虑计算最多有$i$条边相同的方案数，即\n\n$$G_i=\\sum_{j=i}C(j,i)F_j$$\n\n二项式反演得到$F_i=\\sum_{j=i}(-1)^{j-i}C(j,i)G_j$\n\n> 设分成了$m$个联通块，大小分别为$size_i$，则这些联通块随意构成树的方案数就是$n^{m-2}\\cdot\\prod size_i$\n\n根据上述性质可以写出一个简单的$O(n^4)$树形dp求得$G_i$，即$dp[i][j][k]$表示在$i$的子树里，有$j$条边相同，当前还剩下一个大小为$k$的联通块,每多转移一条相同边，系数是$\\frac{1}{ny}$\n\n考虑优化$dp$\n\n1.\n\n联通块大小的问题，可以转化为每次在联通块里选择一个关键点的方案数，$dp$第三维$0/1$表示当前联通块里是否已经选出了关键点\n\n每次断开一个联通块时必须已经存在关键点\n\n2.\n\n答案是\n\n$\\sum_i F_i\\cdot y^{n-i}$\n\n$=\\sum_i y^{n-i} \\sum_{j=i}(-1)^{j-i}C(j,i)G_j$\n\n$=y^n G_j\\sum_{i=0}^j(-1)^{j-i}C(j,i)y^{-i}$\n\n发现右边的式子$\\sum_0^j(-1)^{j-i}C(j,i)y^{-i}=(\\frac{1}{y}-1)^j$\n\n那么直接把$\\frac{1}{y}-1$带入作为保留一条边的转移系数，消去了第二维\n\n那么这个$\\text{dp}$可以被优化到$O(n)$\n\n$$ \\ $$\n\n```cpp\nnamespace pt2{\n\tvector <int> G[N];\n\tint dp[N][2],g[2],Inv;\n\tvoid dfs(int u,int f){\n\t\tdp[u][0]=dp[u][1]=1;\n\t\tfor(int v:G[u]) if(v!=f) {\n\t\t\tdfs(v,u);\n\t\t\tg[0]=g[1]=0;\n\t\t\trep(i,0,1) rep(j,0,1) {\n\t\t\t\tif(!i||!j) g[i|j]=(g[i|j]+1ll*dp[u][i]*dp[v][j]%P*Inv)%P;\n\t\t\t\tif(j) g[i]=(g[i]+1ll*dp[u][i]*dp[v][j])%P;\n\t\t\t}\n\t\t\tdp[u][0]=g[0],dp[u][1]=g[1];\n\t\t}\n\t}\n\tvoid Solve() {\n\t\trep(i,2,n) {\n\t\t\tint u=rd(),v=rd();\n\t\t\tG[u].pb(v),G[v].pb(u);\n\t\t}\n\t\tInv=(qpow(y)-1)*qpow(n)%P;\n\t\tdfs(1,0);\n\t\tll res=dp[1][1]*qpow(y,n)%P*qpow(n,P+n-3)%P;\n\t\tprintf(\"%lld\\n\",res);\n\t}\n}\n```\n\n\n\n\n\n## Part3\n\n有了上面的$dp$，这一部分就简单多了，设分成了$m$个联通块，每个大小为$a_i$，则贡献为\n\n$$\\begin{aligned}\\frac{n!\\cdot a_i^{a_i-2}\\cdot (n^{m-2})^2(\\frac{1}{y}-1)^{n-m}(\\frac{1}{n}^{n-m})^2\\cdot a_i^2}{\\prod a_i! m !}\\end{aligned}$$\n\n即枚举每个联通块生成树的数量，且需要考虑两棵树分别的**联通块之间的连边数量**，这一部分需要**平方**\n\n很显然，可以直接对于$[x^i]F(x)=\\frac{1}{i!}\\cdot (\\frac{1}{n^2}\\cdot (\\frac{1}{y}-1))^{i-1} i^2i^{i-2}$这个多项式求exp得到\n\n\n\n```cpp\nconst int M=1<<18|10,K=17;\n\ttypedef vector <int> Poly;\n\n\tint w[M],rev[M],Inv[M];\n\tvoid Init(){\n\t\tll t=qpow(3,(P-1)>>K>>1);\n\t\tw[1<<K]=1;\n\t\trep(i,(1<<K)+1,(1<<(K+1))-1) w[i]=w[i-1]*t%P;\n\t\tdrep(i,(1<<K)-1,1) w[i]=w[i<<1];\n\t\tInv[0]=Inv[1]=1;\n\t\trep(i,2,M-1) Inv[i]=1ll*(P-P/i)*Inv[P%i]%P;\n\t}\n\tint Init(int n){\n\t\tint R=1,cc=-1;\n\t\twhile(R<n) R<<=1,cc++;\n\t\trep(i,1,R-1) rev[i]=(rev[i>>1]>>1)|((i&1)<<cc);\n\t\treturn R;\n\t}\n\t\n\tvoid NTT(int n,Poly &a,int f){\n\t\tif((int)a.size()<n) a.resize(n);\n\t\trep(i,1,n-1) if(rev[i]<i) swap(a[i],a[rev[i]]);\n\t\tfor(int i=1;i<n;i<<=1) {\n\t\t\tint *e=w+i;\n\t\t\tfor(int l=0;l<n;l+=i*2){\n\t\t\t\tfor(int j=l;j<l+i;++j){\n\t\t\t\t\tint t=1ll*a[j+i]*e[j-l]%P;\n\t\t\t\t\ta[j+i]=a[j]-t,Mod2(a[j+i]);\n\t\t\t\t\ta[j]+=t,Mod1(a[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f==-1) {\n\t\t\treverse(a.begin()+1,a.end());\n\t\t\trep(i,0,n-1) a[i]=1ll*a[i]*Inv[n]%P;\n\t\t}\n\t}\n\n\tPoly operator * (Poly a,Poly b){\n\t\tint n=a.size(),m=b.size();\n\t\tint R=Init(n+m-1);\n\t\tNTT(R,a,1),NTT(R,b,1);\n\t\trep(i,0,R-1) a[i]=1ll*a[i]*b[i]%P;\n\t\tNTT(R,a,-1),a.resize(n+m-1);\n\t\treturn a;\n\t}\n\n\tPoly Poly_Inv(Poly a){\n\t\tint n=a.size();\n\t\tif(n==1) return {(int)qpow(a[0])};\n\t\tPoly b=a; b.resize((n+1)/2),b=Poly_Inv(b);\n\t\tint R=Init(n*2);\n\t\tNTT(R,a,1),NTT(R,b,1);\n\t\trep(i,0,R-1) a[i]=1ll*b[i]*(2-1ll*a[i]*b[i]%P+P)%P;\n\t\tNTT(R,a,-1); a.resize(n);\n\t\treturn a;\n\t}\n\n\tPoly Deri(Poly a){\n\t\trep(i,1,a.size()-1) a[i-1]=1ll*i*a[i]%P;\n\t\ta.pop_back();\n\t\treturn a;\n\t}\n\tPoly IDeri(Poly a){\n\t\ta.pb(0);\n\t\tdrep(i,a.size()-2,0) a[i+1]=1ll*a[i]*Inv[i+1]%P;\n\t\ta[0]=0;\n\t\treturn a;\n\t}\n\n\tPoly Ln(Poly a){\n\t\tint n=a.size();\n\t\ta=Deri(a)*Poly_Inv(a),a.resize(n+1);\n\t\treturn IDeri(a);\n\t}\n\n\tPoly Exp(Poly a){\n\t\tint n=a.size();\n\t\tif(n==1) return Poly{1};\n\t\tPoly b=a; b.resize((n+1)/2),b=Exp(b);\n\t\tb.resize(n); Poly c=Ln(b);\n\t\trep(i,0,n-1) c[i]=a[i]-c[i],Mod2(c[i]);\n\t\tc[0]++,c=c*b;\n\t\tc.resize(n);\n\t\treturn c;\n\t}\n\t\n\tvoid Solve() {\n\t\tint I=(qpow(y)-1)*qpow(1ll*n*n%P)%P;\n\t\tInit();\n\t\tPoly F(n+1);\n\t\tfor(int i=1,FInv=1;i<=n;FInv=1ll*FInv*Inv[++i]%P){\n\t\t\tF[i]=qpow(I,(i-1)) * // 保留i-1条边\n\t\t\t(i==1?1:qpow(i,i-2))%P   // i个点生成树\n\t\t\t*  i%P * i%P // \n\t\t\t* FInv%P; // 阶乘常数\n\t\t}\n\t\tF=Exp(F);\n\t\trep(i,1,n) F[n]=1ll*F[n]*i%P;\n\t\tll res=F[n]*qpow(y,n)%P*qpow(n,2*(P+n-3))%P;\n\t\tprintf(\"%lld\\n\",res);\n\t}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[[HDU-6791] 2020HDU多校第三场T1](回文自动机)","url":"/2021/05/21/[[HDU-6791] 2020HDU多校第三场T1](回文自动机)/","content":"#[[HDU-6791] 2020HDU多校第三场T1](http://acm.hdu.edu.cn/showproblem.php?pid=6791)(回文自动机)\n\n### 前置知识：\n\n1.[字符串的$\\text{Border}$](https://www.cnblogs.com/chasedeath/p/13396877.html)\n\n2.[回文自动机](https://www.cnblogs.com/chasedeath/p/13396957.html)\n\n3.回文串与$\\text{Border}$\n\n3.1:回文串的$\\text{Border}$也是回文串\n\n若有回文串$S$的一个$\\text{Border} :T$，则$S_{1,|T|}=S_{|S|-|T|+1,|S|}=reverse(S_{1,|T|})$\n\n故$T$也是一个回文串\n\n3.2:遍历回文自动机的$fail$链，能得到当前串的所有$\\text{Border}$(基于3.1得到)\n\n\n\n约定:串$S$的$\\text{Border}$集合为$B(S)$，字符集为$\\Sigma$\n\n### 题意:\n\n设随机空串末尾添加$\\Sigma$中的字符，第一次出现子串$S$的期望长度为$E(S)$\n\n给定一个串，每次查询它的两个回文子串$A,B$，比较$E(A),E(B)$\n\n### 起源？\n\n一切的起源都是\" 国家集训队论文2018 :1-浅谈生成函数在掷骰子问题上的应用 \"的一个结论。。。\n\n还有为什么会是回文子串呢？因为只有回文自动机能访问子串的所有$\\text{Border}$。。。\n\n### 结论 以及 口胡证明?\n\n$\\begin{aligned}E(S)=\\sum_{T\\in B(S)}|\\Sigma|^{|T|}\\end{aligned}$~~(???)~~\n\n在原论文给出了生成函数性的证明，实际可以直接口胡(好吧也差不多)，大致分成两个步骤\n\n1.$E(S)=\\sum_{i=0}^{\\infty}$长度为$i$依然不包含$S$的概率(即把长度为$i$时恰好合法转化为了$0..i-1$时不合法)\n\n2.设所有长度下不合法的串集合为$G$(每个不合法串有概率$G(T)$)，合法的串集合为$F$(每个合法串也有概率$F(T)$)\n\n由第一步$E(S)=\\sum G(T)$，合法串的概率不会重复，所以$\\sum F(T)=1$\n\n考虑$G$中所有的串，如果在后面接上$S$必然合法，但是可能在更早的时候就结束了，这是必然满足接上的前缀是$\\text{Border}$\n\n也就是说，在$G$集合后面接上$S$后，不仅会得到$F$集合，还会得到$F$集合后面额外接上$|S|-|R|,(R\\in B(S))$长度字符的状态\n\n所以有$\\sum G(T)\\cdot (\\frac{1}{|\\Sigma|})^{|S|}=\\sum_{R\\in B(S)}\\sum F(T)\\cdot (\\frac{1}{|\\Sigma|})^{|S|-|R|}$\n\n化简且带入$\\sum F(T)=1$，得到$E(S)=\\sum G(T)=\\begin{aligned}\\sum_{R\\in B(S)}|\\Sigma|^{|R|}\\end{aligned}$\n\n那么比较问题就落到了比较$\\text{Border}$上面\n\n视答案为为一个$26$进制数从高位到低位比较，转化为直接从大到小比较$\\text{Border}$序列的字典序即可\n\n建出回文自动机后，倍增找到当前查询串对应的状态，所有的$\\text{Border}$就是$fail$链上所有非空状态长度\n\n比较字典序可以\n\n1.倍增+hash\n\n2.可以根据$\\text{Border}$的性质分解为等差数列后暴力比较\n\n3.像后缀数组一样，倍增地去为所有节点的字典序排序，这样查询是$O(1)$的\n\nhash应该细节比较少，但是常数大\n\n以下是hash版本\n\n````cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0;int f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=1e5+10;\nconst ll P1=1e9+13,P2=19260817;\nconst ll K1=123213,K2=342525;\n\nint n;\nchar s[N];\nint now,len[N],fail[N],nxt[N][26],pos[N],cnt;\nint Pow1[N],Pow2[N];\nint fa[N][18],h1[N][18],h2[N][18];\n\nvoid Init(){\n\trep(i,0,cnt) memset(nxt[i],fail[i]=0,104);\n\tlen[1]=-1;\n\tfail[now=0]=fail[1]=cnt=1;\n}\nint Find(int x,int y){\n\twhile(s[y]!=s[y-len[x]-1]) x=fail[x];\n\treturn x;\n}\nvoid Extend(int i,int c){\n\tnow=Find(now,i);\n\tif(!nxt[now][c]){\n\t\tfail[++cnt]=nxt[Find(fail[now],i)][c];\n\t\tlen[nxt[now][c]=cnt]=len[now]+2;\n\t}\n\tpos[i]=now=nxt[now][c];\n}\nint Que(int l,int p){\n\tl=p-l+1,p=pos[p];\n\tdrep(i,17,0) if(len[fa[p][i]]>=l) p=fa[p][i];\n\treturn p;\n}\n\nint main(){\n\trep(i,Pow1[0]=Pow2[0]=1,N-1) Pow1[i]=1ll*Pow1[i-1]*K1%P1,Pow2[i]=Pow2[i-1]*K2%P2;\n\trep(kase,1,rd()){\n\t\tInit(),n=rd(),scanf(\"%s\",s+1);\n\t\trep(i,1,n) Extend(i,s[i]-'a');\n\t\trep(i,2,cnt) {\n\t\t\tfa[i][0]=fail[i],h1[i][0]=h2[i][0]=len[i];\n\t\t\trep(j,1,17){\n\t\t\t\tfa[i][j]=fa[fa[i][j-1]][j-1];\n\t\t\t\tif(fa[i][j]>1){\n\t\t\t\t\th1[i][j]=(1ll*h1[i][j-1]*Pow1[1<<(j-1)]+h1[fa[i][j-1]][j-1])%P1;\n\t\t\t\t\th2[i][j]=(1ll*h2[i][j-1]*Pow2[1<<(j-1)]+h2[fa[i][j-1]][j-1])%P2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(q,1,rd()) {\n\t\t\tint A=rd(),B=rd(),C=rd(),D=rd();\n\t\t\tA=Que(A,B),C=Que(C,D);\n\t\t\tdrep(i,17,0) if(fa[A][i]>1 && fa[C][i]>1 && h1[A][i]==h1[C][i] && h2[A][i]==h2[C][i]) A=fa[A][i],C=fa[C][i];\n\t\t\tA=max(len[A],0),C=max(len[C],0);\n\t\t\tif(A==C) puts(\"draw\");\n\t\t\telse if(A<C) puts(\"sjfnb\");\n\t\t\telse puts(\"cslnb\");\n\t\t}\n\t}\n}\n\n\n````\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[「BalticOI 2020」村庄 (贪心)]","url":"/2021/05/21/[「BalticOI 2020」村庄 (贪心)]/","content":"# [「BalticOI 2020」村庄 (贪心)](https://loj.ac/p/3336)\n\n## Subtask1: Min\n\n考虑链上的情况，最优解肯定是两两相邻的交换，如果还有多，就再多交换一次\n\n因此树上的也是类似，实际上就是求解一个最小边覆盖问题，选择一条边就是交换边两端的点编号\n\n可以$O(n)$贪心/dp求解树上最小边覆盖\n\n$$ \\ $$\n\n## Subtask2: Max\n\n考虑理想的最优情况：对于任意一条边，我们要求它被经过次数尽可能多\n\n如果这条边两端子树大小分别为$a,b$，则它被经过的最多次数显然是$2\\min\\{a,b\\}$\n\n考虑找到树的重心，以它为根，此时任意一颗真子树的大小$\\leq \\frac{n}{2}$\n\n为了构造最优答案，只需要每棵子树的集合相互错开即可\n\n一种简单的构造方法是：取$\\text{dfs}$序，平移$\\frac{n}{2}$即可得到解\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\nchar IO;\nint rd(){\n\tint s=0;\n\twhile(!isdigit(IO=getchar()));\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn s;\n}\n\nconst int N=1e5+10,INF=1e9+10;\n\nint n;\nvector <int> G[N];\nll Min,Max;\nint ans1[N],ans2[N];\nint dep[N],fa[N],vis[N];\n// 最小边覆盖贪心法\nvoid pre_dfs(int u,int f){ \n\tans1[u]=u,fa[u]=f;\n\tfor(int v:G[u]) if(v!=f) {\n\t\tpre_dfs(v,u); \n\t\tif(!vis[v]) vis[v]=vis[u]=1,swap(ans1[u],ans1[v]),Min+=2;\n\t}\n\tif(!vis[u] && !f) vis[u]=1,swap(ans1[u],ans1[G[u][0]]),Min+=2;\n}\n\nint A[N],C;\nint mi=1e9,rt,sz[N];\n// 找重心\nvoid dfs(int u,int f){\n\tsz[u]=1;\n\tint ma=0;\n\tfor(int v:G[u]) if(v!=f) {\n\t\tdfs(v,u);\n\t\tcmax(ma,sz[v]),sz[u]+=sz[v];\n\t\tMax+=2*min(n-sz[v],sz[v]);\n\t}\n\tcmax(ma,n-sz[u]);\n\tif(mi>ma) mi=ma,rt=u;\n}\n// 遍历dfs序\nvoid dfs_get(int u,int f) {\n\tA[++C]=u;\n\tfor(int v:G[u]) if(v!=f) dfs_get(v,u);\n}\nint main(){\n\tn=rd();\n\trep(i,2,n) {\n\t\tint u=rd(),v=rd();\n\t\tG[u].pb(v),G[v].pb(u);\n\t}\n\tpre_dfs(1,0),dfs(1,0),dfs_get(rt,0);\n\trep(i,1,n) ans2[A[i]]=A[(i+n/2-1)%n+1];\n\tprintf(\"%lld %lld\\n\",Min,Max);\n\trep(i,1,n) printf(\"%d \",ans1[i]);\n\tputs(\"\");\n\trep(i,1,n) printf(\"%d \",ans2[i]);\n\tputs(\"\");\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[学军20201104CSP模拟赛] 二维码              ","url":"/2021/05/21/[学军20201104CSP模拟赛] 二维码              /","content":"# [学军20201104CSP模拟赛] 二维码              \n\n简要题意：\n\n对于$n\\times m$的网格图，初始时全部为白色，现在 通过下面的方法染色\n\n每次选择一个行或者列，把它全部染成黑色或者全部染成白色\n\n求任意操作的情况下，可以得到的不同网格图的数量$\\mod 998244353$\n\n$$ \\ $$\n\n\n\n判定一个染色方案是否有解的条件是：\n\n染色完成的矩阵不包含一个子矩阵满足四个角分别为\n\n01\n\n10\n\n或者\n\n10\n\n01\n\n但是这样看这个条件似乎比较抽象，如果具体对于一个行上考虑，就是满足\n\n每一行**所包含的1的位置**的集合之间  **互为子集**\n\n显然一个方案可以任意交换行/列，不妨把按照每一行1的个数将每一行排序，设每一行有$a_i$个1，边界条件为$a_0=0$\n\n那么对于行上的1考虑排列，方案数为$\\begin{aligned} \\prod \\binom{m-a_{i-1}}{a_i-a_{i-1}}\\end{aligned}$，即从空的$m-a_{i-1}$个位置里选出多出的$a_i-a_{i-1}$个位置\n\n而对于列之间的排列需要考虑$a_i$与$a_{i+1}$的关系，因为如果$a_i=a_{i+1}$时，必然满足这两行相同\n\n设所有的$a_i$构成若干个相同的组，每一组包含$b_i(i\\in[1,k])$个元素，则方案数显然为$\\begin{aligned} \\frac{n!}{\\prod b_i!}\\end{aligned}$\n\n而组内的$a_i$之间显然是没有$\\begin{aligned} \\sum \\binom{m-a_{i-1}}{a_i-a_{i-1}}\\end{aligned}$的贡献的，可以跳过\n\n由此，不妨令$dp_{i,j}$表示$dp$了前$i$行，最后一行$a_i=j$，每次枚举每个组$b_i$转移\n\n复杂度为$O(n^4)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\nconst int N=2010,P=998244353;\nint n,m,C[N][N],dp[N][N],I[N],J[N];\nll qpow(ll x,ll k=P-2) {\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\nint main(){\n\trep(i,J[0]=1,N-1) J[i]=1ll*J[i-1]*i%P;\n\tI[N-1]=qpow(J[N-1]);\n\tdrep(i,N-2,0) I[i]=1ll*I[i+1]*(i+1)%P;\n\trep(i,0,N-1) rep(j,C[i][0]=1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%P;\n\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,n) dp[i][0]=I[i]; // 第一个块\n\trep(i,1,n) rep(j,1,m) {\n\t\trep(a,0,i-1) rep(b,0,j-1) {\n\t\t\tdp[i][j]=(dp[i][j]+1ll*dp[a][b]*I[i-a]%P*C[m-b][j-b])%P;\n\t\t}\n\t}\n\tint ans=0;\n\trep(i,0,m) ans=(ans+dp[n][i])%P;\n\tans=1ll*ans*J[n]%P;\n\tprintf(\"%d\\n\",ans);\n}\n```\n\n\n\n优化：\n\n发现两维$dp$之间是相互独立的，分别是把$n,m$分组\n\n令$F_{i,j}$表示把$n$分成了$i$个组，当前总和为$j$的方案数，$G_{i,j}$表示把$m$分成$i$组，当前总和为$j$\n\n 按照上面的系数转移，最后$O(n)$合并，复杂度为$O(n^3)$\n\n$$ \\ $$\n\n进一步优化：\n\n为了方便下面的叙述，不妨先整理一下$a_i$之间转移的系数，不妨设边界$a_{n+1}=m$\n\n$\\begin{aligned} \\prod \\binom{m-a_{i-1}}{a_i-a_{i-1}}=\\prod_{i=1}^n \\frac{(m-a_{i-1})!}{(a_i-a_{i-1})!(m-a_{i})!}= \\frac{m!}{\\prod_{i=1}^{n+1} (a_{i}-a_{i-1})!}\\end{aligned}$ \n\n发现实际上和列之间的系数是类似的，每次枚举$a_i-a_{i-1}$即可\n\n而实际上只有$k$个$b_i$直接相交的位置$a_{i}-a_{i-1}$有效，因此行和列实际上分别是将$n,m$分成了$k$组\n\n观察上面的转移系数，行构成的块，首个块大小可以为$0$，而列构成的块最后一个块大小可以为$0$，所以这个并不是严格分成$k$组，下面会讨论这个问题\n\n我们计算答案的复杂度消耗在计算分成若干块的方案，而实际上，把$n$分成$k$块的方案数就是$\\begin{Bmatrix} n\\\\ k\\end{Bmatrix}\\cdot k!$\n\n用$n^2$递推第二类斯特林数的方法即可计算\n\n对于并不是严格分成$k$组的问题，可以考虑把开头/结尾那一个大小为$0$的块删掉，即同时还要考虑$\\begin{Bmatrix}n \\\\ k-1\\end{Bmatrix}(k-1)!$\n\n最后再枚举$k$，复杂度为$O(n^2)$\n\n更优化的就是$\\text{NTT}$计算斯特林数，带入通项公式\n\n$\\begin{aligned} \\begin{Bmatrix}n\\\\ m\\end{Bmatrix}m!=\\sum_{i=0}^m i^n(-1)^{m-i}\\binom{m}{i} \\end{aligned}$\n\n显然把组合数拆开$\\text{NTT}$即可\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\nconst int N=1<<18|10,P=998244353;\n\nint n,m,ans;\nll qpow(ll x,ll k=P-2) {\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\n\nint I[N],J[N];\n\nint rev[N];\nint Init(int n){ \n\tint R=2,c=0;\n\twhile(R<=n) R<<=1,c++;\n\trep(i,0,R-1) rev[i]=(rev[i>>1]>>1)|((i&1)<<c);\n\treturn R;\n}\n\nvoid NTT(int n,int *a,int f){\n\tstatic int e[N>>1];\n\trep(i,1,n-1) if(i<rev[i]) swap(a[i],a[rev[i]]);\n\tfor(int i=e[0]=1;i<n;i<<=1) {\n\t\tll t=qpow(f==1?3:(P+1)/3,(P-1)/i/2);\n\t\tfor(int j=i-2;j>=0;j-=2) e[j+1]=(e[j]=e[j>>1])*t%P;\n\t\tfor(int l=0;l<n;l+=i*2) {\n\t\t\tfor(int j=l;j<l+i;++j) {\n\t\t\t\tint t=1ll*a[j+i]*e[j-l]%P;\n\t\t\t\ta[j+i]=a[j]-t,Mod2(a[j+i]);\n\t\t\t\ta[j]+=t,Mod1(a[j]);\n\t\t\t}\n\t\t}\n\t}\n\tif(f==-1) {\n\t\tll base=qpow(n);\n\t\trep(i,0,n-1) a[i]=a[i]*base%P;\n\t}\n}\n\nint A[N],B[N],C[N];\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tif(n<m) swap(n,m);\n\trep(i,J[0]=1,N-1) J[i]=1ll*J[i-1]*i%P;\n\tI[N-1]=qpow(J[N-1]);\n\tdrep(i,N-2,0) I[i]=1ll*I[i+1]*(i+1)%P;\n\n\tint R=Init(n+n+2);\n\trep(i,0,n) A[i]=qpow(i,n)*I[i]%P;\n\trep(i,0,n) B[i]=(i&1)?P-I[i]:I[i];\n\tNTT(R,A,1),NTT(R,B,1);\n\trep(i,0,R-1) A[i]=1ll*A[i]*B[i]%P;\n\tNTT(R,A,-1);\n\trep(i,n+1,R) A[i]=0;\n\n\trep(i,0,m) C[i]=qpow(i,m)*I[i]%P;\n\tNTT(R,C,1);\n\trep(i,0,R-1) C[i]=1ll*C[i]*B[i]%P;\n\tNTT(R,C,-1);\n\trep(i,m+1,R) C[i]=0;\n\n\tint ans=0;\n\trep(i,0,min(n,m)) ans=(ans+1ll*(1ll*A[i]*J[i]%P+1ll*A[i+1]*J[i+1]%P)*(1ll*C[i]%P*J[i]%P+1ll*C[i+1]*J[i+1]%P))%P;\n\tprintf(\"%d\\n\",ans);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[补]NOIP2020T4微信步数","url":"/2021/05/21/[补]NOIP2020T4微信步数/","content":"# [补]NOIP2020T4微信步数\n\n题意：一个人在$k$维平面上，每一维范围是$[1,W_i]$上的任意一个位置，初始可以在任何一个位置\n\n这个人在空间上游走，每$n$步为一轮不断重复，每一步是一个方向上走-1或者1，求所有情况下 最后他离开空间范围的时间 之和\n\n分析：\n\n行走是循环的，每一维可以先看做独立，然后离开范围的时间就是每一维取$\\min$\n\n### 一个简单的思路：\n\n求出每一维每一个位置离开的时间，然后$k$路归并得到答案，复杂度为$O((\\sum W_i)k+nk)$\n\n容易想到根据循环来优化计算，但是如果以每一个位置为元素进行考虑，难以处理不同长度循环之间的合并\n\n$$ \\ $$\n\n### 更换思路：\n\n简单的计数方法的转换：\n\n从初始位置离开的时间之和 = 前$i(i\\ge 0)$步还未离开空间的初始位置个数之和\n\n令$F_{i,j}$为$i$这一维$j$步还未离开的初始位置个数，则答案就是 $\\begin{aligned} \\sum_{i\\ge 0}\\prod F_{i,j}\\end{aligned}$\n\n此时观察发现除了第一轮需要特殊考虑以外，其它的$F_{i,j}$可以表示为$\\max\\lbrace0,F_{i,j-n}-D_i\\rbrace$(其中$D_i$为每一轮$i$这一维偏移的量)\n\n对于前面$n$(好像是$2n$)个特殊考虑，后面对于每一个不同的$i\\mod n$可以放在一起考虑，用一个统一的式子表示\n\n然后计算就是类似$\\begin{aligned} \\sum_{i\\ge 0}\\prod (G_j-i D_j)\\end{aligned}$，以$i$为元，所求的就是是一个$k$次多项式前缀和，也就是一个$k+1$次多项式的点值\n\n暴力的方法就是 求出前面$k+2$项的值，然后用 拉格朗日插值/高斯消元 得到答案，复杂度为$O(nk^2-nk^3)$(如果插值写好一点，复杂度主要受限于求值)\n\n~~然后甚至可以无脑吸多项式做到$O(nk\\log ^2k)$~~\n\n求值时可以发现 对于$i$所求的$j$处点值的积式里面 最多只有一项和$i-1$不同，因而可以特殊考虑以优化求值复杂度\n\n下面是$nk^2$，由于求值已经是$k^2$了，所以插值也没优化\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\nchar IO;\nint rd(){\n\tint s=0,f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=5e5+10,P=1e9+7;\nll qpow(ll x,ll k=P-2) {\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\nint n,m,W[12],F[12][N*2];\nint A[N],B[N],D[N];\nint ans;\nll X[20],Y[20],I[20];\nint Lag(int n,int x){\n\tll res=0;\n\trep(i,0,n) {\n\t\tll a=1,b=1;\n\t\trep(j,0,n) if(i!=j) a=a*(P+x-X[j])%P,b=b*(X[i]<X[j]?-I[X[j]-X[i]]:I[X[i]-X[j]])%P;\n\t\tres=(res+a*b%P*Y[i])%P;\n\t}\n\treturn res;\n}\nint main() {\n\tI[0]=I[1]=1;\n\trep(i,2,19) I[i]=P-P/i*I[P%i]%P;\n\tn=rd(),m=rd();\n\trep(i,1,m) W[i]=rd();\n\trep(i,1,n) A[i]=rd(),B[i]=rd();\n\tint f=0;\n\trep(i,1,m) {\n\t\tint c=F[i][0]=W[i],now=0,l=0,r=0;\n\t\trep(j,1,n*2) {\n\t\t\tif(A[j<=n?j:j-n]==i) now+=B[j<=n?j:j-n];\n\t\t\tif(now<l) l=now,c--;\n\t\t\tif(now>r) r=now,c--;\n\t\t\tc=max(c,0),F[i][j]=c;\n\t\t}\n\t\tD[i]=abs(now)/2;\n\t\tif(now || c==0) f=1;\n\t}\n\tif(!f) return puts(\"-1\"),0;\n\trep(i,0,n){\n\t\tll t=1;\n\t\trep(j,1,m) t=t*F[j][i]%P;\n\t\tans=(ans+t)%P;\n\t}\n\trep(i,n+1,n*2) {\n\t\tint n=1e9,f=1;\n\t\trep(j,1,m) {\n\t\t\tif(D[j]) n=min(n,F[j][i]/D[j]);\n\t\t\tf&=F[j][i]>0;\n\t\t}\n\t\tif(!f) continue;\n\t\tint t=1;\n\t\trep(j,1,m) t=1ll*t*max(0,F[j][i]-D[j]*(n+1))%P;\n\t\tans=(ans+t)%P;\n\t\tint s=0;\n\t\trep(k,0,m+1) {\n\t\t\tint t=1;\n\t\t\trep(j,1,m) t=1ll*t*(F[j][i]-D[j]*k)%P;\n\t\t\tX[k]=k,Y[k]=s=(s+t)%P;\n\t\t}\n\t\tans=(ans+Lag(m+1,n))%P;\n\t}\n\tans=(ans%P+P)%P,printf(\"%d\\n\",ans);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[补]「WC2021」括号路径 ","url":"/2021/05/21/[补]「WC2021」括号路径 /","content":"# [补]「WC2021」括号路径 \n\n注意到到达关系是相互的，因此可以把能够互相到达的点放到同一集合中\n\n因此只需要考虑最简单的到达情况，发现实际上当一个点有两条同色入边时，可以将这两条边对应的点合并\n\n对于每个集合，维护一个颜色出边的集合，可以用$\\text{std::map}$实现，每次合并两个点用并查集处理集合关系\n\n然后用启发式合并的方式维护集合的边，即可做到$O(m\\log^2 m)$\n\n用线段树合并的方式维护同样的东西即可做到$O(m\\log k)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nenum{N=300010};\nint n,m,i,u,v,w,F[N],S[N];\nint Find(int x){ return F[x]==x?x:F[x]=Find(F[x]); }\nmap <int,int> M[N];\nvoid U(int x,int y){\n\tx=Find(x),y=Find(y);\n\tif(x==y) return;\n\tif(M[x].size()>M[y].size()) swap(x,y);\n\tF[x]=y,S[y]+=S[x]; \n\tfor(auto i:M[x]) M[y].emplace(i);\n\tfor(auto i:M[x]) U(M[y][i.first],i.second);\n}\nmain(){\n\tfor(scanf(\"%d%d%*d\",&n,&m),i=1;i<=n;++i) S[F[i]=i]=1;\n\twhile(m--){\n\t\tscanf(\"%d%d%d\",&v,&u,&w),u=Find(u),v=Find(v);\n\t\tif(M[u].count(w)) U(M[u][w],v);\n\t\telse M[u][w]=v;\n\t}\n\tint64_t ans=0;\n\tfor(i=1;i<=n;++i) if(Find(i)==i) ans+=1ll*S[i]*(S[i]-1)/2;\n\tprintf(\"%lld\\n\",ans);\n}\n```\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"[补]联合省选2021 图函数","url":"/2021/05/21/[补]联合省选2021 图函数/","content":"# [补]联合省选2021 图函数\n\n考虑将所有加入$i-m$这些边的答案一起算出来\n\n模拟删去点的过程容易发现，删去$u$时，$u,v$在同一个强连通分量里的点满足：\n\n存在仅包含$\\ge u$的点的路径，使得$u,v$互相连通\n\n设$A_{u,v}$表示最大的$i$使得$u$能仅通过$\\ge u$的点到达$v$\n\n设$B_{u,v}$表示最大的$i$使得$v$能仅通过$\\ge u$的点到达$u$\n\n计算$\\min\\{A_{u,v},B_{u,v}\\}$即可确定一个点对能够贡献到的区间\n\n考虑依次加入每一条边$(u,v)$，在正反图上计算$A,B$中每个元素第一次被确定的时间\n\n以计算$A$为例，每次会被更新的$A_{i,..}$一定满足\n\n$i\\ge \\min\\{u,v\\},i\\rightarrow u,i\\not \\rightarrow v$\n\n可以暴力$\\text{for}$这样的$i$，从$[i,v]$开始，让$v$扩展，每次扩展找到未确定的$[i,w]$\n\n每个元素只会被确定一次，复杂度为$O(n^2)$，暴力枚举起点为$O(nm)$\n\n可以用$\\text{bitset}$优化到$O(\\frac{nm}{64}+n^2)$ (扩展元素的部分复杂度可能是假的，但是没有关系)\n\n[Loj Submission](https://loj.ac/s/1131239)\n\n```cpp\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nusing ull=unsigned long long;\n#define pb push_back\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\nint rd(){\n\tint s=0; static char c;\n\twhile(c=getchar(),c<48);\n\tdo s=(s<<1)+(s<<3)+(c^'0');\n\twhile(c=getchar(),c>47);\n\treturn s;\n}\nenum{N=1010,M=200010};\nint n,m,t;\nint A[N][N],B[N][N],U[M],V[M],ans[M];\nint Log(ull x){ return !x?-1:__builtin_ctzll(x); }\nstruct Bitset{\n\tull a[16];\n\tvoid turn(int x){ a[x>>6]^=1ull<<x; }\n} X[N],Y[N];\nvector <int> G[N],E[N];\nvoid dfs1(int st,int u) {\n\tif(~A[st][u]) return;\n\tA[st][u]=t,X[u].turn(st);\n\tfor(int v:G[u]) if(v>=st) dfs1(st,v);\n}\nvoid dfs2(int st,int u) {\n\tif(~B[st][u]) return;\n\tB[st][u]=t,Y[u].turn(st);\n\tfor(int v:E[u]) if(v>=st) dfs2(st,v);\n}\n\nint main(){\n\tn=rd(),m=rd();\n\trep(i,0,m-1) U[i]=rd(),V[i]=rd();\n\tmemset(A,-1,sizeof A),memset(B,-1,sizeof B);\n\trep(i,1,n) A[i][i]=B[i][i]=m,X[i].turn(i),Y[i].turn(i);\n\tfor(t=m-1;~t;t--) {\n\t\tG[U[t]].pb(V[t]),E[V[t]].pb(U[t]);\n\t\tint L=min(U[t],V[t]);\n\t\trep(i,0,L>>6) {\n            // bitset 优化。\n\t\t\tfor(int j;~(j=Log(X[U[t]].a[i]&~X[V[t]].a[i])) && (i<<6|j)<=L;) dfs1(i<<6|j,V[t]);\n\t\t\tfor(int j;~(j=Log(Y[V[t]].a[i]&~Y[U[t]].a[i])) && (i<<6|j)<=L;) dfs2(i<<6|j,U[t]);\n\t\t}\n\t}\n\trep(i,1,n) rep(j,i,n) if(~A[i][j] && ~B[i][j]) ans[min(A[i][j],B[i][j])]++;\n\tdrep(i,m,0) ans[i]+=ans[i+1];\n\trep(i,0,m) printf(\"%d \",ans[i]);\n}\n```\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「2019 集训队互测 Day 1」最短路径  (点分治+NTT/FFT+线段树)","url":"/2021/05/21/「2019 集训队互测 Day 1」最短路径  (点分治+NTT FFT+线段树)/","content":"# 「2019 集训队互测 Day 1」最短路径  (点分治+NTT/FFT+线段树)\n\n题意：给定了一棵基环树，求所有的$d(u,v)^k$的期望\n\n当$k$较小时，可以想到用斯特林数/二项式定理展开 维护+1操作，对于树的可以从儿子合并上来，对于环上可以枚举每个块求得答案\n\n复杂度为$O(nk)$\n\n当图为一棵树时，由于不好处理$x^k$，考虑直接求出$d(u,v)=i$的数量\n\n比较容易想到用用点分治+$\\text{NTT}$求解，复杂度为$O(n\\log ^2n)$\n\n环上的情况比较麻烦，不妨为每个块标号$1,2,\\cdots m$，每个块包含$sz_i$个结点\n\n显然$(i,j)$的距离为$\\min\\lbrace|i-j|,m-|i-j|\\rbrace$\n\n考虑计算所有块$(i,j)(i<j)$之间的贡献，令$d=\\lfloor \\frac{m}{2}\\rfloor $，则对于$j\\in[i+1,i+d]$在环上的距离为$j-i$，否则距离为$m-(j-i)$\n\n对于两种情况分类讨论，这里以计算$j\\in[i+1,i+d]$为例\n\n因为是一段区间，考虑直接在线段树的$[i+1,i+d]$加入$i$，然后对于线段树上每个结点计算\n\n推论1：能够被添加到线段树结点$[l,r]$上的$i$构成一段连续的区间\n\n推论2：从区间$[l,r]$的一端出发，$\\text{dfs}$区间内的块得到的$\\max dis_u\\leq \\sum_{i=l}^r sz_i$\n\n因此同样考虑用$\\text{NTT}$维护该答案，每次更新答案可以看做是区间$[l1,r1],[l2,r2](r1<l2)$之间的贡献\n\n分别从$r1,l2$开始$\\text{dfs}$得到$dis_u$，然后$\\text{NTT}$合并，不把$[r1+1,l2-1]$这一部分在环上的加入$\\text{NTT}$大小\n\n这样就能保证卷积大小$\\leq \\sum_{i=l1}^{r1} sz_i+\\sum_{i=l2}^{r2} sz_i$\n\n同理可以类似处理$j>i+d$的情况\n\n分析复杂度：每个$i$会出现在线段树上$\\log n$个位置，每个$j$会在线段树上$\\log n$层被计算\n\n因此每个点被加入卷积大小的次数为$O(\\log n)$，复杂度为$O(n\\log ^2 n)$与前面的点分治同阶\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\nchar IO;\nint rd(){\n\tint s=0,f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nbool Mbe;\nconst int N=1<<18|10,P=998244353;\n\nint n,m,k;\nint A[N];\nll qpow(ll x,ll k=P-2) {\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\nint Pow[N];\nstruct Edge{\n\tint to,nxt;\n}e[N];\nint head[N],ecnt,deg[N];\nvoid AddEdge(int u,int v) {\n\te[++ecnt]=(Edge){v,head[u]};\n\thead[u]=ecnt,deg[v]++;\n}\n#define erep(u,i) for(int i=head[u];i;i=e[i].nxt)\n\nint w[N];\nvoid Init() {\n\tint R=1<<18;\n\tint t=qpow(3,(P-1)/R);\n\tw[R/2]=1;\n\trep(i,R/2+1,R-1) w[i]=1ll*w[i-1]*t%P;\n\tdrep(i,R/2-1,1) w[i]=w[i<<1];\n}\n\nint rev[N];\nvoid NTT(int n,int *a,int f) {\n\tstatic int e[N>>1];\n\trep(i,0,n-1) if(i<rev[i]) swap(a[i],a[rev[i]]);\n\tfor(int i=e[0]=1,t;i<n;i<<=1) {\n\t\tint *e=w+i;\n\t\tfor(int l=0;l<n;l+=i*2) {\n\t\t\tfor(int j=l;j<l+i;++j) {\n\t\t\t\tt=1ll*a[j+i]*e[j-l]%P;\n\t\t\t\ta[j+i]=a[j]-t,Mod2(a[j+i]);\n\t\t\t\ta[j]+=t,Mod1(a[j]);\n\t\t\t}\n\t\t}\n\t}\n\tif(f==-1) {\n\t\treverse(a+1,a+n);\n\t\tll base=qpow(n);\n\t\trep(i,0,n-1) a[i]=a[i]*base%P;\n\t}\n}\nint Init(int n) {\n\tint R=1,c=-1;\n\twhile(R<=n) R<<=1,c++;\n\trep(i,0,R-1) rev[i]=(rev[i>>1]>>1)|((i&1)<<c);\n\treturn R;\n}\n\nint Q[N],L,R,vis[N];\n\nnamespace pt1{ \n\tconst int N=1010;\n\tint dis[N];\n\tvoid Bfs(int u) {\n\t\trep(i,1,n) dis[i]=-1;\n\t\tdis[Q[L=R=1]=u]=0;\n\t\twhile(L<=R) {\n\t\t\tu=Q[L++];\n\t\t\terep(u,i){\n\t\t\t\tint v=e[i].to;\n\t\t\t\tif(~dis[v]) continue;\n\t\t\t\tdis[v]=dis[u]+1,Q[++R]=v;\n\t\t\t}\n\t\t}\n\t}\n\tvoid Solve() {\n\t\tint ans=0;\n\t\trep(i,2,n) {\n\t\t\tBfs(i);\n\t\t\trep(j,1,i-1) ans=(ans+Pow[dis[j]])%P;\n\t\t}\n\t\tans=ans*qpow(n*(n-1)/2)%P;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint Ans[N],sz[N];\nnamespace pt2{ \n\tint mi=1e9,rt;\n\tvoid FindRt(int n,int u,int f) {\n\t\tint ma=0; sz[u]=1;\n\t\terep(u,i) {\n\t\t\tint v=e[i].to;\n\t\t\tif(v==u || v==f || vis[v]) continue;\n\t\t\tFindRt(n,v,u),sz[u]+=sz[v],cmax(ma,sz[v]);\n\t\t}\n\t\tcmax(ma,n-sz[u]);\n\t\tif(mi>ma) mi=ma,rt=u;\n\t}\n\n\tint F[N],A[N],B[N];\n\tvoid Solve(int n,int k) {\n        // 容斥型 点分治\n\t\tint R=Init(n*2+1);\n\t\trep(i,0,R) F[i]=0;\n\t\trep(i,0,n) F[i]=A[i];\n\t\tNTT(R,F,1);\n\t\trep(i,0,R-1) F[i]=1ll*F[i]*F[i]%P;\n\t\tNTT(R,F,-1);\n\t\tif(k==1) rep(i,0,n*2) Ans[i]+=F[i],Mod1(Ans[i]);\n\t\telse rep(i,0,n*2) Ans[i]-=F[i],Mod2(Ans[i]);\n\t}\n\tint maxd;\n\tvoid dfs(int u,int f,int d=0) {\n\t\tA[d]++,sz[u]=1,cmax(maxd,d);\n\t\terep(u,i) {\n\t\t\tint v=e[i].to;\n\t\t\tif(v==u || v==f || vis[v]) continue;\n\t\t\tdfs(v,u,d+1),sz[u]+=sz[v];\n\t\t}\n\t}\n\tvoid Divide(int n,int u) {\n\t\tmi=1e9,FindRt(n,u,0),u=rt;\n\t\tvis[u]=1;\n\t\tint D=0;B[0]=1;\n\t\terep(u,i) {\n\t\t\tint v=e[i].to;\n\t\t\tif(vis[v]) continue;\n\t\t\tmaxd=0,dfs(v,u,1);\n\t\t\tSolve(maxd,-1);\n\t\t\trep(j,0,maxd) B[j]+=A[j],A[j]=0;\n\t\t\tcmax(D,maxd);\n\t\t}\n\t\trep(i,0,D) A[i]=B[i],B[i]=0;\n\t\tSolve(D,1);\n\t\trep(i,0,D) A[i]=0;\n\t\terep(u,i) {\n\t\t\tint v=e[i].to;\n\t\t\tif(vis[v]) continue;\n\t\t\tDivide(sz[v],v);\n\t\t}\n\t}\n\tvoid Solve() {\n\t\trep(i,1,n) vis[i]=0;\n\t\tDivide(n,1);\n\t\tint ans=0;\n\t\trep(i,1,n) ans=(ans+1ll*Ans[i]*Pow[i])%P;\n\t\tans=ans*qpow(1ll*n*(n-1)%P)%P;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint QL[N<<2],QR[N<<2];\nvoid Add(int p,int l,int r,int ql,int qr,int x) {\n    // 在线段树上加入结点\n\tif(ql<=l && r<=qr) {\n\t\tif(!QL[p]) QL[p]=x;\n\t\tQR[p]=x;\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tif(ql<=mid) Add(p<<1,l,mid,ql,qr,x);\n\tif(qr>mid) Add(p<<1|1,mid+1,r,ql,qr,x);\n}\n\nint typ;\nint X[N],Y[N],D;\n\nvoid dfs(int *C,int u,int f,int d) {\n\tcmax(D,d),C[d]++;\n\tfor(int i=head[u];i;i=e[i].nxt) {\n\t\tint v=e[i].to;\n\t\tif(v==f || vis[v])  continue;\n\t\tdfs(C,v,u,d+1);\n\t}\n}\n\nvoid Mark(int i,int k) {\n\tint l=A[i==1?m:i-1],r=A[i==m?1:i+1];\n\tvis[l]=vis[r]=k;\n}\n\nvoid Get(int p,int l,int r) { \n\tif(QL[p]) {\n        // 计算区间QL,QR到l,r的贡献\n\t\tif(typ==0) {\n\t\t\tint qr=QR[p];\n\t\t\trep(x,QL[p],QR[p]) Mark(x,1),dfs(X,A[x],0,qr-x),Mark(x,0);\n\t\t\tint T=D; D=0;\n\t\t\trep(x,l,r) Mark(x,1),dfs(Y,A[x],0,x-l),Mark(x,0);\n\t\t\tint R=Init(T+D+1);\n\t\t\tNTT(R,X,1),NTT(R,Y,1);\n\t\t\trep(i,0,R-1) X[i]=1ll*X[i]*Y[i]%P;\n\t\t\tNTT(R,X,-1);\n\t\t\trep(i,0,T+D) Ans[i+l-qr]+=X[i],Mod1(Ans[i+l-qr]);\n\t\t\trep(i,0,R) X[i]=Y[i]=0;\n\t\t} else {\n\t\t\tint ql=QL[p];\n\t\t\trep(x,QL[p],QR[p]) Mark(x,1),dfs(X,A[x],0,x-ql),Mark(x,0); \n\t\t\tint T=D; D=0;\n\t\t\trep(x,l,r) Mark(x,1),dfs(Y,A[x],0,r-x),Mark(x,0);\n\t\t\tint R=Init(T+D+1);\n\t\t\tNTT(R,X,1),NTT(R,Y,1);\n\t\t\trep(i,0,R-1) X[i]=1ll*X[i]*Y[i]%P;\n\t\t\tNTT(R,X,-1);\n\t\t\tint d=ql+m-r;\n\t\t\trep(i,0,T+D) Ans[i+d]+=X[i],Mod1(Ans[i+d]);\n\t\t\trep(i,0,R) X[i]=Y[i]=0;\n\t\t}\n\t\tQL[p]=QR[p]=0;\n\t}\n\tif(l==r) return;\n\tint mid=(l+r)>>1;\n\tGet(p<<1,l,mid),Get(p<<1|1,mid+1,r);\n}\n\nint main() {\n\tfreopen(\"path.in\",\"r\",stdin),freopen(\"path.out\",\"w\",stdout);\n\tn=rd(),k=rd();\n\trep(i,1,n) Pow[i]=qpow(i,k);\n\trep(i,1,n) {\n\t\tint u=rd(),v=rd();\n\t\tAddEdge(u,v),AddEdge(v,u);\n\t}\n\tif(n<=1000) return pt1::Solve(),0;\n\tInit(),L=1;\n    // 拓扑求环\n\trep(i,1,n) if(deg[i]==1) sz[Q[++R]=i]=1;\n\twhile(L<=R) {\n\t\tint u=Q[L++]; vis[u]=1;\n\t\tfor(int i=head[u];i;i=e[i].nxt) {\n\t\t\tint v=e[i].to;\n\t\t\tif(deg[v]<=1) sz[u]+=sz[v];\n\t\t\tif(--deg[v]==1) Q[++R]=v;\n\t\t}\n\t}\n\tfor(int u=1;u<=n;++u) if(!vis[u]) {\n\t\twhile(1) {\n\t\t\tvis[u]=1,A[++m]=u;\n\t\t\tint nxt=-1;\n\t\t\tfor(int i=head[u];i;i=e[i].nxt) {\n\t\t\t\tint v=e[i].to;\n\t\t\t\tif(!vis[v]) nxt=v;\n\t\t\t}\n\t\t\tif(nxt==-1) break;\n\t\t\tu=nxt;\n\t\t}\n\t\tbreak;\n\t}\n\tif(m==1) return pt2::Solve(),0;\n\tfprintf(stderr,\"Circle Length =%d\\n\",m);\n\trep(i,1,n) vis[i]=0;\n\n\tk=m/2;\n\trep(i,1,m) {\n\t\tMark(i,1);\n\t\tpt2::Divide(sz[A[i]],A[i]);\n\t\tMark(i,0);\n\t}\n\trep(i,1,n) Ans[i]=1ll*Ans[i]*(P+1)/2%P;\n\trep(i,1,n) vis[i]=0;\n\trep(i,1,m-1) Add(1,1,m,i+1,min(i+k,m),i);\n\ttyp=0,Get(1,1,m);\n\trep(i,1,m-k-1) Add(1,1,m,i+k+1,m,i);\n\ttyp=1,Get(1,1,m);\n\tint ans=0;\n\trep(i,1,n) ans=(ans+1ll*Ans[i]*Pow[i])%P;\n\tans=ans*qpow(1ll*n*(n-1)/2%P)%P;\n\tprintf(\"%d\\n\",ans);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「2019五校联考-雅礼」大凯的疑惑              ","url":"/2021/05/21/「2019五校联考-雅礼」大凯的疑惑              /","content":"# 「2019五校联考-雅礼」大凯的疑惑              \n\n首先判断是否有无穷解，即判断$\\gcd(a,b)>1$时有无穷解\n\n接下来我们由小凯的疑惑知道最大的无法表示的数是$ab-a-b$，这能确定一个上界\n\n考虑计算$[1,R](R<ab)$中能用$a,b$表示出来的数\n\n因为$\\gcd(a,b)=1,R<ab$，所以每个数最多只有一种构成法，可以枚举其包含了几个$b$，剩下的部分直接任意放$a$\n\n即得到计算能够被构成的个数的方法为$\\begin{aligned}\\sum_{i=0}^{\\lfloor \\frac{R}{a}\\rfloor} \\lfloor \\frac{R-ib}{a}\\rfloor+1 \\end{aligned}$\n\n其中+1是计算了包含0个$a$的情况\n\n如果二分答案，复杂度为$O(a\\log (ab))$，恐怕难以通过\n\n优化：\n\n我的思路是是先确定了$\\lfloor \\frac{R}{a}\\rfloor$，那么此时确定了所有$b$的个数的贡献\n\n那么考虑枚举，找到答案所属的$\\lfloor \\frac{R}{a}\\rfloor$的区间，在这段区间里，判断一个数$x$是否可以被构成即:\n\n$x\\equiv ib\\pmod a(i\\leq \\lfloor \\frac{R}{a}\\rfloor)$，即考虑了不同$b$的个数的贡献\n\n用一个数组存下$ib\\bmod a$，那么可以$O(1)$判断一个数是否合法，如果直接for过去是$O(b)$的\n\n显然这在一段中，构成情况每$a$个一循环，那么先快速跳循环即可\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\nconst int N=2e7+10;\n\nll a,b,k;\nll gcd(ll a,ll b){ return b==0?a:gcd(b,a%b); }\nbool mk[N];\nint main() {\n\tfreopen(\"math.in\",\"r\",stdin),freopen(\"math.out\",\"w\",stdout);\n\tscanf(\"%lld%lld%lld\",&a,&b,&k);\n\tif(gcd(a,b)!=1 || a==1) return puts(\"-1\"),0;\n\tif(a>b) swap(a,b);\n\tif(k==1) return printf(\"%lld\\n\",a*b-a-b),0;\n\tll s=(a-1)*(b-1)/2,c=0; // s为总的个数\n\tif(s<k) return puts(\"-1\"),0;\n\tk=s-k+1; // 改为求第k小\n\tint p=mk[0]=1;  // p为所属区间\n\trep(i,1,a-1) {\n\t\tc+=i*b/a;\n\t\tll t=i*(b-1)-c; // t为这段区间内无法被表示的个数\n\t\tif(t>=k){ p=i; break; }\n\t\tmk[i*b%a]=1;  // 把区间内的ib mod a 放进去\n\t}\n\tk-=(p-1)*(b-1)-(c-p*b/a); //还需要做的个数\n\tll l=(p-1)*b+1,d=l%a; //l为区间开始位置\n\tll i=l+(k-1)/(a-p)*a; // 每个长度为a的循环中已经有p个位置被标记，可以被表示，因此还有a-p个位置无法表示\n\tk-=(k-1)/(a-p)*(a-p); // 跳过循环\n\tfor(;;++i,d++,d==a&&(d=0)) if(!mk[d] && --k==0) return printf(\"%lld\\n\",i),0; // 暴力for最后a个\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「2020-2021 集训队作业」Yet Another Permutation Problem","url":"/2021/05/21/「2020-2021 集训队作业」Yet Another Permutation Problem/","content":"# 「2020-2021 集训队作业」Yet Another Permutation Problem\n\n### 题目大意\n\n对于一个初始为$1,2,\\ldots n$的排列，每次操作为选择一个数放到开头或者结尾，求$k$次操作能够生成的排列数\n\n对于$k=0,1,\\ldots ,n-1$求解\n\n$$ \\ $$\n\n###  模型转化\n\n容易发现，对于一个排列，生成它的最小次数取决于中间保留段的长度\n\n而保留段实际上是任何一个上升子段\n\n设一个排列的最长上升子段为$l$，那么最少操作步骤就是$n-l$\n\n那么对于$k$，合法的序列就是存在一个长度$\\ge n-k$的上升子段\n\n存在不好算，改为计算任何一个上升子段$<n-k$的数量\n\n为了便于描述，令下文的$k=n-k-1$\n\n$$ \\ $$\n\n### 生成函数构造\n\n考虑一个序列是由若干上升段构成的，设一个长度为$l$的上升段的权值为$[l\\leq k]$\n\n那么排列的权值就是上升段权值之积\n\n容易想到用$\\text{EGF}$合并上升段，但是直接的统计，我们无法保证上升段之间无法拼接\n\n假设我们确定了一个单位上升段的$\\text{EGF}$为$G(x)$，$\\text{OGF}$为$F(x)$\n\n那么按照上面$\\text{Naive}$的计算，上升段之间的合并为有序拼接，即$\\displaystyle \\sum_{i=0}G^i(x)=\\frac{1}{1-G(x)}$\n\n容易发现，这样的计算，会导致一个长度为$l$的极长上升段被分解成若干小段\n\n也就是被计算了$\\displaystyle [x^l](\\sum_{i=0}F^i(x))=[x^l]\\frac{1}{1-F(x)}$次\n\n在合法的计算中，我们希望，$[x^l]\\frac{1}{1-F(x)}$恰好为权值$[l\\leq k]$\n\n也就是说，我们希望$\\displaystyle \\frac{1}{1-F(x)}=H(x)=\\sum_{i=0}^kx^i=\\frac{x^{k+1}-1}{x-1}$\n\n那么可以反向由$H(x)$构造出我们想要的$F(x)$，从而得到$G(x)$，再进行求解\n\n$$ \\ $$\n\n### 答案计算\n\n$\\displaystyle F(x)=1-\\frac{1}{H(x)}=1-\\frac{x-1}{x^{k+1}-1}=\\frac{x-x^{k+1}}{1-x^{k+1}}$\n\n可以爆算得到$F(x)$，从而得到$G(x)$，然后暴力求逆就是$O(n^2)$\n\n优化：\n\n$1-x^{k+1}$的逆，只包含$\\frac{n}{k+1}$项，所以$G(x)$只含$2\\frac{n}{k+1}$项\n\n即$\\displaystyle F(x)=\\sum_{d=0}x^{d(k+1)+1}-\\sum_{d=1}x^{d(k+1)}$，$G(x)$就是除一个阶乘\n\n这样暴力求逆就是$O(n^2\\ln n)$\n\n~~（不是你干嘛要真的求逆，直接进行$G(x)$的叠加就可以了）~~\n\n```cpp\nconst int N=1010;\n\nint n,P,I[N],J[N];\nll qpow(ll x,ll k=P-2){\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\nint F[N];\n\nint main(){\n\tn=rd(),P=rd();\n\trep(i,*J=1,n) J[i]=1ll*J[i-1]*i%P;\n\tI[n]=qpow(J[n]);\n\tdrep(i,n,1) I[i-1]=1ll*I[i]*i%P;\n\tdrep(k,n,1) {\n\t\tF[0]=1;\n\t\trep(j,1,n) {\n\t\t\tF[j]=0;\n\t\t\tfor(int d=1;d<=j;d+=k) F[j]=(F[j]+1ll*F[j-d]*I[d])%P;\n\t\t\tfor(int d=k;d<=j;d+=k) F[j]=(F[j]-1ll*F[j-d]*I[d])%P;\n\t\t}\n\t\tprintf(\"%d\\n\",int((1ll*(P+1-F[n])*J[n])%P));\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「2020noip模拟题-蒋凌宇」幂","url":"/2021/05/21/「2020noip模拟题-蒋凌宇」幂/","content":"# 「2020noip模拟题-蒋凌宇」幂\n\n### Analysis\n\n计算$x$出现的次数，可以转化为枚举每一个$x$，计算剩余$n-1$个位置合法括号序列个数\n\n因此我们只需要计算合法括号序列个数\n\n定义一个辅助计数：**不可分割** 的合法括号序列\n\n这样的括号序列，满足：其恰好为$x$，或者序列两端是一对匹配的左右括号\n\n而实际要求的括号序列 的就是这样的 **不可分割**括号序列 去掉两端的匹配括号\n\n$$\\  $$\n\n## Solution\n\n设$a_n$为长度为$n$的**不可分割** 的合法括号序列数量\n\n括号序列并非排列问题，因此我们用普通生成函数计算\n\n设$\\text{OGF(a)}=A(x)$，$A(x)$容易发现$A(x)$满足下面的递归式\n\n$\\displaystyle A(x)=x^2(\\sum_{i=0}^{\\infty} A^i(x))+x^1$\n\n其中$x^2$表示在外层加一对匹配括号，$\\sum_{i=0}^{\\infty} A^i(x)$枚举子括号中的分裂段，$x^1$表示单个$x$\n\n容易得到下面的化简过程\n\n$\\displaystyle A(x)=\\frac{x^2}{1-A(x)}+x$\n\n$A(x)-A^2(x)=x^2+xA(x)$\n\n$A^2(x)-(x+1)A(x)+x^2+x=0$\n\n带入求根公式，得到$A(x)$的 **收敛形式**\n\n$\\displaystyle A_1(x)=\\frac{x+1+\\sqrt{-3x^2-2x+1}}{2},A_2(x)=\\frac{x+1-\\sqrt{-3x^2-2x+1}}{2}$\n\n令$\\displaystyle F(x)=-3x^2-2x+1,G(x)=\\sqrt{F(x)}$\n\n容易手玩发现：$[x^0]G(x)=1$\n\n而根据定义，我们知道$[x^0]A(x)=0$，因此$A(x)=A_2(x)$\n\n接下来我们要求$\\displaystyle G(x)=F^\\frac{1}{2}(x)$\n\n$$ \\ $$\n\n下面介绍对于短多项式$F(x)$，设$\\text{deg}(F(x))=m$，有理数$k(k\\ne 1)$\n\n求解$G(x)=F^k(x)$的前$n$项的$O(m^2+nm)$递推做法\n\n#### 变形\n\n$G(x)=F^k(x)$\n\n$\\displaystyle G'(x)=kF^{k-1}(x)F'(x)$\n\n$G'(x)F(x)=kF^k(x)F'(x)$\n\n$G'(x)F(x)=kG(x)F'(x)$\n\n$$ \\ $$\n\n#### 求解递推式\n\n对于等号两边，考虑$[x^n]$一项的系数，容易求出$F'(x)=-6x-2$\n\n$\\displaystyle \\sum_{i=0}^m [x^{n-i}]G'(x)F_i=k\\sum_{i=0}^{m-1}[x^{n-i}]G(x)F'_i$\n\n$\\displaystyle \\sum_{i=0}^m [x^{n-i+1}](n-i+1)G(x)F_i=k\\sum_{i=0}^{m-1}[x^{n-i}]G(x)F'_i$\n\n$\\displaystyle (n+1)[x^{n+1}]G(x)=k\\sum_{i=0}^{m-1}[x^{n-i}]G(x)F'_i-\\sum_{i=1}^m [x^{n-i+1}](n-i+1)G(x)F_i$\n\n带入这题的$k$，得到\n\n$\\displaystyle [x^n]=\\frac{3(n-3)[x^{n-2}]+(2n-3)[x^{n-1}]}{n}$\n\n递推边界$[x^0]G(x)=1,[x^1]G(x)=-1$\n\n然后由$G(x)$得到$A(x)$再得到最终答案即可\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「2020联考北附1」命运歧途              ","url":"/2021/05/21/「2020联考北附1」命运歧途              /","content":"# 「2020联考北附1」命运歧途              \n\n排列$dp$问题通常想到容斥，因为很难在$dp$的同时保证排列元素不多次出现\n\n对于这个问题，我们只需要考虑相邻关系\n\n我们需要计算包含**0**个非法位置的排列个数，因此容斥容易定义为计算\n\n**包含至少$i$个非法位置的**排列个数，容斥系数可以简单设置为$(-1)^i$\n\n考虑一个序列的合法与非法情况，容易发现是类似下面的情况\n\n![Snipaste_2020-11-30_19-31-05.png](https://i.loli.net/2020/11/30/r5gyxpcMqCKXuiL.png)\n\n序列会被分成若干段，每一段是形如$x,x+k,x+2k,\\cdots$或者$x,x-k,x-2k$\n\n显然$x,y$会产生非法关系的必要条件是$x\\equiv t \\pmod k$，因此按照$x\\mod k$分组\n\n组内实际上是类似$k=1$的子问题，不妨设一组包含$m$个元素\n\n显然不同组之间一定构成不同的段，而对于一组内的元素，我们可以强制某一些位置分段\n\n最终会得到一个若干段的序列，段之间由于不确定相互关系，设最终分成$i$段，则可以有$i!$种段之间排列\n\n(分成$i$段的贡献在我们计算时实际上是至少包含了$n-i$个非法位置)\n\n现在问题就是落到了$dp$序列分成$i$段的方案数，显然对于每一组，是一个分组背包的问题\n\n对于每一个大小为$m$的组，考虑$dp$其分段方案\n\n令$dp_{i,j}$表示当前已经确定的总大小为$i$且已经分成了$j$段\n\n转移可以枚举下一段的大小$k$，由于实际排列中的段是有递增和递减两种情况，因此对于任意$k>1$，有两种段分配方法\n\n转移式子是\n\n$dp_{i,j}\\rightarrow dp_{i+k,j+1} (k=1)$\n\n$2dp_{i,j}\\rightarrow dp_{i+k,j+1} (k>1)$\n\n这个式子容易用前缀和优化，特殊的转移位置只有一个，处理一下即可\n\n于是可以在$O(n^2)$复杂度内计算任何一个大小的组的分段方案\n\n暴力合并组之间的背包，对于每个查询，复杂度为$O(n^2)$\n\n因此总复杂度受限于查询，为$O(qn^2)$\n\n接下来考虑如何削减查询复杂度\n\n由于$q$的上限实际是$n$，下文认为$q=n$\n\n-----------------------\n\n### 优化1\n\n上面的问题中，我们并没有具体地分析分组的情况\n\n实际上对于$n,k$，可能的组大小只有两种，即$\\lfloor \\frac{n}{k}\\rfloor ,\\lceil \\frac{n}{k}\\rceil$\n\n不同的$\\lfloor \\frac{n}{k}\\rfloor $只有$O(\\sqrt n)$种，不妨对于每种$\\lfloor \\frac{n}{k}\\rfloor $从小到大计算每一个$k$的答案\n\n简单观察即可发现：\n\n在每个块内，按照$k$递增，两种组的个数一个递增一个递减\n\n如果在每个$\\lfloor \\frac{n}{k}\\rfloor $中，为最小的$k$暴力$O(n^2)$预处理出答案，然后不断增大\n\n不妨维护两个单调的个数指针\n\n如果能够支持背包回撤一个分组，增加一个分组，那么容易做到每个块内$O(n^2)$递推答案\n\n增加一个分组不必说，而对于去掉一个分组，不好求出模逆元\n\n但是由于上面的$dp_{i,j}$满足$dp_{i,i}=1$，因此考虑从高到低递推每一位\n\n模拟一个长除法即可\n\n合理的常数优化也可以通过此题\n\n```cpp\nconst int N=2010;\n\nint n,m,P;\nint C[N][N],J[N];\nint dp[N][N],S[N],F[N],G[N];\n\nint len;\nint pl=-1,nc1,nc2;\nvoid clear() { \n\trep(i,0,len) F[i]=0;\n\tF[len=0]=1,nc1=nc2=0; \n}\nint cnt=0;\nvoid Mul(int m,int *A){ \n\tdrep(i,len+=m,0) {\n\t\tull t=0;\n\t\trep(j,1,min(i,m)) {\n\t\t\tt+=1ll*F[i-j]*A[j];\n\t\t\t((j&15)==0) && (t%=P);\n\t\t}\n\t\tF[i]=t%P;\n\t}\n}\nvoid Div(int m,int *A){ \n\tstatic int G[N];\n\trep(i,0,len) G[i]=F[i],F[i]=0;\n\tdrep(i,len-=m,0) {\n\t\tull t=G[i+m];\n\t\trep(j,1,m) {\n\t\t\tt+=1ll*F[i+j]*(P-A[m-j]);\n\t\t\t((j&15)==0) && (t%=P);\n\t\t}\n\t\tF[i]=t%P;\n\t}\n}\n\nint Ans[N],Pow1[N],Pow2[N];\nint clr;\nvoid Solve(int m) {\n\tint l=(n-1)/m+1,c1=0,c2=0;\n\trep(i,1,m) if((n-i)/m+1==l) c1++;\n\telse c2++;\n\tif(l==2) {\n\t\trep(i,0,c1+c2) F[i]=0;\n\t\trep(i,0,n-c1-c2) F[i+c1+c2]=1ll*C[c1][i]*Pow1[c1-i]%P*Pow2[i]%P;\n\t\tint x=1;\n\t\trep(i,1,c2) x=1ll*x*dp[1][1]%P;\n\t\trep(i,c1+c2,n) F[i]=1ll*F[i]*x%P;\n\t} else {\n\t\tif(l!=pl) {\n\t\t\tclr++;\n\t\t\tclear(); \n\t\t\tpl=l;\n\t\t}\n\t\tcnt++;\n\t\twhile(c1<nc1) Div(l,dp[l]),nc1--;\n\t\twhile(c2<nc2) Div(l-1,dp[l-1]),nc2--;\n\t\twhile(c1>nc1) Mul(l,dp[l]),nc1++;\n\t\twhile(c2>nc2) Mul(l-1,dp[l-1]),nc2++;\n\t}\n\trep(i,0,n) G[n-i]=1ll*F[i]*J[i]%P;\n\tint ans=0;\n\trep(i,0,n) ans=(ans+1ll*((i&1)?-1:1)*G[i])%P;\n\tans=(ans%P+P)%P;\n\tAns[m]=ans;\n}\n\nint main() {\n\tfreopen(\"fate.in\",\"r\",stdin),freopen(\"fate.out\",\"w\",stdout);\n\tn=rd(),m=rd(),P=rd();\n\trep(i,0,n) rep(j,C[i][0]=1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P;\n\trep(i,J[0]=1,n) J[i]=1ll*J[i-1]*i%P;\n\tdp[0][0]=S[0]=1;\n\trep(i,1,n) {\n\t\tdrep(j,i,1) {\n\t\t\tdp[i][j]=(2ll*S[j-1]+P-dp[i-1][j-1])%P;\n\t\t\tS[j]+=dp[i][j],Mod1(S[j]);\n\t\t}\n\t}\n\trep(i,Pow1[0]=1,n) Pow1[i]=1ll*Pow1[i-1]*dp[2][1]%P;\n\trep(i,Pow2[0]=1,n) Pow2[i]=1ll*Pow2[i-1]*dp[2][2]%P;\n\trep(i,1,n-1) Solve(i);\n\tAns[n]=J[n];\n\tfprintf(stderr,\"%d %d\\n\",cnt,clr);\n\trep(i,1,m) printf(\"%d\\n\",Ans[rd()]);\n}\n```\n\n\n\n$$ \\ $$\n\n### 优化2\n\n从生成函数的角度，我们容易把所求的值归纳为\n\n$H(x)=F^a(x)G^b(x)$\n\n我们知道多项式快速幂的复杂度为$\\exp$的$n\\log n$\n\n当然那是对于长度为$n$的情况\n\n而现在是长度之和为$n$\n\n由于EI在无数道题中介绍了这个东西，看到马上想到可以求导\n\n$H'(x)=aF^{a-1}(x)F'(x)G(x)+bG^{b-1}(x)G'(x)F(x)$\n\n$H'=H(a\\cdot \\frac{F'}{F}+b\\cdot \\frac{G'}{G})$\n\n理想的情况是：对于这个式子，两边从低到高解方程确定每一项的值\n\n然而首先遇到的多项式除法操作就难以解决\n\n要除掉的$F,G$没有常数项，而第一项系数为1或2，因此除法操作只需要计算$2$的逆元\n\n因此可以考虑对于模数中的$2^t$提取出来，然后最后暴力exCRT合并\n\n接下来就是分成两部分\n\n#### 计算$\\mod 2^t$\n\n由上面知道，背包的每一个位置实际对于最后答案的贡献是$i!(-1)^{n-i}$\n\n因此对于$i!\\mod 2^t=0$的位置都不用考虑，只需要求出背包前$O(\\log P)$位，暴力即可\n\n$$ \\ $$\n\n### 计算$\\mod P(2\\not |P)$\n\n接下来就是上面的递推过程\n\n然而还有一个问题就是从$[x^n]H'$得到$[x^{n+1}]H$，显然这里需要一个逆元\n\nEI为我们提供一个很好的思路，或许有助于解决任意模数的逆元问题：\n\n>  因为答案计算的是$k![x^k]H$，因此可以直接在计算过程中加入\n>\n> 这样求导的系数在阶乘中被省略，变成了单纯的平移\n>\n> 而乘法只需要额外添加一个权值$\\binom{i+j}{i}\\cdot x^i\\cdot x^j\\rightarrow x^{i+j}$\n\n接下来具体的方法是：\n\n先将$F(x),G(x)$平移一位去掉空余的项，处理过后$H(x)$被平移了$a+b$的位置，首项为$x^0$\n\n从低到高递推$H(x)$的每一位，同步维护$ \\frac{H}{F},\\frac{H}{G}$\n\n对于$H'(x)$的第$i$项累和得到，然后平移一位得到$H(x)$的$i+1$项\n\n最后需要加上平移部分的贡献，$i!\\rightarrow (i+a+b)!$，可以用一个组合数解决\n\n```cpp\nconst int N=2010;\n\nint n,m,P;\nint J[N];\nint dp[N][N],S[N],F[N],G[N];\n\nstruct Solve2t{\n\tint F[N],P,U;\n\tvoid Init(int x) {\n\t\tP=x;\n\t\tint t=1;\n\t\trep(i,1,n) {\n\t\t\tt=1ll*t*i%P;\n\t\t\tif(t==0) break;\n\t\t\tU=i;\n\t\t}\n\t}\n\tint Solve(int m) {\n\t\trep(i,0,U) F[i]=0;\n\t\tF[0]=1;\n\t\trep(x,1,m) {\n\t\t\tint c=(n-x)/m+1;\n\t\t\trep(i,0,U) G[i]=F[i],F[i]=0;\n\t\t\trep(i,0,U) if(G[i]) rep(j,1,min(c,U)) F[i+j]=(F[i+j]+1ll*G[i]*dp[c][j])%P;\n\t\t}\n\t\tint ans=0;\n\t\trep(i,1,U) {\n\t\t\tF[i]=1ll*F[i]*J[i]%P;\n\t\t\tans=(ans+(((n-i)&1)?-1:1)*F[i])%P;\n\t\t}\n\t\tans=(ans%P+P)%P;\n\t\treturn ans;\n\t}\n} Sol1;\n\nvoid Exgcd(ll a,ll b,ll &x,ll &y) {\n\tif(b==0) {\n\t\tx=1,y=0;\n\t\treturn;\n\t}\n\tExgcd(b,a%b,y,x),y-=a/b*x;\n}\nll Inv(int a,int P) {\n\tll x,y;\n\tExgcd(a,P,x,y);\n\treturn (x%P+P)%P;\n}\n\nstruct SolveP{\n\tint C[N][N];\n\tint F[N],G[N];\n\tint A[N],B[N];\n\tint X[N],Y[N];\n\tint P,I2;\n\tvoid Init(int x) { \n\t\tP=x; \n\t\trep(i,0,n) rep(j,C[i][0]=1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P;\n\t\tI2=(P+1)/2;\n\t}\n\tint Solve(int m) {\n\t\tif(P==1) return 0;\n\t\tint l1=(n-1)/m+1,l2=l1-1;\n\t\tint c1=0,c2=0;\n\t\trep(i,1,m) if((n-i)/m+1==l1) c1++;\n\t\telse c2++;\n\t\tint Inv=dp[l1][1]==1?1:I2;\n\t\trep(i,1,l1) A[i-1]=1ll*J[i-1]*dp[l1][i]%P*Inv%P;\n\t\tInv=dp[l2][1]==1?1:I2;\n\t\trep(i,1,l2) B[i-1]=1ll*J[i-1]*dp[l2][i]%P*Inv%P;\n\t\t// 将A,B偏移补充常数项\n\t\t// 同时除掉常数项，为下面做除法铺路\n\n\t\tint d=c1+c2;\n\t\t// A,B存储偏移之后的值，d为偏移量\n\t\t// X,Y存储除法之后的值\n\t\tF[0]=X[0]=Y[0]=1;\n\t\trep(i,1,n-d) {\n\t\t\tull x=0,y=0;\n\t\t\t// 注意这里计算的是两边次数为x^{i-1}一项的值\n\t\t\trep(j,1,min(l1-1,i)) {\n\t\t\t\t// 将除法的结果乘上求导以后的值，注意求导以后第一位消失了\n\t\t\t\tx+=1ll*X[i-j]*A[j]%P*C[i-1][j-1];\n\t\t\t\t(j&15)==0 && (x%=P);\n\t\t\t\t// 求导以后是j-1位，因此实际应该是x^{i-j}*x^{j-1}\n\t\t\t}\n\t\t\trep(j,1,min(l2-1,i)) {\n\t\t\t\ty+=1ll*Y[i-j]*B[j]%P*C[i-1][j-1];\n\t\t\t\t(j&15)==0 && (y%=P);\n\t\t\t}\n\t\t\t// 由[x^{i-1}]H'(x)一项得到[x^i]H(x)\n\t\t\tF[i]=X[i]=Y[i]=(x%P*c1+y%P*c2)%P;\n\t\t\t// 接下来做二项除法(雾)\n\t\t\tx=0,y=0;\n\t\t\trep(j,1,min(i,l1-1)) {\n\t\t\t\tx+=1ll*(P-A[j])*X[i-j]%P*C[i][j];\n\t\t\t\t(j&15)==0 && (x%=P);\n\t\t\t}\n\t\t\trep(j,1,min(i,l2-1)) {\n\t\t\t\ty+=1ll*(P-B[j])*Y[i-j]%P*C[i][j];\n\t\t\t\t(j&15)==0 && (y%=P);\n\t\t\t}\n\t\t\tX[i]=(X[i]+x)%P,Y[i]=(Y[i]+y)%P;\n\t\t}\n\t\tint ans=0;\n\t\trep(i,0,n-d) {\n\t\t\tF[i]=1ll*F[i]*C[i+d][d]%P*J[d]%P;\n\t\t\tans=(ans+(((n-i-d)&1)?-1:1)*F[i])%P;\n\t\t}\n        // 将除掉的系数乘回来\n\t\trep(i,1,c1) ans=1ll*ans*dp[l1][1]%P;\n\t\trep(i,1,c2) ans=1ll*ans*dp[l2][1]%P;\n\t\tans=(ans%P+P)%P;\n\t\treturn ans;\n\t}\n} Sol2;\n\nint t;\nvoid Init() {\n\tt=1;\n\tfor(t=1;P%2==0;) t*=2,P/=2;\n\tSol1.Init(t),Sol2.Init(P);\n}\n\nvoid Solve(int m) {\n\tint x=Sol1.Solve(m),y=Sol2.Solve(m);\n    // CRT\n\tll res=1ll*((y-x)%P+P)*Inv(t,P)%P;\n\tll mod=t*P;\n\tres=((res*t+x)%mod+mod)%mod;\n\tprintf(\"%lld\\n\",res);\n}\n\nint main() {\n\tfreopen(\"fate.in\",\"r\",stdin),freopen(\"fate.out\",\"w\",stdout);\n\tn=rd(),m=rd(),P=rd();\n\trep(i,J[0]=1,n) J[i]=1ll*J[i-1]*i%P;\n\tdp[0][0]=S[0]=1;\n\trep(i,1,n) {\n\t\tdrep(j,i,1) {\n\t\t\tdp[i][j]=(S[j-1]*2ll+P-dp[i-1][j-1])%P;\n\t\t\tS[j]+=dp[i][j],Mod1(S[j]);\n\t\t}\n\t}\n\tInit();\n\trep(i,1,m) Solve(rd());\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「300iq Contest 2」[LOJ 6719] 数仙人掌 Counting Cactus ","url":"/2021/05/21/「300iq Contest 2」[LOJ 6719] 数仙人掌 Counting Cactus /","content":"# 「300iq Contest 2」[LOJ 6719] 数仙人掌 Counting Cactus \n\nLOJ上的 $n\\leq 18$ \n\n如果把仙人掌上的树边看做二元环，那么可以认为仙人掌就是由很多环嵌套在一起的结构\n\n## $n\\leq 13$\n\n状压$dp$，300iq的题解里给出了状态，但是也只告诉了你状态。。。\n\n令$f(i,S)$为$i$号节点为根，子树集合为$S$的方案数\n\n令$g(i,S)$为$i$号节点为根，子树集合为$S$的方案数，并且强制根上只接了一个环\n\n令$dp(u,v,S)$为钦定一个当前环的开头为$u$，环尾扩展到了$v$，当前包含$S$的方案数\n\n由此得到转移为\n\n1.$f(i,S)\\cdot g(j,T)(S\\cap T=\\empty)\\rightarrow f(i,S\\cup T)$\n\n2.$dp(u,v,S)\\cdot f(d,T)(S\\cap T=\\empty,(u,v)\\in E) \\rightarrow dp(u,d,S\\cup T)$\n\n3.$dp(u,v,S) ((u,v)\\in E)\\rightarrow g(u,S)$\n\n实际上涉及到很多计算重复，因此需要在转移过程中加入一些调整:\n\n1.在转移环时，**钦定的环开头节点下方不应该接有任何其他节点**\n\n2.转移1中$S,T$合并上来时，可以保证$S<T$来避免集合加入顺序的重复\n\n3.当环长>2时，同一个环，同一个开始位置会由于环遍历顺序的不同被转移两次\n\n对于这个问题我的解决方法是: 让$\\frac{dp(u,v,S)}{2}\\rightarrow g(u,S)$，然后把环长为2的部分加上去\n\n转移过程中涉及到集合运算都是枚举子集，因此复杂度一个很松的上限为$O(n^33^n)$\n\n转移顺序不难解决，代码比较丑\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define reg register\ntypedef long long ll;\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n\nchar IO;\nint rd(){\n\tint s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=13,M=1<<N|3,P=998244353;\n\nint n,m;\nint G[N];\nint f[M][N],g[M][N];\nint dp[M][N][N];\n\nint main(){\n\tn=rd(),m=rd();\n\tif(n==1) return puts(\"1\"),0;\n\trep(i,1,m) {\n\t\tint u=rd()-1,v=rd()-1;\n\t\tG[u]|=1<<v,G[v]|=1<<u;\n\t}\n\tint A=(1<<n)-1;\n\trep(i,0,n-1) g[1<<i][i]=1,dp[1<<i][i][i]=1;\n\trep(S,1,A) {\n\t\t// dp[S][u][v]转移\n\t\trep(u,0,n-1) rep(v,0,n-1) if(S&(1<<u) && S&(1<<v)) {\n\t\t\tint R=S^(1<<u);\n\t\t\tif(u!=v) R^=(1<<v);\n\t\t\tfor(int T=R&(R-1);;T=(T-1)&R){\n\t\t\t\tint X=T|(1<<u)|(1<<v),Y=S^X;\n\t\t\t\tif(dp[X][u][v]) rep(d,0,n-1) if(f[Y][d] && G[v]&(1<<d)) \n\t\t\t\t\tdp[S][u][d]=(dp[S][u][d]+1ll*dp[X][u][v]*f[Y][d])%P;\n\t\t\t\tif(!T) break;\n\t\t\t}\n\t\t}\n\t\t// dp反馈给g\n\t\trep(u,0,n-1) rep(v,0,n-1) if(dp[S][u][v] && G[u]&(1<<v)) \n\t\t\tg[S][u]=(g[S][u]+1ll*(P+1)/2*dp[S][u][v])%P;\n\t\t// 特判环长为2的情况\n\t\trep(i,0,n-1) rep(j,0,n-1) if(i!=j && S&(1<<i) && S&(1<<j) && G[i]&(1<<j)) \n\t\t\tg[S][i]=(g[S][i]+1ll*(P+1)/2*f[S^(1<<i)][j])%P;\n\t\t// f[S][i]合并\n\t\trep(i,0,n-1) f[S][i]+=g[S][i],Mod1(f[S][i]);\n\t\trep(i,0,n-1) if(S&(1<<i)) {\n\t\t\tint R=S^(1<<i);\n\t\t\tfor(int T=R&(R-1);T;T=(T-1)&R) {\n\t\t\t\tint X=T,Y=T^R;\n\t\t\t\tif(X>Y) continue;\n\t\t\t\t// 防止转移顺序重复\n\t\t\t\tf[S][i]=(f[S][i]+1ll*f[X|(1<<i)][i]*g[Y|(1<<i)][i])%P;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[A][0]);\n}\n```\n\n\n\n## $n\\leq 18$\n\n前置知识：[集合幂级数的$\\ln ,\\exp$](https://www.cnblogs.com/chasedeath/p/13891189.html)\n\n同样上面的，一颗仙人掌可以看做若干$\\ge 2$环，两两之间在某一个节点上相接构成\n\n不妨先求出环的集合幂级数，枚举环上编号最小的点，然后走环，复杂度为$O(n^32^n)$，常数较小\n\n接下来当然想到枚举环的交点$i$，将当前所有包含$i$的项取出，去掉$i$后求出$\\exp$，然后放回去，就能计算相交在$i$上的方案\n\n两部分复杂度均为$O(n^32^n)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<=b;++i)\nenum{N=20,M=1<<18|10,P=998244353};\nstruct U{\n\tint x;\n\tU(){} U(int x):x(x){}\n\tinline void operator += (const U &t){ x+=t.x,x>=P&&(x-=P); }\n\tinline void operator -= (const U &t){ x-=t.x,x<0&&(x+=P); }\n\tinline U operator * (const U &t){ return U(static_cast<unsigned long long>(x)*t.x%P); }\n}I[N],F[M][N],H[M][N];\nint n,m,G[N],C[M],B[M];\nvoid FWT(int f) {\n\tfor(int i=1;i<m;i<<=1) {\n\t\tfor(int l=0;l<m;l+=i*2) {\n\t\t\tfor(int j=l;j<l+i;++j) {\n\t\t\t\tif(f==1) rep(d,1,n) F[j+i][d]+=F[j][d];\n\t\t\t\telse rep(d,1,n) F[j+i][d]-=F[j][d];\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Exp(U *a){\n\tstatic U b[N];\n\trep(i,0,n-1) b[i]=a[i+1]*(i+1);\n\trep(i,0,n-1) {\n\t\tU t=b[i];\n\t\trep(j,1,i) t+=a[j]*b[i-j];\n\t\ta[i+1]=t*I[i+1];\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==1) return puts(\"1\"),0;\n\tfor(int x,y;m--;) scanf(\"%d%d\",&x,&y),x--,y--,G[x]|=1<<y,G[y]|=1<<x;\n\tI[0]=I[1]=1,m=1<<n;\n\trep(i,0,n-1) B[1<<i]=i;\n\trep(i,2,n) I[i]=U(P-P/i)*I[P%i];\n\trep(i,1,m-1) C[i]=C[i&(i-1)]+1;\n\trep(st,0,n-1) {\n\t\tH[1<<st][st]=1;\n\t\trep(S,0,m-1) rep(i,st,n-1) if(H[S][i].x) {\n\t\t\tfor(int T=G[i]&~S;T;T&=T-1) \n\t\t\t\tH[S|(T&-T)][B[T&-T]]+=H[S][i];\n\t\t\tif(G[i]&(1<<st)) F[S][C[S]]+=H[S][i]*I[1+(C[S]>2)];\n\t\t\tH[S][i]=0;\n\t\t}\n\t}\n\tFWT(1);\n\tfor(int i=1;i<m;i<<=1){\n\t\tfor(int l=0;l<m;l+=i*2) for(int j=l;j<l+i;++j) {\n\t\t\trep(k,1,n) F[j+i][k]-=F[j][k];\n\t\t\tExp(F[j+i]+1);\n\t\t\trep(k,1,n) F[j+i][k]+=F[j][k];\n\t\t}\n\t}\n\tFWT(-1),printf(\"%d\\n\",F[m-1][n].x);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「517模拟赛1」ABC难题","url":"/2021/05/21/「517模拟赛1」ABC难题/","content":"# 「517模拟赛1」ABC难题\n\nTips: 模数是$10^8+7$\n\n不妨令序列总长为$n$，包含$m$种不同的数字\n\n发现存在$ABC$的子序列只需要满足最左边的$A$和最右边的$C$之间有一个$B$\n\n由于可能出现多个$ABC$，考虑计算不存在$ABC$的情况\n\n那么可以枚举最左边的$A$和最右边的$C$分别为$X,Y$，那么需要不存在$ABC$，并且枚举的$X,Y$合法 的充要条件是\n\n$[1,X-1]$中不存在$A$，$[X+1,Y-1]$中不存在$B$，$[Y+1,n]$中不存在$C$\n\n这三个限制，每一个限制会让一种颜色能够选择的字母数量-1\n\n那么枚举$X$，扫描每一个$Y$(注意不一定满足$X< Y$)，同时记录每个数字是否出现在$[1,X-1],[X+1,Y-1],[Y+1,n]$中\n\n在每次扫描时改变限制，同步统计出受到$0,1,2,3$个限制的数字的个数，然后答案就是$(3-i)^k$之积\n\n然而这样还不够，因为可能根本不存在$A,C$，不存在$A$或者$C$的答案为$2^m$，同时不存在$A,C$的答案为$1^m$，容斥一下即可","tags":["default tag"],"categories":["default category"]},{"title":"「APIO2018」选圆圈(K-D Tree/CDQ+Set)","url":"/2021/05/21/「APIO2018」选圆圈(K-D Tree CDQ+Set)/","content":"# 「APIO2018」选圆圈(K-D Tree/CDQ+Set)\n\n## Part1 K-D Tree做法\n\nK-D Tree经常用来优化大暴力。。\n\n把圆$(x,y,r)$视为矩形$(x-r,y-r,x+r,y+r)$，依据$(x,y)$构建K-D Tree\n\n维护K-D Tree每个节点所有矩形最小和最大的$x,y$，通过判断当前圆与其是否有交来剪枝\n\n删去的节点$x,y$不算进矩形范围即可\n\n很显然这是一个最坏$O(n^2)$的算法，直接$x,y$轮换建树这样写APIO的数据已经卡过了。。\n\n比较好的办法是按照$x,y$的方差大的一维建树，当然旋转角度也是可以的\n\n实际运行速度堪比$O(n\\log n)$\n\nCode1:旋转+$x,y$轮换建树\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); } \ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\nchar IO;\nint rd(){\n\tint s=0,f=0;\n\twhile(!isdigit(IO=getchar())) f=IO=='-';\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=3e5+10,INF=1e9+10;\nconst db eps=1e-7;\nconst db co=cos(1123),si=sin(1123);\n\nint n,typ;\nstruct Node{\n\tdb x,y; int r,id;\n}A[N],B[N];\ndb Dis(db x,db y,Node z){ return (x-z.x)*(x-z.x)+(y-z.y)*(y-z.y); }\ndb Dis(Node x,Node y){ return Dis(x.x,x.y,y); }\ndb In(db x,db y,Node z){ return Dis(x,y,z)-eps<=(db)z.r*z.r; }\nint cmp(Node x,Node y){ return typ?x.x<y.x:x.y<y.y; }\nint c[N],ch[N][2],rt;\ndb lx[N],rx[N],ly[N],ry[N];\nvoid Up(int u) {\n\tif(c[B[u].id]) lx[u]=ly[u]=1e18,rx[u]=ry[u]=-1e18;\n\telse lx[u]=B[u].x-B[u].r,rx[u]=B[u].x+B[u].r,ly[u]=B[u].y-B[u].r,ry[u]=B[u].y+B[u].r;\n\tfor(int v:ch[u]) if(v) cmin(lx[u],lx[v]),cmax(rx[u],rx[v]),cmin(ly[u],ly[v]),cmax(ry[u],ry[v]);\n}\nint Build(int l,int r) {\n\tif(l>r) return 0;\n\tint u=(l+r)>>1;\n\tnth_element(B+l,B+u,B+r+1,cmp);\n\ttyp^=1; ch[u][0]=Build(l,u-1),ch[u][1]=Build(u+1,r); typ^=1;\n\treturn Up(u),u;\n}\nint Cross(int x,Node y){\n\tif(lx[x]>rx[x]) return 0;\n\tif(In(lx[x],ly[x],y) || In(lx[x],ry[x],y) || In(rx[x],ly[x],y) || In(rx[x],ry[x],y)) return 1;\n\tif(lx[x]-eps<=y.x && y.x<=rx[x]+eps && ly[x]-eps<=y.y && y.y<=ry[x]+eps) return 1;\n\tif(lx[x]-eps<=y.x && y.x<=rx[x]+eps) if(In(y.x,ly[x],y) || In(y.x,ry[x],y)) return 1;\n\tif(ly[x]-eps<=y.y && y.y<=ry[x]+eps) if(In(lx[x],y.y,y) || In(rx[x],y.y,y)) return 1;\n\treturn 0;\n}\nvoid Del(int u,Node x){\n\tif(!u || !Cross(u,x)) return;\n\tif(!c[B[u].id] && Dis(x,B[u])-eps<=(db)(x.r+B[u].r)*(x.r+B[u].r)) c[B[u].id]=x.id;\n\tDel(ch[u][0],x),Del(ch[u][1],x);\n\tUp(u);\n}\n\nint main(){\n\tn=rd();\n\trep(i,1,n) {\n\t\tdb x=rd(),y=rd();\n\t\tA[i]=B[i]=(Node){x*co-y*si,x*si+y*co,rd(),i};\n\t}\n\tsort(A+1,A+n+1,[&](Node x,Node y){ return x.r!=y.r?x.r>y.r:x.id<y.id;}),rt=Build(1,n);\n\trep(i,1,n) if(!c[A[i].id]) Del(rt,A[i]);\n\trep(i,1,n) printf(\"%d \",c[i]);\n}\n```\n\n$$ \\ $$\n\nCode2:方差建树\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); } \ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\nchar buf[200000],*p1,*p2;\n#define getchar() (((p1==p2)&&(p2=(p1=buf)+fread(buf,1,200000,stdin))),*p1++)\nchar IO;\nint rd(){\n\tint s=0,f=0;\n\twhile(!isdigit(IO=getchar())) f=IO=='-';\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\nvoid wt(int x){\n\tstatic int buf[10],l=0;\n\twhile(x) buf[++l]=x%10+'0',x/=10;\n\tdrep(i,l,1) putchar(buf[i]);\n\tl=0;\n}\n\nconst int N=3e5+10,INF=1e9+10;\n\nint n,typ;\nstruct Node{\n\tll x,y,r;\n\tint id;\n}A[N],B[N];\nll Dis(ll x,ll y,Node z){ return (x-z.x)*(x-z.x)+(y-z.y)*(y-z.y); }\nll Dis(Node x,Node y){ return Dis(x.x,x.y,y); }\nint In(ll x,ll y,Node z){ return Dis(x,y,z)<=z.r*z.r; }\nint cmp(Node x,Node y){ return typ?x.x<y.x:x.y<y.y; }\nint c[N],ch[N][2],rt;\nint lx[N],rx[N],ly[N],ry[N];\nvoid Up(int u) {\n\tif(c[B[u].id]) lx[u]=ly[u]=INF,rx[u]=ry[u]=-INF;\n\telse lx[u]=B[u].x-B[u].r,rx[u]=B[u].x+B[u].r,ly[u]=B[u].y-B[u].r,ry[u]=B[u].y+B[u].r;\n\tfor(int v:ch[u]) if(v) cmin(lx[u],lx[v]),cmax(rx[u],rx[v]),cmin(ly[u],ly[v]),cmax(ry[u],ry[v]);\n}\n\nint Get(int l,int r){\n\tlong double _x=0,_y=0,x=0,y=0;\n\trep(i,l,r) _x+=B[i].x,_y+=B[i].y;\n\t_x/=r-l+1,_y/=r-l+1;\n\trep(i,l,r) x+=(B[i].x-_x)*(B[i].x-_x),y+=(B[i].y-_y)*(B[i].y-_y);\n\treturn x>y;\n}\n\nint Build(int l,int r) {\n\tif(l>r) return 0;\n\tint u=(l+r)>>1;\n\ttyp=Get(l,r),nth_element(B+l,B+u,B+r+1,cmp);\n\tch[u][0]=Build(l,u-1),ch[u][1]=Build(u+1,r);\n\treturn Up(u),u;\n}\nint Cross(int x,Node y){\n\tif(lx[x]>rx[x]) return 0;\n\tif(In(lx[x],ly[x],y) || In(lx[x],ry[x],y) || In(rx[x],ly[x],y) || In(rx[x],ry[x],y)) return 1;\n\tif(lx[x]<=y.x && y.x<=rx[x] && ly[x]<=y.y && y.y<=ry[x]) return 1;\n\tif(lx[x]<=y.x && y.x<=rx[x]) if(In(y.x,ly[x],y) || In(y.x,ry[x],y)) return 1;\n\tif(ly[x]<=y.y && y.y<=ry[x]) if(In(lx[x],y.y,y) || In(rx[x],y.y,y)) return 1;\n\treturn 0;\n}\nvoid Del(int u,Node x){\n\tif(!u || !Cross(u,x)) return;\n\tif(!c[B[u].id] && Dis(x,B[u])<=(x.r+B[u].r)*(x.r+B[u].r)) c[B[u].id]=x.id;\n\tDel(ch[u][0],x),Del(ch[u][1],x);\n\tUp(u);\n}\n\nint main(){\n\tn=rd();\n\trep(i,1,n) {\n\t\tint x=rd(),y=rd();\n\t\tA[i]=B[i]=(Node){x,y,rd(),i};\n\t}\n\tsort(A+1,A+n+1,[&](Node x,Node y){ return x.r!=y.r?x.r>y.r:x.id<y.id;}),rt=Build(1,n);\n\trep(i,1,n) if(!c[A[i].id]) Del(rt,A[i]);\n\trep(i,1,n) printf(\"%d \",c[i]);\n}\n```\n\n\n\n$$ \\ $$\n\n## Part2 CDQ+Set\n\n这是一个稳定$O(n\\log ^2n)$的算法\n\n按照$r$递减，$id$递增的顺序对于圆排序后，$CDQ$考虑$[l,mid]$对$[mid+1,r]$的贡献\n\n先处理$[l,mid]$的部分，就能知道哪些圆可以对$[mid+1,r]$产生贡献\n\n处理贡献时，依然把圆视为矩形，按照$x$插入、删除和查询矩形的左右边界$(x-r,y),(x+r,y)$\n\n插入、删除和查询均是在$set$中维护$y$的前驱后继\n\n同时还需要交换$x,y$重新进行一遍\n\n正确性：\n\n与每个圆交的圆一定在$x$或$y$上与它相邻\n\n如果这个圆在x,y上都不与它相邻还与它相交，则必然会跨过一个相邻的圆，这个圆不会被加入set\n\n故不存在这种情况\n\n\n\n实际运行常数很大，被K-D Tree吊起来打\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(i=a;i<=b;++i)\nusing P=pair<int,int>;\n#define M make_pair\n#define X first\n#define Y second\n#define S(x) 1ll*(x)*(x)\nconst int N=1e6+10;\nint n,c[N],i,j,D[N];\nstruct C{ int x,y,r,i; } A[N]; \nvoid Upd(int i,int j) { if(S(A[i].x-A[j].x)+S(A[i].y-A[j].y)<=S(A[i].r+A[j].r)&&D[c[A[j].i]]>i) c[A[j].i]=A[i].i; }\nset<P>st;\nP I[N],E[N],Q[N];\nvoid Work(int l,int r){\n\tint mid=(l+r)>>1,n=0,m=0,x=0,y=0,t;\n\trep(i,l,mid) if(c[A[i].i]==A[i].i) I[m]=M(A[i].x-A[i].r,i),E[m++]=M(A[i].x+A[i].r+1,i);\n\trep(i,mid+1,r) Q[n++]=M(A[i].x-A[i].r,i),Q[n++]=M(A[i].x+A[i].r,i);\n\tsort(I,I+m),sort(E,E+m),sort(Q,Q+n),st.clear();\n\trep(i,0,n-1) {\n\t\twhile(x<m&&I[x].X<=Q[i].X) st.insert(M(A[t=I[x++].Y].y,t));\n\t\twhile(y<m&&E[y].X<=Q[i].X) st.erase(M(A[t=E[y++].Y].y,t));\n\t\tauto j=st.lower_bound(M(A[t=Q[i].Y].y,t));\n\t\tif(j!=st.end()) Upd(j->Y,t);\n\t\tif(j!=st.begin()) Upd((--j)->Y,t);\n\t}\n}\nvoid Solve(int l,int r) {\n\tif(r-l+1<=80) {\n\t\trep(i,l,r)if(c[A[i].i]==A[i].i)rep(j,i+1,r) Upd(i,j);\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tSolve(l,mid);\n\tWork(l,r);rep(i,l,r) swap(A[i].x,A[i].y);\n\tWork(l,r);rep(i,l,r) swap(A[i].x,A[i].y);\n\tSolve(mid+1,r);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%d%d%d\",&A[i].x,&A[i].y,&A[i].r),A[i].i=i;\n\tsort(A+1,A+n+1,[&](C x,C y){return M(-x.r,x.i)<M(-y.r,y.i);});\n\trep(i,1,n) D[A[i].i]=c[i]=i;\n\tSolve(1,n);\n\trep(i,1,n) printf(\"%d \",c[i]);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「APIO2019」奇怪装置 ","url":"/2021/05/21/「APIO2019」奇怪装置 /","content":"# 「APIO2019」奇怪装置 \n\n找到循环就很简单了\n\n很显然$y$是每$B$次一循环的，对于每个相邻的$y$循环$x$的值均相差$B+1 \\pmod A$\n\n因此总的循环就是$B+1$对于$A$的循环乘上$B$\n\n即$\\frac{A}{gcd(A,B+1)}\\cdot B$\n\n知道循环节之后，把查询分成$O(n)$个区间，排序之后直接解决即可\n\n如果使用基数排序即可做到$O(n)$\n\n以下是快排版本\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n#define mp make_pair\nchar IO;\nll rd(){\n\tll s=0;\n\twhile(!isdigit(IO=getchar()));\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn s;\n}\nint n,c,i;\nll A,B,ans,r=-1,L,R;\npair <ll,ll> S[2000010];\nint main(){\n\tfor(n=rd(),A=rd(),B=rd(),A=min(1.0*B*(A/__gcd(A,B+1)),1e18),i=1;i<=n;++i) {\n\t\tL=rd(),R=rd();\n\t\tif(R-L+1>=A) return printf(\"%lld\\n\",A),0;\n\t\tL%=A,R%=A;\n\t\tL<=R?S[++c]=mp(L,R):(S[++c]=mp(L,A-1),S[++c]=mp(0,R));\n\t}\n\tfor(sort(S+1,S+c+1),i=1;i<=c;++i) if(r<=S[i].second) ans+=S[i].second-max(r,S[i].first-1),r=S[i].second;\n\tprintf(\"%lld\\n\",ans);\n}\n\n```\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「APIO2019」桥梁(询问分块+并查集)","url":"/2021/05/21/「APIO2019」桥梁(询问分块+并查集)/","content":"# 「APIO2019」桥梁(询问分块+并查集)\n\n询问每$S$个分块后，每次对于所有块内未被更改的边 及 所有询问 排序，然后依次加入并查集，这一部分复杂度为$O(m \\frac{q}{S}(\\log m+\\alpha(n)))$\n\n对于$S$条被改变的边，对于每个询问分别考虑这些边的贡献，复杂度为$O(qS)$，由于涉及到并查集回撤的问题，可以使用按秩合并，复杂度为$O(qS\\log S)$\n\n按照上面两步暴力实现，复杂度大概可以做到$O((m+q)\\sqrt{q}\\log n)$\n\n实际可行的优化有：\n\n用平衡树实现排序，每次暴力遍历，第一部分复杂度降为$O(q\\log m+m\\frac{q}{S} \\alpha(n))$\n\n由于最多访问到$O(S)$个联通块，第二部分用$dfs$遍历来实现，复杂度降为$O(q S \\alpha(n))$(遍历过程中要访问联通块编号)\n\n复杂度可以降到约$O((m+q)\\sqrt {q} \\cdot \\alpha(n))$\n\n以下是暴力实现的代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n#define pb push_back\nchar IO;\nint rd(){\n\tint s=0;\n\twhile(!isdigit(IO=getchar()));\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn s;\n}\n\nconst int N=1e5+10;\nint n,m,S,q,qc;\nstruct Edge{\n\tint u,v,w;\n\tbool operator < (Edge __) const { return w<__.w; }\n} A[N],B[N],Q[N];\nstruct Node{ int t,w; };\nvector <Node> G[N];\nint uid[N],uc,fa[N],sz[N],ux[N],uy[N],rc,ans[N];\nint Find(int x){ while(fa[x]!=x) x=fa[fa[x]]; return x; }\nvoid Union(int x,int y){\n\tx=Find(x),y=Find(y);\n\tif(x==y) return;\n\tif(sz[x]>sz[y]) swap(x,y);\n\tux[++rc]=x,uy[rc]=y;\n\tfa[x]=y,sz[y]+=sz[x]; // 按秩合并用于回撤\n}\n\nint main(){\n\tn=rd(),m=rd();\n\trep(i,1,m) A[i].u=rd(),A[i].v=rd(),A[i].w=rd();\n\tS=sqrt(3*(n+m));\n\trep(i,1,q=rd()) {\n\t\tans[i]=-1;\n\t\tint opt=rd(),x=rd(),y=rd();\n\t\tif(opt==1) G[x].pb((Node){i,y});\n\t\telse Q[++qc]=(Edge){i,x,y};\n\t\tif(qc%S==0 || i==q) {\n\t\t\tif(!qc) continue;\n\t\t\tint c=0;\n\t\t\trep(i,1,m) if(!G[i].size()) B[++c]=A[i];\n\t\t\telse uid[++uc]=i;\n\t\t\tsort(B+1,B+c+1),sort(Q+1,Q+qc+1);\n\t\t\trep(i,1,n) fa[i]=i,sz[i]=1;\n\t\t\tint p=c;\n\t\t\tdrep(i,qc,1) {\n\t\t\t\twhile(p && B[p].w>=Q[i].w) Union(B[p].u,B[p].v),p--;\n\t\t\t\trc=0;\n\t\t\t\trep(j,1,uc) {\n\t\t\t\t\tint x=uid[j],w=A[x].w;\n\t\t\t\t\tfor(auto k:G[x]) if(k.t<=Q[i].u) w=k.w;\n\t\t\t\t\telse break; // 找到询问时这条边的权值\n\t\t\t\t\tif(w>=Q[i].w) Union(A[x].u,A[x].v);\n\t\t\t\t}\n\t\t\t\tans[Q[i].u]=sz[Find(Q[i].v)];\n\t\t\t\tdrep(j,rc,1) fa[ux[j]]=ux[j],fa[uy[j]]=uy[j],sz[uy[j]]-=sz[ux[j]];// 回撤\n\t\t\t\trc=0;\n\t\t\t}\n\t\t\trep(i,1,uc) A[uid[i]].w=G[uid[i]].rbegin()->w,G[uid[i]].clear();\n\t\t\tuc=qc=0;\n\t\t}\n\t}\n\trep(i,1,q) if(~ans[i]) printf(\"%d\\n\",ans[i]);\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「APIO2019」路灯 (K-D Tree / 树套树 / CDQ + 树状数组)","url":"/2021/05/21/「APIO2019」路灯 (K-D Tree   树套树   CDQ + 树状数组)/","content":"#「APIO2019」路灯 (K-D Tree / 树套树 / CDQ + 树状数组)\n\n首先想到一个简单的问题转化\n\n对于一个询问，联通的时间是若干连续的区间$[L_i,R_i]$\n\n所有的$L_i,R_i+1$都是**关键点**，即由不连通变为联通的时间 和 由联通变为不连通的时间\n\n把答案转化为$\\sum R_i+1-L_i$即可\n\n问题转化为对于当前的操作，找到它是那些询问的关键点\n\n如果是合并操作，被合并的两个区间之间变得联通\n\n如果是分裂操作，裂开的两个区间之间不再联通\n\n可以用set维护上述区间，发现每次被更新的值都是一个二维区间\n\n算上时间这一维，问题转化为一个类 **三维偏序问题**，但是题限制了内存\n\n## Part1 K-D Tree\n\n限制了内存，很容易想到直接K-D Tree，实际运行也比较优秀\n\n注意可以把要询问的点拿出来建出K-D Tree，每次区间修改即可\n\n时间复杂度$O(n\\sqrt n)$，空间复杂度$O(n)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define pb push_back\ntypedef pair <int,int> Pii;\n#define mp make_pair\nvoid cmin(int &a,int b){ ((a>b)&&(a=b)); }\nvoid cmax(int &a,int b){ ((a<b)&&(a=b)); }\n\nchar IO;\nint rd(){\n\tint s=0;\n\twhile(!isdigit(IO=getchar()));\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn s;\n}\nconst int N=3e5+10,INF=1e9;\n\nint n,m,rt,col[N],opt[N],a[N],b[N];\nchar str[N];\nset <pair <int,int> > st,tmp;\nstruct Node{ int x,y; } A[N];\nint cmp1(Node a,Node b){ return mp(a.x,a.y)<mp(b.x,b.y); }\nint cmp2(Node a,Node b){ return mp(a.y,a.x)<mp(b.y,b.x); }\nint ch[N][2],lx[N],rx[N],ly[N],ry[N],s[N],t[N];\nint Build(int l,int r,int d=0) { \n\tif(l>r) return 0;\n\tint u=(l+r)>>1;\n    nth_element(A+l,A+u,A+r+1,d?cmp2:cmp1);\n\tch[u][0]=Build(l,u-1,d^1),ch[u][1]=Build(u+1,r,d^1);\n\tlx[u]=rx[u]=A[u].x,ly[u]=ry[u]=A[u].y;\n\tfor(int i:ch[u]) if(i) cmin(lx[u],lx[i]),cmin(ly[u],ly[i]),cmax(rx[u],rx[i]),cmax(ry[u],ry[i]);\n\treturn u;\n}\n\nvoid Upd(int x1,int x2,int y1,int y2,int u,int x) {\n\tif(!u || x1>rx[u] || x2<lx[u] || y1>ry[u] || y2<ly[u]) return;\n\tif(x1<=lx[u] && rx[u]<=x2 && y1<=ly[u] && ry[u]<=y2) return void(s[u]+=x);\n\tif(x1<=A[u].x && A[u].x<=x2 && y1<=A[u].y && A[u].y<=y2) t[u]+=x;\n\tfor(int i:ch[u]) Upd(x1,x2,y1,y2,i,x);\n}\nint Que(Node x,int u,int d=0) {\n\tif(A[u].x==x.x && A[u].y==x.y) return s[u]+t[u];\n\tint y=ch[u][!(d?cmp2(x,A[u]):cmp1(x,A[u]))];\n\treturn Que(x,y,d^1)+s[u];\n}\n\nint main(){\n\tn=rd(),m=rd();\n\tscanf(\"%s\",str+1);\n\trep(i,1,n) col[i]=str[i]-'0';\n\trep(i,1,n+1) {\n\t\tint r=i;\n\t\twhile(col[r]) r++;\n\t\tst.insert(mp(i,r));\n\t\ti=r;\n\t}\n\trep(i,1,m) {\n\t\tscanf(\"%s\",str+1);\n\t\tif(str[1]=='t') opt[i]=1,a[i]=rd();\n\t\telse opt[i]=2,a[i]=rd(),b[i]=rd(),tmp.insert(mp(a[i],b[i]));\n\t}\n\tn=0;\n\tfor(auto it:tmp) A[++n]=(Node){it.first,it.second};\n\trt=Build(1,n);\n\trep(i,1,m) {\n\t\tif(opt[i]==1) {\n\t\t\tint x=a[i];\n\t\t\tif(col[x]) {\n\t\t\t\tauto it=st.upper_bound(mp(x,INF)); it--;\n\t\t\t\tint l=it->first,r=it->second;\n\t\t\t\tst.erase(it);\n\t\t\t\tst.insert(mp(l,x)),st.insert(mp(x+1,r));\n\t\t\t\tUpd(l,x,x+1,r,rt,i);\n\t\t\t} else {\n\t\t\t\tauto it=st.upper_bound(mp(x,INF)),tmp=it; it--;\n\t\t\t\tint l=it->first,r=tmp->second; \n\t\t\t\tst.erase(it),st.erase(tmp);\n\t\t\t\tst.insert(mp(l,r)),Upd(l,x,x+1,r,rt,-i);\n\t\t\t}\n\t\t\tcol[x]^=1;\n\t\t} else {\n\t\t\tint ans=Que((Node){a[i],b[i]},rt);\n\t\t\tauto it=st.upper_bound(mp(a[i],INF)); it--;\n\t\t\tif(it->second>=b[i]) ans+=i;\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n}\n```\n\n\n\n## Part2 树套树(没有代码)\n\n由于已知查询的节点，树套树的内存可以优化到$O(n\\log n)$\n\n把要询问的点拉出来，每次询问在第二维中有$\\log n$次单点查询，所以需要被查询的位置一共只有$n\\log n$个\n\n把这些会被查询的位置拿出来建成$n$棵静态的线段树，更新就直接在这些静态的线段树上区间更新即可\n\n时间复杂度$O(n\\log ^2 n)$，空间复杂度$O(n\\log n)$\n\n\n\n## Part3 CDQ+树状数组\n\n是常规写法，不会被限制内存\n\nCDQ一维，排序一维，树状数组一维，参见[三维偏序](https://www.luogu.com.cn/problem/P3810)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「BalticOI 2020」小丑","url":"/2021/05/21/「BalticOI 2020」小丑/","content":"# 「BalticOI 2020」小丑\n\n## Analysis\n\n问题即考虑加入一个边集，判断是否是二分图\n\n容易想到用带权并查集/LCT 之类的结构维护\n\n考虑对于每个左端点/右端点 维护最长的有解区间$R_i/L_i$\n\n$L_i,R_i$显然具有单调性\n\n就可以$O(1)$完成查询\n\n下文认为$n,m$同阶\n\n## Sol1 LCT\n\n考虑尺取，同时用$\\text{LCT}$暴力维护答案合法性，下面只讲$\\text{LCT}$实现\n\n考虑对于所有的边，优先加入树上，对于每一个环，只保留最后被删除的边\n\n这样可以保证一条边被删除时，两个连通块之间没有边\n\n同时，维护每一个连通块内的奇环边 最优集合 即可\n\n复杂度为$O(n\\log n)$，速度。。。。\n\n\n\n## Sol2 分治决策单调性/整体二分\n\n考虑用并查集维护二分图，求出$R_i$，对于$i\\in [l,r]$，已知答案区间为$[L,R]$\n\n通过枚举来找到$[l,r]$中答案分别为$[L,mid),[mid,R]$的两部分的界点$p$\n\n为此我们加入$[mid+1,m]$的边，然后依次加入$[1,r]$的边，直到出现方案\n\n直接维护复杂度显然是错的\n\n因此考虑在分治过程中，保证分治$[l,r],[L,R]$时，$[1,l-1],[R+1,m]$的边集已经加入\n\n此时每次操作需要移动的范围在$[l,r],[L,R]$以内\n\n分治共$\\log n$层，每层长度总和为$n$，因此移动次数为$O(n\\log n)$\n\n由于需要维护简单的回撤操作，可以用按秩合并并查集，因此总复杂度为$O(n\\log ^2n)$\n\n[Loj Submission](https://loj.ac/s/1085800)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「BalticOI 2020」混合物 ","url":"/2021/05/21/「BalticOI 2020」混合物 /","content":"# 「BalticOI 2020」混合物 \n\n题目大意：\n\n对于给定的向量$\\vec{O}=(x,y,z)$\n\n动态维护一个集合$S=\\{(x_i,y_i,z_i)\\}$\n\n求出最少用几个$S$中的元素能够 **实数正系数** 线性组合得到$O$\n\n考虑令$\\displaystyle x'=\\frac{x}{x+y+z},y'=\\frac{y}{x+y+z}$，显然$x,y$能够完成组合，$z$就一定成立\n\n此时，问题转化为了一个平面问题，答案分为几种情况\n\n1.$S$包含$O$，答案显然为1\n\n2.$O$在$S$中两点构成的线段上，显然答案为2\n\n3.$O$被某一个三角形包含，答案为3\n\n4.无解\n\n不妨令$T=\\{P-O|P\\in S\\}$，此时\n\n情况1即$T$包含原点\n\n情况2即$T$中某两点与原点共线且在原点两端\n\n情况3即$S$构成的凸包包含原点\n\n因为只需要判断是否包含，所以其实和凸包并没有关系\n\n考虑不包含的情况，则显然可以用一个 以原点为界的**半平面** 包住$S$中的所有点\n\n因此可以维护每个点的极角，判断是否可以用半平面完全包含\n\n实现上，完全包含可以认为是$\\max-\\min<\\pi$\n\n或者是半平面跨过极角为$0$的位置，此时令$x,y$分别为$<\\pi$最大值，$>\\pi$最小值\n\n能包含即$x+2\\pi-y<\\pi$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double db;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) f|=IO=='-';\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=2e5+10,INF=1e9+10;\nconst db eps=1e-9,PI=acos((db)-1);\n\nint n;\nstruct Node{\n\tdb x,y;\n\tNode(){}\n\tNode(db x,db y):x(x),y(y){}\n\tNode operator - (const Node &t) const { return Node(x-t.x,y-t.y); }\n\tdb angle(){ \n\t\tdb t=atan2(y,x);\n\t\tif(t<-eps) t+=2*PI;\n\t\treturn t;\n\t}\n} O,A[N];\nNode Read() {\n\tdb a=rd(),b=rd(),c=rd(),s=a+b+c;\n\treturn Node(a/s,b/s);\n}\n\nint cnt1,cnt2;\nchar op[2];\nstruct cmp{ bool operator () (const db &x,const db &y) const { return x+eps<y; } };\nmultiset <db,cmp> st;\ndb Go(db x){\n\tx+=PI;\n\tif(x>=2*PI) x-=2*PI;\n\treturn x;\n}\nvoid Ins(Node x){\n\tif(fabs(x.x)<eps && fabs(x.y)<eps) return void(cnt1++);\n\tdb y=x.angle();\n\tif(st.find(y)==st.end() && st.find(Go(y))!=st.end()) cnt2++;\n\tst.insert(y);\n}\n\nvoid Del(Node x){\n\tif(fabs(x.x)<eps && fabs(x.y)<eps) return void(cnt1--);\n\tdb y=x.angle();\n\tst.erase(st.find(y));\n\tif(st.find(y)==st.end() && st.find(Go(y))!=st.end()) cnt2--;\n}\n\nint main(){\n\tO=Read();\n\trep(_,1,rd()) {\n\t\tscanf(\"%s\",op);\n\t\tif(*op=='A') Ins(A[++n]=(Read()-O));\n\t\telse Del(A[rd()]);\n\t\tif(cnt1) puts(\"1\");\n\t\telse if(cnt2) puts(\"2\");\n\t\telse {\n\t\t\tint f=1;\n\t\t\tif(st.empty()) f=0;\n\t\t\telse {\n\t\t\t\tif(*st.rbegin()-*st.begin()<PI+eps) f=0;\n\t\t\t\telse {\n\t\t\t\t\tauto y=st.upper_bound(PI),x=y; x--;\n\t\t\t\t\tif(*x+2*PI-*y<PI+eps) f=0;\n\t\t\t\t} \n\t\t\t}\n\t\t\tputs(f?\"3\":\"0\");\n\t\t} \n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「BalticOI 2020」病毒","url":"/2021/05/21/「BalticOI 2020」病毒/","content":"# 「BalticOI 2020」病毒\n\n设点集大小为$N$，边集总长度$\\sum k=M$，模板串总长$L=\\sum ℓ$\n\n涉及到多串匹配的转移问题，容易想到$\\text{AC}$自动机\n\n因为本题状态非常少，可以暴力矩阵维护转移，暴力计算由状态$i$转移至状态$j$，且中途不匹配的最小长度\n\n有$NL^2$个状态\n\n给定的是一张有向图，可以用奇怪的$\\text{Bellman-Ford,Dijkstra}$完成暴力转移\n\n复杂度未知。。。上界应该比较高，但是鉴于常数小可以通过\n\n$$ \\ $$\n\n$$\\ $$\n\n优化的转移：把每一条边的前缀拆出来，建立虚点\n\n这样以来，所有状态转移可以归纳为 虚点+实点 $\\to$ 虚点/实点\n\n一共有$(N+M)L^2$个状态，$(N+M)L^2$种转移，每种转移涉及两个元素，产生$L$个元素\n\n故对于每种转移的每一方，被遍历时都要枚举依次转移，共有$2(N+M)L^3$次转移\n\n因此可以认为建立的图有$(N+M)L^2$个点，$2(N+M)L^3$条边\n\n对此运行 类似 最短路算法即可\n\n因此用$\\text{Dijkstra}$维护转移的复杂度为$O(\\ (N+M)L^3\\ \\log ((N+M)L^2)\\ )$\n\n$$ \\ $$\n\n---以下是未优化Bellman-Ford代码----\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ll;\n#define pb push_back\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) f|=IO=='-';\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=110,M=54;\n\n\nint n,m,k;\ntypedef vector <int> V;\nint trie[M][2],fail[M],mk[M],cnt;\nvoid Ins(const V &S){\n\tint now=0;\n\tfor(int i:S) {\n\t\tint &nxt=trie[now][i];\n\t\tif(!nxt) nxt=++cnt;\n\t\tnow=nxt;\n\t}\n\tmk[now]=1;\n}\nvoid Build(){\n\tstatic queue <int> que;\n\trep(i,0,1) if(trie[0][i]) que.push(trie[0][i]);\n\twhile(!que.empty()) { \n\t\tint u=que.front(); que.pop();\n\t\tmk[u]|=mk[fail[u]];\n\t\trep(i,0,1){\n\t\t\tint &v=trie[u][i];\n\t\t\tif(v) que.push(v);\n\t\t\t(!v?v:fail[v])=trie[fail[u]][i];\n\t\t}\n\t}\n    // delete illegal state\n\trep(i,0,cnt) rep(j,0,1) if(mk[trie[i][j]]) trie[i][j]=cnt+1;\n}\n\nV Read(){\n\tV Res;\n\trep(i,1,rd()) Res.pb(rd());\n\treturn Res;\n}\n\nvector <V> G[N];\nint E[N][N];\nconst ll INF=-1;\nll dis[N][M][M],ans[N];\nint fl=1;\nvoid Work(int u){\n\tstatic ll F[M][M],G[M][M];\n\tll f=INF;\n\tfor(V S:(::G[u])) {\n\t\tmemset(F,255,sizeof F);\n\t\trep(i,0,cnt) F[i][i]=0;\n\t\tfor(int c:S) {\n\t\t\trep(i,0,cnt) rep(j,0,cnt) G[i][j]=F[i][j],F[i][j]=INF;\n\t\t\trep(i,0,cnt) rep(j,0,cnt) if(G[i][j]<INF) \n\t\t\t\trep(k,0,cnt) if(G[i][j]+dis[c][j][k]>=max(G[i][j],dis[c][j][k])) \n\t\t\t\t\tcmin(F[i][k],G[i][j]+dis[c][j][k]);\n\t\t}\n\t\trep(i,0,cnt) rep(j,0,cnt) if(dis[u][i][j]>F[i][j]) dis[u][i][j]=F[i][j],cmin(f,F[i][j]);\n\t}\n\tif(f!=INF) fl=1;\n}\n\nint main(){\n\tn=rd()-1,m=rd(),k=rd();\n\trep(i,1,m) {\n\t\tint u=rd(); V w=Read();\n\t\tG[u].pb(w);\n\t\tfor(int v:w) E[v][u]=1;\n\t}\n\trep(i,1,k) Ins(Read());\n\tBuild();\n\tmemset(dis,255,sizeof dis),memset(ans,255,sizeof ans);\n\trep(u,0,1) rep(i,0,cnt) if(!mk[i]) dis[u][i][trie[i][u]]=1;\n\twhile(fl){\n\t\tfl=0;\n\t\trep(i,2,n) Work(i);\n\t}\n\trep(i,2,n) rep(j,0,cnt) if(!mk[j]) cmin(ans[i],dis[i][0][j]);\n\trep(i,2,n) {\n\t\tif(ans[i]==INF) puts(\"YES\");\n\t\telse printf(\"NO %llu\\n\",ans[i]);\n\t}\n}\n```\n\n\n\n----以下是无比垃圾的优化代码----\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ll;\n#define pb push_back\ntypedef pair <int,int> Pii;\n#define mp make_pair\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\nchar IO;\nint rd(){\n\tint s=0;\n\twhile(!isdigit(IO=getchar()));\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn s;\n}\n\nconst int N=210,M=52;\nconst ll INF=-1;\n\nint n,m,k,c;\ntypedef vector <int> V;\nint trie[M][2],fail[M],mk[M],cnt;\nvoid Ins(const V &S){\n\tint now=0;\n\tfor(int i:S) {\n\t\tint &nxt=trie[now][i];\n\t\tif(!nxt) nxt=++cnt;\n\t\tnow=nxt;\n\t}\n\tmk[now]=1;\n}\nvoid Build(){\n\tstatic queue <int> que;\n\trep(i,0,1) if(trie[0][i]) que.push(trie[0][i]);\n\twhile(!que.empty()) { \n\t\tint u=que.front(); que.pop();\n\t\tmk[u]|=mk[fail[u]];\n\t\trep(i,0,1){\n\t\t\tint &v=trie[u][i];\n\t\t\tif(v) que.push(v);\n\t\t\t(!v?v:fail[v])=trie[fail[u]][i];\n\t\t}\n\t}\n\tmk[cnt+1]=1;\n\trep(i,0,cnt) rep(j,0,1) if(mk[i] || mk[trie[i][j]]) trie[i][j]=cnt+1;\n}\n\nV Read(){\n\tV Res;\n\trep(i,1,rd()) Res.pb(rd());\n\treturn Res;\n}\n\nvector <Pii> G[N];\nll dis[N][M][M];\nstruct Node{\n\tint u,s,t;\n\tll d;\n\tbool operator < (const Node &__) const {\n\t\treturn d>__.d;\n\t}\n};\npriority_queue <Node> que;\nvoid Upd(int u,int s,int t,ll d){\n\tif(mk[s]||mk[t]||dis[u][s][t]<=d) return;\n\tdis[u][s][t]=d,que.push((Node){u,s,t,d});\n}\n\nint main(){\n\tc=n=rd()-1,m=rd(),k=rd();\n\t++c; // 建立一个空虚点\n\trep(i,1,m) {\n\t\tint u=rd(); V w=Read();\n\t\tint lst=n+1;\n\t\trep(j,0,w.size()-1) {\n\t\t\tif(j==jend) G[lst].pb(mp(w[j],u)),G[w[j]].pb(mp(lst,u));\n\t\t\telse G[lst].pb(mp(w[j],++c)),G[w[j]].pb(mp(lst,c)),lst=c;\n\t\t}\n\t}\n\trep(i,1,k) Ins(Read());\n\tBuild();\n\tmemset(dis,255,sizeof dis);\n\trep(i,0,cnt) if(!mk[i]) dis[n+1][i][i]=0; // 单位矩阵\n\trep(u,0,1) rep(i,0,cnt) Upd(u,i,trie[i][u],1);\n\twhile(!que.empty()) {\n\t\tint u=que.top().u,s=que.top().s,t=que.top().t;\n\t\tll d=que.top().d;  que.pop();\n\t\tif(d>dis[u][s][t]) continue;\n\t\tfor(auto i:G[u]) {\n\t\t\tint v=i.first,to=i.second;\n\t\t\tif(u<=n) {\n\t\t\t\trep(i,0,cnt) if(dis[v][i][s]<INF) Upd(to,i,t,dis[v][i][s]+d);\n\t\t\t} else {\n\t\t\t\trep(i,0,cnt) if(dis[v][t][i]<INF) Upd(to,s,i,d+dis[v][t][i]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,2,n) {\n\t\tll ans=-1;\n\t\trep(j,0,cnt) if(!mk[j]) ans=min(ans,dis[i][0][j]);\n\t\tif(ans==INF) puts(\"YES\");\n\t\telse printf(\"NO %llu\\n\",ans);\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「CEOI2018」斐波那契表示法","url":"/2021/05/21/「CEOI2018」斐波那契表示法/","content":"# 「CEOI2018」斐波那契表示法\n\n思路：维护当前数值的唯一表示法，然后根据唯一表示法来确定答案\n\n### Part1 唯一表示法\n\n任何一个数$x$有唯一表示$P_i$，满足$x=\\sum F_{P_i},P_i<P_{i+1}-1$\n\n即不会出现相邻两项\n\n依次插入每一个数$x$，考虑可能出现的情况\n\n1.$x$一位以及前后为空，那么直接插入\n\n2.$x$一位为空，且$x-1$为空，$x+1$已经出现\n\n删除$x+1$，插入$x+2$\n\n\n\n3.$x$一位为空，且$x+1$为空，$x-1$已经出现\n\n删除$x-1$，插入$x+1$\n\n4.$x$一位有\n\n先删除$x$，然后插入$x+1,x-2$\n\n对于操作1,2,3以及4中的$x+1$，每次操作增加$O(1)$个元素，每次递归进行删除$O(1)$个元素\n\n操作次数为均摊$O(n)$\n\n对于$4$操作中的$x-2$，如果$x-2$已经出现就会不断进行递归\n\n最终的效果就是所有被操作到的$x-2,x-4,x-6\\ldots$向右平移了一位\n\n~~大致如此，实际情况比较复杂，要讨论x-2=0,x-2<0等等情况~~\n\n用一棵平衡树维护$P_i-P_{i-1}$的值即可，4操作可以二分左边第一个>2的元素，然后进行平移\n\n最终复杂度为$O(n\\log n)$\n\n$$ \\ $$\n\n### Part2 dp求答案\n\n令边界$P_0=0$，根据上面维护的$\\delta_i=P_i-P_{i-1}$\n\n考虑根据$\\delta_i$求解答案\n\n显然一个数$x$可以下分为$x$或者$x-1,x-2$ 或 $x-1,x-3,x-4$ 或$x-1,x-3,x-5,x-6\\ldots$\n\n且不能碰到前面的数\n\n简单分析发现$P_i$有$\\lceil \\frac{\\delta_i}{2}\\rceil $种下分方案\n\n然而，$P_{i-1}$如果被下分，那么$P_{i-1}$这一位会消失，变成$P_{i-1}-1$作为限制点\n\n也就是说，$P_{i-1}$的下分会影响到$\\delta_i$，使得$\\delta_i\\rightarrow \\delta_i+1$\n\n那么依次考虑每个$\\delta_i$，令$dp_{i,f}$表示前$i$个，最后一个是否下分的方案数，可以$dp$求解\n\n由于要动态维护，因此可以考虑用一个类似矩阵的东西来维护区间的dp情况\n\n在平衡树中$up$维护答案即可\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair <int,int> Pii;\n#define reg register\n#define mp make_pair\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\nchar IO;\ntemplate <class T=int> T rd(){\n    T s=0; int f=0;\n    while(!isdigit(IO=getchar())) f|=IO=='-';\n    do s=(s<<1)+(s<<3)+(IO^'0');\n    while(isdigit(IO=getchar()));\n    return f?-s:s;\n}\n\nconst int N=4e5+10,P=1e9+7;\n\nint n;\nstruct Node{\n    int l,r,ma,len;\n    int a[2][2];\n    void clear(){ memset(a,0,sizeof a); }\n    Node(){ } \n    Node(int x){\n        l=r=ma=len=x;\n        rep(i,0,1) {\n            a[i][0]=1;\n            a[i][1]=(x-1+i)/2;\n        }\n    }\n    Node operator + (const Node _) const {\n        Node res; res.l=l,res.r=_.r,res.ma=max(ma,_.ma),res.len=len+_.len;\n        res.a[0][0]=(1ll*a[0][0]*_.a[0][0]+1ll*a[0][1]*_.a[1][0])%P;\n        res.a[1][0]=(1ll*a[1][0]*_.a[0][0]+1ll*a[1][1]*_.a[1][0])%P;\n        res.a[0][1]=(1ll*a[0][0]*_.a[0][1]+1ll*a[0][1]*_.a[1][1])%P;\n        res.a[1][1]=(1ll*a[1][0]*_.a[0][1]+1ll*a[1][1]*_.a[1][1])%P;\n        return res;\n    }\n} s[N],val[N];\n\nint rt,ls[N],rs[N],key[N];\nvoid Up(int x){\n    s[x]=val[x];\n    if(ls[x]) s[x]=s[ls[x]]+s[x];\n    if(rs[x]) s[x]=s[x]+s[rs[x]];\n}\nint U(int x,int y){\n    if(!x||!y) return x|y;\n    if(key[x]<key[y]) return rs[x]=U(rs[x],y),Up(x),x;\n    return ls[y]=U(x,ls[y]),Up(y),y;\n}\n\nPii Lower(int x,int len){\n    if(len<=0 || !x) return mp(0,x);\n    if(s[x].len<=len) return mp(x,0);\n    if(s[ls[x]].len>=len) {\n        Pii y=Lower(ls[x],len);\n        return ls[x]=y.second,Up(x),mp(y.first,x);\n    } else {\n        Pii y=Lower(rs[x],len-s[ls[x]].len-val[x].len);\n        return rs[x]=y.first,Up(x),mp(x,y.second);\n    }\n}\n\nvoid EraseEnd(int &x){\n    if(!rs[x]){ x=ls[x]; return; }\n    static int T[N],C;\n    for(int y=x;y;y=rs[y]) T[++C]=y;\n    rs[T[C-1]]=ls[T[C]];\n    drep(i,C-1,1) Up(T[i]);\n    C=0;\n}\nvoid AddR(int x,int y){\n    if(!x) return;\n    if(rs[x]) return AddR(rs[x],y),Up(x);\n    val[x]=Node(val[x].len+y),Up(x);\n}\nvoid AddL(int x,int y){\n    if(!x) return;\n    if(ls[x]) return AddL(ls[x],y),Up(x);\n    val[x]=Node(val[x].len+y),Up(x);\n}\n\nPii Split(int x){\n    if(s[x].ma<=2) return mp(0,x);\n    if(val[x].ma<=2 && s[rs[x]].ma<=2) {\n        Pii y=Split(ls[x]);\n        return ls[x]=y.second,Up(x),mp(y.first,x);\n    } else {\n        Pii y=Split(rs[x]);\n        return rs[x]=y.first,Up(x),mp(x,y.second);\n    }\n}\nPii Split2(int x){\n    if(s[x].ma<=2) return mp(x,0);\n    if(s[ls[x]].ma>2 || val[x].ma>2) {\n        Pii y=Split2(ls[x]);\n        return ls[x]=y.second,Up(x),mp(y.first,x);\n    } else {\n        Pii y=Split2(rs[x]);\n        return rs[x]=y.first,Up(x),mp(x,y.second);\n    }\n}\nint New(int x){ return key[++n]=rand(),s[n]=val[n]=Node(x),n; }\n\nvoid Ins(int x){\n    if(x<0) return;\n    cmax(x,1);\n    if(!rt) { rt=New(x); return; }\n    if(s[rt].len<x-1) {\n        rt=U(rt,New(x-s[rt].len));\n        return;\n    }\n    if(s[rt].len==x-1) {\n        EraseEnd(rt);\n        return Ins(x+1);\n    }\n    Pii t=Lower(rt,x);\n    if(s[t.first].len!=x) {\n        if(x>1) {\n            Pii y=Lower(t.first,x-1);\n            if(s[y.first].len==x-1) {\n                AddR(y.first,s[y.second].len),rt=U(y.first,t.second);\n                return Ins(x+1);\n            } \n            t.first=U(y.first,y.second);\n        }\n        if(s[t.first].len==x+1) {\n            Pii y=Split2(t.second);\n            AddL(y.second,-1);\n            int d=s[t.first].r+s[y.first].len+1;\n            EraseEnd(t.first);\n            rt=U(U(t.first,New(d)),y.second);\n            return;\n        }\n        int d=s[t.first].len-x;\n        AddR(t.first,-d);\n        rt=U(U(t.first,New(d)),t.second);\n        return;\n    }\n    if(s[t.second].l==2) return AddL(t.second,s[t.first].r),EraseEnd(t.first),rt=U(t.first,t.second),Ins(x+1),Ins(x-2);\n    Pii y=Split(t.first); AddL(t.second,-1);\n    if(!y.first) {\n        if(s[y.second].l==1) {\n            AddL(y.second,1),rt=U(y.second,t.second);\n            return;\n        }\n        rt=U(U(New(1),y.second),t.second);\n        return;\n    } \n    if(s[y.first].len>3 && s[y.first].r==3) {\n        EraseEnd(y.first),AddR(y.first,2);\n        rt=U(U(U(y.first,New(2)),y.second),t.second);\n        return;\n    }\n    AddR(y.first,-2);\n    rt=U(U(U(y.first,New(3)),y.second),t.second);\n}\n\n\nint main(){\n    rep(kase,1,rd()) Ins(rd()),printf(\"%d\\n\",(s[rt].a[0][0]+s[rt].a[0][1])%P);\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「CCO 2020」购物计划","url":"/2021/05/21/「CCO 2020」购物计划/","content":"# 「CCO 2020」购物计划\n\n核心思想：堆+调整临近\n\n### $x_i=y_i=1$\n\n 这个限制相当于每一组内的权值排名可以确定，设组内为$A_{i,j}(j\\ge 1)$\n\n那么我们一个方案的选择可以用$M$个指针$P_i$表示，和为$\\displaystyle \\sum A_{i,P_i}$\n\n考虑用调整的方式解决这个问题，大体思路上，我们可以记录当前移动指针$P_p$\n\n每次可以选择移动$P_p$，或者某一个$P_{i},i>p$\n\n如果直接进行，每次移动的指针数量是$O(m)$级别的，显然不可行\n\n考虑优化一下进行，每次只能选取$i=p+1$\n\n此时，编号小的会先被移动\n\n为了保证答案单调性，我们需要将$A_{i,2}-A_{i,1}$较小的组先移动\n\n同时，并不是每一个组都会被移动，因此转移还要支持一个**特殊回撤操作**，来撤回当前组的指针\n\n也就是说，若$P_p=2$，可以选择把$P_p$回撤为$1$，然后将$P_{p+1}$改为$2$\n\n由此，每个点状态可以选择：\n\n1.移动自己\n\n2.移动下一个\n\n3.若$P_p=2$，回撤自己，同时移动下一个\n\n这样的调整法，可以保证每一个状态恰好有一个前驱，且转移过程中值不断变大\n\n由此可以$O(k)$状态数进行调整，用堆维护，复杂度为$O(k\\log k)$\n\n$$ \\ $$\n\n### 组内调整\n\n一个组内会选择若干个数$A_{b_i},i\\in [1,c]$\n\n初始最小值，显然满足$b_i=i$\n\n类似的，我们记录当前指针$p$，前驱指针$l$，后继指针$r$\n\n显然$p$要往后移，且不能达到$r$，因此决策只有两种\n\n1.移动前驱$l$，并将当前指针变为前驱\n\n2.移动自己$p$\n\n这样的调整是固定个数的，因此，一开始就把$c\\in[x_i,y_i]$的所有情况插入即可\n\n\n\n$$ \\ $$\n\n最后，将两部分一同进行，每次组间调整时，通过组内调整查询答案\n\n总的组内和组间调整次数均为$O(k)$，状态数分别不超过$2k,3k$\n\n复杂度为$O(k\\log k)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\nchar IO;\nint rd(){\n    int s=0;\n    while(!isdigit(IO=getchar()));\n    do s=(s<<1)+(s<<3)+(IO^'0');\n    while(isdigit(IO=getchar()));\n    return s;\n}\nenum{N=200010,LINF=1ll<<60};\n\nint n,m,k,I[N]; ll L;\nstruct Group{\n    vector <int> A;\n    int l,r,c;\n    struct Node{\n        int l,p,r; ll s;\n        bool operator < (const Node &__) const { return s>__.s; }\n    };\n    priority_queue <Node> que;\n    vector <ll> V;\n    void Init(){\n        l=rd(),r=rd(),sort(A.begin(),A.end()),c=A.size();\n        if(c<l) {\n            rep(i,1,k) puts(\"-1\");\n            exit(0);\n        }\n        r=min(r,c);\n        rep(i,0,l-1) L+=A[i];\n        ll s=0;\n        if(!l) V.pb(0);\n        rep(i,0,c-1) {\n            if(i>=r) break;\n            s+=A[i];\n            if(i>=l-1) que.push((Node){i-1,i,c-1,s});\n        }\n    }\n    void Next(){\n        if(que.empty()) return V.pb(LINF);\n        Node t=que.top(); que.pop();\n        V.pb(t.s);\n        if(t.p<t.r) que.push((Node){t.l,t.p+1,t.r,t.s-A[t.p]+A[t.p+1]}); // Move current point\n        if(~t.l && t.l<t.p-1) que.push((Node){t.l-1,t.l+1,t.p-1,t.s-A[t.l]+A[t.l+1]}); // Move previous point \n    }\n    // get kth sum\n    ll operator [] (const int &k){\n        while((int)V.size()<k) Next();\n        return V[k-1];\n    }\n} S[N];\n\nstruct Node{\n    int x,y; ll s;\n    bool operator < (const Node &__) const { return s>__.s; }\n};\npriority_queue <Node> que;\n\nint main(){\n    n=rd(),m=rd(),k=rd();\n    rep(i,1,n) { int x=rd(); S[x].A.pb(rd()); }\n    rep(i,1,m) S[i].Init();\n    printf(\"%lld\\n\",L),k--;\n    rep(i,1,m) I[i]=i;\n    sort(I+1,I+m+1,[&](int x,int y){ return S[x][2]-S[x][1]<S[y][2]-S[y][1]; });\n    que.push((Node){1,2,L-S[I[1]][1]+S[I[1]][2]});\n    while(k) {\n        Node t=que.top(); que.pop();\n        if(t.s>=LINF) break;\n        k--,printf(\"%lld\\n\",t.s);\n        int i=I[t.x],j=I[t.x+1];\n        que.push((Node){t.x,t.y+1,t.s-S[i][t.y]+S[i][t.y+1]});// Move current point\n        if(j) que.push((Node){t.x+1,2,t.s-S[j][1]+S[j][2]}); // Move next point\n        if(t.y==2 && j) que.push((Node){t.x+1,2,t.s-S[i][2]+S[i][1]-S[j][1]+S[j][2]}); \n        // Back current point ,and move next point\n    }\n    while(k--) puts(\"-1\");\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「CCO 2020」千山万壑","url":"/2021/05/21/「CCO 2020」千山万壑/","content":"# 「CCO 2020」千山万壑\n\n### 性质推演\n\n#### 推论1:不选择非树边时，答案为$2(n-1)-$直径长\n\n比较明显就不证了\n\n#### 推论2:最多只会选择一条非树边\n\n考虑如果选择两条非树边，此时必然有答案$\\ge n-1+3\\lceil\\frac{n}{3}\\rceil$\n\n因为能够选择这样的非树边，则必然存在一条长度$>\\frac{n}{3}$的路径，也就是说\n\n直径长度$>\\frac{n}{3}$，故此时选择直径更优\n\n因此不会选择两条非树边\n\n$$ \\  $$\n\n#### 答案计算\n\n下称起点终点路径$(s,t)$，选择的边为$(u,v,w)$\n\n如果$(s,t)$与$(u,v)$无交，则无序额外计算贡献，此时贡献为\n\n$2(n-1)-dis(s,t)-(dis(u,v)-w)$\n\n当$(s,t)$与$(u,v)$有交时，设交长度为$len$，则需要额外花费$2(len-1)$的代价取遍历交部分的点\n\n![](https://10.220.121.125/up/img/tree-pic1.png)\n\n$$ \\ $$\n\n### 求解\n\n显然我们需要先知道$dis(u,v)$，可以$O(n)$预处理，我们选择的非树边一定满足$dis(u,v)>w$\n\n考虑抽直径构成序列$L_i$，然后考虑每一条非树边$(u,v,w)$的贡献，设$u,v$在直径上对应根的编号为$x,y$\n\n如果$x=y$，显然可以选择直径，下面讨论$x<y$的情况\n\n1.$(s,t)$与$(u,v)$无交\n\n1-1.对于$(u,v)$之间的部分可以区间查询最值\n\n1-2.两边预处理前缀/后缀最值\n\n1-3.直径连接到$u$，$v$子树的部分的答案可以换根$dp$预处理\n\n2.$(s,t)$与$(u,v)$有交，设交部分在直径上的区间为$[l,r]$\n\n![](http://10.220.121.125/up/img/tree-pic2.png)\n\n2-1. 相交跨过直径上多个点\n\n2-1-1.若$x<l<r<y$，此时容易用线段树维护答案\n\n![](http://10.220.121.125/up/img/tree-pic3.png)\n\n2-1-2. 若$x<y , \\text{and   } (l=x \\text{   or  } r=y)$，此时显然两边部分最优一定是选择在直径上的部分\n\n![](http://10.220.121.125/up/img/tree-pic4.png)\n\n以下情况一定不优\n\n![](http://10.220.121.125/up/img/tree-pic5.png)\n\n另一边的答案可以在线段树上查询出来，是一个区间的前缀/后缀\n\n2-2.若$l=r$，此时$l=x$或$l=y$，且在$[u,x],[v,y]$部分有交\n\n![](http://10.220.121.125/up/img/tree-pic6.png)\n\n容易发现，此时确定$(s,t)$一边一定在直径的一端，另一端$x,y$对应的子树中\n\n同样可以通过换根$dp$解决\n\n区间查询，如果使用线段树解决，复杂度为$O(n+m\\log n)$\n\n如果用奇怪数据结构~~（猫树）~~，复杂度为$O(n\\log n+m)$\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 「CCO 2020」千山万壑\n\n### 性质推演\n\n#### 推论1:不选择非树边时，答案为$2(n-1)-$直径长\n\n比较明显就不证了\n\n#### 推论2:最多只会选择一条非树边\n\n考虑如果选择两条非树边，此时必然有答案$\\ge n-1+3\\lceil\\frac{n}{3}\\rceil$\n\n因为能够选择这样的非树边，则必然存在一条长度$>\\frac{n}{3}$的路径，也就是说\n\n直径长度$>\\frac{n}{3}$，故此时选择直径更优\n\n因此不会选择两条非树边\n\n$$ \\  $$\n\n#### 答案计算\n\n下称起点终点路径$(s,t)$，选择的边为$(u,v,w)$\n\n如果$(s,t)$与$(u,v)$无交，则无序额外计算贡献，此时贡献为\n\n$2(n-1)-dis(s,t)-(dis(u,v)-w)$\n\n当$(s,t)$与$(u,v)$有交时，设交长度为$len$，则需要额外花费$2(len-1)$的代价取遍历交部分的点\n\n![Snipaste_2021-03-03_09-44-08.png](https://i.loli.net/2021/03/03/CF5b2LK37qRpgyx.png)\n\n$$ \\ $$\n\n### 求解\n\n显然我们需要先知道$dis(u,v)$，可以$O(n)$预处理，我们选择的非树边一定满足$dis(u,v)>w$\n\n考虑抽直径构成序列$L_i$，然后考虑每一条非树边$(u,v,w)$的贡献，设$u,v$在直径上对应根的编号为$x,y$\n\n确定非树边之后，我们需要选择一个最优的$(s,t)$，答案计算上面已经提及\n\n如果$x=y$，显然可以选择直径，下面讨论$x<y$的情况\n\n1.$(s,t)$与$(u,v)$无交\n\n1-1.对于$(u,v)$之间的部分可以区间查询子树最值\n\n1-2.两边预处理前缀/后缀最值\n\n1-3.直径连接到$u$，$v$子树的部分的答案\n\n就是一棵树剔除根到一个点路径之后的直径长度，可以换根$dp$预处理\n\n2.$(s,t)$与$(u,v)$有交，设交部分在直径上的区间为$[l,r]$\n\n容易参分转化为求解：$dis(s,t)+dis(u,v)-w-2(r-l)+2$最大值\n\n![Snipaste_2021-03-03_09-58-39.png](https://i.loli.net/2021/03/03/G8TPMO6XjUlHCW7.png)\n\n2-1. 相交跨过直径上多个点\n\n2-1-1.若$x<l<r<y$，此时容易用线段树维护答案\n\n合并时减去跨过长度的贡献即可\n\n![Snipaste_2021-03-03_10-00-38.png](https://i.loli.net/2021/03/03/hdlGsfQ4eFicT8D.png)\n\n2-1-2. 若$x<y , \\text{and   } (l=x \\text{   or  } r=y)$，此时显然两边部分最优一定是选择在直径上的部分\n\n![Snipaste_2021-03-03_10-01-17.png](https://i.loli.net/2021/03/03/o5itfJTen9XFCVO.png)\n\n以下情况一定不优\n\n![Snipaste_2021-03-03_10-03-49.png](https://i.loli.net/2021/03/03/EnsIrueTi5qJpYd.png)\n\n另一边的答案可以在线段树上查询出来，是一个区间的前缀/后缀\n\n2-2.若$l=r$，此时$l=x$或$l=y$，且在$[u,x],[v,y]$部分有交\n\n![Snipaste_2021-03-03_10-05-43.png](https://i.loli.net/2021/03/03/pOANxDCRHG5d6E2.png)\n\n容易发现，此时确定$(s,t)$一边一定在直径的一端，另一端$x,y$对应的子树中\n\n同样可以通过换根$dp$解决\n\n区间查询，如果使用线段树解决，复杂度为$O(n+m\\log n)$\n\n如果用奇怪数据结构~~（猫树）~~，复杂度为$O(n\\log n+m)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair <int,int> Pii;\n#define reg register\n#define mp make_pair\n#define pb push_back\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) f|=IO=='-';\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=5e5+10,M=2e6+10,INF=1e9+10;\n\n\nint n,m;\nint U[M],V[M],W[M],D[M],vis[N];\n\nstruct Edge{\n\tint to,nxt;\n} e[N<<1];\nint head[N],ecnt;\nvoid AddEdge(int u,int v){\n\te[++ecnt]=(Edge){v,head[u]};\n\thead[u]=ecnt;\n}\n\nint ma,num,fa[N],dep[N];\nvector <Pii> G[N];\nint Find(int x){ return fa[x]==x?x:fa[x]=Find(fa[x]); }\nvoid dfs1(int u,int f){\n\tif(dep[u]>ma) ma=dep[u],num=u;\n\tvis[fa[u]=u]=1;\n\tfor(Pii v:G[u]) if(vis[v.first]) D[v.second]=dep[u]+dep[v.first]-2*dep[Find(v.first)];\n\tfor(int i=head[u];i;i=e[i].nxt) {\n\t\tint v=e[i].to;\n\t\tif(v==f) continue;\n\t\tdep[v]=dep[u]+1,dfs1(v,u);\n\t}\n\tfa[u]=f;\n}\nvoid dfs2(int u,int f){\n\tif(dep[u]>ma) ma=dep[u],num=u;\n\tfa[u]=f;\n\tfor(int i=head[u];i;i=e[i].nxt) {\n\t\tint v=e[i].to;\n\t\tif(v==f) continue;\n\t\tdep[v]=dep[u]+1,dfs2(v,u);\n\t}\n}\n\nint id[N],L[N],C,dp[N][2],dp2[N],g[N],h[N];\nint subid[N];\n\nvoid dfs3(int u,int f){\n\tfa[u]=f;\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(id[v]||v==f) continue;\n\t\tdfs3(v,u);\n\t\tcmax(dp2[u],dp2[v]);\n\t\tint t=dp[v][0]+1;\n\t\tif(t>dp[u][0]) dp[u][1]=dp[u][0],dp[u][0]=t;\n\t\telse cmax(dp[u][1],t);\n\t}\n\tcmax(dp2[u],dp[u][0]+dp[u][1]);\n}\nvoid dfs4(int u,int f,int d=0){\n\tdep[u]=d,subid[u]=d<=1?u:subid[f];\n\tint tg[2]={-INF,-INF},th[2]={0,0};\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(id[v]||v==f) continue;\n\t\tint x=dp[v][0]+1-(d?d:1e9);\n\t\tif(x>tg[0]) tg[1]=tg[0],tg[0]=x;\n\t\telse cmax(tg[1],x);\n\n\t\tx=max(dp2[v],dp[v][0]+1);\n\t\tif(x>th[0]) th[1]=th[0],th[0]=x;\n\t\telse cmax(th[1],x);\n\t}\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(id[v]||v==f) continue;\n\t\th[v]=max(h[u],th[0]==max(dp2[v],dp[v][0]+1)?th[1]:th[0]);\n\t\tg[v]=max(g[u],tg[0]==dp[v][0]+1-(d?d:1e9)?tg[1]:tg[0]);\n\t\tid[v]=id[u],dfs4(v,u,d+1);\n\t}\n\tif(f) cmax(g[u],dp[u][0]-d);\n\tcmax(h[u],dp2[u]);\n}\n\nstruct Node{\n\tint len,ans,l,r;\n\tNode operator + (const Node __) const {\n\t\tNode res; res.len=len+__.len;\n\t\tres.ans=max(ans,__.ans);\n\t\tres.l=max(l,__.l-len),res.r=max(r-__.len,__.r);\n\t\tcmax(res.ans,r+__.l+1);\n\t\treturn res;\n\t}\n} s[N<<2];\nvoid Build(int p,int l,int r) {\n\tif(l==r) {\n\t\ts[p]=(Node){1,max(dp2[L[l]],dp[L[l]][0]),dp[L[l]][0],dp[L[l]][0]};\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tBuild(p<<1,l,mid),Build(p<<1|1,mid+1,r);\n\ts[p]=s[p<<1]+s[p<<1|1];\n}\nNode Que(int p,int l,int r,int ql,int qr){\n\tif(ql<=l && r<=qr) return s[p];\n\tint mid=(l+r)>>1;\n\tif(qr<=mid) return Que(p<<1,l,mid,ql,qr);\n\tif(ql>mid) return Que(p<<1|1,mid+1,r,ql,qr);\n\treturn Que(p<<1,l,mid,ql,qr)+Que(p<<1|1,mid+1,r,ql,qr);\n}\nint ls[N],rs[N];\n\nint main(){\n\tn=rd();\n\trep(t,1,rd()){\n\t\tint u=rd()+1,v=rd()+1,w=rd();\n\t\tif(w==1) AddEdge(u,v),AddEdge(v,u);\n\t\telse U[++m]=u,V[m]=v,W[m]=w,G[u].pb(mp(v,m)),G[v].pb(mp(u,m));\n\t}\n\tma=-1,dfs1(1,0);\n\tma=-1,dep[num]=0,dfs2(num,0);\n\tfor(int u=num;u;u=fa[u]) L[id[u]=++C]=u;\n\trep(i,1,C) dfs3(L[i],0),g[L[i]]=-INF,dfs4(L[i],0);\n\trep(i,1,C) ls[i]=max(ls[i-1],i-1+dp[L[i]][0]);\n\tdrep(i,C,1) rs[i]=max(rs[i+1],C-i+dp[L[i]][0]);\n\tBuild(1,1,C);\n\n\tint ans=C-1;\n\trep(i,1,m) if(D[i]>W[i]) {\n\t\tint u=U[i],v=V[i],d=0;\n\t\tif(id[u]>id[v]) swap(u,v);\n\t\tif(id[u]==id[v]) d=C-1;\n\t\telse {\n\t\t\tif(fa[u]) {\n\t\t\t\tcmax(d,h[u]);\n\t\t\t\tint f=subid[u],t=fa[f];\n\t\t\t\tcmax(d,id[u]-1+(dp[f][0]+1==dp[t][0]?dp[t][1]:dp[t][0]));\n\t\t\t\tcmax(d,id[u]-1+g[u]+2);\n\t\t\t} else cmax(d,dp[u][0]+id[u]-1);\n\t\t\tif(fa[v]) {\n\t\t\t\tcmax(d,h[v]);\n\t\t\t\tint f=subid[v],t=fa[f];\n\t\t\t\tcmax(d,C-id[v]+(dp[f][0]+1==dp[t][0]?dp[t][1]:dp[t][0]));\n\t\t\t\tcmax(d,C-id[v]+g[v]+2);\n\t\t\t} else cmax(d,dp[v][0]+C-id[v]);\n\t\t\tcmax(d,ls[id[u]-1]),cmax(d,rs[id[v]+1]);\n\n\t\t\tint g1=id[u]-1,g2=C-id[v];\n\t\t\tcmax(d,g1+g2-(id[v]-id[u])+2);\n\t\t\tif(id[u]+1<id[v]) {\n\t\t\t\tNode t=Que(1,1,C,id[u]+1,id[v]-1);\n\t\t\t\tcmax(d,t.ans);\n\t\t\t\tcmax(d,t.l+g1+1);\n\t\t\t\tcmax(d,t.r+g2+1);\n\t\t\t}\n\t\t}\n\t\tcmax(ans,D[i]-W[i]+d);\n\t}\n\tprintf(\"%d\\n\",2*(n-1)-ans);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「CEOI2020」象棋世界  ","url":"/2021/05/21/「CEOI2020」象棋世界  /","content":"# 「CEOI2020」象棋世界  \n\n下文默认$n=R,m=C,x=c_1,y=c_R$\n\n### Pawn\n\n略\n\n### Rook\n\n略\n\n### Queen\n\n先判掉一次到达的情况，然后就可以从起点和终点分别画出5条可行线\n\n由此得到若干交点，手动数一下有几个交点在内部的整点上\n\n```cpp\nvoid QQQ(){\n\tint d=abs(x-y);\n\tif(d==n-1 || d==0) puts(\"1 1\"); // 一次到达\n\telse {\n\t\td=(n-1-d)/2;\n\t\tint res=4;\n\t\tif(n==m) {\n            // 一条斜着，一条平着\n\t\t\tif(x==1 || x==n) res++;\n\t\t\tif(y==1 || y==n) res++;\n\t\t}\n\t\tif(((x+1)&1)==((y+n)&1)) { // 先判断整点，然后判断两条斜线相交是否在内部\n\t\t\tif(min(x,y)-d>=1) res++;\n\t\t\tif(max(x,y)+d<=m) res++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",2,res);\n\t}\n}\n```\n\n$$ \\ $$\n\n$$ \\ $$\n\n### Bishop\n\n看起来是很复杂的问题，但是实际上可以从一个简单的贪心入手\n\n#### 判定条件\n\n可以发现，任意一次行走的直线上，坐标$(x,y)$的$(x+y)\\mod 2$不变\n\n所以只要$x+1\\equiv y+n\\pmod 2$即可\n\n#### 贪心策略\n\n首先一定是每次向前走\n\n第一步选择向左/右，然后每次转向，每次走都顶到边界线\n\n但是这样显然会无法到达最终位置\n\n#### 纠正方法\n\n考虑贪心到达的最后位置为$to$，那么得到的差值$|to-y|$是我们要矫正的距离\n\n而矫正方法：在中途出现的每次转向位置，向里面\"凹\"进去一点，每凹进去一格，实际上相当于少走了两格\n\n注意矫正的方向是根据最后一步走的方向而变化的，因此如果矫正方向不对，需要额外增加一步\n\n此时，相当于需要多矫正到沿边界线对称的位置，需要多走$2(to-1)$或者$2(m-to)$的距离\n\n假设走了$c$步，那么我们有$c-1$个转折点，最后将这若干的矫正距离分配到$c-1$个转折点上，可以用一个组合数解决\n\n由于矫正距离是$O(m)$的，所以组合数显然可以在$O(m)$时间内求出\n\n$$ \\ $$\n\n最后将向左向右合并即可\n\n```cpp\nll qpow(ll x,ll k=P-2) {\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\nint C(int n,int m) {\n\tif(m>n-m) m=n-m;\n\tint a=1,b=1;\n\trep(i,1,m) a=1ll*a*(n-i+1)%P,b=1ll*b*i%P;\n\treturn a*qpow(b)%P;\n}\nint Divide(int n,int m){ // Divide n elements in to m groups , each can be empty\n\tif(m<=0 && n>0) return 0;\n\treturn C(n+m-1,m-1);\n}\nvoid BBB(){\n\tif(((x+1)&1)!=((y+n)&1)) return puts(\"0 0\"),void();\n\tauto Subsolver=[&](int x,int y){\n        // assume that we go left first\n\t\tint c=0,to=x,dis=n-1; // count , towardsposition\n\t\tc=1,dis-=x-1,to=1; // go left by x-1\n\t\tc+=dis/(m-1),to=((dis/(m-1))&1)?m:1,dis%=m-1; // then each step m-1 opposite\n\t\tif(dis) c++,to=to==1?to+dis:to-dis; // reach destination (NO!)\n\t\tif(to==y) return mp(c,1);\n\t\tint d=abs(to-y)/2;\n\t\tif((c&1)  && y>to) d+=to-1,c++;\n\t\tif((~c&1) && y<to) d+=m-to,c++;\n\t\treturn mp(c,Divide(d,c-1));\n\t};\n\tPii l=Subsolver(x,y),r=Subsolver(m-x+1,m-y+1);\n\tif(l.first>r.first) swap(l,r);\n\tif(r.first==l.first) (l.second+=r.second)%=P;\n\tprintf(\"%d %d\\n\",l.first,l.second);\n}\n```\n\n$$ \\ $$\n\n$$ \\ $$\n\n### King\n\n可以发现，每次一定是向前的三个方向走，由此可以得到一个简单的$O(nm)\\ $ $dp$\n\n用矩阵优化可以做到$O(m^3\\log n)$求出所有的答案\n\n难点在于如果快速求出这个矩阵$A$的$A^{n-1}$，即要加速矩阵求幂\n\n容易想到用 **特征多项式** 解决该问题，[参考 ](https://www.cnblogs.com/chasedeath/p/12949896.html)\n\n问题分为两步\n\n#### 得到$p_m(\\lambda)$\n\n列出我们的转移矩阵$A=$\n\n$\\begin{matrix}1\\ 1\\ 0\\ 0\\ 0\\ 0\\ \\cdots \\ 0\\\\ 1\\ 1\\ 1\\ 0\\ 0\\ 0\\ \\cdots \\ 0\\\\ 0\\ 1\\ 1\\ 1\\ 0\\ 0\\ \\cdots \\ 0\\\\ \\cdots\\cdots\\cdots\\cdots \\\\ 0\\ \\cdots\\ 0\\ 0\\ 1\\ 1\\ 1\\ 0\\\\0\\ \\cdots\\ 0\\ 0\\ 0\\ 1\\ 1\\  1\\\\ 0\\ \\cdots\\ 0\\ 0\\ 0\\ 0\\ 1 \\ 1\\end{matrix}$\n\n\n\n$\\lambda I-A=$\n\n| $\\lambda -1$ | $-1$         | $0$          | $0$      | $0$      | $0$          | $\\cdots$     | $0$          |\n| ------------ | ------------ | ------------ | -------- | -------- | ------------ | ------------ | ------------ |\n| $-1$         | $\\lambda -1$ | $-1$         | $0$      | $0$      | $0$          | $\\cdots$     | $0$          |\n| $0$          | $-1$         | $\\lambda -1$ | $-1$     | $0$      | $0$          | $\\cdots$     | $0$          |\n| $\\cdots$     | $\\cdots$     | $\\cdots$     | $\\cdots$ | $\\cdots$ | $\\cdots$     | $\\cdots$     | $\\cdots$     |\n| $0$          | $0$          | $\\cdots$     | $0$      | $-1$     | $\\lambda -1$ | $-1$         | $0$          |\n| $0$          | $0$          | $\\cdots$     | $0$      | $0$      | $-1$         | $\\lambda -1$ | $-1$         |\n| $0$          | $0$          | $\\cdots$     | $0$      | $0$      | $0$          | $-1$         | $\\lambda -1$ |\n\n每一行有$2/3$个元素，看起来并不是很好得到行列式\n\n但是容易得到一个递推式，设$m$阶转移矩阵的特征多项式为$p_m(\\lambda)$\n\n如果最后一行取第$m$个元素，值为$(\\lambda-1)p_{m-1}(\\lambda)$\n\n如果最后一行取第$m-1$个元素，值为$-p_{m-2}(\\lambda)$\n\n因而得到\n\n$p_m(\\lambda)=\\left\\{\\begin{aligned}1&& m=0\\\\ \\lambda-1 && m=1\\\\ (\\lambda-1)p_{m-1}(\\lambda)-p_{m-2}(\\lambda) && m>1\\end{aligned}\\right.$\n\n可以在$O(m^2)$的时间内暴力求出，也可以得到通项公式(太憨了)\n\n那么得到关系用$\\lambda^n\\mod p_m(\\lambda)$的系数优化计算，可以用暴力实现的多项式取模+快速幂得到$O(m^2\\log n)$\n\n当然也可以优化\n\n$$ \\ $$\n\n#### 求出$A^0,A^1,A^2\\cdots A^m$\n\n直接求显然是$O(m^3)$的，~~卡一卡说不定能过？~~\n\n由于走的是一个$m\\times m$的棋盘，可以用一个简单容斥得到答案\n\n设$f_{x,y}$为从$x$走到$y$，中途允许超出边界的方案数\n\n由于棋盘只有$m\\times m$，中途最多只会可能经过一条边界线\n\n而一旦在某一个时刻超出边界线到达$0/m+1$，那么接下来达到这条边界线两侧对称点的方案数是一样的\n\n即：跨过了某一条边界线$0/m+1$的不合法方案数，可以用到达$y$关于这条边界线的 **对称点的** 不一定合法方案数得到\n\n而不一定合法的$f_{x,y}$实际上只和$|x-y|$有关\n\n由此，可以用$f_{0,i}$表示出$A^i_{x,y}$，那么接下来只需要先计算出$f_{0,i}$对于系数的求和，最终进行一次容斥，减去两侧不合法方案数即可\n\n```cpp\ntypedef vector <int> Poly;\nPoly operator * (const Poly &a,const Poly &b){\n\tint n=a.size()-1,m=b.size()-1;\n\tPoly c(n+m+1);\n\trep(i,0,n) rep(j,0,m) c[i+j]=(c[i+j]+1ll*a[i]*b[j])%P;\n\treturn c;\n}\nPoly operator * (Poly a,const int &b){\n\tfor(int &i:a) i=1ll*i*b%P;\n\treturn a;\n}\nPoly operator + (Poly a,const Poly &b){\n\tif(a.size()<b.size()) a.resize(b.size());\n\trep(i,0,b.size()-1) a[i]+=b[i],Mod1(a[i]);\n\treturn a;\n}\nPoly operator - (Poly a,const Poly &b){\n\tif(a.size()<b.size()) a.resize(b.size());\n\trep(i,0,b.size()-1) a[i]-=b[i],Mod2(a[i]);\n\treturn a;\n}\nPoly operator % (Poly a,const Poly &b){\n\tint n=a.size()-1,m=b.size()-1;\n\tif(n<m) return a;\n\tassert(b[m]==1);\n\tdrep(i,n-m,0) rep(j,0,m) a[i+j]=(a[i+j]+1ll*(P-a[i+m])*b[j])%P;\n\ta.resize(m);\n\treturn a;\n}\nPoly Pow(Poly x,int k,Poly Mod){\n\tPoly res=x; k--;\n\tfor(;k;k>>=1,x=x*x%Mod) if(k&1) res=res*x%Mod;\n\treturn res;\n}\n\nPoly F,G,T=Poly{P-1,1};\nint f[N*2],g[N*2],H[N*2];\nvoid KKKInit(){\n\tG=Poly{1},F=T;\n\trep(i,2,m) swap(F,G),F=G*T-F; // 递推特征多项式\n\tF=Pow(Poly{0,1},n-1,F); // 求出x^{n-1} mod p(x)\n\tf[0]=1,H[0]=F[0];\n\trep(t,1,F.size()-1) { // 求出f_{0,i}，只需要求一半\n\t\trep(i,0,t) g[i]=f[i];\n\t\trep(i,0,t) {\n\t\t\tf[i]=(0ll+(i?g[i-1]:g[1])+g[i]+g[i+1])%P;\n\t\t\tH[i]=(H[i]+1ll*f[i]*F[t])%P; // 乘上系数累和\n\t\t}\n\t}\n}\nvoid KKK(){\n\tint res=H[abs(x-y)];\n    // 两侧对称点\n\t// y -> 0-(y-0)=-y\n\t// y -> m+1+(m+1-y)=2(m+1)-y\n\tres-=H[abs(-y-x)];\n\tres-=H[abs(2*(m+1)-y-x)];\n    // 容斥\n\tres=(res%P+P)%P;\n\tprintf(\"%d %d\\n\",n-1,res);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「CEOI2020」星际迷航","url":"/2021/05/21/「CEOI2020」星际迷航/","content":"# 「CEOI2020」星际迷航\n\n首先是最简单的判断是否必胜的$dp$转移$\\displaystyle dp_u=\\bigcup_{v\\in son_u} \\text{not  } dp_{v}$\n\n考虑第$i+1$层对于第$i$层的贡献，实际上只和$i+1$层有多少个点$dp$值为0/1有关\n\n下面称$dp$值为0/1的点为 败/胜 点\n\n考虑对于确定第$i$层的根为某一节点$root$之后\n\n在某一个点下面接一个胜点，或者在一个胜点下面接一个点，对于胜败情况没有影响\n\n在一个败点下面接一个败点，可能会导致一段连续祖先段的胜败翻转\n\n考虑对于每个$u$作为根求出：\n\n1.没有接上下一层时的胜败情况 ： $dp_u$\n\n2.有多少个节点接上一个败点之后，会导致根的胜败情况翻转：$R_u$\n\n这是一个换根$dp$问题\n\n具体来说，$R_u$的值，根据子节点中败点的个数可以得到转移：\n\n1.没有败点，那么就是所有子节点$R$之和+自己\n\n2.恰好有一个败点，那么就是败点的$R$\n\n对此，每个点维护子节点中败点的个数，然后换根$dp$即可\n\n求出每个$root$的1，2后，可以用一个矩阵维护每层的转移，就不再赘述\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\nchar IO;\nint rd(){\n    int s=0;\n    while(!isdigit(IO=getchar()));\n    do s=(s<<1)+(s<<3)+(IO^'0');\n    while(isdigit(IO=getchar()));\n    return s;\n}\n\nconst int N=1e5+10,INF=1e9+10,P=1e9+7;\n\nint n;\nll m;\nstruct Mat{\n    int a[2][2];\n    void clear(){ memset(a,0,sizeof a); }\n    Mat operator * (const Mat x) const {\n        Mat res; res.clear();\n        rep(i,0,1) rep(j,0,1) rep(k,0,1) res.a[i][k]=(res.a[i][k]+1ll*a[i][j]*x.a[j][k])%P;\n        return res;\n    }\n} Res,X;\n\nint F[N],FC[N],FR[N],son[N][2],SR[N];\n// F子树胜败，FC子节点败点个数，FR子树翻转点个数，son存储两个儿子中的败点，SR存储儿子中的FR之和\nint G[N],GC[N],GR[N];\n// F,GC,GR是子树外的\nint dp[N],R[N],fa[N];\n// dp,R即上文所述\n\nvector <int> E[N];\nvoid dfs1(int u,int f) {\n    // 子树处理\n    fa[u]=f;\n    for(int v:E[u]) if(v!=f) {\n        dfs1(v,u);\n        FC[u]+=!F[v];\n        if(!F[v]) {\n            if(!son[u][0]) son[u][0]=v;\n            else son[u][1]=v;\n        }\n        SR[u]+=FR[v];\n    }\n    F[u]=FC[u]>0;\n    FR[u]=!F[u];\n    if(FC[u]<=1) for(int v:E[u]) if(v!=f && F[u]!=F[v]) FR[u]+=FR[v];\n}\n\n//换根dp\nvoid dfs2(int u,int f) {\n    if(f) GC[u]=G[u]=!G[f],GR[u]=GR[f]+!G[u];\n    else GC[u]=G[u]=0,GR[u]=1;\n    dp[u]=F[u]|G[u];\n    if(!dp[u]) R[u]=FR[u]+GR[u]-1;\n    else if(FC[u]+G[u]==1) {\n        if(G[u]) R[u]=GR[u];\n        else R[u]=FR[u];\n    }\n    for(int v:E[u]) if(v!=f) {\n        GC[u]=FC[u]-!F[v]+(f?!G[f]:0);\n        G[u]=GC[u]>0;\n        GR[u]=0;\n        if(!G[u]) GR[u]=GR[f]+SR[u]-FR[v]+1;\n        else if(GC[u]==1) {\n            if(son[u][0] && son[u][0]!=v) GR[u]=FR[son[u][0]];\n            else if(son[u][1] && son[u][1]!=v) GR[u]=FR[son[u][1]];\n            else GR[u]=GR[f];\n        }\n        dfs2(v,u);\n    }\n}\n\nint cnt[2];\nint main(){\n    n=rd(),scanf(\"%lld\",&m);\n    rep(i,2,n) {\n        int u=rd(),v=rd();\n        E[u].pb(v),E[v].pb(u);\n    }\n    dfs1(1,0),dfs2(1,0);\n    // 矩阵处理\n    rep(i,1,n) {\n        cnt[dp[i]]++;\n        X.a[1][dp[i]]=(X.a[1][dp[i]]+n)%P;\n        X.a[0][!dp[i]]=(X.a[0][!dp[i]]+R[i])%P;\n        X.a[0][dp[i]]=(X.a[0][dp[i]]+n-R[i])%P;\n    }\n    m--,Res.a[0][0]=Res.a[1][1]=1;\n    while(m) {\n        if(m&1) Res=Res*X;\n        X=X*X;\n        m>>=1;\n    }\n    int x=(1ll*Res.a[0][0]*cnt[0]+1ll*Res.a[1][0]*cnt[1])%P;\n    int y=(1ll*Res.a[0][1]*cnt[0]+1ll*Res.a[1][1]*cnt[1])%P;\n    // 得到第一层败/胜 的个数，与第0层合并\n    int ans=0;\n    if(!dp[1]) ans=1ll*x*R[1]%P;\n    else ans=(1ll*x*(n-R[1])+1ll*n*y)%P;\n    printf(\"%d\\n\",ans);\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「CEOI2019」建造摩天楼","url":"/2021/05/21/「CEOI2019」建造摩天楼/","content":"# 「CEOI2019」建造摩天楼\n\n显然是倒着考虑删除每个大楼，此时每次面临的情况都是一个子问题\n\n下文称当前局面未被删除的大楼为黑点，其余为白点\n\n子问题有解的充要条件是：黑点之间能 8-连通\n\n当前一个点能够被删掉的条件是：\n\n1.这个点能够连通到无穷处\n\n2.这个点不是当前8-连通图的割点\n\n$$ \\ $$\n\n考虑用一个简单的方法维护条件1：\n\n将一开始每个黑点周围的白点取出，按照白点之间4-连通构建连通块\n\n能够4-连通接触到最外层连通块的黑点满足条件1\n\n每次删除黑点之后，增加能够连通的白点，每个白点只会增加一次\n\nps:寻找最外层4-连通白点的一个方法：找到x最大的白点\n\n$$ \\ $$\n\n接下来考虑如何判定一个点$u$是否是割点：\n\n首先删除$u$之后，周围8连通内能够构成多个连通块，可以发现大致可以归结为以下几种情况，其中x,y为黑点\n\n多个$x$表示$x$在其中任何一个位置都可以\n\n| 1.   |      |      |\n| ---- | ---- | ---- |\n| x    | ①    | y    |\n| x    | u    | y    |\n| x    | ②    | y    |\n\n| 2.   |      |      |\n| ---- | ---- | ---- |\n| x    | ①    | y    |\n| ②    | u    | y    |\n| y    | y    | y    |\n\n对于这两种情况，只要白点1和白点2在同一4-连通块，割掉$u$就会分开x和$y$\n\n由此，每次插入一个白点，可以$O(1)$检测一个点是否合法\n\n简单讨论可以发现，会被影响合法性的点，一定在新加入最外层连通块的白点周围\n\n这样总共check了$O(n)$次，每次用一个堆/set维护能选的最大编号的点即可\n\nps:代码非常丑非常垃圾。。。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int,int> Pii;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) f|=IO=='-';\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=1.3e6+10,INF=1e9+10;\nconst int z[5][4]={{1,0},{0,-1},{-1,0},{0,1}};\nconst int Z[9][4]={{1,1},{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1},{0,1}};\n\nint n,m,k;\nint F[N];\nint Find(int x){ return F[x]==x?x:F[x]=Find(F[x]);}\nvoid Union(int x,int y){ F[Find(x)]=Find(y); }\nmap <Pii,int> B,W;\nset <int> st;\nvector <int> ans;\nPii A[N],P[N];\nint ma=-1e9,maxid;\nint G[N][4];\nvoid Ins(int x,int y){\n    // Insert white point\n\tPii T=mp(x,y);\n\tif(B.count(T)) return ;\n\tif(!W.count(T)) P[W[T]=++m]=T,F[m]=m;\n\tint u=W[T];\n\tif(x>ma) ma=x,maxid=u;\n\trep(i,0,3) {\n\t\tint x1=x+z[i][0],y1=y+z[i][1];\n\t\tif(W.count(mp(x1,y1))) {\n\t\t\tint v=W[mp(x1,y1)];\n\t\t\tG[u][i]=v;\n\t\t\tG[v][(i+2)%4]=u;\n\t\t\tUnion(u,v);\n\t\t}\n\t}\n}\n\nint del[N],vis[N],reach[N];\nint Check(int u){\n\tif(del[u]||!reach[u]) return 0;\n\tstatic int I[8];\n\tint c=0;\n\trep(i,0,7) {\n\t\tPii T=mp(A[u].x+Z[i][0],A[u].y+Z[i][1]);\n\t\tif(W.count(T)) I[i]=Find(W[T]);\n\t\telse I[i]=0,c++;\n\t}\n\tfor(int i=1,t=0;t<4;t++,i=(i+2)%8){\n\t\tint j=(i+2)%8;\n\t\tif(I[i] && I[i]==I[j] && !I[(i+1)%8] && c>1) return 0;\n\t}\n\tif((!I[0]||!I[1]||!I[2]) && (!I[4]||!I[5]||!I[6]) && I[3] && I[3]==I[7]) return 0;\n\tif((!I[2]||!I[3]||!I[4]) && (!I[6]||!I[7]||!I[0]) && I[1] && I[5]==I[1]) return 0;\n\treturn 1;\n}\nvoid ReCheck(int u){\n\tauto it=st.find(u);\n\tif(it!=st.end()) st.erase(it);\n\tif(Check(u)) st.insert(u);\n}\n\nvector <int> tmp;\nvoid dfs(int u){\n\tif(!u) return;\n\tif(vis[u]) return;\n\tvis[u]=1;\n\trep(i,0,3) {\n\t\tif(G[u][i]) dfs(G[u][i]);\n\t\tPii T=mp(P[u].x+z[i][0],P[u].y+z[i][1]);\n\t\tif(B.count(T)) reach[B[T]]=1;\n\t}\n\trep(dx,-1,1) rep(dy,-1,1) if(dx||dy) {\n\t\tPii T=mp(P[u].x+dx,P[u].y+dy);\n\t\tif(B.count(T)) tmp.pb(B[T]);\n\t}\n}\nvoid Dfs(int u){\n\tdfs(u);\n\tsort(tmp.begin(),tmp.end()),tmp.erase(unique(tmp.begin(),tmp.end()),tmp.end());\n\tfor(int i:tmp) ReCheck(i);\n\ttmp.clear();\n}\n\nvoid Del(int u){\n    // delete black point\n\tdel[u]=1;\n\tB.erase(A[u]),Ins(A[u].x,A[u].y);\n\tDfs(W[A[u]]);\n}\n\nint main(){\n\tn=rd(),rd();\n\trep(i,1,n) A[i].x=rd(),A[i].y=rd(),B[A[i]]=i;\n\trep(i,1,n) F[i]=i;\n\t\n\t// Check NO\n\trep(i,1,n) { \n\t\trep(dx,-1,1) rep(dy,-1,1) {\n\t\t\tPii T=mp(A[i].x+dx,A[i].y+dy);\n\t\t\tif(B.count(T)) Union(i,B[T]);\n\t\t}\n\t}\n\trep(i,1,n) if(Find(i)!=Find(1)) return puts(\"NO\"),0;\n\n\trep(i,1,n) rep(dx,-1,1) rep(dy,-1,1) if(dx||dy) Ins(A[i].x+dx,A[i].y+dy);\n\tDfs(maxid);\n\n\trep(i,1,n) {\n\t\tint u=*st.rbegin();\n\t\tauto it=st.end(); --it;st.erase(it);\n\t\tDel(u),ans.pb(u);\n\t}\n\treverse(ans.begin(),ans.end());\n\tputs(\"YES\");\n\tfor(int i:ans) printf(\"%d\\n\",i);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「CTS2019 | CTSC2019」重复(Kmp)","url":"/2021/05/21/「CTS2019   CTSC2019」重复(Kmp)/","content":"# 「CTS2019 | CTSC2019」重复(Kmp)\n\n-------------\n\n\n## Part1\n\n首先我们考虑对于一个已经确定的$t$串，如何检查是否合法\n\n对于$s$串建立$\\text{kmp}$($\\text{kmp}$自动机当然可以)，\n\n如果当前$\\text{kmp}$指针$j$在$\\text{fail}$树上的祖先所对应的所有下一个位置$s[ancestor+1]$中，存在一个字符，$t$中当前位置的字符$t[i]<s[ancestor+1]$\n\n那么就是存在一个\"有意义的串\",并且这个串和s串第一个不同的位置就是$ancestor+1$\n\n所以可以预处理一个$fail$树上祖先最大的$s[ancestor+1],Max[state]$\n\n```cpp\nrep(i,1,n) Max[i-1]=s[i];\nMax[n]='a';//边界条件\ncmax(Max[1],Max[0]);\nrep(i,2,n) {\n\tint j=nxt[i-1];\n\twhile(j && s[i]!=s[j+1]) j=nxt[j];\n\tif(s[i]==s[j+1]) ++j;\n\tnxt[i]=j;\n\tcmax(Max[i],Max[j]);\n}\n//预处理Max\nrep(i,0,n) {\n\tif(i<n) Trans[i][s[i+1]-'a']=i+1;\n\trep(j,0,25) if(j!=s[i+1]-'a') Trans[i][j]=Trans[nxt[i]][j];\n}//kmp自动机，不要再暴力了\nrep(i,m+1,n+m) t[i]=t[i-m]; // 延长到n+m就够了\nint j=0,f=0;\nrep(i,1,n+m){\n\tif(t[i]<Max[j]) { // 存在一个位置满足即可\n\t\tf=1;\n\t\tbreak;\n\t}\n\tj=Trans[j][t[i]-'a'];\n}\n```\n\n\n\n配合dfs枚举，可以拿到pts10\n\n----------------\n\n## Part2\n\n设状态转移为$Trans[state][c]$\n\n把kmp状态压进dp状态里\n\n如果把问题直接放到无穷意义下来看\n\n那么跑够长度之后，后面的任意加入$m$次字符都会构成一个循环\n\n枚举循环开始状态为$st$，$\\text{dp}$走了$m$步回到$st$的方案数\n\n如果计算合法方案数，那么还要多一维，所以直接计算不合法方案，也就是\n\n$Trans[state][Max[state]..25]$这一段转移是不会出现合法情况的\n\n最后减一下\n\n复杂度$O(m\\cdot n^2)$\n\n```cpp\nnamespace pt2{\n\tint dp[2][N];\n\tvoid Solve(){\n\t\tint cur=0,ans=0;\n\t\trep(st,0,n) { // 枚举初始状态\n\t\t\trep(i,0,n) dp[cur][i]=dp[!cur][i]=0;\n\t\t\tdp[cur][st]=1;\n\t\t\trep(t,1,m) {\n\t\t\t\tcur^=1;\n\t\t\t\trep(i,0,n) if(dp[!cur][i]){\n\t\t\t\t\trep(c,Max[i]-'a',25) {//只转移不合法的\n\t\t\t\t\t\tdp[cur][Trans[i][c]]+=dp[!cur][i];\n\t\t\t\t\t\tMod1(dp[cur][Trans[i][c]]);\n\t\t\t\t\t}\n\t\t\t\t\tdp[!cur][i]=0;\n\t\t\t\t}\n\t\t\t}// 走m步回到st\n\t\t\tans+=dp[cur][st],Mod1(ans);\n\t\t}\n\t\tans=(qpow(26,m)-ans+P)%P;//减一下\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\n\n```\n\n\n---------------------\n\n## Part3\n\n观察上面一档情况，合法的转移$Trans[state][Max[state]..25]$\n\n如果枚举下一个字符$c>Max[state]$，那么在$s$串中就找不到任何匹配了，下一个状态就是$0$\n\n否则，下一个状态就是$Trans[state][c]$\n\n也就是说，每个点出发其实只有两种情况，一种是一定会经过$0$的\n\n所以对于这个环是否经过$0$进行讨论\n\n如果不经过$0$，那么考虑直接从$st$出发走$m$步非0转移即可\n\n经过$0$的，预处理一个从$0$出发，走了$i$步第一次回到$0$的方案数\n\n$[st\\rightarrow 0,0\\rightarrow 0,0\\rightarrow 0...,0\\rightarrow st]$\n\n长成这个样子的转移\n\n枚举第一个$st\\rightarrow 0$的时间，后面可以预处理出来\n\n复杂度$O(n\\cdot m)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define reg register\ntypedef long long ll;\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\ntemplate <class T> void cmin(T &a, T b){ ((a>b)&&(a=b)); }\ntemplate <class T> void cmax(T &a, T b){ ((a<b)&&(a=b)); }\n\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=2010,P=998244353;\n\nint n,m;\nchar s[N];\nint Max[N],nxt[N],Trans[N][26];\nll qpow(ll x,ll k=P-2) {\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\n\nint st[N][N]; // 从i出发，走了j步第一次到0\nint dp[N][N]; // 从0出发，走了i步，到了j,如果到0就不进行转移 \n\nint main(){\n\tfreopen(\"repeat.in\",\"r\",stdin),freopen(\"repeat.out\",\"w\",stdout);\n\tm=rd();\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\trep(i,1,n) Max[i-1]=s[i];\n\tMax[n]='a';\n\tcmax(Max[1],Max[0]);\n\trep(i,2,n) {\n\t\tint j=nxt[i-1];\n\t\twhile(j && s[i]!=s[j+1]) j=nxt[j];\n\t\tif(s[i]==s[j+1]) ++j;\n\t\tnxt[i]=j;\n\t\tcmax(Max[i],Max[j]);\n\t}\n\trep(i,0,n) {\n\t\tif(i<n) Trans[i][s[i+1]-'a']=i+1;\n\t\trep(j,0,25) if(j!=s[i+1]-'a') Trans[i][j]=Trans[nxt[i]][j];\n\t}\n\n\tint ans=0;\t\n\tst[0][0]++;\n\trep(i,1,n) {\n\t\tint j=i,f=1;\n\t\trep(k,1,m) {\n\t\t\tst[i][k]+=25-(Max[j]-'a'),j=Trans[j][Max[j]-'a'];\n\t\t\tif(!j) {\n\t\t\t\tst[i][k]++,f=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(j==i) ans+=f;\n\t}\n\n\tdp[0][0]=1;\n\trep(i,1,m) {\n\t\trep(j,0,n) if(dp[i-1][j]) {\n\t\t\tdp[i][Trans[j][Max[j]-'a']]+=dp[i-1][j],Mod1(dp[i][Trans[j][Max[j]-'a']]);\n\t\t\tdp[i][0]=(dp[i][0]+1ll*(25-(Max[j]-'a'))*dp[i-1][j])%P;\n\t\t}\n\t}\n\n\trep(i,0,n) { // 枚举初始状态\n\t\trep(j,0,m) if(st[i][j] && dp[m-j][i]) { // 枚举走了几步第一次到0\n\t\t\tans=(ans+1ll*st[i][j]*dp[m-j][i])%P;\n\t\t}\n\t}\n\tans=(qpow(26,m)-ans+P)%P;\n\tprintf(\"%d\\n\",ans);\n}\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「FJWC2020Day5-Zzq」lg","url":"/2021/05/21/「FJWC2020Day5-zzq」lg/","content":"# 「FJWC2020Day5-zzq」lg\n\n设模数为$P$\n\n考虑对于每一个$\\gcd$计算$\\text{lcm}$之积$F(m)$\n\n那么可以想到强制每个数都是$\\gcd$的倍数，问题转化为求$\\lfloor \\frac{m}{gcd}\\rfloor $以内所有$\\text{lcm}$的积$G(m)$\n\n那么对于每个质因数依次考虑,则得到一个简单的式子\n\n$$G(m)=\\begin{aligned}\\prod p_i^{\\sum_{j=1}m^n-(m-\\lfloor \\frac{m}{p_i^j}\\rfloor )^n} \\end{aligned}$$\n\n其中枚举的$j$是$p_i$至少出现$j$次的方案数，枚举的$j$是$\\log m$ 级别的\n\n肯定是先求出指数$\\mod \\varphi(P)$，可以线性预处理出所有的$i^n \\mod \\varphi(P)$\n\n对于每个$p_i$求出指数后还要快速幂，复杂度就是$O(|p_i|\\log P)=O(m)$，实际带有一些常数\n\n那么求$G(m)$的复杂度上界是$O(m\\log m)$，实际上$\\lfloor \\frac{m}{i}\\rfloor $有很多重复，复杂度要低很多\n\n得到的每个$\\gcd$的答案还要把强制取出的$\\gcd$补上，是{% raw %}$\\gcd^{{\\lfloor \\frac{m}{gcd}\\rfloor }^n}${% endraw %}\n\n那么对于$G(m)$枚举倍数进行容斥的到$F(m)$即可，需要求每个$F(m)$的逆元，复杂度是$O(m(\\log P+\\log m))$\n\n总复杂度的上界就是$O(m\\log P)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,a,b) for(int i=a;i<=b;++i)\nenum{N=200010,P=998244353,Phi=P-1};\nint n,m,p[N],mk[N],g[N],ig[N],h[N];\nll qpow(ll x,ll k,ll P) {\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\nint G(int m) {\n\tif(h[m]) return h[m];\n\tll ans=1;\n\trep(i,2,m) if(!mk[i]) {\n\t\tll d=1,s=0;\n\t\tfor(;(d*=i)<=m;) s+=p[m]-p[m-m/d]; // 带入上式求出答案\n\t\tans=ans*qpow(i,(s%Phi+Phi)%Phi,P)%P;\n\t}\n\treturn h[m]=ans;\n}\nint main(){\n\tfreopen(\"lg.in\",\"r\",stdin),freopen(\"lg.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,2,N-1) if(!mk[i]) for(int j=i+i;j<N;j+=i) mk[j]=1;\n\trep(i,0,m) p[i]=qpow(i,n,Phi); // 预处理出i^n mod Phi\n\trep(i,1,m) g[i]=G(m/i)*qpow(i,p[m/i],P)%P; // 注意要补上\n\tll ans=1;\n\tfor(int i=m;i;i--){\n\t\tfor(int j=i+i;j<=m;j+=i) g[i]=1ll*g[i]*ig[j]%P; // 容斥得到f\n\t\tig[i]=qpow(g[i],P-2,P),ans=ans*qpow(g[i],i,P)%P;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「CodePlus 2017 11 月赛」Yazid 的新生舞会              ","url":"/2021/05/21/「CodePlus 2017 11 月赛」Yazid 的新生舞会              /","content":"# 「CodePlus 2017 11 月赛」Yazid 的新生舞会              \n\n最基本的分析这里只保留：$cnt>\\frac{len}{2}\\Rightarrow 2cnt>len$\n\n对于每一个合法的区间，合法的众数显然只有一个\n\n考虑对于每一个众数计算答案，把$x$出现的位置拿出来成一个序列$A_i$\n\n如果选择的区间恰好包含$A_i,A_{i+1},\\cdots ,A_j$，那么合法的情况就是$2(j-i+1)>R-L+1,L\\in[A_{i-1}+1,A_i],R\\in[A_{j},A_{j},A_{j+1}-1]$\n\n参数分离得到$2j-R>2i-L$\n\n如果对于每一个$L$更新答案，那么更新的是一段区间，不妨设其为$UL,UR$\n\n对于每个$R$查询则是一段前缀 和 的区间 \n\n我们知道树状数组维护区间修改区间查询需要做一次差分，而这次是区间前缀和\n\n也就是说是再高一维。。\n\n不妨在$UL$上加,$UR$上减，那么在$p$处的更新对于在$k$处的查询的贡献是\n\n$\\cfrac{(k-p+1)(k-p+2)}{2}=\\cfrac{k^2+p^2-2pk+3k-3p+2}{2}$\n\n那么直接处理这个式子即可，需要维护$updval,p\\cdot updval,p^2\\cdot updval$\n\n查询时加入$k$的贡献\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\nint rd(){\n\tint s=0; char c;\n\twhile(c=getchar(),c<48);\n\tdo s=s*10+c-'0';\n\twhile(c=getchar(),c>47);\n\treturn s;\n}\nenum{N=1000010};\nint n;\nvector <int> A[N];\nll ans,s1[N],s2[N],s3[N];\nvoid Add(int p,ll x) {\n\tp--; ll a=x,b=x*p,c=x*p*p;\n\tfor(p+=n+1;p<=n*2;p+=p&-p) s1[p]+=a,s2[p]+=b,s3[p]+=c;\n}\nvoid Add(int l,int r,int x) { Add(l,x),Add(r+1,-x); }\nll Que(int p) {\n\tll r1=0,r2=0,r3=0,tp=p;\n\tfor(p+=n;p;p-=p&-p) r1+=s1[p],r2+=s2[p],r3+=s3[p];\n\treturn ((tp*tp+tp)*r1-(2*tp+1)*r2+r3)/2;\n}\nll Que(int l,int r) { return Que(r)-Que(l-1); }\nint main(){ \n\tfreopen(\"party.in\",\"r\",stdin),n=rd(),rd();\n\trep(i,1,n) A[rd()].push_back(i);\n\trep(k,0,n-1) if(A[k].size()) {\n\t\trep(i,0,A[k].size()-1) {\n\t\t\tint p=A[k][i],l=i?A[k][i-1]:0,r=i<(int)A[k].size()-1?A[k][i+1]:n+1;\n\t\t\tAdd(2*i-p+1,2*i-l,1);\n\t\t\tans+=Que(2*(i+1)-r,2*(i+1)-p-1);\n\t\t}\n\t\trep(i,0,A[k].size()-1) {\n\t\t\tint p=A[k][i],l=i?A[k][i-1]:0;\n\t\t\tAdd(2*i-p+1,2*i-l,-1);\n\t\t}\n\t}\n\tfprintf(fopen(\"party.out\",\"w\"),\"%lld\\n\",ans);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「GDOI2020模拟赛day1」Permutation              ","url":"/2021/05/21/「GDOI2020模拟赛day1」Permutation              /","content":"# 「GDOI2020模拟赛day1」Permutation              \n\n为了便于叙述，设原题中的 $n$ 为$N$\n\n### 题目分析\n\n要求一个$1-n$的环排列，看成是一个环遍历\n\n发现每条边的权值限制了遍历过程中穿过这条边的次数\n\n取$1$为根，强制从$1$开始遍历，考虑以一个个**自由段**（即未确定前后连接关系的子段）的形式维护$u$子树中的序列段\n\n那么，只需要满足$u$子树中自由段的个数为$\\frac{w(u,fa_u)}{2}$ （每一个自由段的两端均对应一次跨越）即可\n\n分析即可发现$w(u,fa_u)$显然是$O(size_u)$级别的，因此考虑树形背包\n\n那么我们就需要支持合并两组自由段\n\n$$ \\ $$\n\n### $O(N^3-N^2\\log N)$\n\n设当前$1\\ldots n$个自由端，合并上$m$个自由段(从子树合并上来是恰好$m$个)\n\n注意这些自由段之间是无序的\n\n先考虑一个简单的模型：\n\n把$n$个无序自由段拼接成$m$个无序自由段，设方案数为$W(n,m)$，则考虑\n\n先把$n$个自由段排列，然后选出$n-m$个间隔连接，然后除掉得到的$m$个段之间的排列\n\n得到$\\begin{aligned} W(n,m)=\\frac{n!}{m!}\\binom{n-1}{n-m} \\end{aligned}$\n\n类似的，可以把$n+m$个自由段排成一排，合并成若干段\n\n但是显然存在的问题就是：可能在两组自由段之间形成了连接，这样的连接是非法的\n\n因此考虑容斥\n\n$\\begin{aligned} dp'_{d}\\longleftarrow\\sum_{i=1}^ndp_{u,i}\\sum_{j=1}^idp_v (-1)^{i-j}W(i,j) \\sum_{k=1}^m (-1)^{m-k}W(m-1,k)\\sum_{d=1}^{j+k}W(j+k,d)\\end{aligned}$\n\n将上式分解为四步转移\n\n$n,i\\rightarrow j,O(n^2)$\n\n$m\\rightarrow k,O(m)$\n\n$j,k\\rightarrow j+k,O(nm)$\n\n$j+k\\rightarrow d,O((n+m)^2)$\n\n其中$O(n^2,(n+m)^2)$的部分如果用卷积优化，即可做到$O(N^2\\log N)$\n\n但是$O(N^3)$就$pts75$了...\n\n\n\nTips:注意在将$1$号节点加入序列时，用上面的方法无法保证它在序列首\n\n需要特殊处理，始终强制它在第一个\n\n### $O(N^2)$\n\n当我发现这个做法不需要任何优化就可以做到$O(N^2)$的时候。。。。\n\n~~把这个容斥的过程爆开~~\n\n先对于每个儿子的$dp$值按照容斥系数进行上文中$m\\rightarrow k$的变换，复杂度为$O(size_u)$\n\n然后进行背包合并，由树形背包的复杂度分析，总复杂度为$O(N^2)$\n\n最后发现其实我们只需要知道$dp_{u,w(u,fa_u)}$，因此这里也只需要$O(size_u)$\n\n综上，复杂度为$O(N^2)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair <int,int> Pii;\n#define reg register\n#define mp make_pair\n#define pb push_back\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T& a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T& a,T b){ ((a<b)&&(a=b)); }\n\nconst int DEBUG=1;\n#define Log(...) (DEBUG&&(fprintf(stderr,__VA_ARGS__)))\n\nchar IO;\nint rd(){\n\tint s=0,f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nbool Mbe;\nconst int N=5010;\n\nint n,P;\nll qpow(ll x,ll k=P-2){\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\nint I[N],J[N],C[N][N],W[N][N];\n\nstruct Edge{\n\tint to,nxt,w;\n} e[N<<1];\nint head[N],ecnt;\nvoid AddEdge(int u,int v,int w){\n\te[++ecnt]=(Edge){v,head[u],w};\n\thead[u]=ecnt;\n}\n\nint sz[N],w[N],dp[N][N],T[N];\nint A[N],B[N];\n\nvoid dfs(int u,int f){\n\tsz[u]=0,dp[u][0]=1;\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==f) continue;\n\t\tw[v]=e[i].w,dfs(v,u);\n\t\trep(a,0,sz[u]) T[a]=dp[u][a],dp[u][a]=0;\n\t\trep(a,0,sz[u]) rep(b,1,sz[v]) dp[u][a+b]=(dp[u][a+b]+1ll*T[a]*dp[v][b])%P;\n\t\tsz[u]+=sz[v];\n\t}\n\tint s=0;\n\trep(i,w[u],sz[u]+1) {\n\t\tint e=W[i][w[u]];\n\t\tif(u==1) e=1ll*C[i-1][i-w[u]]*J[i-1]%P*I[w[u]-1]%P;\n\t\ts=(s+1ll*e*dp[u][i-1])%P;\n\t}\n    // 求出我们需要的点值\n\t\n\trep(i,w[u]+1,sz[u]) dp[u][i]=0;\n\tif(!s) puts(\"0\"),exit(0);\n    // 容斥系数变换\n\trep(i,1,w[u]) {\n\t\tdp[u][i]=1ll*s*W[w[u]][i]%P;\n\t\tif((w[u]-i)&1) dp[u][i]=P-dp[u][i];\n\t}\n\tsz[u]=w[u];\n}\n\nbool Med;\nint main(){\n\tLog(\"Memory taken %.2lf\\n\",(&Med-&Mbe)/1024.0/1024.0);\n\tn=rd(),P=rd();\n\trep(i,J[0]=1,n) J[i]=1ll*J[i-1]*i%P;\n\tI[n]=qpow(J[n]);\n\tdrep(i,n,1) I[i-1]=1ll*I[i]*i%P;\n\trep(i,0,n) rep(j,C[i][0]=1,i) C[i][j]=C[i-1][j]+C[i-1][j-1],Mod1(C[i][j]),W[i][j]=1ll*C[i-1][i-j]*J[i]%P*I[j]%P;\n\trep(i,2,n){\n\t\tint u=rd(),v=rd(),w=rd();\n\t\tif(w&1) return puts(\"0\");\n\t\tAddEdge(u,v,w/=2),AddEdge(v,u,w);\n\t}\n\tdfs(w[1]=1,0);\n\tdp[1][1]=1ll*dp[1][1]*n%P;\n\tprintf(\"%d\\n\",dp[1][1]);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「GDOI2020模拟赛day2」我的朋友们","url":"/2021/05/21/「GDOI2020模拟赛day2」我的朋友们/","content":"# 「GDOI2020模拟赛day2」我的朋友们\n\n默认翻转了$a_i$顺序，下文多项式省略$(x)$\n\n设当前区间为$(i-L,i]$到最终结束的期望步数为$dp_i$\n\n令$A_i=a_ix+1-a_i$\n\n令$P_i=\\prod_{j\\in(i-L,i]}A_j$\n\n令$F_i=\\sum_{j=1}^i dp_jx^j$\n\n令$\\displaystyle G_i=F_{i-1}P_i,dp_i=\\frac{[x^i]G_i}{coef_i}$\n\n其中常数$coef_i=1-[x^0]P_i=1-\\prod_{j\\in(i-L,i]}(1-a_j)$，容易预处理得到\n\n用分治$\\text{NTT}$，过程中维护\n\n$P_{l,r}=\\prod_{j\\in(r-L,l]}A_j$\n\n$\\displaystyle G_{l,r}=F_{l-1}P_{l,r}$\n\n显然$G_{i,i}=G_i$\n\n分治转移如下：\n\n$\\displaystyle G_{l,mid}=G_{l,r}\\prod_{j\\in (mid-L,min(l,r-L)]} A_j$\n\n$P_{l,mid}=P_{l,r}\\prod_{j\\in (mid-L,min(l,r-L)]} A_j$\n\n先求出$G_{l,mid}$\n\n$P_{mid+1,r}=P_{l,r}\\prod_{j\\in (max(r-L,l),mid+1]} A_j$\n\n$\\displaystyle G_{mid+1,r}=(G_{l,r}+(F_{mid}-F_{l-1})P_{l,r})\\prod_{j\\in (max(r-L,l),mid+1]} A_j$\n\n\n\n归纳上述过程，发现实际上同步维护的部分只需要维护\n\n$G_{l,r}$的$[l-(r-l),r]$项，$P_{l,r}$的$[0,r-l]$项\n\n只需要实现\n\n通过$G_{l,r}$的$[l-(r-l),r]$项得到$G_{l,mid}$的$[l-(mid-l),mid]$，以及$G_{mid+1,r}$的$[l,r]$\n\n通过$P_{l,r}$的$[0,r-l]$得到$P_{l,mid}$的$[0,mid-l]$，$P_{mid+1,r}$的$[0,r-mid-1]$\n\n初始状态\n\n$P_{L,n}=\\prod_{j\\in(n-L,L]}A_j$\n\n$G_{L,n}=0$\n\n在分治过程中有非常多的$P_{l,r}$都是空的。。\n\n\n\n可以分治$\\text{NTT}$预处理出转移系数$\\displaystyle \\prod_{i=l}^r A_i$，或者用记忆化暴力求出，复杂度为$O(n\\log ^2n)$\n\n在转移过程中维护的部分长度与$r-l$同阶，因此复杂度为$O(n\\log^2 n)$\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「GXOI / GZOI2019」宝牌一大堆","url":"/2021/05/21/「GXOI   GZOI2019」宝牌一大堆/","content":"# 「GXOI / GZOI2019」宝牌一大堆\n\n~~麻将.jpg~~\n\n观察牌型和计算方法可知，选择一个杠与选择一个面子对于牌型的贡献是等价的\n\n而选择一个杠的答案一定没有选择一个刻子优，因此是没有任何意义的\n\n除去 \"七对子\" \"国士无双\" 的特殊情况后，此外的情况就是选择 4个面子 + 1个雀头\n\n容易想到对于每个花色dp得到选择$i$个面子$j$个雀头的答案，然后背包合并\n\n为了$dp$顺子的情况，可以存储前面两个位置作为顺子头的个数\n\n令$dp_{i,j,a,b}$表示当前选了$i$个面子，$j$个雀头，上两个位置选了$a$个顺子，上一个位置选了$b$个顺子\n\n暴力维护dp即可\n\n```cpp\nconst int INF=1e9+10;\n\nint min(int x,int y,int z){ return min(min(x,y),z); }\n\nint n,m;\nint C[5][5],c[4][12],mk[4][12];\nll ans,val[5][2];\n\nvoid Check7(){\n\tstatic int val[40],cnt;\n\tcnt=0;\n\trep(i,0,3) rep(j,0,9) if(c[i][j]>=2) val[++cnt]=C[c[i][j]][2]<<(mk[i][j]*2);\n\tif(cnt<7) return;\n\tsort(val+1,val+cnt+1,greater<int>());\n\tll res=7;\n\trep(i,1,7) res*=val[i];\n\tcmax(ans,res);\n}\n\nvoid Check13(){\n\tll res=13,x=0,y=0;\n\tauto chk=[&](ll a,ll b) {\n\t\tif(!x) x=a,y=b;\n\t\tif(x*b<a*y) x=a,y=b;\n\t};\n\trep(i,0,2) {\n\t\tif(!c[i][0] || !c[i][8]) return;\n\t\tres*=c[i][0]*c[i][8];\n\t\tres<<=(mk[i][0]+mk[i][8]);\n\t\tif(c[i][0]>=2) chk(C[c[i][0]][2]<<(mk[i][0]*2),c[i][0]<<mk[i][0]);\n\t\tif(c[i][8]>=2) chk(C[c[i][8]][2]<<(mk[i][8]*2),c[i][8]<<mk[i][8]);\n\t}\n\trep(i,0,6) {\n\t\tif(!c[3][i]) return;\n\t\tres<<=mk[3][i];\n\t\tres*=c[3][i];\n\t\tif(c[3][i]>=2) chk(C[c[3][i]][2]<<(mk[3][i]*2),c[3][i]<<mk[3][i]);\n\t}\n\tif(!x) return;\n\tcmax(ans,res*x/y);\n}\n\nvoid Work(int *cnt,int *mk,ll res[5][2]){\n\tstatic ll dp[2][5][2][5][5],w[5];\n\tint cur=0;\n\tmemset(dp,0,sizeof dp),dp[cur][0][0][0][0]=1;\n\trep(t,0,8) {\n\t\tint x=cnt[t]; ll val;\n\t\tmemset(dp[!cur],0,sizeof dp[!cur]);\n\t\trep(i,0,x) w[i]=C[x][i]<<(mk[t]*i);\n\t\trep(i,0,4) rep(j,0,1) rep(a,0,x) rep(b,0,x-a) if((val=dp[cur][i][j][a][b])) {\n\t\t\tint d=a+b,y=x-d,u=min(cnt[t+1]-b,cnt[t+2]);\n\n\t\t\trep(k,0,min(3-i,y-3,u))\n\t\t\t\tcmax(dp[!cur][i+k+1][j][b][k],val*w[d+k+3]); // 刻 + 顺\n\n\t\t\trep(k,0,min(4-i,y,u))\n\t\t\t\tcmax(dp[!cur][i+k][j][b][k],val*w[d+k]); // 顺\n\n\t\t\tif(j) continue;\n\t\t\trep(k,0,min(4-i,y-2,u))\n\t\t\t\tcmax(dp[!cur][i+k][j+1][b][k],val*w[d+k+2]); // 雀 + 顺\n\t\t}\n\t\tcur^=1;\n\t}\n\tdrep(i,4,0) drep(j,1,0) if(res[i][j]) {\n\t\trep(a,0,4-i) rep(b,0,1-j) \n\t\t\tif(dp[cur][a][b][0][0]) \n\t\t\t\tcmax(res[i+a][j+b],res[i][j]*dp[cur][a][b][0][0]);\n\t}\n}\n\nPii Read(){\n\tstatic char O[5];\n\tscanf(\"%s\",O);\n\tif(*O=='0') return mp(-1,0);\n\tif(isalpha(*O)) {\n\t\tif(*O=='E') return mp(3,0);\n\t\tif(*O=='S') return mp(3,1);\n\t\tif(*O=='W') return mp(3,2);\n\t\tif(*O=='N') return mp(3,3);\n\t\tif(*O=='Z') return mp(3,4);\n\t\tif(*O=='B') return mp(3,5);\n\t\tif(*O=='F') return mp(3,6);\n\t\treturn mp(-1,-1);\n\t}\n\tif(O[1]=='m') return mp(0,*O-'1');\n\tif(O[1]=='p') return mp(1,*O-'1');\n\tif(O[1]=='s') return mp(2,*O-'1');\n\treturn mp(-1,-1);\n}\n\nvoid Solve(){\n\tans=0,memset(val,0,sizeof val),memset(mk,0,sizeof mk),val[0][0]=1;\n\trep(i,0,2) rep(j,0,8) c[i][j]=4;\n\trep(i,0,6) c[3][i]=4;\n\twhile(1) {\n\t\tPii T=Read();\n\t\tif(T.first==-1) break;\n\t\tc[T.first][T.second]--;\n\t}\n\twhile(1) {\n\t\tPii T=Read();\n\t\tif(T.first==-1) break;\n\t\tmk[T.first][T.second]=1;\n\t}\n\tCheck7(),Check13();\n\trep(i,0,2) Work(c[i],mk[i],val);\n\trep(i,0,6) {\n\t\tstatic ll w[5];\n\t\tint x=c[3][i];\n\t\trep(j,0,x) w[j]=C[x][j]<<(j*mk[3][i]);\n\t\tdrep(a,4,0) drep(b,1,0) if(val[a][b]) {\n\t\t\tif(b<1 && x>=2) cmax(val[a][b+1],val[a][b]*w[2]); // 雀\n\t\t\tif(a<4 && x>=3) cmax(val[a+1][b],val[a][b]*w[3]); // 刻\n\t\t\tif(a<4 && x>=4) cmax(val[a+1][b],val[a][b]*w[4]); // 杠\n\t\t}\n\t}\n\tcmax(ans,val[4][1]);\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\trep(i,0,4) rep(j,C[i][0]=1,i) C[i][j]=C[i-1][j]+C[i-1][j-1];\n\tint T; scanf(\"%d\",&T);\n\twhile(T--) Solve();\n}\n```\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「JOI 2018 Final」毒蛇越狱                    ","url":"/2021/05/21/「JOI 2018 Final」毒蛇越狱                    /","content":"# 「JOI 2018 Final」毒蛇越狱                    \n\n### Algorithm 1: 暴力计算\n\n对于所有$0,1,?$组成的$3^n$种串处理出答案\n\n具体的，对于当前串包含的最后一个$?$位置，枚举它变成0/1的答案，按照一定的顺序累和即可\n\n(代码可以在Algo2里面看到)\n\n### Algorithm 2 : Meet in the Middle\n\n$3^{20}$太大，优化上面的暴力，容易想到把复杂度从预处理分一部分给查询\n\n取出$n$中前$k$个位置，这些位置不处理$3^k$，而是让每个询问暴力地去枚举这些位置上的$?$变成$0/1$\n\n显然每个询问有最多$2^k$次枚举，即复杂度为$O(Q\\cdot 2^k)$\n\n对于剩下的$n-k$个位置，采取上面的暴力方法预处理，三进制枚举，预处理复杂度为$O(2^k3^{n-k})$\n\n因此复杂度为$O(Q\\cdot 2^k +2^k3^{n-k})$，计算在$k=6,7$时复杂度约为$3.5\\cdot 10^8$\n\n~~(这是一个非常稳的复杂度)~~\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair <int,int> Pii;\n#define reg register\n#define pb push_back\n#define mp make_pair\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\n\nchar IO;\nll rd(){\n\tll s=0,f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=20,M=1<<20,M3=1600000;\nconst int DM=7;\n\n\nint n,m,k;\nint Pow[N],S[M3],Low[M3],trans[M3];\nint QX[M],QY[M],QZ[M],Ans[M],rev[M];\nchar val[M],q[N];\n\nint main() {\n\trep(i,Pow[0]=1,N-1) Pow[i]=Pow[i-1]*3;\n\tn=rd(),m=rd(),k=min(DM,n),scanf(\"%s\",val);\n\trep(i,1,(1<<n)-1) {\n\t\trev[i]=(rev[i>>1]>>1)|((i&1)<<(n-1));\n\t\tif(i<rev[i]) swap(val[i],val[rev[i]]);\n\t}\n\tLow[0]=1e9;\n\trep(i,1,Pow[n-k]-1) {\n\t\tLow[i]=(i%3==2)?0:Low[i/3]+1;\n\t\tif(Low[i]>n) trans[i]=(trans[i/3]<<1)|(i%3);\n\t}\n\trep(i,1,m) {\n\t\tscanf(\"%s\",q);\n\t\trep(j,0,n-1) {\n\t\t\tif(q[j]=='?') QY[i]|=1<<j,q[j]='2';\n\t\t\telse QX[i]|=(q[j]-'0')<<j;\n\t\t}\n\t\trep(j,k,n-1) QZ[i]+=Pow[j-k]*(q[j]-'0');\n\t}\n\tint A=(1<<k)-1;\n\trep(i,0,A) {\n\t\trep(j,0,Pow[n-k]-1) {\n\t\t\tif(Low[j]>n) S[j]=val[(trans[j]<<k)|i]-'0';\n\t\t\telse S[j]=S[j-Pow[Low[j]]]+S[j-2*Pow[Low[j]]];\n\t\t} // 暴力预处理前缀和\n\t\trep(j,1,m) if((QX[j]&A)==(i&~QY[j])) Ans[j]+=S[QZ[j]];\n\t}\n\trep(i,1,m) printf(\"%d\\n\",Ans[i]);\n}\n```\n\n\n\n### Algorithm 3 : 高位前缀和+容斥\n\n起始学过高位前缀和/FMT的看到这个题第一反应可能都是这个。。\n\n-> 对于$?$的位置，直接赋值成1，然后对于这个数从高位前缀和里查询\n\n然后你发现不知道怎么对于1的把0的去掉\n\n显然这个可以通过一个暴力的容斥来完成，枚举一些1的位置变成0，然后就是容斥的奇数减偶数加\n\n复杂度为$O(Q\\cdot 2^{1的个数}\\ \\ \\ \\ \\ )$\n\n同理，处理高位后缀和，复杂度为$\\begin{aligned}O(Q\\cdot 2^{0的个数}\\ \\ \\  \\ )\\end{aligned}$\n\n而直接暴力枚举$?$变成0/1，复杂度为$\\begin{aligned}O(Q\\cdot 2^{?的个数}\\ \\ \\ \\ \\ )\\end{aligned}$\n\n综合这三种算法，选一个更优的做，就得到一个复杂度为\n\n$\\begin{aligned}O(Q \\ \\cdot 2^{ \\begin{aligned}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\min\\lbrace 1的个数,0的个数,?的个数\\rbrace\\end{aligned}})\\ \\ \\ \\ \\ \\ \\end{aligned}$\n\n显然查询复杂度就是$O(Q\\cdot 2^{\\lfloor \\frac{n}{3}\\rfloor }=Q\\cdot 2^6)$\n\n算上预处理，复杂度为$O(2^nn+Q\\cdot 2^6)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nenum{N=1<<20};\nint n,k,m,A[N],B[N],C[N],P[N];\n// A 高位前缀和\n// B 高位后缀和\n// C 点值(打扰了)\n// P __builtin_parity\nchar val[N],q[21];\nint main() {\n\tscanf(\"%d%d%s\",&n,&m,val),k=1<<n;\n\tfor(int i=0;i<k;++i) A[i]=B[i]=C[i]=val[i]-'0',P[i]=P[i>>1]^(i&1);\n\tfor(int i=1;i<k;i<<=1) for(int l=0;l<k;l+=i*2) for(int j=l;j<l+i;++j) A[j+i]+=A[j],B[j]+=B[j+i];\n    //预处理高位前缀和，高位后缀和\n\twhile(m--) {\n\t\tint x=0,y=0,a=0,b=0,ans=0;\n\t\tfor(int i=scanf(\"%s\",q+1);i<=n;++i) {\n\t\t\tif(q[i]=='?') x|=1<<(n-i),a++;\n\t\t\tif(q[i]=='1') y|=1<<(n-i),b++;\n\t\t}\n\t\tif(a<=n/3) for(int S=x;~S;S=S?(S-1)&x:-1) ans+=C[y|S]; // 枚举?变成0/1\n\t\telse if(b<=n/3) for(int S=y;~S;S=S?(S-1)&y:-1) ans+=P[S^y]?-A[S|x]:A[S|x]; // 对于高位前缀和容斥\n\t\telse for(int S=x=(k-1)^x^y;~S;S=S?(S-1)&x:-1) ans+=P[S]?-B[S|y]:B[S|y]; // 对于高位后缀和容斥\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\n```","tags":["default tag"],"categories":["default category"]},{"title":"「HAOI2018」字串覆盖","url":"/2021/05/21/「HAOI2018」字串覆盖/","content":"# 「HAOI2018」字串覆盖\n\n这自然有后缀数组和后缀自动的写法，我写的是后缀数组\n\n现对于$A,B$两串拼接后建立$\\text{SA}$\n\n对于查询的四个参数$[s,t,l,r]$，在$\\text{SA}$上找到能够匹配$[l,r]$的$\\text{rank}$区间$[l',r']$\n\n这个$[l',r']$就用$\\text{SA}$的$\\text{height}$数组上倍增即可$O(\\log n)$找到\n\n由于$K>n$，显然覆盖就是从左到右依次匹配每个$\\text{rank}$在$[l',r']$中的$i$，能放就放\n\n数据范围提示我们切分写\n\n### Part1 $r-l\\leq 50$\n\n对于每种不同的$r-l$，倍增预处理\n\n我们将依次匹配的过程描述成一个个跳跃\n\n对于每个$i$找到后面第一个$j$满足$j>i+r-l,\\text{LCP}(i,j)\\ge r-l+1$\n\n具体的，将$\\text{SA}$的$\\text{height}$数组按照$\\text{height}_p\\ge r-l+1$分成一段一段\n\n每个连续段中的两个位置$\\text{LCP}\\ge r-l+1$\n\n合法的$i,j$一定出现的某个连续段中\n\n找到每一个这样一个连续段，然后双指针得到合法的$i,j$即可\n\n$$ \\ $$\n\n这样的跳跃关系，以及跳跃过程中的答案，可以通过倍增来维护出来\n\n对于每个询问，可以先找到区间内第一个合法的点$i_0$，然后倍增查询答案即可\n\n找到$i_0$可以用主席树二分出$\\text{rank}$在$[l',r']$内的第一个$i_0\\ge s$的位置\n\n复杂度为$O(50n\\log n+q\\log n)$\n\n$$ \\ $$\n\n### Part2 $r-l>50$\n\n根据数据范围，这里我们只要能够暴力跳每一个合法的$i$即可\n\n那么像上面一样，用主席树每次找$[l',r']$内第一个$i'> i+r-l$\n\n每次$\\log n$跳即可，复杂度为$O(\\frac{nq}{r-l}\\log n)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n\nchar IO;\nint rd(){\n    int s=0,f=0;\n    while(!isdigit(IO=getchar())) f|=IO=='-';\n    do s=(s<<1)+(s<<3)+(IO^'0');\n    while(isdigit(IO=getchar()));\n    return f?-s:s;\n}\n\nconst int N=2e5+10,M=N*18,S=60;\n\nint n,K,q;\nchar s[N];\nint cnt[N],rk[N<<1],tmp[N],sa[N];\nint st[19][N],Log[N];\nvoid Build() {\n    rep(i,1,n) cnt[(int)s[i]]++;\n    rep(i,1,200) cnt[i]+=cnt[i-1];\n    drep(i,n,1) sa[cnt[(int)s[i]]--]=i;\n    rep(i,1,n) rk[sa[i]]=rk[sa[i-1]]+(s[sa[i]]!=s[sa[i-1]]);\n    for(int m=rk[sa[n]],k=1;k<n && m<n;k<<=1,m=rk[sa[n]]) {\n        int h=0;\n        rep(i,n-k+1,n) tmp[++h]=i;\n        rep(i,1,n) if(sa[i]>k) tmp[++h]=sa[i]-k;\n\n        memset(cnt,0,(m+1)<<2);\t\n        rep(i,1,n) cnt[rk[i]]++;\n        partial_sum(cnt+1,cnt+m+1,cnt+1);\n        drep(i,n,1) sa[cnt[rk[tmp[i]]]--]=tmp[i];\n        rep(i,1,n) tmp[sa[i]]=tmp[sa[i-1]]+(rk[sa[i]]!=rk[sa[i-1]] || rk[sa[i]+k]!=rk[sa[i-1]+k]);\n        memcpy(rk,tmp,(n+1)<<2);\n    }\n    rep(i,2,n) Log[i]=Log[i>>1]+1;\n    int h=0;\n    rep(i,1,n) {\n        int j=sa[rk[i]-1];\n        if(h) h--;\n        while(s[i+h]==s[j+h]) h++;\n        st[0][rk[i]-1]=h;\n    }\n    rep(i,1,Log[n]) {\n        int len=1<<(i-1);\n        rep(j,1,n-len+1) st[i][j]=min(st[i-1][j],st[i-1][j+len]);\n    }\n}\n\nint ls[M],rs[M],c[M],rt[N],tcnt;\nvoid Upd(int &p,int pre,int l,int r,int x){\n    c[p=++tcnt]=c[pre]+1,ls[p]=ls[pre],rs[p]=rs[pre];\n    if(l==r) return;\n    int mid=(l+r)>>1;\n    x<=mid?Upd(ls[p],ls[pre],l,mid,x):Upd(rs[p],rs[pre],mid+1,r,x);\n}\nint Que(int p1,int p2,int l,int r,int x){\n    if(c[p1]==c[p2] || r<x) return n+1;\n    if(l==r) return l;\n    int mid=(l+r)>>1,t=Que(ls[p1],ls[p2],l,mid,x);\n    return t<=n?t:Que(rs[p1],rs[p2],mid+1,r,x);\n}\n\nvector <int> G[S];\nint A[N],B[N],L[N],R[N],X[N];\nll ans[N];\nll H[20][N]; int F[20][N];\nint D[N],C;\n\nint main(){\n    n=rd(),K=rd();\n    scanf(\"%s\",s+1),scanf(\"%s\",s+n+1);\n    n*=2,Build(),n/=2;\n    rep(i,1,n*2) {\n        rt[i]=rt[i-1];\n        if(sa[i]<=n) Upd(rt[i],rt[i],1,n,sa[i]);\n    }\n    rep(i,1,q=rd()) {\n        A[i]=rd(),B[i]=rd();\n        int l=rd(),x=rd()-l+1,r=l=rk[l+n];\n        drep(j,18,0) {\n            if(r+(1<<j)<=n*2 && st[j][r]>=x) r+=1<<j;\n            if(l>(1<<j) && st[j][l-(1<<j)]>=x) l-=1<<j;\n        }\n        L[i]=l,R[i]=r,X[i]=x;\n        if(n<=5000 && q<=5000) {\n            int p=A[i],e=B[i]-x+1;\n            while(p<=e) {\n                while(p<=e && (rk[p]<l || rk[p]>r)) p++;\n                if(p>e) break;\n                ans[i]+=K-p,p+=x;\n            }\n        } else if(X[i]>=S) {\n            int p=A[i],e=B[i]-x+1;\n            while(p<=e) {\n                int c=0;\n                while(++c<5 && p<=e && (rk[p]<l || rk[p]>r)) p++;\n                if(p>e) break;\n                if(rk[p]<l || rk[p]>r) p=Que(rt[l-1],rt[r],1,n,p);\n                if(p>e) break;\n                ans[i]+=K-p,p+=x;\n            }\n        } else G[X[i]].pb(i);\n    }\n    rep(x,1,S-1) if(G[x].size()) {\n        rep(i,1,n) F[0][i]=n+1;\n        rep(i,0,17) F[i][n+1]=n+1;\n        rep(i,1,n*2) {\n            int j=i;\n            while(j<n*2 && st[0][j]>=x) j++;\n            C=0;\n            rep(k,i,j) if(sa[k]<=n) D[++C]=sa[k];\n            if(C) {\n                sort(D+1,D+C+1);\n                int j=1;\n                rep(i,1,C) {\n                    while(j<=C && D[j]-D[i]<x) j++;\n                    if(j<=C) F[0][D[i]]=D[j];\n                }\n            }\n            i=j;\n        }\n        rep(i,1,n) H[0][i]=K-i;\n        rep(j,1,17) rep(i,1,n) {\n            F[j][i]=F[j-1][F[j-1][i]];\n            H[j][i]=H[j-1][i]+H[j-1][F[j-1][i]];\n        }\n        rep(d,0,G[x].size()-1) {\n            int i=G[x][d],e=B[i]-x+1;\n            int p=Que(rt[L[i]-1],rt[R[i]],1,n,A[i]);\n            if(p>e) continue;\n            drep(j,17,0) if(F[j][p]<=e) {\n                ans[i]+=H[j][p];\n                p=F[j][p];\n            }\n            ans[i]+=H[0][p];\n        }\n    }\n    rep(i,1,q) printf(\"%lld\\n\",ans[i]);\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「JOI 2020 Final」奥运公交  (最短路)","url":"/2021/05/21/「JOI 2020 Final」奥运公交  (最短路)/","content":"# 「JOI 2020 Final」奥运公交  (最短路)\n\n问题实际上就是要分别求$1-n$和$n-1$对于每一条边翻转之后的最短路\n\n由于$m$的上限为$n^2$，下面所说的$\\text{Dijkstra}$都是没有堆优化的板本，即$n^2$找最小点，$m$更新\n\n以计算$1-n$为例\n\n不妨先考虑计算删除每一条边$(u,v,c)$之后，1为源点的的最短路情况\n\n我们知道从源点$S$出发的最短路可以用最短路图描述，而最短路图是一张拓扑图（fix:这道题含有0边，所以并不是，但是没有关系）\n\n如果从最短路图中提取一棵树，那么显然只有这些树边需要考虑删除之后对于最短路的影响\n\n对于这些边重新求最短路即可，复杂度为$O(n(m+n^2))$\n\n如何考虑翻转一条边之后的贡献？\n\n不妨再求出以$n$为结束的最短路，即求反图$n$为源点的答案\n\n然后在两个最短路上查询一下即可得到$1-n$的最短路\n\n同理得到$n-1$的答案\n\n复杂度为$O(n(m+n^2))$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair <int,int> Pii;\n#define reg register\n#define mp make_pair\n#define pb push_back\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T& a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T& a,T b){ ((a<b)&&(a=b)); }\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0;int f=0;\n\twhile(!isdigit(IO=getchar())) f|=IO=='-';\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\n\nbool Mbe;\nconst int N=210,M=5e4+10,INF=2e9+10;\n\nint n,m;\nint E[N][N],E2[N][N],EI[N][N],dis[N],vis[N];\nvoid Dijkstra(int S){\n\trep(i,0,n) dis[i]=INF,vis[i]=0;\n\tdis[S]=0;\n\twhile(1) {\n\t\tint u=0;\n\t\trep(i,1,n) if(!vis[i] && dis[i]<dis[u]) u=i;\n\t\tif(!u) break;\n\t\tvis[u]=1;\n\t\trep(i,1,n) if(E[u][i]<INF) cmin(dis[i],dis[u]+E[u][i]);\n\t}\n}\n\nint U[M],V[M],C[M],D[M];\nint mk[M];\nvoid dfs(int u) {\n\tvis[u]=1;\n\trep(i,1,n) if(!vis[i] && E[u][i]<INF && dis[i]==dis[u]+E[u][i]) mk[EI[u][i]]=1,dfs(i);\n}\n\nint Res1[M][N],Res2[M][N];\nll Ans[M];\n\nvoid Solve(int S,int Res[M][N]){ \n    // 计算删除每条边之后，S为源点的最短路情况，放在Res[M][N]中\n\trep(i,1,n) rep(j,1,n) E[i][j]=INF,E2[i][j]=INF;\n\trep(i,1,m) {\n\t\tint u=U[i],v=V[i],c=C[i];\n\t\tif(E[u][v]>c) E2[u][v]=E[u][v],E[u][v]=c,EI[u][v]=i;\n\t\telse if(E2[u][v]>c) E2[u][v]=c;\n\t}\n\tDijkstra(S);\n\trep(i,1,n) vis[i]=0;\n\trep(i,1,m) mk[i]=0;\n\tdfs(S);\n\trep(i,1,m) if(!mk[i]) rep(j,1,n) Res[i][j]=dis[j];\n\trep(i,1,m) if(mk[i]) {\n\t\tswap(E[U[i]][V[i]],E2[U[i]][V[i]]);\n\t\tDijkstra(S);\n\t\trep(j,1,n) Res[i][j]=dis[j];\n\t\tswap(E[U[i]][V[i]],E2[U[i]][V[i]]);\n\t}\n}\n\nvoid Solve(){ \n\tSolve(1,Res1);\n\trep(i,1,m) swap(U[i],V[i]);\n    // 反图计算\n\tSolve(n,Res2);\n\trep(i,1,m) swap(U[i],V[i]);\n\n\trep(i,1,m) {\n\t\tint t=min(Res1[i][n],Res2[i][1]);\n\t\tif(Res1[i][V[i]]<INF && Res2[i][U[i]]<INF) cmin(t,Res1[i][V[i]]+Res2[i][U[i]]+C[i]);\n\t\tAns[i]+=t; // 合并贡献\n\t}\n}\n\nbool Med;\nint main(){ \n\t//fprintf(stderr,\"%.2lf\\n\",(&Med-&Mbe)/1024.0/1024.0);\n\tn=rd(),m=rd();\n\trep(i,1,m) U[i]=rd(),V[i]=rd(),C[i]=rd(),D[i]=rd();\n\tll ans=0;\n\trep(i,1,n) rep(j,1,n) E[i][j]=INF;\n\trep(i,1,m) cmin(E[U[i]][V[i]],C[i]);\n\tDijkstra(1),ans+=dis[n];\n\tDijkstra(n),ans+=dis[1];\n\t\n    // 计算1-n\n\tSolve();\n    // 计算n-1\n\trep(i,1,m) U[i]=n-U[i]+1,V[i]=n-V[i]+1;\n\tSolve();\n\trep(i,1,m) cmin(ans,Ans[i]+D[i]);\n\tprintf(\"%lld\\n\",ans>=INF?-1:ans);\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「JOI 2021 Final」地牢 3 ","url":"/2021/05/21/「JOI 2021 Final」地牢 3 /","content":"# 「JOI 2021 Final」地牢 3 \n\n\n\n### 判定无解\n\n无解即：$\\exists i\\in[S,T-1],A_i>U$\n\n是一个简单的区间最值问题\n\n$$\\  $$\n\n### $O(nm)$\n\n关于用单调队列之类的东西维护每个点权值的方法这里就不提了\n\n形式化地，我们把一层层点放到数轴上，令$X_i=\\sum_{j<i}A_j$\n\n在数轴上坐标每$+1$消耗一点能量，我们要从$X_S$走到$X_T$\n\n考虑每个点的情况，不妨看做是用$B_i$去覆盖$(X_S,X_T]$，求最小权值\n\n发现对于$B_i$，它能够合法覆盖的区间一定是$(X_i,X_i+U]$\n\n暴力地，可以直接让$B_i$更新这段区间的最小权值，然后暴力求和\n\n$$\\  $$\n\n进一步分析每个$B_i$覆盖的区间，可以发现是合法区间$(X_i,X_i+U]$中的某一连续段$(L_i,R_i]$\n\n而$L_i$取决于$B_i$前面第一个$B_{pre}<B_i$，$R_i$取决于后面第一个$B_{nxt}\\leq B_i$\n\n关于$pre,nxt$的求解显然只是一个单调栈解决\n\n得到$(L_i,R_i]$简单的描述\n\n$L_i=\\max\\{X_i,X_{pre}+U\\}$\n\n$R_i=\\min\\{X_i+U,X_{nxt}\\}$\n\n(ps:这样求得的$L_i$不一定$<R_i$)\n\n暴力枚举即可$O(n)$查询\n\n\n\n$$ \\ $$\n\n$$ \\ $$\n\n### $T_i=n+1$ ~~从这里开始需要一些数据结构？~~\n\n考虑倒着从$n$到$1$计算每一个$S_i$的答案\n\n发现在刚插入$i$的时候，$pre_i$还未出现，可以看做$-\\infty$，$nxt_i$已经确定\n\n当$pre_i$出现时可以重新进行一次插入\n\n每次插入可以用三元组表示$(i,pre,nxt)$，为了便于叙述这里$pre,nxt$直接是坐标\n\n考虑对于$L_i,R_i$进行参数分离计算，首先要考虑何时满足$L_i<R_i$\n\n显然条件就是$nxt-pre>U$\n\n$\\displaystyle L_i=\\max\\{X_i,X_{pre}+U\\}=X_{pre}+\\max\\{X_i-X_{pre},U\\}$\n\n$\\displaystyle R_i=\\min\\{X_i+U,X_{nxt}\\}=X_i+\\min\\{U,X_{nxt}-X_i\\}$\n\n$\\displaystyle Answer=\\sum_{nxt-pre>U} (R_i-L_i)\\cdot B_i$\n\n离线询问，离散之后可以用树状数组维护上述式子，对于不合法部分不要加入即可\n\n$$\\ $$\n\n$$ \\ $$\n\n### $O(n\\log n)$\n\n上面已经能计算$T_i=n+1$的询问，考虑将$S,T$转化为$T_{i}=n+1$的问题\n\n如果直接$S,T$相减显然不合法，不妨找到在$(S,n+1)$的方案中，覆盖的$T$的点$T'$\n\n$(S,n+1)-(T',n+1)$会抵消掉在$S$的方案中$T$右边的部分，而$(X_{T'},X_T]$显然仍然是由$B_{T'}$覆盖，补回来即可\n\n由此完成分离操作，而根据上面区间覆盖的定义，$T'$实际上就是$(X_T-U,X_T]$中最小的$B_i$\n\n所有操作都可以$O(n\\log n)$完成\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair <int,int> Pii;\n#define mp make_pair\n#define pb push_back\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\nchar IO;\nint rd(){\n\tint s=0,f=0;\n\twhile(!isdigit(IO=getchar())) f|=IO=='-';\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=2e5+10,INF=1e9+10;\n\nint n,m,A[N],B[N],nxt[N],stk[N],top,C;\nll ans[N],X[N],H[N];\nstruct Node{ int U,k,id; };\nvector <Node> Q[N];\nvector <int> G[N];\nstruct BIT{\n\tll s[N];\n\tvoid Add(int p,ll x){ \n\t\twhile(p<=C) s[p]+=x,p+=p&-p; \n\t}\n\tll Que(int p){\n\t\tll res=0;\n\t\twhile(p) res+=s[p],p-=p&-p;\n\t\treturn res;\n\t}\n} T1,T2;\n// T1维护式子中含U项的和\n// T2维护式子中常数和\n\nstruct MaxTree{\n\tint s[N<<2],bit;\n\tvoid Build(){\n\t\tfor(bit=1;bit<=n+1;bit<<=1) ;\n\t\trep(i,1,n) s[bit+i]=A[i];\n\t\tdrep(i,bit,1) s[i]=max(s[i<<1],s[i<<1|1]);\n\t}\n\tint Que(int l,int r){\n\t\tif(l==r) return s[l+bit];\n\t\tint res=0;\n\t\tfor(l+=bit-1,r+=bit+1;l^r^1;l>>=1,r>>=1){\n\t\t\tif(~l&1) cmax(res,s[l^1]);\n\t\t\tif(r&1) cmax(res,s[r^1]);\n\t\t}\n\t\treturn res;\n\t}\n} Max;\nstruct MinTree{\n\tint s[N<<2],bit;\n\tint Min(int x,int y){ return mp(B[x],x)<mp(B[y],y)?x:y; }\n\tvoid Build(){\n\t\tB[0]=1e9;\n\t\tfor(bit=1;bit<=n+1;bit<<=1) ;\n\t\trep(i,1,n) s[bit+i]=i;\n\t\tdrep(i,bit,1) s[i]=Min(s[i<<1],s[i<<1|1]);\n\t}\n\tint Que(int l,int r){\n\t\tif(l==r) return s[l+bit];\n\t\tint res=0;\n\t\tfor(l+=bit-1,r+=bit+1;l^r^1;l>>=1,r>>=1){\n\t\t\tif(~l&1) res=Min(res,s[l^1]);\n\t\t\tif(r&1) res=Min(res,s[r^1]);\n\t\t}\n\t\treturn res;\n\t}\n} Min;\n// Min 用于寻找T'\n\nvoid Add(int i,ll pre,ll nxt,int k){\n\tint p=lower_bound(H+1,H+C+1,X[i]-pre)-H,r=lower_bound(H+1,H+C+1,nxt-pre)-H;\n\t// -L\n\tT1.Add(p,-B[i]*k), T1.Add(r,B[i]*k);\n\tT2.Add(p,k*B[i]*(X[i]-pre)), T2.Add(r,-k*B[i]*(X[i]-pre));\n\t// +R \n\tp=lower_bound(H+1,H+C+1,nxt-X[i])-H;\n\tT1.Add(1,k*B[i]),T1.Add(p,-k*B[i]);\n\tT2.Add(p,k*(nxt-X[i])*B[i]),T2.Add(r,-k*(nxt-X[i])*B[i]);\n}\n\nint main(){\n\tn=rd(),m=rd();\n\trep(i,1,n) A[i]=rd(),X[i+1]=X[i]+A[i];\n\trep(i,1,n) B[i]=rd();\n\tdrep(i,n+1,1) {\n\t\twhile(top && B[stk[top]]>=B[i]) G[i].pb(stk[top--]);\n\t\tnxt[i]=stk[top],stk[++top]=i;\n\t}\n\tMin.Build(),Max.Build();\n\trep(i,1,m) {\n\t\tint S=rd(),T=rd(),U=rd();\n\t\tif(Max.Que(S,T-1)>U){ ans[i]=-1; continue; }\n\t\tH[++C]=U,Q[S].pb((Node){U,1,i});\n\t\tint l=lower_bound(X+1,X+n+2,X[T]-U)-X; cmax(l,S);\n\t\tint t=Min.Que(l,T);\n\t\tans[i]+=(X[T]-X[t])*B[t];\n\t\tQ[t].pb((Node){U,-1,i});\n\t}\n\tsort(H+1,H+C+1),C=unique(H+1,H+C+1)-H-1;\n\tdrep(i,n,1){\n\t\tAdd(i,-1e9,X[nxt[i]],1);\n\t\tfor(int j:G[i]) Add(j,-1e9,X[nxt[j]],-1),Add(j,X[i],X[nxt[j]],1);\n\t\tfor(Node j:Q[i]){\n\t\t\tint p=lower_bound(H+1,H+C+1,j.U)-H;\n\t\t\tans[j.id]+=j.k*(j.U*T1.Que(p)+T2.Que(p));\n\t\t}\n\t}\n\trep(i,1,m) printf(\"%lld\\n\",ans[i]);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「JOI 2021 Final」机器人","url":"/2021/05/21/「JOI 2021 Final」机器人/","content":"# 「JOI 2021 Final」机器人\n\n原问题中颜色什么时候改没有影响\n\n显然不能记录每条边的颜色，显然在行走过程中不会回到原先的点\n\n因此考虑简化状态\n\n从一个点出去时，走了一条边$(u,v,c,w)$，从$u$出发颜色为$c$的边$w$之和为$S_{u,c}$，则有两种转移：\n\n1.走过来时的边被改变了，权值$w$\n\n2.改变了其他同种颜色的边，权值$S_{u,c}-w$\n\n对于2情况在前面修改的边，在后面不会产生贡献（否则可以直接通过这条边过去，而不需要绕路）\n\n可以直接转移到对应节点\n\n\n\n1类转移的贡献相当于下次走这种颜色时，可以少改变一条边的颜色\n\n即下一次转移2时，权值变为$S_{v,c}-w-w'$\n\n可以增加一个额外权值$-w$，然后对于下一个点$v$所有颜色为$c$的出边转移，这可以通过构建虚点解决\n\n实际上总权值就是$0$\n\n考虑到一种不合法的情况，即走回$u$，但是这样的转移权值就是$S_{v,c}-w'\\ge 0$\n\n非法情况无影响\n\n\n\n最终得到的转移就是一个非负边权的最短路图，可以跑$Dijkstra$解决\n\n总点数$\\leq n+2m$，总边数$\\leq 6m$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n\nchar IO;\nint rd(){\n\tint s=0;\n\twhile(!isdigit(IO=getchar()));\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn s;\n}\n\nconst int N=5e5+10,INF=1e9+10;\n\nint n,m,k;\nstruct Edge{\n\tint v,c,w;\n};\nvector <Edge> G[N];\nint U[N],V[N],C[N],W[N];\n\nstruct Node{\n\tint u; ll d;\n\tbool operator < (const Node __) const {\n\t\treturn d>__.d;\n\t}\n};\npriority_queue <Node> que;\nll dis[N],S[N];\nvoid Upd(int u,ll d){\n\tif(dis[u]<=d) return;\n\tdis[u]=d,que.push((Node){u,d});\n}\nmap <int,int> st[N];\nvoid AddEdge(int u,int v,int c,int w){\n\tif(!st[u].count(c)) {\n\t\tst[u][c]=++k;\n\t\tG[u].pb((Edge){k,0,0});\n\t}\n\tint t=st[u][c];\n\tG[t].pb((Edge){v,c,w}),S[t]+=w;\n}\n\nvoid Dijkstra(){\n\tmemset(dis,63,sizeof dis);\n\tdis[1]=0,que.push((Node){1,0});\n\twhile(!que.empty()) {\n\t\tint u=que.top().u; ll d=que.top().d; que.pop();\n\t\tif(dis[u]<d) continue;\n\t\tif(u<=n) {\n\t\t\tfor(Edge dd:G[u]) {\n\t\t\t\tint t=dd.v;\n\t\t\t\tfor(Edge i:G[t]) {\n\t\t\t\t\tUpd(i.v,d+min((ll)i.w,S[t]-i.w));\n\t\t\t\t\tUpd(st[i.v][i.c],d);\n\t\t\t\t}\n\t\t\t}\n\t\t} else for(Edge i:G[u]) Upd(i.v,d+S[u]-i.w);\n\t}\n\tprintf(\"%lld\\n\",dis[n]<1e17?dis[n]:-1);\n}\n\nint main(){\n\tfreopen(\"robot.in\",\"r\",stdin),freopen(\"robot.out\",\"w\",stdout);\n\tn=rd(),m=rd(),k=n;\n\trep(i,1,m) {\n\t\tint u=rd(),v=rd(),c=rd(),w=rd();\n\t\tAddEdge(u,v,c,w),AddEdge(v,u,c,w);\n\t}\n\tDijkstra();\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「JOISC 2020 Day3」收获","url":"/2021/05/21/「JOISC 2020 Day3」收获/","content":"# 「JOISC 2020 Day3」收获\n\n~~分类讨论.jpg~~\n\n分析一棵苹果树被不断摘掉的过程，找到第一个摘它的人$i$\n\n此后，每次摘它的人，就是$i$前面第一个距离它$\\ge C$的人，不妨设其为$nxt_i$\n\n显然，$i,nxt_i$的关系，会构成基环内向树森林，每条内向边有一个权值$w_i$\n\n容易$O(n)$尺取得到$nxt_i,w_i$，考虑选择环上的一个点$u$，断开$u$对应的内向边，得到一棵树\n\n![Snipaste_2021-03-13_13-26-19.png](https://i.loli.net/2021/03/13/WmyTG6ksfDpoJVl.png)\n\n处理得到环长$len_u$，令$dis_u=w_u$，树上每个点的$dis_v=dis_{nxt_v}+w_v$\n\n考虑一棵苹果树被第一次摘的情况，用一个二元组表示$(v,t)$，即被$v$在$t$时刻摘掉\n\n我们认为是苹果树在基环内向树上走\n\n1.苹果树不跨过$u$时的贡献\n\n此时相当于每个$(v,t)$在往根节点走，贡献来自每个查询$(x,d)$的子树\n\n即满足$v\\in subtree_x,dis_v-dis_x+t\\leq d$\n\n离散之后可以用简单的 询问离线+$dfs$作差+树状数组解决\n\n$$ \\ $$\n\n2.跨过$u$，先将苹果树的贡献移动到$last$上，变为$(last,t'=t+dis_v)$\n\n对于每个询问，显然必须满足$x$在环上\n\n我们也可以令$d'=d-(len_u-dis_v)$，同样将$x$移动到$last$上\n\n此时只需要考虑每个$t'$对于$d'$的贡献\n\n按照$len_u$，我们可以将$t',d'$分段，每段都是$[i\\cdot len_u,(i+1)\\cdot len_u)$的形式\n\n2-1.对于不是同一段内的，每个$t'$的对于$d'$的贡献次数 就是 段编号 之差 \n\n2-2.同一段内，就是满足$t'\\leq d'$且$t'\\mod len_u\\leq d'\\mod len_u$ 的个数\n\n将所有$d',t'$排序后依次处理，容易通过参数分离处理2-1\n\n对于2-2，将$t'\\mod len_u$离散后可以用树状数组处理\n\n[Loj Submission](https://loj.ac/s/1089106)\n\n空间复杂度为$O(n)$，时间复杂度为$O(n\\log n)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll=int64_t;\n#define pb push_back\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\nll rd(){\n    char c;ll s=0;\n    while(c=getchar(),c<48);\n    do s=(s<<1)+(s<<3)+(c^'0');\n    while(c=getchar(),c>47);\n    return s;\n}\nenum{N=200010};\nint n,m,q,nxt[N],L,C,C2,A[N*2],B[N],id[N],incir[N];\nvector <int> E[N],G[N];\nll H[N],dis[N],H2[N],len[N],ans[N];\nvoid dfs(int u){\n    for(int i:E[u]) H[++C]=dis[u]+i;\n    vector <int> tmp;\n    for(int v:G[u]) {\n        if(id[v]==id[u]) continue;\n        tmp.pb(v),id[v]=id[u];\n        dis[v]+=dis[u],dfs(v);\n    }\n    G[u]=tmp;\n}\n\nstruct Node{ ll d; int id; };\nvector <Node> Q[N],que;\nvector <ll> upd;\nstruct BIT{\n    int s[N],n;\n    void Init(int m){ n=m,memset(s,0,(n+1)<<2); }\n    void Add(int p,int x) { while(p<=n) s[p]+=x,p+=p&-p; }\n    int Que(int p) {\n        int res=0;\n        while(p) res+=s[p],p-=p&-p;\n        return res;\n    }\n} T,X;\n\n// dfs作差处理情况1\nvoid dfs2(int u){\n    for(Node &i:Q[u]) {\n        // 如果满足查询点在环上，就要加入2-1,2-2的计算\n        if(incir[u]) {\n            ll d=i.d-(len[id[u]]-dis[u]);\n            if(d>=0) que.pb((Node){d,i.id});\n        }\n        // dfs作差-1\n        ans[i.id]-=T.Que(i.d=upper_bound(H+1,H+C+1,dis[u]+i.d)-H-1);\n    }\n    for(int i:E[u]) T.Add(lower_bound(H+1,H+C+1,dis[u]+i)-H,1),upd.pb(dis[u]+i);\n    for(int v:G[u]) dfs2(v);\n    // dfs作差+1\n    for(Node i:Q[u]) ans[i.id]+=T.Que(i.d);\n}\n\nint main(){\n    n=rd(),m=rd(),L=rd(),C=rd();\n    rep(i,0,n-1) A[i]=rd(),A[i+n]=A[i]+L;\n    rep(i,0,m-1) B[i]=rd();\n    int C_=C%L,p=0;\n    // 尺取预处理i,nxt[i],w[i]\n    rep(i,n,n*2-1) {\n        while(p<i && A[i]-A[p+1]>=C_) p++;\n        nxt[i-n]=p%n,G[p%n].pb(i-n);\n        dis[i-n]=C-C_+A[i]-A[p];\n    }\n    p=0;\n    // 预处理(v,t)\n    rep(i,0,m-1) {\n        while(p<n*2-1 && B[i]+L>=A[p+1]) p++;\n        E[p%n].pb(B[i]+L-A[p]);\n    }\n    C=0;\n    // 断环构建树\n    rep(i,0,n-1) id[i]=-2;\n    rep(i,0,n-1) if(id[i]==-2) {\n        int u=i;\n        for(;~id[u];u=nxt[u]) id[u]=-1;\n        id[u]=u,len[u]=dis[u],incir[u]=1;\n        for(int v=nxt[u];v!=u;v=nxt[v]) len[u]+=dis[v],incir[v]=1;\n        dfs(u);\n    }\n    sort(H+1,H+C+1),T.Init(C=unique(H+1,H+C+1)-H-1);\n    // 离线询问，权值离散\n    rep(i,1,q=rd()) {\n        int u=rd()-1; ll d=rd();\n        Q[u].pb((Node){d,i});\n    }\n    rep(i,0,n-1) if(id[i]==i) {\n        que.clear(),upd.clear();\n        dfs2(i);\n        sort(upd.begin(),upd.end()),sort(que.begin(),que.end(),[&](Node x,Node y){ return x.d<y.d; });\n        C2=0;\n        for(ll x:upd) H2[++C2]=x%len[i];\n        sort(H2+1,H2+C2+1),X.Init(C2=unique(H2+1,H2+C2+1)-H2-1);\n        auto it=upd.begin();\n        ll s=0,c=0;\n        for(Node &q:que) {\n            while(it!=upd.end() && *it<=q.d) \n                X.Add(lower_bound(H2+1,H2+C2+1,*it%len[i])-H2,1),s+=*(it++)/len[i],c++;\n            // 参数分离处理2-1\n            ans[q.id]+=q.d/len[i]*c-s;\n            // 树状数组查询2-2\n            ans[q.id]+=X.Que(upper_bound(H2+1,H2+C2+1,q.d%len[i])-H2-1);\n        }\n    }\n    rep(i,1,q) printf(\"%lld\\n\",ans[i]);\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「JOISC 2020 Day4」传奇团子师傅 (假模拟退火)","url":"/2021/05/21/「JOISC 2020 Day4」传奇团子师傅 (假模拟退火)/","content":"# 「JOISC 2020 Day4」传奇团子师傅 (假模拟退火)\n\n感觉每次想写模拟退火，调着调着就不知道变成什么东西了\n\n首先是分析原图，每个方案对应选择三个点，不同的方案之间显然存在排斥关系\n\n将这些关系建立成边，问题就转化为一个 **一般图最大独立集** 问题\n\n~~这怎么搞得定。。~~\n\n因此考虑退火，每次操作随机选择一个点，检查周围的点是否选择，数一下如果自己被选，要弹掉的点的个数\n\n同普通的退火，一开始温度高不停随机\n\n到了后面就直接变成 选择答案不劣的方案（也就是交换两个点），事实证明这样的效率比较高\n\n但是直接随机容易随机到选过的点，需要稍微加速一下\n\n具体的，退火每若干次为一轮，每轮随机一个排列\n\n在排列中从左到右找到前面$L$个未选点，然后在$L$个点中随机若干次进行决策\n\n我是直接暴力bitset存答案的，但是效率好像还可以\n\n因为是跑一个点调一次参数的，前面的代码都没存。。。\n\ntips:代码对于不同数据需要修改前面三行的常量\n\n```cpp\nconst int N=510,M=N*N/2,INF=1e9+10;\nconst char infile[]=\"5.in\",outfile[]=\"output_05.txt\";\nconst int MAX=48620;\n\nint n,m,C;\nchar s[N][N];\nint chk(char x){ return x=='P' || x=='G'; }\nstruct Node{\n    int x,y,t;\n} R[M];\nbitset <M> Ansmap,Nowmap;\nint ans,now;\n\nint z[4][2]={{0,1},{1,0},{-1,-1},{-1,1}};\nchar S[]=\"-|\\\\/\";\nvector <int> G[N][N],E[M];\n\nstruct Naive_Simulator{\n    ~Naive_Simulator(){\n        cerr<<\"!\"<<endl;\n        rep(i,1,C) if(Ansmap[i]) s[R[i].x][R[i].y]=S[R[i].t];\n        rep(i,1,n) puts(s[i]+1);\n    }\n    int P[M],D[M],F[M],PC,counter,lst,L;\n    void Work(db T,db d,db End,int delta) {\n        while(T>End && ans<MAX) {\n            if(++counter%4000==0) {\n                cerr<<ans<<' '<<T<<endl;\n            }\n            if(counter%500==0) random_shuffle(D+1,D+C+1),lst=1;\n            PC=0;\n            rep(i,lst,C) if(!Nowmap[D[i]]) {\n                P[++PC]=D[i];\n                lst=i;\n                if(PC>=L) break;\n            }\n            if(PC<L) {\n                lst=1;\n                PC=0;\n                rep(i,lst,C) if(!Nowmap[D[i]]) {\n                    P[++PC]=D[i];\n                    lst=i;\n                    if(PC>=L) break;\n                }\n            }\n            rep(kase,1,50) {\n                int u,v;\n                u=P[rand()%PC+1],v=P[rand()%PC+1];\n                if(u==v || Nowmap[u]) {\n                    kase--;\n                    continue;\n                }\n                int cnt=0;\n                for(int v:E[u]) cnt+=Nowmap[v];\n                if(cnt-delta<=T) {\n                    Nowmap[u]=1;\n                    for(int v:E[u]) Nowmap[v]=0;\n                    now+=1-cnt;\n                } \n                if(kase%5==0 && now>ans) ans=now,Ansmap=Nowmap;\n            }\n            T*=d;\n        }\n    }\n    void Simulate(){\n        //srand(114514);\n        //srand(1919810);\n        srand(time(NULL));\n        now=0,Nowmap.reset();\n        counter=0,lst=1,L=200;\n        rep(i,1,C) D[i]=i;\n        rep(kase,1,10) Work(2,0.95,1e-2,1);\n        Work(0.99,0.99993,1e-8,2);\n        Nowmap=Ansmap,now=ans;\n        Work(0.99,0.99999,0,1);\n        return;\n    }\n\n    Naive_Simulator(){\n        freopen(infile,\"r\",stdin),freopen(outfile,\"w\",stdout);\n        n=rd(),m=rd();\n        rep(i,1,n) scanf(\"%s\",s[i]+1);\n        rep(i,1,n) rep(j,1,m) if(!chk(s[i][j])) {\n            s[i][j]='W';\n            rep(d,0,3) if(chk(s[i+z[d][0]][j+z[d][1]]) && chk(s[i-z[d][0]][j-z[d][1]]) && s[i+z[d][0]][j+z[d][1]]!=s[i-z[d][0]][j-z[d][1]]) {\n                R[++C]=(Node){i,j,d};\n                G[i][j].pb(C);\n                G[i+z[d][0]][j+z[d][1]].pb(C);\n                G[i-z[d][0]][j-z[d][1]].pb(C);\n            }\n        }\n        rep(i,1,n) rep(j,1,m) rep(k,0,G[i][j].size()-1) rep(l,k+1,kend) {\n            E[G[i][j][k]].pb(G[i][j][l]);\n            E[G[i][j][l]].pb(G[i][j][k]);\n        }\n        Simulate();\n    }\n} Solver;\n\nint main(){ ; }\n```\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「JOISC 2020 Day3」星座 3 (Dp)","url":"/2021/05/21/「JOISC 2020 Day3」星座 3 (dp)/","content":"# 「JOISC 2020 Day3」星座 3 (dp)\n\n考虑根据$A_i$的值建立笛卡尔树，此时平面被划分为个矩形空间\n\n下称选择一个点为保留一个星星\n\n![Snipaste_2021-03-13_11-21-27.png](https://i.loli.net/2021/03/13/SLHx8PR4rwIo1h3.png)\n\n具体的，对于笛卡尔树上的节点$(u,l,r)$，它的矩形就是父节点矩形以下，且满足$x\\in[l,r],y>A_u$的部分\n\n可以用一个线段树来查询矩形内部的点，线段树上每个节点维护$y_{max}$，每次剥掉$y_{max}>A_u$的部分\n\n复杂度为均摊$O(n\\log n)$\n\n$$ \\ $$\n\n观察笛卡尔树的树形，容易发现，\n\n1.笛卡尔树左右子树的矩形之间不会产生贡献\n\n2.每个节点对应的矩形区间内最多选择一个点\n\n3.如果一个节点$(u,l,r)$的祖先中有一个$x_i\\in[l,r]$的点选择了，那么自己的矩形内不能选择点\n\n那么令$dp_{u,i}$表示父节点传下来的点$x=i$时，$u$子树内的答案\n\n对于$i\\in[l,r]$的情况，可以直接将儿子的值合并，加上自己区间内部的权值总和$C_i$\n\n对于$i\\not \\in[l,r]$的情况，这一部分答案相同\n\n可以从自己子区间内选择一个点$(x_i,y_i,c_i)$下传，此时沿用上面合并得到的$dp$值\n\n$outans=\\min\\{dp_{x_i}+sum-c_i\\}$\n\n如何实现这个奇怪的$dp$过程？\n\n考虑子树的区间不交，因此对于$(u,l,r)$，只维护$l,r$内部的答案，对于$i\\not \\in[l,r]$的部分额外记录一个值$dp_u$\n\n考虑用一棵静态的线段树维护$dp$，线段树上存储$i\\in[l,r]$的答案\n\n合并左右儿子时，两个儿子的区间不交\n\n因此，实际上答案就是将$dp_{ls}$加到$[u,r]$上，将$dp_{rs}$加到$[l,u]$上\n\n处理出$sum$之后，区间修改$[l,r]$的答案，对于$dp_u$直接按照上面的方法枚举$(x_i,y_i,c_i)$来计算即可\n\n复杂度为$O(n\\log n)$\n\n```cpp\nint n,A[N];\nstruct SegFinder{\n\tvector <Pii> V[N];\n\tint s[N<<2];\n\tvoid Build(int p,int l,int r){\n\t\tif(l==r) {\n\t\t\tsort(V[l].begin(),V[l].end());\n\t\t\ts[p]=V[l].empty()?0:V[l].back().first;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tBuild(p<<1,l,mid),Build(p<<1|1,mid+1,r);\n\t\ts[p]=max(s[p<<1],s[p<<1|1]);\n\t}\n\tvoid Get(int p,int l,int r,int ql,int qr,int x,vector <Pii> &Res){\n\t\tif(s[p]<x) return;\n\t\tif(l==r) {\n\t\t\twhile(!V[l].empty() && V[l].back().first>=x) Res.pb(mp(l,V[l].back().second)),V[l].pop_back();\n\t\t\ts[p]=V[l].empty()?0:V[l].back().first;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tif(ql<=mid) Get(p<<1,l,mid,ql,qr,x,Res);\n\t\tif(qr>mid) Get(p<<1|1,mid+1,r,ql,qr,x,Res);\n\t\ts[p]=max(s[p<<1],s[p<<1|1]);\n\t}\n} Finder;\n\nint ls[N],rs[N],stk[N],top,mk[N];\nint rt[N];\nll dp[N],s[N<<2],t[N<<2];\nll Que(int p,int l,int r,int ql,int qr){\n\tif(ql<=l && r<=qr) return s[p];\n\tint mid=(l+r)>>1; ll res=1e18;\n\tif(ql<=mid) cmin(res,Que(p<<1,l,mid,ql,qr));\n\tif(qr>mid) cmin(res,Que(p<<1|1,mid+1,r,ql,qr));\n\treturn res+t[p];\n}\n\nvoid Upd(int p,int l,int r,int ql,int qr,ll x){\n\tif(ql<=l && r<=qr) {\n\t\ts[p]+=x,t[p]+=x;\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tif(ql<=mid) Upd(p<<1,l,mid,ql,qr,x);\n\tif(qr>mid) Upd(p<<1|1,mid+1,r,ql,qr,x);\n\ts[p]=min(s[p<<1],s[p<<1|1])+t[p];\n}\n\n// 线段树内存储的是 如果父节点有下传下来的答案\n// dp 存储没有父节点下传的答案\n\nvoid Solve(int p,int l,int r){\n\tvector <Pii> V; Finder.Get(1,1,n,l,r,A[p]+1,V);\n\t// 拿出我的决策矩形\n\n\tif(l<p) Solve(ls[p],l,p-1);\n\tif(p<r) Solve(rs[p],p+1,r);\n\tif(rs[p]) Upd(1,1,n,l,p,dp[rs[p]]);\n\tif(ls[p]) Upd(1,1,n,p,r,dp[ls[p]]);\n\tll sum=0;\n\tfor(Pii i:V) sum+=i.second;\n\tif(sum) Upd(1,1,n,l,r,sum); \n\t// 如果父节点有下传，那么自己必须被清空\n\t// 否则考虑选择一个下传下去，这样就能得到 没有父节点下传时的值\n\tdp[p]=Que(1,1,n,l,r);\n\tfor(Pii i:V) cmin(dp[p],Que(1,1,n,i.first,i.first)-i.second);\n}\n\nint main(){\n\tn=rd();\n\trep(i,1,n) {\n\t\tA[i]=rd();\n\t\twhile(top && A[stk[top]]<=A[i]) ls[i]=stk[top--];\n\t\tstk[++top]=i;\n\t}\n\ttop=0;\n\tdrep(i,n,1) {\n\t\twhile(top && A[stk[top]]<A[i]) rs[i]=stk[top--];\n\t\tstk[++top]=i;\n\t}\n\trep(i,1,n) mk[ls[i]]=mk[rs[i]]=1;\n\trep(_,1,rd()) {\n\t\tint x=rd(),y=rd(),c=rd();\n\t\tFinder.V[x].pb(mp(y,c));\n\t}\n\tFinder.Build(1,1,n);\n\trep(i,1,n) if(!mk[i]) {\n\t\tSolve(i,1,n);\n\t\tprintf(\"%lld\\n\",dp[i]);\n\t\treturn 0;\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「JOISC 2020 Day4」首都城市","url":"/2021/05/21/「JOISC 2020 Day4」首都城市/","content":"# 「JOISC 2020 Day4」首都城市\n\n题目大意：给定一棵树，每个点有颜色\n\n求选择一个最小的颜色集合，使得这些颜色的点能够构成一个连通块\n\n----------\n\n容易发现，选取这个颜色就必须将这个颜色连通路径上的所有其它颜色选掉\n\n但是要纠正一个：\n\n并不是选取的这个颜色的连通路径上的颜色就行\n\n因为选取另一个颜色，可能导致不在当前连通路径上的其它颜色也需要被选取\n\n$$ \\ $$\n\n这样的关系构成一个有向图，一条边表示选了$u$就选$v$\n\n因此可以考虑$\\text{tarjan}$强连通缩点，由于最终我们选择强连通分量一定没有出边（否则不优）\n\n因此可以线性统计答案，问题在于如何建立这个图\n\n首先考虑如何将这个连通路径提取出来，一种简单的办法是：找到这个颜色所有点的$\\text{LCA}$，路径就可以表示为$\\text{LCA}$到所有点路径的并\n\n### Solution1\n\n树剖线段树完成路径连边\n\n点数为$O(n)$，边数为$O(n\\log ^2n)$\n\n### Solution2\n\n倍增连边\n\n点数边数均为$O(n\\log n)$\n\n### Solution3\n\n离线，用类似$\\text{tarjan LCA}$的方式，维护一个并查集\n\n每次并查集的父亲关系改变时，新建节点，即可完成一个类似可持久化的操作\n\n如果再用$\\text{tarjan}$预处理$\\text{LCA}$，复杂度/点数/边数 就为$O(n\\alpha(n))$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair <int,int> Pii;\n#define pb push_back\n#define mp make_pair\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\nchar buf[200000],*p1,*p2;\n#define getchar() (((p1==p2)&&(p2=(p1=buf)+fread(buf,1,200000,stdin))),*p1++)\nint rd(){\n\tint s=0;static char c;\n\twhile(c=getchar(),c<48);\n\tdo s=(s<<1)+(s<<3)+(c^'0');\n\twhile(c=getchar(),c>47);\n\treturn s;\n}\n\nconst int N=2e5+10,INF=1e9+10,K=N*3.5;\n\nint n,k,m;\nint A[N],L[N],F[N],C[N],Fir[N],I[N];\nvector <int> G[N],V[N];\nstruct Edge{ \n\tint to,nxt; \n} e[K*2];\nint head[K],ecnt;\nvoid AddEdge(int u,int v){\n\tif(u==v) return;\n\te[++ecnt]=(Edge){v,head[u]};\n\thead[u]=ecnt;\n}\n\nint Find1(int x){ return F[x]==x?x:F[x]=Find1(F[x]); }\nvoid pre_dfs(int u,int f){\n\tF[u]=u;\n\tif(!Fir[A[u]]) Fir[A[u]]=u;\n\tif(--C[A[u]]==0) L[A[u]]=Find1(Fir[A[u]]);\n\tfor(int v:G[u]) if(v!=f) pre_dfs(v,u);\n\tF[u]=f;\n}\n\nPii Find(int x){\n\tif(F[x]==x) return mp(F[x],I[x]);\n\tPii t=Find(F[x]);\n\treturn AddEdge(++m,t.second),AddEdge(m,I[x]),F[x]=t.first,mp(F[x],I[x]=m);\n}\n\nvoid dfs(int u,int f){\n\tF[u]=u,I[u]=A[u];\n\tfor(int v:G[u]) if(v!=f) dfs(v,u);\n\tfor(int v:V[u]) AddEdge(A[v],Find(v).second);\n\tF[u]=f;\n}\n\nint t[K],low[K],ins[K],stk[K],top,dfn;\nint ans=1e9,vis[N],out[K];\nvoid dfs(int u){\n\tt[u]=low[u]=++dfn,ins[stk[++top]=u]=1;\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(!t[v]) dfs(v),cmin(low[u],low[v]);\n\t\telse if(ins[v]) cmin(low[u],t[v]);\n\t}\n\tif(low[u]==t[u]){\n\t\tint fl=1,tmp=top;\n\t\tfor(int v=-1;v!=u;){\n\t\t\tv=stk[top--];\n\t\t\tfor(int i=head[v];i;i=e[i].nxt) if(!ins[e[i].to]) { fl=0; break; }\n\t\t}\n\t\trep(i,top+1,tmp) ins[stk[i]]=0;\n\t\tif(fl) {\n\t\t\tint res=0;\n\t\t\trep(i,top+1,tmp) {\n\t\t\t\tint x=stk[i];\n\t\t\t\tif(x<=k && !vis[x]) vis[x]=1,res++;\n\t\t\t}\n\t\t\trep(i,top+1,tmp) if(stk[i]<=k) vis[stk[i]]=0;\n\t\t\tif(res) cmin(ans,res-1);\n\t\t}\n\t}\n}\n\nint main(){\n\tn=rd(),k=rd();\n\trep(i,2,n) {\n\t\tint u=rd(),v=rd();\n\t\tG[u].pb(v),G[v].pb(u);\n\t}\n\trep(i,1,n) C[A[i]=rd()]++;\n\tpre_dfs(1,0);\n\trep(i,1,n) V[L[A[i]]].pb(i);\n\tm=k;\n\tdfs(1,0);\n\trep(i,1,k) if(!t[i]) dfs(i);\n\tprintf(\"%d\\n\",ans);\n\tfprintf(stderr,\"Vertices =%d \\nEdges =%d\\n\",m,ecnt);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「JSOI2019」神经网络","url":"/2021/05/21/「JSOI2019」神经网络/","content":"# 「JSOI2019」神经网络\n\n考虑一个合法的哈密顿路可以表示为什么样子：\n\n按照不同树的编号，分割为一段段，相邻两段属于不同树\n\n同时，如果最后一段和第一段同编号，将最后一段移动到第一段前面\n\n由此，一个哈密顿路可以由唯一表示：\n\n1号点在第一个段中，此后每一段和上一个属于不同树，且最后一段不属于1树\n\n由此，问题分解为两部分：\n\n### Part1 求解树路径分段\n\n考虑树形$dp$求解，每个点记录$dp_{i,j,0/1}$表示当前$i$子树内已经产生$j$条路径，$i$自己是否可以向父亲连边\n\n容易用类似树形背包的方式合并，每次决策儿子是否连接到自己上面\n\n注意：一个长度$>1$的段，需要考虑正反方向的排放\n\n复杂度为$O(\\sum k_i^2)$\n\n$$ \\ $$\n\n### Part2 合并每棵树的段\n\n相邻两段不同色，考虑容斥求解\n\n枚举这棵树中的$i$个段自己生成了$j$个不合法的相邻，$i$个段合并生成$i-j$个段，且乘上容斥系数$(-1)^j$\n\n$i$个并掉$j$个，方案数计算如下：\n\n先把$i$个排好，乘上$i!$，然后选择$j$个间隔合并掉$\\binom{i-1}{j}$，然后对于剩下的$i-j$个元素无序，需要除掉$(i-j)!$\n\n背包合并容斥之后的结果，对于当前的$i$个元素，任意排列即可\n\n然而上面是理想情况，还需要考虑$1$号元素不能被排列，要强制最后一个段不是1树的段\n\n这一部分，在树1的容斥以及最终背包合并时特殊处理即可，即少排列一个元素，且最后合并时先选一个放在最后面\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair <int,int> Pii;\n#define reg register\n#define mp make_pair\n#define pb push_back\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) f|=IO=='-';\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=5e3+10,P=998244353;\n\nint n,m;\nint I[N],J[N],C[N][N];\nll qpow(ll x,ll k=P-2) {\n\tll res=1;\n\tfor(;k;k>>=1,x=x*x%P) if(k&1) res=res*x%P;\n\treturn res;\n}\n\nstruct Edge{\n\tint to,nxt;\n} e[N<<1];\nint head[N],ecnt;\nvoid AddEdge(int u,int v){\n\te[++ecnt]=(Edge){v,head[u]};\n\thead[u]=ecnt;\n}\nint dp[N][N][2]; // 0,1 是否向上连\nint G[N][3],H[N][3],sz[N];\n\nvoid dfs(int u,int f){\n\tsz[u]=0;\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==f) continue;\n\t\tdfs(v,u);\n\t}\n\tG[0][0]=1,G[0][1]=G[0][2]=0;\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==f) continue;\n\t\trep(i,0,sz[u]+sz[v]) rep(j,0,2) H[i][j]=G[i][j],G[i][j]=0;\n\t\trep(i,0,sz[u]) rep(a,0,2) if(H[i][a]) rep(j,0,sz[v]) rep(b,0,min(1,2-a)) G[i+j][a+b]=(G[i+j][a+b]+1ll*H[i][a]*dp[v][j][b])%P;\n\t\tsz[u]+=sz[v];\n\t}\n\trep(i,0,sz[u]+1) dp[u][i][0]=dp[u][i][1]=0;\n\trep(i,0,sz[u]) {\n\t\tdp[u][i+1][0]=(0ll+dp[u][i+1][0]+G[i][0]+2*G[i][1]+2*G[i][2])%P; // 长度>1的段可以翻转\n\t\tdp[u][i][1]=(0ll+dp[u][i][1]+G[i][0]+G[i][1])%P; // 如果连了两个儿子，就无法向上连了\n\t}\n\tsz[u]++;\n}\n\nint F[N],T[N];\nvoid Get(){\n\tn=rd();\n\trep(i,1,n) head[i]=0;\n\tecnt=0;\n\trep(i,2,n) {\n\t\tint u=rd(),v=rd();\n\t\tAddEdge(u,v),AddEdge(v,u);\n\t}\n\tdfs(1,0);\n\trep(i,1,n) {\n\t\tF[i]=dp[1][i][0],T[i]=0;\n\t\tll t=1ll*F[i]*J[i]%P;\n\t\trep(j,1,i) {\n\t\t\tT[j]=(T[j]+((i-j)&1?P-1:1)*t%P*C[i-1][i-j]%P*I[j])%P;\n\t\t}\n\t}\n}\n\nint S[N],c;\n\nint main(){\n\trep(i,J[0]=1,N-1) J[i]=1ll*J[i-1]*i%P;\n\tI[N-1]=qpow(J[N-1]);\n\tdrep(i,N-1,1) I[i-1]=1ll*I[i]*i%P;\n\trep(i,0,N-1) rep(j,C[i][0]=1,i) C[i][j]=C[i-1][j]+C[i-1][j-1],Mod1(C[i][j]);\n\tm=rd();\n\tif(m==1) return n=rd(),printf(\"%d\\n\",n<=2),0;\n\tS[0]=1;\n\trep(t,1,m-1) {\n\t\tGet();\n\t\tdrep(i,n+c,0) {\n\t\t\tS[i]=0;\n\t\t\trep(j,1,min(i,n)) S[i]=(S[i]+1ll*S[i-j]*T[j])%P;\n\t\t}\n\t\tc+=n;\n\t}\n\tGet();\n\trep(i,1,n) {\n\t\tF[i]=dp[1][i][0],T[i]=0;\n\t\tll t=1ll*F[i]*J[i-1]%P; \n\t\t// 特殊处理，不允许排列第一段\n\t\trep(j,1,i) T[j]=(T[j]+((i-j)&1?P-1:1)*t%P*C[i-1][i-j]%P*I[j-1])%P;\n\t}\n\tint ans=0;\n\t// 不允许改变第一段的位置\n\t// 且强制最后一段不能属于第一棵树\n\trep(i,1,c) if(S[i]) rep(j,1,n) if(T[j]) {\n\t\t// 强制前面的最后一个在最后\n\t\tint t=1ll*J[i]*J[j-1]%P*C[i-1+j-1][j-1]%P;\n\t\tans=(ans+1ll*t*S[i]%P*T[j])%P;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「NOI2020」时代的眼泪","url":"/2021/05/21/「NOI2020」时代的眼泪/","content":"# 「NOI2020」时代的眼泪\n\n#### 前言\n\n这种东西看到就给人一种\n\n分块分块分块分块分块分块!\n\n啊啊啊啊啊啊啊啊啊啊啊\n\n$$\\  $$\n\n### 问题分析\n\n这是一个二维区间顺序对问题，对于普通的区间顺序对问题，我们有简单分块解法\n\n预处理整块的答案，有$n\\sqrt n$个数要插入预处理，也就是有$O(\\sqrt n)$个区间查询\n\n对于散点暴力求，也是$n\\sqrt n$个区间查询问题\n\n那么离线+分块就可以做到$O(\\sqrt n)$插入一个数，$O(\\sqrt 1)$查询，并且有办法将空间实现到$O(n)$\n\n那么对于二维区间考虑部分沿用上面的思路\n\n$$ \\ $$\n\n### Solution\n\n首先对于散块的部分，是完全一样的处理，可以$O(n)$内存实现\n\n具体的：\n\n散点之间可以暴力$for$答案，每次还需要一个二维区间个数查询\n\n每次需要查询的散点又是一段区间\n\n可以描述为$O(m)$个查询，总共查询$O(m\\sqrt n)$个散点\n\n$$ \\ $$\n\n问题在于整块部分的查询$[p1,p2],[u,d]$\n\n对于同一个块内的答案，可以暴力预处理出来\n\n$$ \\ $$\n\n而块之间，可以转化为$[1,d]-[1,u-1]-[1,u-1]\\times [u,d]$\n\n前面两个前缀型问题，可以用如下方法实现：\n\n按照$p_i$从小到大插入，同时维护每个块内已经出现的个数\n\n每次插入$i$后，对于$i$前面的块，会产生$O(\\sqrt n)$对 顺序对\n\n我们要查询的是一个块编号$[p1,p2]$内块的关系，这是一个二维前缀和\n\n可以把两个维度的前缀和分开给插入和查询\n\n具体的，在插入时，处理$S_{l,r}=\\sum_{i\\ge l} C_{i,r}$\n\n查询$[p1,p2]$时，就可以暴力求$S_{l,i}i\\in[l,r]$的和\n\n这样可以分摊复杂度为$O(n\\sqrt n)$，并且内存为$O(n)$，常数较小\n\n$$ \\ $$\n\n对于$[1,u-1]\\times [u,d]$，从左到右一段段 查询过来，每次查询块内$[1,u-1]$$，[u,d]$个数即可\n\n这个统计和上面的块内答案统计都需要预处理每个数在块内排名\n\n但是也可以通过离线去掉这个步骤，避免了一个$O(n\\sqrt n)$的数组\n\n$$ \\ $$\n\n实际实现时，发现散块暴力的部分枚举起来实在太慢，所以块开大了一点，加了一点底层玄学优化\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair <int,int> Pii;\ntypedef vector <int> V;\n#define reg register\n#define mp make_pair\n#define pb push_back\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,T b){ ((a<b)&&(a=b)); }\n\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) f|=IO=='-';\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=1e5+10,M=2e5+10,S=1000;\n\nint n,m,A[N],len,P[N];\nstruct Blocker{\n\tint s[M],t[N];\n\tvoid clear(){ memset(s,0,(n+1)<<2),memset(t,0,(n+1)<<2); }\n\tvoid Add(int x){\n\t\tint p=x/len;\n\t\trep(i,x,(p+1)*len-1) s[i]++;\n\t\trep(i,p+1,n/len) t[i]++;\n\t}\n\tint operator [](const int &x) const{ return s[x]+t[x/len]; }\n} B;\nint L[M],R[M],U[M],D[M],p1[M],p2[M],I[M],T[M];\nll Ans[M];\nstruct Que{ int l,r,k,id; };\nvector <Que> Q[N];\n// 处理散点\nvoid SolvePoints(){\n\trep(i,1,n) {\n\t\tB.Add(A[i]);\n\t\tfor(Que x:Q[i]) {\n\t\t\trep(j,x.l,x.r) {\n\t\t\t\tint u=U[x.id],d=D[x.id];\n\t\t\t\tif(A[j]<u || A[j]>d) continue;\n\t\t\t\tif(j>i) cmin(d,A[j]-1);\n\t\t\t\telse cmax(u,A[j]+1);\n\t\t\t\tAns[x.id]+=x.k*(B[d]-B[u-1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector <Pii> E[N];\n// 处理块区间的 前缀逆序对\nvoid SolveB1(){\n\tstatic ll s[S][S],c[S];\n\trep(k,1,n) {\n\t\tint i=P[k],t=0,p=i/len;\n\t\tc[p]++;\n\t\tdrep(j,p-1,0) t+=c[j],s[j][p]+=t;\n\t\tfor(Pii x:E[k]) {\n\t\t\tint u=x.first,l=p1[u]+1,r=p2[u]-1;\n\t\t\trep(j,l+1,r) Ans[u]+=s[l][j]*x.second;\n\t\t}\n    }\n}\n\n//处理块内答案\nvoid SolveB2(){\n\tstatic int s[S][S],C[N];\n\trep(i,0,n/len) {\n\t\tint l=max(1,i*len),r=min(n,(i+1)*len-1);\n\t\trep(j,1,n) C[j]=C[j-1]+(l<=P[j] && P[j]<=r);\n\t\tint L=C[n];\n\t\trep(a,1,L+1) rep(b,a-1,L+1) s[a][b]=0;\n\t\trep(a,l,r) rep(b,a+1,r) if(A[a]<=A[b]) s[C[A[a]]][C[A[b]]]++;\n\t\tdrep(a,L,1) rep(b,a,L) s[a][b]+=s[a+1][b]+s[a][b-1]-s[a+1][b-1];\n\t\trep(j,1,m) if(p1[j]<i && i<p2[j]) {\n\t\t\tAns[j]+=s[C[U[j]-1]+1][C[D[j]]];\n\t\t\tAns[j]-=1ll*T[j]*(C[D[j]]-C[U[j]-1]);\n\t\t\tT[j]+=C[U[j]-1];\n\t\t}\n\t}\n}\n\n// 本来是暴力for l,r内的逆序对的，但是太慢，加了一点底层优化\nint Que(int i,int l,int r,int u,int d){\n\tif(r-l>45) {\n\t\tint mid=(l+r*3)/4;\n\t\tQ[l-1].pb({mid+1,r,-1,i});\n\t\tQ[mid].pb({mid+1,r,1,i});\n\t\treturn Que(i,l,mid,u,d)+Que(i,mid+1,r,u,d);\n\t}\n\tint ans=0;\n\trep(i,l,r) if(u<=A[i] && A[i]<=d) rep(j,i+1,r) ans+=A[i]<=A[j] && A[j]<=d;\n\treturn ans;\n}\n\nint main(){\n\tfreopen(\"tears.in\",\"r\",stdin),freopen(\"tears.out\",\"w\",stdout);\n\tn=rd(),m=rd(),len=ceil(sqrt(n/4.0));\n\tfprintf(stderr,\"Block len=%d ,Block Count=%d\\n\",len,n/len);\n\trep(i,1,n) P[A[i]=rd()]=i;\n\tclock_t ti=clock();\n\trep(i,1,m) {\n\t\tI[i]=i,L[i]=rd(),R[i]=rd(),U[i]=rd(),D[i]=rd();\n\t\tp1[i]=L[i]/len,p2[i]=R[i]/len;\n\t\tif(p1[i]==p2[i]){ Ans[i]=Que(i,L[i],R[i],U[i],D[i]); continue; }\n\t\tAns[i]=Que(i,L[i],(p1[i]+1)*len-1,U[i],D[i])+Que(i,p2[i]*len,R[i],U[i],D[i]);\n\t\tQ[L[i]-1].pb({p2[i]*len,R[i],-1,i});\n\t\tQ[p2[i]*len-1].pb({p2[i]*len,R[i],1,i});\n\t\tif(p1[i]<p2[i]-1) {\n\t\t\tQ[(p1[i]+1)*len-1].pb({L[i],(p1[i]+1)*len-1,-1,i});\n\t\t\tQ[p2[i]*len-1].pb({L[i],(p1[i]+1)*len-1,1,i});\n\t\t\tE[D[i]].pb(mp(i,1));\n\t\t\tE[U[i]-1].pb(mp(i,-1));\n\t\t}\n\t}\n\tfprintf(stderr,\"Part0 %d\\n\",int(clock()-ti)),ti=clock();\n\tSolvePoints();\n\tfprintf(stderr,\"Part1 %d\\n\",int(clock()-ti)),ti=clock();\n\tsort(I+1,I+m+1,[&](int x,int y){ return L[x]<L[y]; });\n\tSolveB1();\n\tfprintf(stderr,\"Part2 %d\\n\",int(clock()-ti)),ti=clock();\n\tSolveB2();\n\tfprintf(stderr,\"Part3 %d\\n\",int(clock()-ti)),ti=clock();\n\trep(i,1,m) printf(\"%lld\\n\",Ans[i]);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「PA 2019」Szprotki I Szczupaki","url":"/2021/05/21/「PA 2019」Szprotki i szczupaki/","content":"# 「PA 2019」Szprotki i szczupaki\n\n根据题意模拟，得到一种浅显的贪心方法是: 每次选择能吃的最大的一个吃掉\n\n如果用set维护，就能得到一个$O(n^2\\log n)$的算法!\n\n考虑用加速这个贪心:\n\n设当前重量为$now$，目标是$des$\n\n每次找到存在$\\ge now$的最小的一条鱼$nxt$\n\n那么这一次决策的目标就是吃最少的鱼让自己能够吃掉$nxt$或者直接达到$des$\n\n在达到这一次的决策目标之前，能够吃的鱼的集合都是一样的\n\n那么就可以找到最短的一段以$now-1$为右端点的区间使得区间的和达到目标\n\n发现每做一次决策之后，下一次吃一条鱼就会翻倍，所以只有$\\log 10^{18}$次决策\n\n那么考虑如何用数据结构维护这个目标\n\n注意一个比较难维护的问题，每次决策之后，被吃掉的鱼应当**暂时消失**\n\n暂时消失的问题，常见的思路可能是:可持久化 或者 删除之后存下来回撤\n\n### 平衡树\n\n涉及到插入，删除，二分区间，删除区间和复原区间\n\n可以用$\\text{Splay}$或者非旋$\\text{Treap}$维护这个问题\n\n复原区间的过程可以写成一个伪平衡树合并的样子\n\n~~非常慢~~\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair <int,int> Pii;\n#define mp make_pair\ntypedef long long ll;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,const T &b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,const T &b){ ((a<b)&&(a=b)); }\n \nchar IO;\ntemplate <class T=int> T rd(){\n    T s=0; int f=0;\n    while(!isdigit(IO=getchar())) if(IO=='-') f=1;\n    do s=(s<<1)+(s<<3)+(IO^'0');\n    while(isdigit(IO=getchar()));\n    return f?-s:s;\n}\n \nconst int N=4e5+10;\nconst ll U=1e12;\n \nint n,m;\nint rt,c[N],ls[N],rs[N],key[N],ma[N],mi[N];\nll s[N],val[N];\n \nint cmp(int x,int y){ return val[x]!=val[y]?val[x]<val[y]:x>y; }\nvoid Up(int p) {\n    s[p]=s[ls[p]]+s[rs[p]]+val[p];\n    c[p]=c[ls[p]]+c[rs[p]]+1;\n    ma[p]=mi[p]=p;\n    if(ma[ls[p]] && cmp(ma[p],ma[ls[p]])) ma[p]=ma[ls[p]];\n    if(ma[rs[p]] && cmp(ma[p],ma[rs[p]])) ma[p]=ma[rs[p]];\n    if(mi[ls[p]] && cmp(mi[ls[p]],mi[p])) mi[p]=mi[ls[p]];\n    if(mi[ls[p]] && cmp(mi[ls[p]],mi[p])) mi[p]=mi[rs[p]];\n}\nvoid Show(int x) {\n    if(ls[x]) Show(ls[x]);\n    printf(\"(%d,%lld,%lld) \",x,val[x],s[x]);\n    if(rs[x]) Show(rs[x]);\n}\n \n \nint Union(int x,int y) {\n    if(!x || !y) return x|y;\n    if(key[x]<key[y]) return rs[x]=Union(rs[x],y),Up(x),x;\n    return ls[y]=Union(x,ls[y]),Up(y),y;\n}\n \nPii Split(int x,int k) {\n    if(c[x]<=k) return mp(x,0);\n    if(!x || !k) return mp(0,x);\n    if(c[ls[x]]+1<=k) {\n        Pii y=Split(rs[x],k-c[ls[x]]-1);\n        return rs[x]=y.first,Up(x),mp(x,y.second);\n    } else {\n        Pii y=Split(ls[x],k);\n        return ls[x]=y.second,Up(x),mp(y.first,x);\n    }\n}\nPii Split2(int x,int k) {\n    if(!x) return mp(0,0);\n    if(cmp(ma[x],k)) return mp(x,0);\n    if(cmp(k,mi[x])) return mp(0,x);\n    if(cmp(x,k)) {\n        Pii y=Split2(rs[x],k);\n        return rs[x]=y.first,Up(x),mp(x,y.second);\n    } else {\n        Pii y=Split2(ls[x],k);\n        return ls[x]=y.second,Up(x),mp(y.first,x);\n    }\n}\nPii Split3(int x,ll k) {\n    if(!x) return mp(0,0);\n    if(s[x]<=k) return mp(0,x);\n    if(s[rs[x]]>=k) {\n        Pii y=Split3(rs[x],k);\n        return rs[x]=y.first,Up(x),mp(x,y.second);\n    } else {\n        Pii y=Split3(ls[x],k-s[rs[x]]-val[x]);\n        return ls[x]=y.second,Up(x),mp(y.first,x);\n    }\n}\n \nvoid Insert(){\n    val[++n]=rd<ll>(),s[n]=val[n],ma[n]=mi[n]=n,c[n]=1,key[n]=rand();\n    Pii t=Split2(rt,n); \n    rt=Union(Union(t.first,n),t.second);\n}\nvoid Erase() {\n    Pii x=Split2(rt,0);\n    Pii y=Split(x.second,1);\n    rt=Union(x.first,y.second);\n}\n \nint T[N],cnt;\nint main(){\n    rep(i,1,rd()) Insert();\n    rep(kase,1,rd()) {\n        int opt=rd();\n        if(opt==2) Insert();\n        else if(opt==3) val[0]=rd<ll>()-1,Erase();\n        else {\n            ll now=rd<ll>(),des=rd<ll>(),ans=cnt=0;\n            while(now<des) {\n                val[n+1]=now;\n                Pii x=Split2(rt,n+1);\n                ll nxt=x.second?val[mi[x.second]]+1:1e18;\n                cmin(nxt,des);\n                ll d=nxt-now;\n                Pii y=Split3(x.first,d);\n                now+=s[y.second],ans+=c[y.second];\n                rt=Union(y.first,x.second);\n                T[++cnt]=y.second;\n                if(now<nxt) break;\n            }\n            drep(i,cnt,1) {\n                Pii x=Split2(rt,T[i]); \n                rt=Union(Union(x.first,T[i]),x.second);\n            }\n            if(now>=des) printf(\"%lld\\n\",ans);\n            else puts(\"-1\");\n        }\n    }\n}\n```\n\n## 线段树\n\n离线之后写，让每个位置只包含一个数会更好写\n\n关于用线段树维护暂时删除的问题，有很多写法\n\n1.强行标记，把被标记的节点全部存下来然后复原\n\n2.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「ROI 2016 Day1」人烟之山 ","url":"/2021/05/21/「ROI 2016 Day1」人烟之山 /","content":"# 「ROI 2016 Day1」人烟之山 \n\n题目大意：\n\n有$n$段折线，$m$个查询点$A$（在折线以上），设折线拐点为$X_i$\n\n求折线上在查询点投影两边最近的位置$B$，且直线$AB$与折线有非边缘的交点 (即从$A$点看过来会被折线遮住)\n\n题目分析：\n\n$B,C$点满足的条件就是其旁边的直线$L$在$x_A$处的值$>y_A$\n\n![Snipaste_2021-02-20_13-43-59.png](https://i.loli.net/2021/02/20/rguOJLKFG89Ipt2.png)\n\n即找到最近的红色直线\n\n## Solution1 $O(n\\log ^2n)$\n\n以求左边为例\n\n考虑二分答案，求出拐点为$X_i,i\\ge mid$的直线中是否存在红色直线\n\n也就是求最大值是否$>y_A$，维护直线最大值，并且区间查询，可以暴力可持久化李超树来解决\n\n因为是求左边的，所以每条直线更新的范围$>X_i$，李超树区间更新复杂度为$O(\\log ^2n)$\n\n李超树查询复杂度为$O(\\log n)$,加上二分，查询为$O(\\log ^2n)$\n\n$$ \\ $$ \n\n### Solution2 $O(n\\log n)$\n\n依然考虑二分，但是这次考虑在线段树上二分\n\n对于所有的$X_i$建立线段树，区间$[L,R]$内维护一个$X_i,i\\in [L,R]$的上凸包，静态维护最大值\n\n凸包可以归并子节点来建立，预处理复杂度为$O(n\\log n)$\n\n如果查询直接在凸包上二分，复杂度会增加一个$\\log n$\n\n解决方法是：将所有查询的$x_A$排序，然后在凸包上查询时就可以做到线性\n\n因此复杂度为$O(n\\log n)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\n#define pb push_back\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\nchar buf[200000],*p1,*p2;\n#define getchar() (((p1==p2)&&(p2=(p1=buf)+fread(buf,1,200000,stdin))),*p1++)\nchar IO;\nint rd(){\n\tint s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) f|=IO=='-';\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=4e5+10,U=1e9+10;\n\nint n,m,K[N],X[N],L[N],R[N];\nll Y[N];\nstruct Que{\n\tint x,y,id;\n\tbool operator < (const Que __) const {\n\t\treturn x<__.x;\n\t}\n} Q[N];\nstruct Node{\n\tint k; ll b;\n\tll operator [] (const ll x) const {\n\t\treturn 1ll*k*x+b;\n\t}\n\tfriend db Cross(Node x,Node y){ return 1.0*(y.b-x.b)/(x.k-y.k); }\n\tbool operator < (const Node __) const {\n\t\treturn k<__.k||(k==__.k && b<__.b);\n\t}\n}; \nvector <Node> H[N<<2];\nvector <Node> ::iterator P[N<<2];\nvoid Build(int p,int l,int r){\n\tif(l==r) return H[p].pb((Node){K[l],Y[l]-1ll*K[l]*X[l]}),P[p]=H[p].begin(),void();\n\tint mid=(l+r)>>1;\n\tBuild(p<<1,l,mid),Build(p<<1|1,mid+1,r);\n\tint p1=0,s1=H[p<<1].size(),p2=0,s2=H[p<<1|1].size(),R=-1;\n\tauto Ins=[&](Node L) {\n\t\twhile(~R && H[p][R].b<=L.b) R--,H[p].pop_back();\n\t\twhile(R>0 && Cross(H[p][R],H[p][R-1])>=Cross(H[p][R],L)-1e-8) R--,H[p].pop_back();\n\t\tH[p].pb(L),R++;\n\t};\n\twhile(p1<s1 || p2<s2) {\n\t\tif(p1<s1 && (p2==s2 || H[p<<1][p1]<H[p<<1|1][p2])) Ins(H[p<<1][p1++]);\n\t\telse Ins(H[p<<1|1][p2++]);\n\t}\n\tP[p]=H[p].begin();\n}\n\nll Que(int p,int x){\n\twhile(P[p]+1!=H[p].end() && (*(P[p]+1))[x]>=(*P[p])[x]) P[p]++;\n\treturn (*P[p])[x];\n}\nint QueL(int p,int l,int r,int x,int qx,int y){\n\tif(x<l || Que(p,qx)<=y) return 0;\n\tif(l==r) return l;\n\tint mid=(l+r)>>1,t;\n\tif(x>mid && (t=QueL(p<<1|1,mid+1,r,x,qx,y))) return t;\n\treturn QueL(p<<1,l,mid,x,qx,y);\n}\nint QueR(int p,int l,int r,int x,int qx,int y){\n\tif(x>r || Que(p,qx)<=y) return n+1;\n\tif(l==r) return l;\n\tint mid=(l+r)>>1,t;\n\tif(x<=mid && (t=QueR(p<<1,l,mid,x,qx,y))<=n) return t;\n\treturn QueR(p<<1|1,mid+1,r,x,qx,y);\n}\n\nint main(){\n\tn=rd(),m=rd();\n\trep(i,1,n) {\n\t\tX[i]=X[i-1]+rd(),K[i]=rd();\n\t\tY[i]=Y[i-1]+1ll*(X[i]-X[i-1])*K[i];\n\t}\n\trep(i,1,m) Q[i].x=rd(),Q[i].y=rd(),Q[i].id=i;\n\tsort(Q+1,Q+m+1);\n\tBuild(1,1,n);\n\tint p=1;\n\trep(i,1,m) {\n\t\twhile(p<=n && X[p]<Q[i].x) p++;\n\t\tL[Q[i].id]=QueL(1,1,n,p-1,Q[i].x,Q[i].y);\n\t\tR[Q[i].id]=QueR(1,1,n,p+(X[p]==Q[i].x),Q[i].x,Q[i].y);\n\t}\n\trep(i,1,m) printf(\"%d %d\\n\",X[L[i]],X[R[i]-1]);\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「ROI 2016 Day2」二指禅 ","url":"/2021/05/21/「ROI 2016 Day2」二指禅 /","content":"# 「ROI 2016 Day2」二指禅 \n\n考虑对于每个点，有前缀和后缀两种转移\n\n对于两种转移分别建立$\\text{trie}$树，并且维护最小权值，对于$dp_i$，可以匹配一段后缀从$j<i$得到\n\n也可以匹配一段前缀更新$j>i$，分别$O(n)$枚举在两棵树上匹配即可完成转移\n\n暴力转移复杂度为$O(n^2)$\n\n考虑优化转移效率，以$dp_i$匹配某一段前缀向$dp_j(j>i)$转移为例\n\n### Part1 考虑求出最大的$j$\n\n这个问题实际上就是求出每一个后缀的最大前缀匹配，也就是一个$\\text{exkmp}$问题\n\n而且这题是一个多模板串版本，并不能用$\\text{exkmp}$解决\n\n#### Solution 1\n\n是把所有前缀hash值取出来，放到$\\text{hash_table}$里，然后二分长度+$\\text{hash_table}$查询，复杂度为$O(\\log L)$\n\n#### Solution 2\n\n树剖+hash\n\n对于$\\text{trie}$树树剖并且预处理hash值，重链上二分hash匹配，轻儿子暴力走，复杂度为$O(\\log ^2L)$\n\n如果使用全局平衡二叉树，可以做到单次查询复杂度为$O(\\log L)$，常数应该远小于$\\text{hash_table}$\n\n$$ \\ $$\n\n$$ \\ $$\n\n### Part2 在$j_{max}$基础上转移\n\n考虑先求出最大的$j$之后，得到其对应的$\\text{trie}$树节点$u$，在的祖先$u$中，每一种不同的权值更新一次\n\n显然每一个祖先长度不同，因此最多只有$O(\\sqrt L)$中不同的权值\n\n因此可以for过去更新每一种权值，每次更新是一段区间，可以用树状数组维护\n\n但是实际上极限情况下段极短，可以暴力枚举区间，所以并不是真的$O(\\sqrt L\\log L)$\n\n比较容易说明复杂度的优化方法是：\n\n采用分块$O(1)$更新，$O(\\sqrt L)$查询\n\n这样可以做到稳定$O(\\sqrt L)$完成转移\n\n$$\\ $$\n\n因此预处理复杂度为$O(m\\log L-m\\log ^2L)$，转移复杂度为$O(m\\sqrt L-m\\sqrt L\\log L)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,T b){ ((a>b)&&(a=b)); }\n\nconst int N=3e5+10,INF=1e9+10,D=6;\n\nint n,m;\nchar T[N];\nint Pow1[N],Pow2[N];\nint S[N];\nconst ll K1=19260817,P1=114514;\nconst ll K2=1e9+13,P2=1919810;\n\nstruct Solver{\n    int S[N];\n    int trie[N][2],s[N],cnt,H1[N],H2[N];\n    int fa[N],top[N],sz[N],h1[N],h2[N],son[N],lst[N],bot[N],L[N],id[N],dfn,dep[N];\n    // lst[i] 记录祖先中第一个s[f]!=s[i]的节点\n    void dfs(int u){\n        sz[u]=1;\n        if(s[u]==s[fa[u]]) lst[u]=lst[fa[u]];\n        else lst[u]=fa[u];\n        rep(i,0,1) {\n            int v=trie[u][i];\n            if(!v) continue;\n            fa[v]=u,dep[v]=dep[u]+1;\n            h1[v]=(h1[u]*K1+i+1)%P1;\n            h2[v]=(h2[u]*K2+i+1)%P2;\n            dfs(v);\n            sz[u]+=sz[v];\n            if(son[u]==0 || sz[v]>sz[son[u]]) son[u]=v;\n        }\n    }\n    void dfs(int u,int t){\n        id[L[u]=++dfn]=u;\n        bot[top[u]=t]=u; if(son[u]) dfs(son[u],t);\n        for(int v:trie[u]) if(v&&v!=son[u]) dfs(v,v);\n    }\n    void Ins(char *T,int l,int w){\n        int now=0;\n        rep(i,1,l) {\n            int c=T[i]-'0';\n            if(!trie[now][c]) s[trie[now][c]=++cnt]=2e9;\n            cmin(s[now=trie[now][c]],w);\n        }\n    }\n    void Init(){\n        rep(i,1,n) {\n            H1[i]=(H1[i-1]*K1+S[i]+1)%P1;\n            H2[i]=(H2[i-1]*K2+S[i]+1)%P2;\n        }\n        dfs(0),dfs(0,0);\n    }\n    int Que(int i) {\n        // 求i 的最长匹配位置\n        int u=0;\n        while(i<=n) {\n            if(!trie[u][S[i]]) break;\n            if(trie[u][S[i]]!=son[u]){ u=trie[u][S[i++]]; continue; }\n            int l=1,r=min(n-i+1,dep[bot[top[u]]]-dep[u]),res=1;\n            while(l<=r){\n                int mid=(l+r)>>1;\n                if( (H1[i+mid-1]-1ll*H1[i-1]*Pow1[mid]%P1+P1)%P1 ==  (h1[id[L[u]+mid]]-1ll*h1[u]*Pow1[mid]%P1+P1)%P1 &&\n                        (H2[i+mid-1]-1ll*H2[i-1]*Pow2[mid]%P2+P2)%P2 == (h2[id[L[u]+mid]]-1ll*h2[u]*Pow2[mid]%P2+P2)%P2)\n                    l=mid+1,res=mid;\n                else r=mid-1;\n            }\n            i+=res,u=id[L[u]+res];\n        }\n        return u;\n    }\n} X,Y;\n\nstruct BIT{\n    ll s[N];\n    void Init(){\n        memset(s,127,sizeof s);\n    }\n    void Add(int p,ll x){\n        while(p) cmin(s[p],x),p-=p&-p;\n    }\n    ll Que(int p){\n        ll res=1e18;\n        while(p<=n) cmin(res,s[p]),p+=p&-p;\n        return res;\n    }\n} TX,TY;\nll dp[N];\n\nint main(){\n    rep(i,Pow1[0]=Pow2[0]=1,N-1) {\n        Pow1[i]=Pow1[i-1]*K1%P1;\n        Pow2[i]=Pow2[i-1]*K2%P2;\n    }\n    scanf(\"%d%d%*d\",&n,&m);\n    rep(i,1,n) scanf(\"%1d\",S+i),X.S[i]=Y.S[n-i+1]=S[i];\n    rep(t,1,m) {\n        int w,l; scanf(\"%d%s\",&w,T+1),l=strlen(T+1);\n        X.Ins(T,l,w),reverse(T+1,T+l+1),Y.Ins(T,l,w);\n    }\n    X.Init(),Y.Init();\n\n    rep(i,1,n) dp[i]=1e18;\n    TX.Init(),TY.Init();\n    TY.Add(1,0);\n    rep(i,0,n) {\n        // 暴力维护转移\n        if(i) {\n            cmin(dp[i],TX.Que(i));\n            int u=Y.Que(n-i+1);\n            while(u) {\n                int l=Y.dep[Y.lst[u]]+1,r=Y.dep[u];\n                if(r-l+1<=D) rep(j,l,r) cmin(dp[i],dp[i-j]+Y.s[u]);\n                else cmin(dp[i],TY.Que(i-r+1)+Y.s[u]);\n                u=Y.lst[u];\n            }\n        }\n        TY.Add(i+1,dp[i]);\n        if(i==n||dp[i]==1e18) continue;\n        int u=X.Que(i+1);\n        while(u) {\n            int l=X.dep[X.lst[u]]+1,r=X.dep[u];\n            if(r-l+1<=D) rep(j,l,r) cmin(dp[i+j],dp[i]+X.s[u]);\n            else TX.Add(i+r,dp[i]+X.s[u]);\n            u=X.lst[u];\n        }\n    }\n    printf(\"%lld\\n\",dp[n]<1e18?dp[n]:-1);\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「ROI 2017 Day 1」虎   (计算几何)","url":"/2021/05/21/「ROI 2017 Day 1」虎   (计算几何)/","content":"# 「ROI 2017 Day 1」虎   (计算几何)\n\n题意：（交互题）\n\n已知$n$个点，$m$次询问，每次询问交互器随机生成一个位置的关键点，要求在$k$次查询中给出一个合法解\n\n查询：一个凸包，返回关键点是否在凸包中\n\n解：一个凸包，包含关键点，且不包含其它点，保证有界\n\n对关键点的包含是包括了边界线的，其它点的包含不包括边界线，凸包均要按照顺时针给出\n\n### Solution 1 ~~（未完全实现）~~\n\n先将给定点分层转化为若干凸包，容易通过二分得到关键点所在的层\n\n如果关键点以内不再有凸包，显然得到一个解\n\n否则，一个合法的解一定是在两层凸包中某一层选取两个点，另一层选取一个点得到的三角形\n\n先考虑内层选两个点的情况，令二分边界为内层凸包上点的编号，$l,r$\n\n考虑实现一个操作，对于$l,r$，找到其连接的直线在顺时针方向上在外层凸包上切到的段\n\n由此得到一个凸包进行查询，即可进行二分，最终$l+1=r$时，再进行一次上述操作得到一组解（不一定合法）\n\n如果不合法，同理再在外层上二分一次\n\n最终写道第一种情况弃掉了。。。\n\n$$ \\ $$\n\n$$ \\ $$\n\n### Solution2 随机分裂\n\n良好的随机分裂可以跑到max query times<=33的好成绩\n\n考虑一个非常简单的剖开$n$个点的方法：\n\n1.找到这些点的**凸包**，从点集中删掉\n\n2.从剩余点中选择一个作为**中心**，分别与凸包上的点连边，将平面分开\n\n3.确定每个三角形中包含的点，加上三个顶点，继续进行剖分\n\n最终当凸包以外不再有点时，结束\n\n$$ \\ $$\n\n查询也是比较显然的：\n\n对于当前凸包及其中心，二分找到关键点对应的位置，然后继续进行，直到不存在中心\n\n二分方法：\n\n凸包构成一圈，取一个点为$l$，顺时针180以内的范围最大角度的点为$r$，每次将中心和$l,mid$这连续一段查询判断是否包含\n\n这样存在的问题是：可能不在$l$的180范围内，需要在开始二分前判断一下\n\n十分朴素的实现也可以获得90分的好成绩\n\n优化：\n\n每次选取中心时，多随机几次，估价找到一个最优剖分即可\n\n[Loj Submission -包含大量调试语句和内嵌的交互部分](https://loj.ac/s/1052555)\n\n[Loj Submission](https://loj.ac/s/1053342)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair <int,int> Pii;\n#define reg register\n#define mp make_pair\n#define pb push_back\n#define Mod1(x) ((x>=P)&&(x-=P))\n#define Mod2(x) ((x<0)&&(x+=P))\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T& a,T b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T& a,T b){ ((a<b)&&(a=b)); }\n\nchar IO;\nint rd(){\n\tint s=0,f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nbool Mbe;\nconst int N=5010;\n\nint n,q;\n\n// 计算几何部分\nnamespace Geometry{\nstruct Node{\n\tll x,y;\n\tNode(){}\n\tNode(ll x,ll y):x(x),y(y){}\n\tNode operator - (const Node __) const { return Node(x-__.x,y-__.y); }\n\tNode operator + (const Node __) const { return Node(x+__.x,y+__.y); }\n\tll operator ^ (const Node __) const { return 1ll*x*__.y-1ll*y*__.x; }\n\tbool operator == (const Node __) const { return x==__.x && y==__.y; }\n\tvoid Read(){ x=rd(),y=rd(); }\n} A[N],QuePoint;\ntypedef vector <int> V;\n// check close wise\nint chk(int i,int j,int k,int bound=0){ return ((A[k]-A[i])^(A[j]-A[i]))>=bound; }\nint chk(Node i,int j,int k,int bound=0){ return ((A[k]-i)^(A[j]-i))>=bound; }\n// this is clockwise\nint CheckConvex(const V &P){\n\tint n=P.size();\n\trep(i,0,n-1) {\n\t\tint j=(i+1)%n,k=(j+1)%n;\n\t\tif(!chk(P[j],P[k],P[i])) return 0;\n\t}\n\treturn 1;\n}\n// this is clock-wise\nint CheckIn(const V&P,Node X,int bound=0){\n\trep(i,0,P.size()-1) {\n\t\tint j=(i+1)%P.size();\n\t\tif(chk(X,P[i],P[j],bound)) continue;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\nint Check(V P){\n\tif(P.size()<=2) return 0;\n\tprintf(\"? %llu \",P.size());\n\tfor(int i:P) printf(\"%d \",i); \n\tputs(\"\");\n\tfflush(stdout);\n\tstatic char s[5]; scanf(\"%s\",s);\n\treturn *s=='Y';\n}\nvoid Output(V P){\n\tprintf(\"! %llu \",P.size());\n\tfor(int i:P) printf(\"%d \",i);\n\tputs(\"\");\n\tfflush(stdout);\n}\nV Convex(V P){\n\tif(P.size()<=2) return P;\n\tV Ans;\n\tint n=P.size();\n\tstatic int I[N],mk[N],S[N],T;\n\trep(i,0,n-1) mk[I[P[i]]=i]=0;\n\tsort(P.begin(),P.end(),[&](int x,int y){ return A[x].x<A[y].x || (A[x].x==A[y].x && A[x].y>A[y].y); });\n\tT=0;\n\trep(i,0,n-1) {\n\t\twhile(T>1 && ((A[P[i]]-A[S[T]])^(A[S[T-1]]-A[S[T]]))>0 ) T--;\n\t\tS[++T]=P[i];\n\t}\n\trep(i,1,T) Ans.pb(S[i]),mk[I[S[i]]]=1;\n\tsort(P.begin(),P.end(),[&](int x,int y){ return A[x].x<A[y].x || (A[x].x==A[y].x && A[x].y<A[y].y); });\n\tT=0;\n\trep(i,0,n-1) {\n\t\twhile(T>1 && ((A[P[i]]-A[S[T]])^(A[S[T-1]]-A[S[T]]))<0 ) T--;\n\t\tS[++T]=P[i];\n\t}\n\tdrep(i,T,1) if(!mk[I[S[i]]]) Ans.pb(S[i]);\n\treturn Ans;\n}\n}\nusing namespace Geometry;\n\n\nconst int M=2e5+10;\n\nV C[M],S[M];\nint K[M],D[M],E[M],rt,m,mk[M];\n// 剖分\n// C凸包，S子节点\n// K中心，D凸包上0号点对应的180范围内的最大点，E凸包上D号点对应180范围内的最大点\n// m个数\nvoid Build(int &u,V P) {\n\tsort(P.begin(),P.end());\n\tint n=P.size();\n\tC[u=++m]=Convex(P);\n\trep(i,0,n-1) mk[i]=0;\n\tif(C[u].size()==P.size()) return;\n\tfor(int i:C[u]) mk[lower_bound(P.begin(),P.end(),i)-P.begin()]=1;\n\tV T; rep(i,0,n-1) if(!mk[i]) T.pb(P[i]);\n\tn=C[u].size();\n    // 获取剖分结果\n\tauto Get=[&]() {\n\t\tif(rand()&1) K[u]=T[(T.size()/(rand()%3+2)+rand()%8)%T.size()];\n\t\telse K[u]=T[rand()%T.size()];\n\t\tV P=T; P.erase(lower_bound(P.begin(),P.end(),K[u]));\n\t\tD[u]=E[u]=0;\n\t\twhile(D[u]<n-1 && chk(K[u],C[u][0],C[u][D[u]+1])) D[u]++;\n\t\tE[u]=D[u];\n\t\twhile(E[u]<n-1 && chk(K[u],C[u][D[u]],C[u][E[u]+1])) E[u]++;\n\t\tvector <V> ST(n);\n\t\tfor(int x:P) {\n\t\t\trep(i,0,n-1) {\n\t\t\t\tif(chk(K[u],C[u][i],x) && chk(K[u],x,C[u][(i+1)%n])) {\n\t\t\t\t\tST[i].pb(x);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,0,n-1) ST[i].pb(K[u]),ST[i].pb(C[u][i]),ST[i].pb(C[u][(i+1)%n]);\n\t\treturn ST;\n\t};\n\tvector <V> st;\n\tint mi=1e9;\n\trep(kase,1,5) {\n\t\tint d=D[u],e=E[u],k=K[u];\n\t\tauto ST=Get();\n\t\tint now=0;\n\t\tfor(V j:ST) cmax(now,(int)j.size());\n\t\tif(now>mi){ D[u]=d,E[u]=e,K[u]=k; continue; }\n\t\tst=ST,mi=now;\n\t}\n\trep(i,0,n-1) {\n\t\tint x; Build(x,st[i]);\n\t\tS[u].pb(x);\n\t}\n}\n\nvoid Init() {\n\tV T(n);\n\trep(i,0,n-1) T[i]=i+1;\n\tBuild(rt,T);\n}\n\nvoid Find(int u=rt){\n\tif(!S[u].size()) return Output(C[u]);\n\tint n=C[u].size();\n\tint l,r;\n\tauto Get=[&](int l,int r) {\n\t\tV T; T.pb(K[u]);\n\t\tl%=n,r%=n;\n\t\tfor(int i=l;;i=(i+1)%n) {\n\t\t\tT.pb(C[u][i]);\n\t\t\tif(i==r) break;\n\t\t}\n\t\treturn Check(T);\n\t};\n\tif(Get(0,D[u])) l=0,r=D[u];\n\telse if(Get(D[u],E[u])) l=D[u],r=E[u];\n\telse l=E[u],r=n;\n\twhile(l+1<r) {\n\t\tint mid=(l+r)>>1;\n\t\tif(Get(l,mid)) r=mid;\n\t\telse l=mid;\n\t}\n\tFind(S[u][l]);\n}\n\nint main(){ \n\tn=rd();\n\trep(i,1,n) A[i].Read();\n\tInit();\n\tq=rd();\n\trep(_,1,q) Find();\n}\n\n```\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「ROI 2018 Day 2」无进位加法","url":"/2021/05/21/「ROI 2018 Day 2」无进位加法/","content":"# 「ROI 2018 Day 2」无进位加法\n\n题目大意：\n\n给出二进制数$a_1,\\ldots a_n$，对于$b_1\\ldots b_n$\n\n满足$a_i\\leq b_i$，$\\bigoplus b_i=\\sum b_i$，其中$\\bigoplus $为异或和\n\n求$\\sum b_i$最小值\n\n设长度量级为$N=\\sum len(a_i)$\n\n### $O(N^2-N^3)$ ， 从高到低确定答案的每一个位\n\n枚举当前位为0，下面的位为1，贪心确定是否存在方案\n\n检查一个答案是否合法：\n\n动态维护一个倒序的$a_i$集合，从高到低考虑每一个位置\n\n1.如果当前位为0：\n\n如果$a_i$中存在大于等于这一位的数，非法\n\n2.如果当前位为1：\n\n2-1.如果$a_i$中存在2个当前位为1的数，非法\n\n2-2.如果$a_i$中存在恰好一个，则将这个1用于这个$a_i$，并将$a_i$去掉最高位后放回集合\n\n2-3.不存在，用这个$1$删除最大的一个$a_i$\n\n实际看来，这个贪心本身效率并不高\n\n$$\\ $$\n\n### 优化1：快速确定答案最高位的可能范围\n\n令$B=\\max\\{ len(a_i)+i-1\\}$\n\n则$len(Ans)\\in[B,B+1]$\n\n上下界均可以由上面的贪心模拟得到\n\n$$  \\ $$\n\n### 优化2：快速维护$a_i$倒序\n\n显然在不断更改的过程中，当前的$a_i$一定是原先的某一个$a_i$的一段后缀\n\n考虑将所有这样的后缀排序，为了方便，用每一个最高的1来表示一个合法的后缀\n\n显然可以先按照后缀长度分类，同长度的后缀，按照后缀中下一个1出现的位置排序\n\n也就是一个类似基数排序个过程，额外维护每一个后缀中下一个出现的$1$所对应的后缀即可\n\n预处理复杂度为$O(N\\log N)$\n\n同时，也可以用线段树快速维护插入/删除的排名，得到$B$的值，单次操作复杂度$O(\\log N)$\n\n$$ \\ $$\n\n### 优化3\n\n称满足$len(a_i)+i-1=B$的$i$为$\\text{critical number}$\n\n令$p$为最小的$\\text{critical number}$，也就是在贪心过程中第一个出现情况2-1./2-2.的位置\n\n决策答案为$B$还是为$B+1$，也就是决策\n\n是用$len(a_p)$这个位置删除$a_p$的最高位，还是用$len(a_p)+1$的位置删除$a_p$\n\n($[1,p-1]$的部分一定会被删掉)\n\n$\\text{intended solution}$采用暴力递归来完成确定每一位的这个操作\n\n```pseudocode\nFunction Solve(Limit) Limit为当前可以使用的最高位的1\n\t求得 B,p\n\t删除 a[1,p-1]\n\t删除 a[p]最高位\n\tif B<=Limit and Solve(p-1) then\n\t\tans[len(a[p]),B]=1\n\t\treturn True\n\t删除a[p]\n\tif B+1<=Limit and Solve(p) then \n\t\tans[len(a[p])+1,B+1]=1\n\t\treturn True\n\telse return False\nend\n```\n\n至于复杂度，官方题解给出为$O(N)$次递归和删除/加入操作，最终复杂度为$O(N\\log N)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,const T &b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,const T &b){ ((a<b)&&(a=b)); }\nchar IO;\nint rd(){\n\tint s=0;\n\twhile(!isdigit(IO=getchar()));\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn s;\n}\n\ntypedef vector <int> V;\nconst int N=3e5+10,INF=1e9+10;\n\nint n,m,I[N],L;\nchar s[N];\nint fir[N],nxt[N],rk[N],len[N],id[N];\nV A[N];\n\nstruct Affirmation_Of_My_Existence{\n\tint s[N<<2],t[N<<2];\n\tvoid Down(int p){\n\t\trep(v,p<<1,p<<1|1) t[v]+=t[p],s[v]+=t[p];\n\t\tt[p]=0;\n\t}\n\tvoid Upd(int p,int l,int r,int ql,int qr,int x) {\n\t\tif(ql>qr) return;\n\t\tif(ql<=l && r<=qr) {\n\t\t\ts[p]+=x,t[p]+=x;\n\t\t\treturn;\n\t\t}\n\t\tDown(p);\n\t\tint mid=(l+r)>>1;\n\t\tif(ql<=mid) Upd(p<<1,l,mid,ql,qr,x);\n\t\tif(qr>mid) Upd(p<<1|1,mid+1,r,ql,qr,x);\n\t\ts[p]=max(s[p<<1],s[p<<1|1]);\n\t}\n\tvoid Build(int p,int l,int r){ \n\t\ts[p]=len[id[l]]-INF;\n\t\tif(l==r) return;\n\t\tint mid=(l+r)>>1;\n\t\tBuild(p<<1,l,mid),Build(p<<1|1,mid+1,r);\n\t}\n\tvoid Add(int x,int k){\n\t\tx=rk[x];\n\t\tUpd(1,1,m,x,x,INF*k),Upd(1,1,m,x+1,m,k);\n\t}\n\t// Find the first critical position \"p\", and return all the bits in [1,p]\n\tvoid Get(int p,int l,int r,int x,V &R){\n\t\tif(s[p]<0) return;\n\t\tif(l==r) return R.pb(id[l]);\n\t\tDown(p);\n\t\tint mid=(l+r)>>1;\n\t\tGet(p<<1,l,mid,x,R);\n\t\tif(s[p<<1]!=x) Get(p<<1|1,mid+1,r,x,R);\n\t}\n} T;\n\nint Solve(int L){\n\t// L denotes the maxmium bit we can use\n\tint B=T.s[1];\n\tif(B<0) return 1;\n\tif(B>L) return 0;\n\tV R; T.Get(1,1,m,B,R);\n\tint p=*R.rbegin(),l=len[p];\n\tfor(int i:R) T.Add(i,-1);\n\t\n\t// Try ans B , so we use bit [nxt,B] to delete the number [1,p-1] \n    // and the number a[p] will be set to a[p]-2^l\n\tif(nxt[p]) T.Add(nxt[p],1);\n\tif(Solve(l-1)) {\n\t\trep(i,l,B) s[i]=1;\n\t\treturn B+1;\n\t}\n\n\t// Try ans B+1 , so we use bit [nxt+1,B+1] to delete the [1,p]\n\tif(nxt[p]) T.Add(nxt[p],-1);\n\tif(B<L && Solve(l)) {\n\t\trep(i,l+1,B+1) s[i]=1;\n\t\treturn B+2;\n\t}\n\tfor(int i:R) T.Add(i,1);\n\treturn 0;\n}\n\nint main(){\n\trep(i,1,n=rd()) {\n\t\tscanf(\"%s\",s); int l=strlen(s);\n\t\tcmax(L,l);\n\t\tdrep(j,l-1,0) if(s[j]=='1') {\n\t\t\tnxt[++m]=fir[i];\n\t\t\tA[len[m]=l-j-1].pb(m);\n\t\t\tfir[i]=m;\n\t\t}\n\t}\n\trk[0]=1e9;\n\tint k=m;\n\trep(i,0,L-1) {\n\t\tk-=A[i].size();\n\t\tsort(A[i].begin(),A[i].end(),[&](int x,int y){ return rk[nxt[x]]<rk[nxt[y]]; });\n\t\tfor(int j:A[i]) id[rk[j]=++k]=j;\n\t\tk-=A[i].size();\n\t}\n\tT.Build(1,1,m);\n\trep(i,1,n) T.Add(fir[i],1);\n\tmemset(s,0,sizeof s);\n\tdrep(i,Solve(INF)-1,0) putchar(s[i]^48);\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「ROI 2018 Day 1」量子隐形传态","url":"/2021/05/21/「ROI 2018 Day 1」量子隐形传态/","content":"# 「ROI 2018 Day 1」量子隐形传态\n\n题目大意：\n\n在$N\\times M$的网格上给定$K$个点$1\\ldots K$，定义两点间的距离为$\\displaystyle 2^{\\max\\{|x_i-x_j|,|y_i-y_j|\\}}$\n\n$N,M,K\\leq 10^4$，求$1$到$k$的最短路，下文认为$N,M$同阶\n\n### 如何存储距离\n\n显然距离是一个不超过$10^4$位的二进制数，用$\\text{bitset}$存下来\n\n每一次转移需要维护一个位+1操作，比较大小操作，都可以$O(\\frac{N}{w})$实现，其中$\\text{w}$为压位数\n\n$$ \\ $$\n\n### Lemma:\n\n对于点$A(x,y)$，将平面分为$8$个部分\n\n![Snipaste_2021-02-16_08-28-24.png](https://i.loli.net/2021/02/16/ucKdVED4bmHfoSF.png)\n\n注意对于$x'=x$或者$y'=y$的区域一定要分离\n\n则有：在任意一个平面区域中，有效的转移点一定是距离$(x,y)$最近的点\n\n简要证明：\n\n对于$A$来说，切比雪夫距离相同的的点构成一条带\n\n![Snipaste_2021-02-16_08-39-07.png](https://i.loli.net/2021/02/16/BM6JbDVQChpg3Al.png)\n\n设最近的点为$B$，那么对于任意一个其它点$C$，显然有$dis(A,C)>dis(B,C),dis(A,C)>dis(A,B)$\n\n故走$A\\rightarrow B\\rightarrow C$不劣\n\n### 快速完成转移\n\n这样的$B$显然不唯一存在，每次转移需要的是$\\text{L}$形的段\n\n故可以对于每行每列用线段树优化区间连边\n\n故得到一个$O(K)$点数，$O(K\\log K)$边数的图\n\n用$\\text{Dijkstra}$完成最短路，复杂度为$O(K\\log ^2 K\\frac{N}{W})$\n\nps: 这里没有考虑找到最近点的过程 ，下面的代码是直接暴力找的。。。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair <int,int> Pii;\n#define reg register\n#define pb push_back\n#define mp make_pair\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\ntemplate <class T> inline void cmin(T &a,const T &b){ ((a>b)&&(a=b)); }\ntemplate <class T> inline void cmax(T &a,const T &b){ ((a<b)&&(a=b)); }\n\nchar IO;\nint rd(){\n\tint s=0;\n\twhile(!isdigit(IO=getchar()));\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn s;\n}\n\nconst int N=30011,INF=1e9+10,U=10000,D=6;\nbool Mbe;\n\nint n,m,k;\nint X[N],Y[N],pre[N],vis[N];\nvector <Pii> E[N];\ntypedef unsigned long long ull;\nstruct Bitset{\n\tull a[N/64+10];\n\tint l;\n\tvoid Add(int x){\n\t\twhile(1) {\n\t\t\tull t=a[x>>D];\n\t\t\ta[x>>D]+=1ull<<(x&63);\n\t\t\tif(t>a[x>>D]) x=((x>>D)+1)<<D;\n\t\t\telse break;\n\t\t}\n\t\tcmax(l,((x>>D)<<D)+63-__builtin_clzll(a[x>>D]));\n\t}\n\tbool operator < (const Bitset &__) const {\n\t\tif(__.l>10009) return 1;\n\t\tif(l!=__.l) return l<__.l;\n\t\tdrep(i,(l>>D)+1,0) if(a[i]!=__.a[i]) return a[i]<__.a[i];\n\t\treturn 0;\n\t}\n} dis[N];\nstruct Queue{\n\tint s[N<<2],bit;\n\tvoid Up(int p) { s[p]=dis[s[p<<1]]<dis[s[p<<1|1]]?s[p<<1]:s[p<<1|1]; }\n\tvoid Build(){\n\t\tfor(bit=1;bit<=n+1;bit<<=1);\n\t\ts[bit+1]=1;\n\t\tfor(int p=bit+1;p;p>>=1) s[p]=1;\n\t}\n\tvoid push(int p) { for(s[p+bit]=p,p+=bit;p>>=1;) Up(p); }\n\tint top(){\n\t\tint res=s[1],p=s[1];\n\t\tfor(s[p+=bit]=0;p>>=1;) Up(p);\n\t\treturn res;\n\t}\n} que;\n\nint Dis(int x,int y) { return max(abs(X[x]-X[y]),abs(Y[x]-Y[y])); }\nint Ans[N],Ac;\nint Min[N][8];\nint Dir(int u,int v){\n\tint x=X[v]-X[u],y=Y[v]-Y[u];\n\tif(y==0) return x>0?0:4;\n\tif(y>0) return x==0?2:(x>0?1:3);\n\treturn x==0?6:(x>0?7:5);\n}\n\ntypedef vector <int> V;\nV A[N],B[N];\nint rtx[N],rty[N],ls[N],rs[N];\nint Build(const V &vec,int l,int r){\n\tif(l==r) return vec[l];\n\tint mid=(l+r)>>1,u=++n;\n\tls[u]=Build(vec,l,mid),rs[u]=Build(vec,mid+1,r);\n\tE[u].pb(mp(ls[u],-1)),E[u].pb(mp(rs[u],-1));\n\treturn u;\n}\nV Res;\nvoid Que(const V &vec,int p,int l,int r,int ql,int qr){\n\tif(!p) return;\n\tif(ql<=vec[l] && vec[r]<=qr) return Res.pb(p);\n\tint mid=(l+r)>>1;\n\tif(ql<=vec[mid]) Que(vec,ls[p],l,mid,ql,qr);\n\tif(qr>=vec[mid+1]) Que(vec,rs[p],mid+1,r,ql,qr);\n}\nvoid AddX(int u,int x,int l,int r){\n\tint d=abs(x-X[u]);\n\tif(rtx[x]) Que(A[x],rtx[x],0,A[x].size()-1,l,r);\n\tfor(int v:Res) {\n\t\tE[u].pb(mp(v,d));\n\t}\n\tRes.clear();\n}\nvoid AddY(int u,int y,int l,int r){\n\tint d=abs(y-Y[u]);\n\tif(rty[y]) Que(B[y],rty[y],0,B[y].size()-1,l,r);\n\tfor(int v:Res) {\n\t\tE[u].pb(mp(v,d));\n\t}\n\tRes.clear();\n}\n\nvoid Init(){\n\trep(i,1,k) A[X[i]].pb(i),B[Y[i]].pb(i);\n\trep(i,1,U) {\n\t\tif(A[i].size()) {\n\t\t\tsort(A[i].begin(),A[i].end(),[&](int x,int y){ return Y[x]<Y[y]; });\n\t\t\trtx[i]=Build(A[i],0,A[i].size()-1);\n\t\t\tfor(int &j:A[i]) j=Y[j];\n\t\t}\n\t\tif(B[i].size()) {\n\t\t\tsort(B[i].begin(),B[i].end(),[&](int x,int y){ return X[x]<X[y]; });\n\t\t\trty[i]=Build(B[i],0,B[i].size()-1);\n\t\t\tfor(int &j:B[i]) j=X[j];\n\t\t}\n\t}\n\trep(i,1,k) rep(j,0,7) Min[i][j]=INF;\n\trep(i,1,k) rep(j,i+1,k){\n\t\tint d=Dir(i,j),dis=Dis(i,j);\n\t\tcmin(Min[i][d],dis);\n\t\tcmin(Min[j][(d+4)&7],dis);\n\t}\n\trep(i,1,k) {\n\t\tif(Min[i][0]!=INF) AddX(i,X[i]+Min[i][0],Y[i],Y[i]);\n\t\tif(Min[i][1]!=INF) {\n\t\t\tAddX(i,X[i]+Min[i][1],Y[i]+1,Y[i]+Min[i][1]);\n\t\t\tAddY(i,Y[i]+Min[i][1],X[i]+1,X[i]+Min[i][1]);\n\t\t}\n\t\tif(Min[i][2]!=INF) AddY(i,Y[i]+Min[i][2],X[i],X[i]);\n\t\tif(Min[i][3]!=INF) {\n\t\t\tAddX(i,X[i]-Min[i][3],Y[i]+1,Y[i]+Min[i][3]);\n\t\t\tAddY(i,Y[i]+Min[i][3],X[i]-Min[i][3],X[i]-1);\n\t\t}\n\t\tif(Min[i][4]!=INF) AddX(i,X[i]-Min[i][4],Y[i],Y[i]);\n\t\tif(Min[i][5]!=INF) {\n\t\t\tAddX(i,X[i]-Min[i][5],Y[i]-Min[i][5],Y[i]-1);\n\t\t\tAddY(i,Y[i]-Min[i][5],X[i]-Min[i][5],X[i]-1);\n\t\t}\n\t\tif(Min[i][6]!=INF) AddY(i,Y[i]-Min[i][6],X[i],X[i]);\n\t\tif(Min[i][7]!=INF) {\n\t\t\tAddX(i,X[i]+Min[i][7],Y[i]-Min[i][7],Y[i]-1);\n\t\t\tAddY(i,Y[i]-Min[i][7],X[i]+1,X[i]+Min[i][7]);\n\t\t}\n\t}\n}\n\nbool Med;\nint main(){\n\tfprintf(stderr,\"%.2lf\\n\",(&Med-&Mbe)/1024.0/1024.0);\n\tn=rd(),m=rd(),k=rd(),n=k;\n\trep(i,1,k) X[i]=rd(),Y[i]=rd();\n\tInit();\n\tque.Build();\n\tdis[0].Add(10111);\n\trep(i,2,n) dis[i].Add(10110);\n\twhile(que.s[1]) {\n\t\tint u=que.top();\n\t\tvis[u]=1;\n\t\tfor(auto t:E[u]) {\n\t\t\tint v=t.first;\n\t\t\tBitset w=dis[u]; if(~t.second) w.Add(t.second);\n\t\t\tif(w<dis[v]) dis[v]=w,que.push(v),pre[v]=u;\n\t\t}\n\t}\n\n\tfor(int u=k;u;u=pre[u]) if(u<=k) Ans[++Ac]=u;\n\tprintf(\"%d\\n\",Ac);\n\tdrep(i,Ac,1) printf(\"%d \",Ans[i]);\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「ROI 2019 Day1」运输 20/19","url":"/2021/05/21/「ROI 2019 Day1」运输 20 19/","content":"# 「ROI 2019 Day1」运输 20/19\n\n题目大意：\n\n给定一个带权$DAG$，$1$为起始点，给定小常数$p$\n\n每次查询一个点$u$，一个权值$r$，问是否存在一条路径$1\\ldots u$，其长度$x$满足$r\\leq x\\leq \\frac{p}{p-1}\\cdot r$\n\n转换一下，$dp$每个点是否存在$r$，那么对于路径的权值$x$，合法的$r$即为$[\\frac{p-1}{p}\\cdot x,x]$\n\n对于任意两个区间，如果其相交，则可以合并，并且用两个区间中最小和最大的$x$来表示这个区间\n\n而不相交的区间最多只有$\\log_{\\frac{p}{p-1}} w$段，大概$700$段\n\n任意时刻，每个点的$dp$情况可以用$700$段不交的区间表示，转移可以归并数组进行\n\n因此维护$dp$复杂度为$O(m\\log_{\\frac{p}{p-1}} w)$常数极小，单次查询复杂度为$O(\\log \\log_{\\frac{p}{p-1}} w)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\nchar IO;\ntemplate <class T=int> T rd(){\n\tT s=0; int f=0;\n\twhile(!isdigit(IO=getchar())) if(IO=='-') f=1;\n\tdo s=(s<<1)+(s<<3)+(IO^'0');\n\twhile(isdigit(IO=getchar()));\n\treturn f?-s:s;\n}\n\nconst int N=5e5+10;\n\nint n,m,q,p;\nstruct Interval{\n\tll l,r,x,y;\n\tInterval(ll a,ll b){ \n\t\tx=a,y=b;\n\t\tl=(x*(p-1)+p-1)/p,r=y;\n\t}\n\tvoid Add(ll c){\n\t\tx+=c,y+=c;\n\t\tl=(x*(p-1)+p-1)/p,r=y;\n\t}\n\tbool operator & (const Interval &__) const { return min(r,__.r)>=max(l,__.l)-1; }\n\tInterval operator + (const Interval &__) const { return Interval(min(x,__.x),max(y,__.y)); }\n\tbool operator < (const ll &x) const {\n\t\treturn r<x;\n\t}\n};\nvector <Interval> dp[N];\n\nstruct Edge{\n\tint to,nxt; ll w;\n} e[N];\nint head[N],ecnt;\nvoid AddEdge(int u,int v,ll w){\n\te[++ecnt]=(Edge){v,head[u],w};\n\thead[u]=ecnt;\n}\nvoid Trans(vector <Interval> &x,vector <Interval> y,ll c){\n\tfor(auto &i:y) i.Add(c);\n\tvector <Interval> res;\n\tint p1=0,p2=0,s1=x.size(),s2=y.size();\n\twhile(p1<s1 || p2<s2) {\n\t\tif(p1<s1 && (p2==s2 || x[p1].l<=y[p2].l)) {\n\t\t\tif(res.size() && *res.rbegin()&x[p1]) res[res.size()-1]=*res.rbegin()+x[p1++];\n\t\t\telse res.pb(x[p1++]);\n\t\t} else {\n\t\t\tif(res.size() && *res.rbegin()&y[p2]) res[res.size()-1]=*res.rbegin()+y[p2++];\n\t\t\telse res.pb(y[p2++]);\n\t\t}\n\t}\n\tx=res;\n}\n\nint main(){\n\trep(kase,1,rd()) {\n\t\tn=rd(),m=rd(),q=rd(),p=rd();\n\t\trep(i,1,n) head[i]=ecnt=0;\n\t\trep(i,1,m){\n\t\t\tint u=rd(),v=rd(); ll w=rd<ll>();\n\t\t\tAddEdge(u,v,w);\n\t\t}\n\t\trep(i,1,n) dp[i].clear();\n\t\tdp[1].pb(Interval(0,0));\n\t\trep(u,1,n) {\n\t\t\tfor(int i=head[u];i;i=e[i].nxt) {\n\t\t\t\tTrans(dp[e[i].to],dp[u],e[i].w);\n\t\t\t}\n\t\t}\n\t\twhile(q--){\n\t\t\tint x=rd(); ll y=rd<ll>();\n\t\t\tauto p=lower_bound(dp[x].begin(),dp[x].end(),y);\n\t\t\tif(p!=dp[x].end() && p->l<=y) putchar('1');\n\t\t\telse putchar('0');\n\t\t}\n\t\tputs(\"\");\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「Lych_cys模拟题2018」橘子树              ","url":"/2021/05/21/「lych_cys模拟题2018」橘子树              /","content":"# 「lych_cys模拟题2018」橘子树              \n\n你可能需要[一点点简单知识](https://www.cnblogs.com/chasedeath/p/13092822.html)\n\n你可能需要[一点点预先知识](https://www.cnblogs.com/chasedeath/p/13492548.html)\n\n设值域上限为$M=2\\cdot 10^5,T=3\\cdot 10^5$\n\n### 求$F(n)$\n\n筛去$n^{\\frac{1}{3}}$以内的质因数，此时$n$剩下的质因数$>n^{\\frac{1}{3}}$\n\n剩下的$n$中，可能出现贡献的只有$n$是完全平方数的情况，$O(1)$判断即可\n\n复杂度为$O(n^{\\frac{1}{3}})$\n\n$$ \\ $$\n\n### 求出$i$结点长了$t$时间的时候被收掉的答案\n\n预处理$a_i,b_i$的答案$c_i=F(a_i),d_i=F(b_i)$，复杂度为$O(n\\pi(M^{\\frac{1}{3}}))$\n\n那么此时查询的权值就是$a_i\\cdot t$，如果$>b_i$特判掉\n\n否则，显然$c_i$的贡献可以先分离掉考虑进答案\n\n对于剩下的部分，不妨设$x=\\frac{a_i}{c_i}$，显然$x$不包含平方因子\n\n考虑$x$与$t$的合并所产生的贡献，实际上就是$\\gcd(x,t)$ (让$x$的单个因子与$t$匹配一下)\n\n然后对于$t$剩下的部分$\\frac{t}{\\gcd(x,t)}$，由于$t\\leq 3\\cdot 10^5$，可以预处理一下答案\n\n综合一下上面的部分，那么一个点的答案就是$c_i\\gcd(x,t)^2 F(\\frac{x}{\\gcd(t,x)})$\n\n因此查询一个点的复杂度就是$\\gcd$的$O(\\log T)$\n\n$$ \\ $$\n\n综合利用上面的方法，勉强可以拿到$nm\\log T$的20分\n\n剩下的部分，可以考虑把树树剖一下，然后每个查询可以化为在$\\text{dfs}$序上的若干更新区间$L_i,R_i,t_i$\n\n由于题目考虑的实际上是查询总和，因此可以对于每个点计算答案\n\n不妨从$1-n$扫描$\\text{dfs}$序，对于每个区间在$L_i$插入$t_i$，在$R_i+1$删除$t_i$\n\n用一个set来维护$t_i$的顺序，复杂度为$O(n\\log ^2n)$\n\n在插入/删除set元素的同时，维护每一个$\\Delta_i=t_i-t_{i-1}$，也就是我们要查询的每个数\n\n查询单点时，由于这样的$\\sum \\Delta_i\\leq T$，所以最多包含$O(\\sqrt T)$种不同的$\\Delta_i$  \n\n用另一个set之类的东西维护这些不同的位置，然后暴力查询，复杂度为$O(n\\sqrt T\\log T)$\n\n总复杂度为$O(n\\pi(M^{\\frac{1}{3}})+n\\sqrt T\\log T)$左右\n\n$$ \\ $$\n\n$$ \\ $$\n\n$$ \\ $$\n\n------------\n\n后记\n\n由于特(智)殊(力)的(缺)原(陷)因\n\n我考场上写了一个树剖+分块+莫比乌斯反演的做法，而且还没调出来，代码是[这个](http://10.220.121.125/submission/70043)，复杂度大概差不多$O(n\\sqrt n \\log_n^{\\frac{3}{2}})$\n\n不提了。。。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]},{"title":"「ROI 2019 Day2」模式串查找 (口胡)","url":"/2021/05/21/「ROI 2019 Day2」模式串查找 (口胡)/","content":"# 「ROI 2019 Day2」模式串查找 (口胡)\n\n设$S=\\sum |w_i|$\n\n显然我们需要一个树形数据结构来维护题目中添加字符的操作\n\n归纳一下，需要实现的操作就是：\n\n1.添加一个新串\n\n2.在当前串中分裂一段区间$[L,R]$\n\n3.将一个串复制$k$次\n\n将每一个单字符视为一个节点，考虑用一个可持久化的平衡树来维护上述操作，比如可持久化非旋$\\text{Treap}$\n\n题解中给出的2-3-Tree不知道效果怎么样\n\n2,3操作增加的数量为$\\log$级别，最终的节点总数为$O(S+n\\log S)$\n\n接下来需要实现的操作是合并两个子串的信息，显然在合并时计算跨过两个节点的串匹配模板串的次数\n\n容易想到记录后缀匹配的$kmp$指针，但是这样的指针难以完成合并操作\n\n为了计算这个，我们需要维护这个串的前缀/后缀 在 原串上最长的匹配子段 \n\n此时一个节点的信息可以用$(l1,r1),(l2,r2),k$来表示，其中$k$标记了这个串是否整个出现在模板串中\n\n合并子串$A,B$信息：\n\n1.求出前缀/后缀匹配，以前缀为例：\n\n1-1.如果$A$无法完全匹配，则匹配前缀为$A$的匹配前缀\n\n1-2.$A$能够完全匹配，设$A$在原串对应$L,R$，$B$的最长匹配前缀在模板串匹配起始位置为$P$\n\n我们需要在$[L,R]$之后借上$P$开始的一段后缀，而$[L,R]$出现在模板串中的位置对应着后缀数组上一段$rank$区间\n\n取模板串反向后缀数组，求出与$R$匹配长度超过$R-L+1$的$rank$区间$[l,r]$\n\n则我们需要找到$[l,r]$中$sa[i]+1$与$P$最长的$LCP$，显然是一个求临近$rank$的问题，可以在线主席树二分解决\n\n由此得到最长前缀为$A$串再加上额外匹配得到的部分\n\n$O(\\log m)$完成\n\n$$ \\ $$\n\n2.求出跨过两个串的完美匹配个数\n\n容易得到前串后缀对应的$\\text{kmp}$指针，后串前缀对应反向的$\\text{kmp}$指针\n\n实际上就是求出这两个指针不断失配时相加恰好完全匹配的个数\n\n注意到，实际上这个询问是完全可以**离线**的\n\n可以通过在线得到的匹配情况，离线得到询问得到询问答案，再从叶子开始重新计算每个节点的答案\n\n比较暴力的做法是：\n\n建立两棵$\\text{kmp}$树，在第一棵树上$\\text{dfs}$，加入祖先对应的位置，然后再第二棵树上查询祖先匹配的个数\n\n可以用$\\text{dfs}$序+差分树状数组维护，复杂度为$O(\\log m)$\n\n$$  \\ $$\n\n因此总体复杂度为$O((S+n\\log S)\\log m)$  ~~实际上常数非常大？~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["default tag"],"categories":["default category"]}]